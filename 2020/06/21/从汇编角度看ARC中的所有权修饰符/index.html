<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xq-120.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="环境：Xcode11 ARC在MRC时代 id obj1 &#x3D; obj; 这一行代码仅仅是赋值，不会引起obj对象引用计数的任何变化。而在ARC时代这一行代码会导致对象的引用计数+1。这背后究竟发生了什么？接下来让我们研究一下。 ARC：自动引用计数。不再需要手动调用 retain 、release、autorelease 等方法，而是由编译器在合适的地方自动添加。那么编译器又是怎么知道是添加ret">
<meta property="og:type" content="article">
<meta property="og:title" content="从汇编角度看ARC中的所有权修饰符">
<meta property="og:url" content="https://xq-120.github.io/2020/06/21/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E7%9C%8BARC%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/index.html">
<meta property="og:site_name" content="芝士就是力量">
<meta property="og:description" content="环境：Xcode11 ARC在MRC时代 id obj1 &#x3D; obj; 这一行代码仅仅是赋值，不会引起obj对象引用计数的任何变化。而在ARC时代这一行代码会导致对象的引用计数+1。这背后究竟发生了什么？接下来让我们研究一下。 ARC：自动引用计数。不再需要手动调用 retain 、release、autorelease 等方法，而是由编译器在合适的地方自动添加。那么编译器又是怎么知道是添加ret">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/20220210154059.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914173316.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914152010.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914153236.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914153831.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914154649.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914165036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914165326.png">
<meta property="article:published_time" content="2020-06-21T08:51:14.000Z">
<meta property="article:modified_time" content="2024-12-14T07:50:26.469Z">
<meta property="article:author" content="jekyttt">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/20220210154059.png">

<link rel="canonical" href="https://xq-120.github.io/2020/06/21/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E7%9C%8BARC%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>从汇编角度看ARC中的所有权修饰符 | 芝士就是力量</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="芝士就是力量" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">芝士就是力量</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">像风一样自由</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/xq-120/xq-120.github.io" class="github-corner" title="XQ on GitHub" aria-label="XQ on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xq-120.github.io/2020/06/21/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E7%9C%8BARC%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jekyttt">
      <meta itemprop="description" content="涉猎的编程语言为Objective-C、Swift、C,主要领域为iOS开发.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝士就是力量">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          从汇编角度看ARC中的所有权修饰符
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-21 16:51:14" itemprop="dateCreated datePublished" datetime="2020-06-21T16:51:14+08:00">2020-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-14 15:50:26" itemprop="dateModified" datetime="2024-12-14T15:50:26+08:00">2024-12-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index"><span itemprop="name">OC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>环境：Xcode11</p>
<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p>在MRC时代 <code>id obj1 = obj;</code> 这一行代码仅仅是赋值，不会引起obj对象引用计数的任何变化。而在ARC时代这一行代码会导致对象的引用计数+1。这背后究竟发生了什么？接下来让我们研究一下。</p>
<p>ARC：自动引用计数。不再需要手动调用 retain 、release、autorelease 等方法，而是由编译器在合适的地方自动添加。那么编译器又是怎么知道是添加retain还是添加autorelease或者weak的呢？这就需要所有权修饰符了。通过不同类型的所有权修饰符，编译器就知道该添加什么语句了。</p>
<p>ARC 有效时，<strong>id 类型和对象类型</strong>必须附加所有权修饰符，有如下几种：</p>
<ul>
<li>__strong 修饰符</li>
<li>__weak 修饰符</li>
<li>__unsafe_unretained 修饰符</li>
<li>__autoreleasing 修饰符</li>
</ul>
<p>其中 <code>__strong</code> 修饰符是OC对象类型的默认修饰符。</p>
<p>接下来从汇编角度看，当一个指针变量使用这些修饰符后，编译器会作何处理。</p>
<h3 id="strong-修饰符"><a href="#strong-修饰符" class="headerlink" title="__strong 修饰符"></a>__strong 修饰符</h3><p>对于下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">       id obj = [NSObject new];</span><br><span class="line">       &#123;</span><br><span class="line">         id __strong obj1 = obj; <span class="comment">//引用计数为2</span></span><br><span class="line">         NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">     .loc    1 12 22 prologue_end    ## WeakDemo/main.m:12:22</span><br><span class="line">     callq    _objc_autoreleasePoolPush</span><br><span class="line"> Ltmp1:</span><br><span class="line">     .loc    1 13 18                 ## WeakDemo/main.m:13:18</span><br><span class="line">     movq    _OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">     movq    _OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">     movq    %rcx, %rdi</span><br><span class="line">     movq    %rax, -40(%rbp)         ## 8-byte Spill</span><br><span class="line">     callq    *_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">     .loc    1 13 12 is_stmt 0       ## WeakDemo/main.m:13:12</span><br><span class="line">     movq    %rax, -24(%rbp)</span><br><span class="line"> Ltmp2:</span><br><span class="line">     .loc    1 15 23 is_stmt 1       ## WeakDemo/main.m:15:23</span><br><span class="line">     movq    -24(%rbp), %rdi</span><br><span class="line">     callq    *_objc_retain@GOTPCREL(%rip)</span><br><span class="line">     leaq    L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">     movq    %rax, -32(%rbp)</span><br><span class="line">     .loc    1 16 29                 ## WeakDemo/main.m:16:29</span><br><span class="line">     movq    -32(%rbp), %rsi</span><br><span class="line">     .loc    1 16 11 is_stmt 0       ## WeakDemo/main.m:16:11</span><br><span class="line">     movq    %rcx, %rdi</span><br><span class="line">     movb    $0, %al</span><br><span class="line">     callq    _NSLog</span><br><span class="line">     xorl    %edx, %edx</span><br><span class="line">     movl    %edx, %esi</span><br><span class="line"> Ltmp3:</span><br><span class="line">     .loc    1 17 9 is_stmt 1        ## WeakDemo/main.m:17:9</span><br><span class="line">     leaq    -32(%rbp), %rdi</span><br><span class="line">     callq    _objc_storeStrong</span><br><span class="line">     xorl    %edx, %edx</span><br><span class="line">     movl    %edx, %esi</span><br><span class="line">     .loc    1 18 5                  ## WeakDemo/main.m:18:5</span><br><span class="line">     leaq    -24(%rbp), %rdi</span><br><span class="line">     callq    _objc_storeStrong</span><br><span class="line">     movq    -40(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">     callq    _objc_autoreleasePoolPop</span><br><span class="line">     xorl    %eax, %eax</span><br></pre></td></tr></table></figure>
<p>上述汇编对应的编译器的模拟源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id obj = objc_msgSend(NSObject, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">id obj1 = objc_retain(obj);  <span class="comment">//插入objc_retain</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">objc_storeStrong(&amp;obj1, nil); <span class="comment">//obj1作用域结束，释放对象，并将obj1置为nil。</span></span><br><span class="line"></span><br><span class="line">objc_storeStrong(&amp;obj, nil);</span><br></pre></td></tr></table></figure>
<p><code>id __strong obj1 = obj;</code> 这句代码实际上被编译器转换为：<code>id obj1 = objc_retain(obj);</code> 。 </p>
<p>看一下函数objc_retain的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="built_in">aligned</span>(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="function">id </span></span><br><span class="line"><span class="function"><span class="title">objc_retain</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">retain</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to calling [this retain], with shortcuts if there is no override</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> id </span></span><br><span class="line"><span class="function"><span class="title">objc_object::retain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">isTaggedPointer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rootRetain</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, @<span class="built_in">selector</span>(retain));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛开那些判断，objc_retain函数最终调用了 retain 方法。对象的引用计数加 1 。这也就是我们常说的在 ARC 下将一个对象赋值给一个强引用的指针变量时，编译器会自动插入一条 retain 方法。</p>
<p>接着往下看，当obj1作用域结束后会执行一句<code>objc_storeStrong(&amp;obj1, nil);</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_storeStrong</span><span class="params">(id *location, id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id prev = *location;</span><br><span class="line">    <span class="keyword">if</span> (obj == prev) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">objc_retain</span>(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    <span class="built_in">objc_release</span>(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//objc_release的实现，基本上等价于调用 release方法。</span></span><br><span class="line">__attribute__((<span class="built_in">aligned</span>(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_release</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to calling [this release], with shortcuts if there is no override</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">isTaggedPointer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>())) &#123;</span><br><span class="line">        <span class="built_in">rootRelease</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="built_in">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, @<span class="built_in">selector</span>(release));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_storeStrong函数的作用：</p>
<p>retain新对象，将指针变量指向新对象，release旧对象。特别的，如果 obj 等于 nil ，上述逻辑代表着将指针变量赋值为 nil，并且 release之前指向的对象。因此 <code>objc_storeStrong(&amp;obj1, nil);</code> 代表着 release obj1 指向的对象，并将obj1置为nil。</p>
<p>这也就是我们常说的在 ARC 下一个强引用的指针变量超出作用域被废弃时，编译器会自动插入一条 release 方法，另外其实还把强引用的指针变量置为nil了。</p>
<p>例子2:</p>
<p>将一个使用new方法创建的对象赋值给一个 <code>__strong</code> 修饰的指针变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          id __strong obj1 = [NSObject new]; <span class="comment">//引用计数为1而不是2</span></span><br><span class="line">          NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp1:</span><br><span class="line">	.loc	1 32 30                 ## WeakDemo/main.m:32:30</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, -32(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">	.loc	1 32 23 is_stmt 0       ## WeakDemo/main.m:32:23</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">	.loc	1 33 29 is_stmt 1       ## WeakDemo/main.m:33:29</span><br><span class="line">	movq	-24(%rbp), %rsi</span><br><span class="line">	.loc	1 33 11 is_stmt 0       ## WeakDemo/main.m:33:11</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_NSLog</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">	movl	%edx, %esi</span><br><span class="line">Ltmp2:</span><br><span class="line">	.loc	1 34 9 is_stmt 1        ## WeakDemo/main.m:34:9</span><br><span class="line">	leaq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_storeStrong</span><br><span class="line">	movq	-32(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	.loc	1 35 5                  ## WeakDemo/main.m:35:5</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj1 = objc_msgSend(NSObject, <span class="string">&quot;new&quot;</span>);</span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">objc_storeStrong(&amp;obj1, nil);</span><br></pre></td></tr></table></figure>
<p>编译器发现obj1可以持有对象，又是创建对象，于是不再 retain。</p>
<p>例子 3：</p>
<p>将一个使用myPerson方法创建的对象赋值给一个 <code>__strong</code> 修饰的指针变量</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">id</span> __<span class="keyword">strong</span> obj1 = [ARCPerson myPerson];</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)myPerson &#123;</span><br><span class="line">    ARCPerson *p = [ARCPerson new];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/20220210154059.png" alt=""></p>
<p>上述汇编对应的编译器的模拟源代码：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1<span class="comment">;</span></span><br><span class="line">id tmp = objc_msgSend(<span class="name">ARCPerson</span>, <span class="string">&quot;myPerson&quot;</span>)<span class="comment">; </span></span><br><span class="line">tmp = objc_autoreleaseReturnValue(<span class="name">tmp</span>)<span class="comment">; //走了优化路径，对象并没有注册到自动释放池</span></span><br><span class="line">obj1 = objc_retainAutoreleasedReturnValue(<span class="name">tmp</span>)<span class="comment">; //和上面不同，这里插入的是objc_retainAutoreleasedReturnValue，而不是objc_retain。由于上面生成的对象没有注册到自动释放池，所以这里也是走的优化路径并没有再retain对象</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1)<span class="comment">;</span></span><br><span class="line">objc_storeStrong(<span class="name">&amp;obj1</span>, <span class="literal">nil</span>)<span class="comment">; //释放对象，起到优化作用，这样就不需要等到runloop结束才释放</span></span><br></pre></td></tr></table></figure>
<p>objc_autoreleaseReturnValue实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare a value at +1 for return through a +0 autoreleasing convention.</span></span><br><span class="line">id </span><br><span class="line"><span class="title function_">objc_autoreleaseReturnValue</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	prepareOptimizedReturn(ReturnAtPlus1)的作用就是</span></span><br><span class="line"><span class="comment">  	检测紧接着调用的是不是objc_retainAutoreleasedReturnValue或objc_unsafeClaimAutoreleasedReturnValue</span></span><br><span class="line"><span class="comment">  	是的话就往线程的TLS上写入ReturnAtPlus1即1.这样后面两个函数获取TLS上的值如果发现是1就知道走了优化路径了。</span></span><br><span class="line"><span class="comment">  	这种优化方式有点特别，平时我们可能用个全局变量标记一下，但这里使用的是线程的TLS区域，另外检测后续调用的函数名称也是吊到不行。</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> obj; <span class="comment">//优化路径，不将对象注册到自动释放池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc_autorelease(obj); <span class="comment">//正常路径，注册到自动释放池中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to prepare for optimized return with the given disposition (+0 or +1).</span></span><br><span class="line"><span class="comment">// Returns true if the optimized path is successful.</span></span><br><span class="line"><span class="comment">// Otherwise the return value must be retained and/or autoreleased as usual.</span></span><br><span class="line"><span class="type">static</span> ALWAYS_INLINE <span class="type">bool</span> </span><br><span class="line"><span class="title function_">prepareOptimizedReturn</span><span class="params">(ReturnDisposition disposition)</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(getReturnDisposition() == ReturnAtPlus0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callerAcceptsOptimizedReturn(__builtin_return_address(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (disposition) setReturnDisposition(disposition);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to accept an optimized return.</span></span><br><span class="line"><span class="comment">// Returns the disposition of the returned object (+0 or +1).</span></span><br><span class="line"><span class="comment">// An un-optimized return is +0.</span></span><br><span class="line"><span class="type">static</span> ALWAYS_INLINE ReturnDisposition </span><br><span class="line"><span class="title function_">acceptOptimizedReturn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ReturnDisposition disposition = getReturnDisposition();</span><br><span class="line">    setReturnDisposition(ReturnAtPlus0);  <span class="comment">// reset to the unoptimized state</span></span><br><span class="line">    <span class="keyword">return</span> disposition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取TLS上RETURN_DISPOSITION_KEY的值</span></span><br><span class="line"><span class="type">static</span> ALWAYS_INLINE ReturnDisposition </span><br><span class="line"><span class="title function_">getReturnDisposition</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (ReturnDisposition)(<span class="type">uintptr_t</span>)tls_get_direct(RETURN_DISPOSITION_KEY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往TLS上写数据RETURN_DISPOSITION_KEY--disposition</span></span><br><span class="line"><span class="type">static</span> ALWAYS_INLINE <span class="type">void</span> </span><br><span class="line"><span class="title function_">setReturnDisposition</span><span class="params">(ReturnDisposition disposition)</span></span><br><span class="line">&#123;</span><br><span class="line">    tls_set_direct(RETURN_DISPOSITION_KEY, (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)disposition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_retainAutoreleasedReturnValue实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="title function_">objc_retainAutoreleasedReturnValue</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (acceptOptimizedReturn() == ReturnAtPlus1) <span class="keyword">return</span> obj; <span class="comment">//优化路径，不 retain而是直接返回对象。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc_retain(obj); <span class="comment">//正常路径，retain,引用计数+1后，才返回对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_autoreleaseReturnValue会做一个优化，如果检测到后续紧接着调用了objc_retainAutoreleasedReturnValue，则往 TLS 写ReturnAtPlus1标识，表明返回的对象的内存管理有优化。此时objc_autoreleaseReturnValue不会再将生成的对象真的注册到自动释放池中而是直接返回。当执行objc_retainAutoreleasedReturnValue时，会先从TLS中取值检测是否等于ReturnAtPlus1，相等说明走的是优化路径则不 retain，避免重复retain。</p>
<p>因此以其他单词命名开头的方法创建并返回的对象，该对象本应该注册到自动释放池，但如果创建后马上就赋值给一个 <code>__strong</code> 修饰符的指针变量，此时系统会做一个优化，该对象将不再注册到自动释放池中，因此能够及时释放对象，起到优化作用。<br>note：使用系统的对象 <code>id __strong obj1 = [NSArray array];</code>可能看不到这种优化。</p>
<p>总结：将一个对象赋值给一个 <code>__strong</code> 修饰符的指针变量，编译器会视情况插入<code>objc_retain</code> 或<code>objc_retainAutoreleasedReturnValue</code> 函数的调用。而当指针变量超出作用域后被销毁时，会插入<code>objc_storeStrong(&amp;obj, nil);</code> 释放对象，并置为nil。</p>
<p>objc_autoreleaseReturnValue 和 objc_retainAutoreleasedReturnValue是一对优化。</p>
<p>objc_retainAutoreleaseReturnValue 和 objc_unsafeClaimAutoreleasedReturnValue 是另一对优化。</p>
<p>如果优化成功，他们都避免了多余的注册到自动释放池的过程，加快了对象的释放。</p>
<h3 id="weak-修饰符"><a href="#weak-修饰符" class="headerlink" title="__weak 修饰符"></a>__weak 修饰符</h3><p>对于下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">     @autoreleasepool &#123;</span><br><span class="line">         id obj = [NSObject new];</span><br><span class="line">         &#123;</span><br><span class="line">           id __weak obj1 = obj;</span><br><span class="line">           NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Ltmp3:</span><br><span class="line">     .loc    1 12 22 prologue_end    ## WeakDemo/main.m:12:22</span><br><span class="line">     callq    _objc_autoreleasePoolPush</span><br><span class="line"> Ltmp4:</span><br><span class="line">     .loc    1 13 18                 ## WeakDemo/main.m:13:18</span><br><span class="line">     movq    _OBJC_CLASSLIST_REFERENCES_$_(%rip), %rdi</span><br><span class="line">     movq    _OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">     movq    _objc_msgSend@GOTPCREL(%rip), %rcx</span><br><span class="line">     movq    %rax, -56(%rbp)         ## 8-byte Spill</span><br><span class="line">     callq    *%rcx</span><br><span class="line">     .loc    1 13 12 is_stmt 0       ## WeakDemo/main.m:13:12</span><br><span class="line">     movq    %rax, -24(%rbp)</span><br><span class="line"> Ltmp5:</span><br><span class="line">     .loc    1 15 28 is_stmt 1       ## WeakDemo/main.m:15:28</span><br><span class="line">     movq    -24(%rbp), %rsi</span><br><span class="line">     leaq    -32(%rbp), %rax</span><br><span class="line">     .loc    1 15 21 is_stmt 0       ## WeakDemo/main.m:15:21</span><br><span class="line">     movq    %rax, %rdi</span><br><span class="line">     movq    %rax, -64(%rbp)         ## 8-byte Spill</span><br><span class="line">     callq    _objc_initWeak</span><br><span class="line">     movq    -64(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">     movq    %rax, -72(%rbp)         ## 8-byte Spill</span><br><span class="line">     .loc    1 16 29 is_stmt 1       ## WeakDemo/main.m:16:29</span><br><span class="line">     callq    _objc_loadWeakRetained</span><br><span class="line">     movq    %rax, %rcx</span><br><span class="line"> Ltmp0:</span><br><span class="line">     .loc    1 16 11 is_stmt 0       ## WeakDemo/main.m:16:11</span><br><span class="line">     leaq    L__unnamed_cfstring_(%rip), %rdi</span><br><span class="line">     xorl    %edx, %edx</span><br><span class="line">                                         ## kill: def $dl killed $dl killed $edx</span><br><span class="line">     movq    %rax, %rsi</span><br><span class="line">     movb    %dl, %al</span><br><span class="line">     movq    %rcx, -80(%rbp)         ## 8-byte Spill</span><br><span class="line">     callq    _NSLog</span><br><span class="line"> Ltmp1:</span><br><span class="line">     jmp    LBB0_1</span><br><span class="line"> LBB0_1:</span><br><span class="line">     .loc    1 0 11                  ## WeakDemo/main.m:0:11</span><br><span class="line">     movq    -80(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">     .loc    1 16 11                 ## WeakDemo/main.m:16:11</span><br><span class="line">     callq    *_objc_release@GOTPCREL(%rip)</span><br><span class="line"> Ltmp6:</span><br><span class="line">     .loc    1 17 9 is_stmt 1        ## WeakDemo/main.m:17:9</span><br><span class="line">     leaq    -32(%rbp), %rdi</span><br><span class="line">     callq    _objc_destroyWeak</span><br><span class="line">     xorl    %eax, %eax</span><br><span class="line">     movl    %eax, %esi</span><br><span class="line">     .loc    1 18 5                  ## WeakDemo/main.m:18:5</span><br><span class="line">     leaq    -24(%rbp), %rdi</span><br><span class="line">     callq    _objc_storeStrong</span><br><span class="line">     movq    -56(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">     callq    _objc_autoreleasePoolPop</span><br><span class="line">     xorl    %eax, %eax</span><br></pre></td></tr></table></figure>
<p>上述汇编对应的编译器的模拟源代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> obj1 = objc_initWeak(&amp;obj1, obj);</span><br><span class="line"><span class="type">id</span> tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;obj1:%@&quot;</span>, tmp);</span><br><span class="line">objc_release(tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br><span class="line"></span><br><span class="line">objc_storeStrong(&amp;obj, <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>id __weak obj1 = obj;</code>，这句代码实际上被编译器转换为：<code>id obj1 = objc_initWeak(&amp;obj1, obj);</code>。没有调用什么 retain 方法，这就是使用__weak修饰符不会导致对象引用计数加 1 的原因。</p>
<p>but，objc_initWeak函数又是干什么的，这里不做详述，有兴趣的可以查看 weak 的实现原理。这里简单说下objc_initWeak的作用就是将一个指针变量的地址登记到对象的 weak 表中。它的实现是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="title function_">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着往下看，会发现 <code>NSLog(@&quot;obj1:%@&quot;, obj1);</code>代码变成了三句：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id tmp = objc_loadWeakRetained(<span class="meta">&amp;obj1);  <span class="comment">//将对象引用计数加 1</span></span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, tmp);</span><br><span class="line">objc_release(tmp);  <span class="comment">//将对象引用计数减 1</span></span><br></pre></td></tr></table></figure>
<p>如果对象还可用时执行了<code>id tmp = objc_loadWeakRetained(&amp;obj1);</code>，那么即使对象在其他线程被释放了，对象此刻也不会被销毁，能够保证<code>NSLog(@&quot;obj1:%@&quot;, obj1);</code>方法在执行完前对象都是可用的。</p>
<p>以前这里是将对象注册到自动释放池的，可以参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40993809/why-weak-object-will-be-added-to-autorelease-pool">Why __weak object will be added to autorelease pool?</a> 。经过测试发现在MRC中还是将对象注册到自动释放池的。这时代码等价于：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id tmp = objc_loadWeakRetained(<span class="meta">&amp;obj1);  <span class="comment">//将对象引用计数加 1</span></span></span><br><span class="line">objc_autorelease(tmp); <span class="comment">//注册到自动释放池.注册到自动释放池仅仅是注册到自动释放池，不会对对象的引用计数产生影响。</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, tmp);</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)hello &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        MRCCat *cat = [MRCCat new];</span><br><span class="line">        <span class="keyword">self</span>.cat = cat;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 1&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">        [cat release];</span><br><span class="line">    &#125; <span class="comment">//使用weak，cat居然还没有被销毁。因为被注册到自动释放池里去了</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 2&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">    [<span class="keyword">self</span>.cat hello];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ hello&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会发现在调用 <code>[cat release];</code> 后，cat对象并没有马上销毁。</p>
<p>我们可以在<code>NSLog(@&quot;%@ 1&quot;, self.cat);</code> 这一行打上断点，并执行 <code>po _objc_autoreleasePoolPrint()</code> :</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848230]</span>    0x7fcd6ef0a5c0  UIWindow</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848238]</span>    0x60000032c6c0  __NSArrayM</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848240]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848248]</span>    0x7fcd6ef0a5c0  UIWindow</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848250]</span>    0x60000032c8a0  __NSArrayM</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848258]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848260]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: ##############</span><br></pre></td></tr></table></figure>
<p>此时AUTORELEASE POOLS里还没有MRCCat对象，接着在 <code>[cat release];</code> 打上断点，再次执行 <code>po _objc_autoreleasePoolPrint()</code> ：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848248</span>]    <span class="number">0x7fcd6ef0a5c0</span>  UIWindow</span><br><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848250</span>]    <span class="number">0x60000032c8a0</span>  __NSArrayM</span><br><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848258</span>]    <span class="number">0x7fcd6ef09f20</span>  ViewController</span><br><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848260</span>]    <span class="number">0x7fcd6ef09f20</span>  ViewController</span><br><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848268</span>]    <span class="number">0x600000f747b0</span>  MRCCat</span><br><span class="line">objc[<span class="number">3377</span>]: ##############</span><br></pre></td></tr></table></figure>
<p>可以看到MRCCat被注册到自动释放池里去了。所以后面即使调用 <code>[cat release];</code> cat对象也不会马上销毁。如果你在<code>[self.cat hello];</code> 打上断点，再次执行 <code>po _objc_autoreleasePoolPrint()</code> ：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848240]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848248]</span>    0x7fcd6ef0a5c0  UIWindow</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848250]</span>    0x60000032c8a0  __NSArrayM</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848258]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848260]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848268]</span>    0x600000f747b0  MRCCat</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848270]</span>    0x600000f747b0  MRCCat</span><br><span class="line">objc<span class="comment">[3377]</span>: ##############</span><br></pre></td></tr></table></figure>
<p>你会发现cat对象被注册了两次。</p>
<p>因此使用附有 <code>__weak</code> 修饰符的变量，等价于使用retain并注册到autoreleasepool中的对象。如果你某段代码需要多次使用该weak变量，最好先retain后赋值给一个变量然后使用该变量。要不然每次都会retain+注册到自动释放池。所幸的是现在几乎接触不到MRC的代码，并且在ARC中使用附有 <code>__weak</code> 修饰符的变量，系统也不会retain后再将其注册到autoreleasepool中了，而是在使用前调用retain，使用后调用release马上释放。</p>
<p>另外我们对上述代码稍作改动，添加一个@autoreleasepool：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)hello &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MRCCat *cat = [MRCCat new];</span><br><span class="line">        <span class="keyword">self</span>.cat = cat;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 1&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">        [cat release];</span><br><span class="line">    &#125; <span class="comment">//这里cat就会被销毁了</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 2&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">    [<span class="keyword">self</span>.cat hello];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ hello&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会发现cat对象在autoreleasepool块执行完成后马上就被销毁了。</p>
<p>继续，当作用域结束时，obj1 变量被废弃，因此编译器插入了一条objc_destroyWeak函数的调用。该方法会将 obj1弱引用指针变量从对象的 weak 表中移除（这里obj1变量先于obj对象废弃，因此obj1不会被置为nil）。</p>
<p>objc_destroyWeak 源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">objc_destroyWeak</span><span class="params">(id *location)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, nil); <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> id </span><br><span class="line"><span class="title function_">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">  <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">      weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Unregister an already-registered weak reference.</span></span><br><span class="line"><span class="comment"> * This is used when referrer&#x27;s storage is about to go away, but referent</span></span><br><span class="line"><span class="comment"> * isn&#x27;t dead yet. (Otherwise, zeroing referrer later would be a</span></span><br><span class="line"><span class="comment"> * bad memory access.)</span></span><br><span class="line"><span class="comment"> * Does nothing if referent/referrer is not a currently active weak reference.</span></span><br><span class="line"><span class="comment"> * Does not zero referrer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * FIXME currently requires old referent value to be passed in (lame)</span></span><br><span class="line"><span class="comment"> * FIXME unregistration should be automatic if referrer is collected</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">weak_unregister_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id, </span></span><br><span class="line"><span class="params">                        id *referrer_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        remove_referrer(entry, referrer); <span class="comment">//将referrer从entry中移除。</span></span><br><span class="line">        <span class="type">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **old_referrer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                     <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                     <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                     <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                         <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                         <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                         <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>weak_unregister_no_lock</code> 的作用：将弱引用指针变量从对象的weak表里移除。如果weak表中对象的weak_entry为空，则将entry也移除。</p>
<p>上述就是使用 <code>__weak</code> 修饰符修饰指针变量时，ARC 对其的处理。</p>
<p>再来看一个例子：</p>
<p>将new方法刚创建的对象赋值给一个__weak指针变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          id __weak obj1 = [NSObject new];</span><br><span class="line">          NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能知道打印的结果为 null，但它对应的汇编又是怎样的呢？</p>
<p>对应的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Ltmp3:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp4:</span><br><span class="line">	.loc	1 32 28                 ## WeakDemo/main.m:32:28</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rdi</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	_objc_msgSend@GOTPCREL(%rip), %rcx</span><br><span class="line">	movq	%rax, -48(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*%rcx</span><br><span class="line">	leaq	-24(%rbp), %rcx</span><br><span class="line">	.loc	1 32 21 is_stmt 0       ## WeakDemo/main.m:32:21</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, %rsi</span><br><span class="line">	movq	%rax, -56(%rbp)         ## 8-byte Spill</span><br><span class="line">	movq	%rcx, -64(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	_objc_initWeak</span><br><span class="line">	movq	_objc_release@GOTPCREL(%rip), %rcx</span><br><span class="line">	movq	-56(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	movq	%rax, -72(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*%rcx</span><br><span class="line">	movq	-64(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	.loc	1 33 29 is_stmt 1       ## WeakDemo/main.m:33:29</span><br><span class="line">	callq	_objc_loadWeakRetained</span><br><span class="line">	movq	%rax, %rcx</span><br><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 33 11 is_stmt 0       ## WeakDemo/main.m:33:11</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rdi</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">                                        ## kill: def $dl killed $dl killed $edx</span><br><span class="line">	movq	%rax, %rsi</span><br><span class="line">	movb	%dl, %al</span><br><span class="line">	movq	%rcx, -80(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	_NSLog</span><br><span class="line">Ltmp1:</span><br><span class="line">	jmp	LBB0_1</span><br><span class="line">LBB0_1:</span><br><span class="line">	.loc	1 0 11                  ## WeakDemo/main.m:0:11</span><br><span class="line">	movq	-80(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	.loc	1 33 11                 ## WeakDemo/main.m:33:11</span><br><span class="line">	callq	*_objc_release@GOTPCREL(%rip)</span><br><span class="line">Ltmp5:</span><br><span class="line">	.loc	1 34 9 is_stmt 1        ## WeakDemo/main.m:34:9</span><br><span class="line">	leaq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_destroyWeak</span><br><span class="line">	movq	-48(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	.loc	1 35 5                  ## WeakDemo/main.m:35:5</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>上述汇编对应的编译器的模拟源代码：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id tmp = objc_msgSend(<span class="name">NSObject</span>, <span class="string">&quot;new&quot;</span>)<span class="comment">;</span></span><br><span class="line">id obj1 = objc_initWeak(<span class="name">&amp;obj1</span>, tmp)<span class="comment">; //注册到对象的 weak 表中，这样对象销毁时指针变量会被置为 nil。</span></span><br><span class="line">objc_release(<span class="name">tmp</span>)<span class="comment">;</span></span><br><span class="line">id tmp1 = objc_loadWeakRetained(<span class="name">&amp;obj1</span>)<span class="comment">;  </span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, tmp1)<span class="comment">;</span></span><br><span class="line">objc_release(<span class="name">tmp1</span>)<span class="comment">;  </span></span><br><span class="line">objc_destroyWeak(<span class="name">&amp;obj1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看到objc_initWeak后，马上调用了objc_release，导致对象被释放销毁，同时 obj1 会被置为 nil，于是后面的 tmp1 也是 nil。打印也是 nil。</p>
<p>对于代码<code>id __weak obj1 = [NSObject new];</code>，由于__weak 修饰的指针变量无法持有对象，因此对象一创建就被销毁。</p>
<p>另外一个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        <span class="type">id</span> __<span class="keyword">weak</span> ref = obj; <span class="comment">//_objc_initWeak(内部调用的是storeWeak)</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;ref-1：%@&quot;</span>, ref);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">id</span> obj2 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">            ref = obj2; <span class="comment">//_objc_storeWeak (内部调用的也是storeWeak)</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;ref-2：%@&quot;</span>, ref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p> <code>__weak</code> 修饰符作用：</p>
<p>1.当我们将一个对象赋值给一个 <code>__weak</code> 修饰符的指针变量时，编译器会插入 <code>objc_initWeak</code> 或 <code>objc_storeWeak</code> 函数将该弱指针变量从旧对象的weak表剔除（如果之前有指向对象的话）并注册到新对象的weak表里，然后将弱指针指向新对象。</p>
<p>2.当使用附有 <code>__weak</code> 修饰符的变量时，编译器会在使用前插入 <code>objc_loadWeakRetained</code> 函数将对象引用计数+1，保证对象在后面的使用过程中不被释放。并在使用后插入 <code>objc_release(tmp1);</code> 释放对象。</p>
<p>3.当弱指针变量超出作用域被废弃时，编译器会插入 <code>objc_destroyWeak</code> 将该变量从对象的weak表里剔除。</p>
<p>4.当对象销毁时，对象的weak表中的所有弱指针变量会被赋值为nil，避免了野指针崩溃，比如对nil对象发送消息不会有任何反应，但是如果是对nil进行解引用还是会崩溃的。</p>
<p>这些功能是assign所不具备的，assign唯一与weak相同的地方就是不会导致对象的引用计数+1。</p>
<h3 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h3><p>对于代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">id</span> __autoreleasing obj1 = obj; <span class="comment">//2</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp1:</span><br><span class="line">	.loc	1 31 18                 ## WeakDemo/main.m:31:18</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, -40(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">	.loc	1 31 12 is_stmt 0       ## WeakDemo/main.m:31:12</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">Ltmp2:</span><br><span class="line">	.loc	1 33 30 is_stmt 1       ## WeakDemo/main.m:33:30</span><br><span class="line">	movq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_retainAutorelease</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">	movq	%rax, -32(%rbp)</span><br><span class="line">	.loc	1 34 29                 ## WeakDemo/main.m:34:29</span><br><span class="line">	movq	-32(%rbp), %rsi</span><br><span class="line">	.loc	1 34 11 is_stmt 0       ## WeakDemo/main.m:34:11</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_NSLog</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">	movl	%edx, %esi</span><br><span class="line">Ltmp3:</span><br><span class="line">	.loc	1 36 5 is_stmt 1        ## WeakDemo/main.m:36:5</span><br><span class="line">	leaq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_storeStrong</span><br><span class="line">	movq	-40(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>模拟代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj = msg_Send(NSObject, <span class="string">&quot;new&quot;</span>);</span><br><span class="line">id obj1 = objc_retainAutorelease(obj); <span class="comment">//retain对象+注册对象到自动释放池</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">objc_storeStrong(&amp;obj, nil);</span><br></pre></td></tr></table></figure>
<p>objc_retainAutorelease实现：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">id</span></span><br><span class="line"><span class="function"><span class="title">objc_retainAutorelease</span>(<span class="variable">id</span> <span class="variable">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">return</span> <span class="function"><span class="title">objc_autorelease</span>(<span class="title">objc_retain</span>(<span class="variable">obj</span>));</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>会先 retain 对象，再将对象注册到自动释放池里。</p>
<p>所以<code>id __autoreleasing obj1 = obj;</code> 执行完后对象的引用计数其实是 2。</p>
<p>例子 2：</p>
<p>创建一个对象并赋值给__autoreleasing 的obj1</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          id __autoreleasing obj1 = [NSObject <span class="keyword">new</span>];</span><br><span class="line">          NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp1:</span><br><span class="line">	.loc	1 32 37                 ## WeakDemo/main.m:32:37</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, -32(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">	.loc	1 32 30 is_stmt 0       ## WeakDemo/main.m:32:30</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	callq	_objc_autorelease</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">	.loc	1 33 29 is_stmt 1       ## WeakDemo/main.m:33:29</span><br><span class="line">	movq	-24(%rbp), %rsi</span><br><span class="line">	.loc	1 33 11 is_stmt 0       ## WeakDemo/main.m:33:11</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_NSLog</span><br><span class="line">	movq	-32(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">Ltmp2:</span><br><span class="line">	.loc	1 35 5 is_stmt 1        ## WeakDemo/main.m:35:5</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>模拟代码：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj1 = msg_Send(<span class="name">NSObject</span>, <span class="string">&quot;new&quot;</span>)<span class="comment">;</span></span><br><span class="line">objc_autorelease(<span class="name">obj1</span>)<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>objc_autorelease实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="built_in">aligned</span>(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="function">id</span></span><br><span class="line"><span class="function"><span class="title">objc_autorelease</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">autorelease</span>(); <span class="comment">//将对象注册到自动释放池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to [this autorelease], with shortcuts if there is no override</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> id </span></span><br><span class="line"><span class="function"><span class="title">objc_object::autorelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">isTaggedPointer</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rootAutorelease</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, @<span class="built_in">selector</span>(autorelease));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是创建一个对象并赋值给__autoreleasing 的指针变量，则仅仅是将对象注册到自动释放池。</p>
<p>因此<code>id __autoreleasing obj1 = [NSObject new];</code>执行完成后，对象的引用计数为 1。</p>
<h3 id="unsafe-unretained-修饰符"><a href="#unsafe-unretained-修饰符" class="headerlink" title="__unsafe_unretained 修饰符"></a>__unsafe_unretained 修饰符</h3><p>代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = obj;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;obj1：%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp1:</span><br><span class="line">	.loc	1 31 18                 ## WeakDemo/main.m:31:18</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, -40(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">	.loc	1 31 12 is_stmt 0       ## WeakDemo/main.m:31:12</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">Ltmp2:</span><br><span class="line">	.loc	1 33 43 is_stmt 1       ## WeakDemo/main.m:33:43</span><br><span class="line">	movq	-24(%rbp), %rax</span><br><span class="line">	.loc	1 33 36 is_stmt 0       ## WeakDemo/main.m:33:36</span><br><span class="line">	movq	%rax, -32(%rbp)</span><br><span class="line">	.loc	1 34 33 is_stmt 1       ## WeakDemo/main.m:34:33</span><br><span class="line">	movq	-32(%rbp), %rsi</span><br><span class="line">	.loc	1 34 13 is_stmt 0       ## WeakDemo/main.m:34:13</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_NSLog</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">	movl	%edx, %esi</span><br><span class="line">Ltmp3:</span><br><span class="line">	.loc	1 36 5 is_stmt 1        ## WeakDemo/main.m:36:5</span><br><span class="line">	leaq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_storeStrong</span><br><span class="line">	movq	-40(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>编译器模拟代码：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj = objc_msgSend(<span class="name">NSObject</span>, <span class="string">&quot;new&quot;</span>)<span class="comment">;</span></span><br><span class="line">id obj1 = obj<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1：%@&quot;</span>, obj1)<span class="comment">;</span></span><br><span class="line">objc_storeStrong(<span class="name">&amp;obj</span>, <span class="literal">nil</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看到仅仅是指针变量间的赋值，其他什么操作都没有。</p>
<p>示例 2：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;obj1：%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器模拟代码：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id tmp = objc_msgSend(<span class="name">NSObject</span>, <span class="string">&quot;new&quot;</span>)<span class="comment">;</span></span><br><span class="line">id obj1 = tmp<span class="comment">;</span></span><br><span class="line">objc_release(<span class="name">tmp</span>)<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1：%@&quot;</span>, obj1)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这一次会发生崩溃，因为obj1已经变成了一个野指针。</p>
<p><code>__unsafe_unretained</code>的功能和 assign 是一样的，只不过assign 既可以修饰对象类型也可以修饰基础类型。注意：没有<code>__assign</code>.</p>
<p>ps：个人感觉虽然 ARC 的优点是在合适的地方自动帮我们添加 retain 和 release，但作为开发者的我们如果没有查看汇编代码并不好确定它究竟会在哪些地方添加以及添加的啥函数调用，所以一些奇怪的现象可能会让你困惑。如果是 MRC 的话，我们就很清楚一个对象的释放与持有，弊端就是麻烦并且容易忘记 release导致内存泄漏。两种方案各有利弊，但总的来说还是 ARC 要更好一些。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><h4 id="Q0：ARC-适用范围？是否仅对-OC-文件起作用？"><a href="#Q0：ARC-适用范围？是否仅对-OC-文件起作用？" class="headerlink" title="Q0：ARC 适用范围？是否仅对 OC 文件起作用？"></a>Q0：ARC 适用范围？是否仅对 OC 文件起作用？</h4><p>这个没查到资料，也不敢确定，但个人感觉 ARC 开启后，编译器应该只对 OC 源文件做处理。毕竟 C++也有它自己的内存管理方式。因此切换语言后还是要注意内存管理的不同。</p>
<h4 id="Q1：把一个-weak-指针变量当做参数传给一个方法，当方法开始调用时，即使对象被其他线程释放了，此刻对象也不会被销毁，原因是什么？是形参这个指针变量又强引用了对象，导致对象不会被销毁，还是因为编译器插入的objc-loadWeakRetained函数？还是说两者都有？"><a href="#Q1：把一个-weak-指针变量当做参数传给一个方法，当方法开始调用时，即使对象被其他线程释放了，此刻对象也不会被销毁，原因是什么？是形参这个指针变量又强引用了对象，导致对象不会被销毁，还是因为编译器插入的objc-loadWeakRetained函数？还是说两者都有？" class="headerlink" title="Q1：把一个 weak 指针变量当做参数传给一个方法，当方法开始调用时，即使对象被其他线程释放了，此刻对象也不会被销毁，原因是什么？是形参这个指针变量又强引用了对象，导致对象不会被销毁，还是因为编译器插入的objc_loadWeakRetained函数？还是说两者都有？"></a>Q1：把一个 weak 指针变量当做参数传给一个方法，当方法开始调用时，即使对象被其他线程释放了，此刻对象也不会被销毁，原因是什么？是形参这个指针变量又强引用了对象，导致对象不会被销毁，还是因为编译器插入的objc_loadWeakRetained函数？还是说两者都有？</h4><p>两者都有，因为函数调用时会有一些压栈操作，如果没有objc_loadWeakRetained，那么在压栈操作期间，对象可能就销毁了。另外形参赋值的时候编译器也会插入objc_storeStrong这时形参指向的对象会被 retain ，当函数执行完成时，形参被废弃会调用release 方法。函数返回后继续执行<code>objc_release(tmp);</code>，释放对象。</p>
<p>编译器对方法的入参对象进行retain和release：</p>
<p>代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">self</span> testOjcParamCompilerInsertRetain];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testOjcParamCompilerInsertRetain &#123;</span><br><span class="line">    XQModel *obj = [XQModel new];</span><br><span class="line">    [<span class="keyword">self</span> hello:obj];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)hello:(XQModel *)model &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;model:%@&quot;</span>, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>NSLog(@&quot;model:%@&quot;, model);</code> 处打好断点，如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914173316.png" style="zoom:50%;" /></p>
<p>可以看到编译器会插入objc_storeStrong，从而对传入的 model 对象进行 retain，保证参数指向的对象在使用期间不被销毁。</p>
<p>可以po一下model的引用计数：已经变为2了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po <span class="built_in">NSLog</span>(<span class="string">@&quot;retain count = %ld\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge  <span class="built_in">CFTypeRef</span>)(model)));</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-14</span> <span class="number">17</span>:<span class="number">18</span>:<span class="number">20.496168</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">53997</span>:<span class="number">4829011</span>] <span class="keyword">retain</span> count = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>当方法执行完后，又会执行objc_storeStrong(&amp;model, nil); 释放对象。</p>
<p>这个其实在MRC下会经常写这样的代码，对入参对象retain，使用完后release。只不过在ARC下编译器帮你自动完成了这些操作。</p>
<h4 id="Q2：函数的调用过程究竟是怎样的？"><a href="#Q2：函数的调用过程究竟是怎样的？" class="headerlink" title="Q2：函数的调用过程究竟是怎样的？"></a>Q2：函数的调用过程究竟是怎样的？</h4><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007977460">C函数调用过程原理及函数栈帧分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongzhiquan/p/7828667.html">X86-64寄存器和栈帧</a></p>
<h4 id="Q3：在-OC-中-obj-hello-实际上是会变成objc-msgSend-obj-quot-hello-quot-的调用，-void-hello-方法其实是暗含了两个参数的一个是-id-self，一个是-sel-cmd，问-self-是否会强引用对象？"><a href="#Q3：在-OC-中-obj-hello-实际上是会变成objc-msgSend-obj-quot-hello-quot-的调用，-void-hello-方法其实是暗含了两个参数的一个是-id-self，一个是-sel-cmd，问-self-是否会强引用对象？" class="headerlink" title="Q3：在 OC 中 [obj hello]; 实际上是会变成objc_msgSend(obj, &quot;hello&quot;)的调用，-(void)hello;方法其实是暗含了两个参数的一个是 id self，一个是 sel _cmd，问 self 是否会强引用对象？"></a>Q3：在 OC 中 <code>[obj hello];</code> 实际上是会变成<code>objc_msgSend(obj, &quot;hello&quot;)</code>的调用，<code>-(void)hello;</code>方法其实是暗含了两个参数的一个是 <code>id self</code>，一个是 <code>sel _cmd</code>，问 self 是否会强引用对象？</h4><p>从观察到的现象来看是没有的，举例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">self</span> testObjLife];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark- weak</span></span><br><span class="line">- (<span class="type">void</span>)testObjLife &#123;</span><br><span class="line">    <span class="keyword">self</span>.obj = [ARCPerson new];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;self.obj:%@&quot;</span>, _obj);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">self</span>.obj = <span class="literal">nil</span>; <span class="comment">//释放对象</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;清除&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//    [_obj doTask]; //崩溃。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     使用[self.obj doTask];</span></span><br><span class="line"><span class="comment">     不会野指针崩溃，因为汇编代码里执行self.obj后会，接着调用的是objc_retainAutoreleasedReturnValue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  	<span class="comment">//这里其实是两个方法的调用:[[self obj] doTask];</span></span><br><span class="line">  	<span class="comment">//相当于ARCPerson *temp = [self obj]; //编译器会插入objc_retainAutoreleasedReturnValue。</span></span><br><span class="line">  	<span class="comment">//[temp doTask];</span></span><br><span class="line">  	<span class="comment">//temp超出作用域废弃时编译器插入objc_release，对应objc_retainAutoreleasedReturnValue。</span></span><br><span class="line">    [<span class="keyword">self</span>.obj doTask]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ARCPerson</span></span><br><span class="line">- (<span class="type">void</span>)doTask &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;开始计算&quot;</span>);</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">60000000</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">       f = f + sin(sin(sin(time(<span class="literal">NULL</span>) + i )));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;计算完成&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;model:%@  rs:%ld&quot;</span>, <span class="keyword">self</span>, (<span class="type">long</span>)f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行了<code>self.obj = nil; //释放对象</code>后，对象就销毁了，然后崩溃在doTask里。说明 self 并没有强引用对象。</p>
<p>为啥使用 <code>[self.obj doTask];</code> 就不会崩溃呢？</p>
<p>在 <code>[self.obj doTask];</code> 处打好断点：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914152010.png" style="zoom:50%;" /></p>
<p>会发现 <code>[self.obj doTask];</code> 等价于：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id tmp = objc_msgSend(<span class="variable language_">self</span>, <span class="string">&quot;obj&quot;</span>); </span><br><span class="line">objc_retainAutoreleasedReturnValue(tmp); <span class="regexp">//</span>貌似只要前一句代码是非常规获得的对象都会有这个函数的出现。</span><br><span class="line">objc_msgSend(tmp, <span class="string">&quot;doTask&quot;</span>);</span><br><span class="line">objc_release(tmp); <span class="regexp">//</span>这里是objc_release而不是objc_storeStrong是因为我们的代码不是<span class="string">&quot;id obj = [self obj]; [obj doTask];&quot;</span></span><br></pre></td></tr></table></figure>
<p>单步执行，并进入到objc_retainAutoreleasedReturnValue函数里：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914153236.png" style="zoom:50%;" /></p>
<p>会发现objc_retainAutoreleasedReturnValue的参数就是tmp，继续跟踪的话会发现objc_retainAutoreleasedReturnValue内部调用了objc_retain，于是tmp的引用计数+1，所以使用 <code>[self.obj doTask];</code> 不会崩溃。</p>
<p>而直接使用示例变量 <code>[_obj doTask];</code> </p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914153831.png" style="zoom:50%;" /></p>
<p>则没有类似的objc_retainAutoreleasedReturnValue处理，因此2秒后当self.obj = nil;置为nil时，obj就会释放并销毁，doTask内部再访问self时会野指针崩溃。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914154649.png" alt=""></p>
<p>打印日志：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">43</span>.<span class="number">518910</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783450</span>] self.obj:&lt;ARCPerson: <span class="number">0</span>x6000039dc500&gt;</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">43</span>.<span class="number">519025</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783450</span>] 开始计算</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">45</span>.<span class="number">521771</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783607</span>] ARCPerson dealloc</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">45</span>.<span class="number">521966</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783607</span>] (null) <span class="number">2</span></span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">45</span>.<span class="number">522120</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783607</span>] 清除</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">59</span>.<span class="number">732099</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783450</span>] 计算完成</span><br></pre></td></tr></table></figure>
<p>可以看到还没计算完成，self指向的对象就已经销毁了。</p>
<h4 id="Q4：MRC下dealloc重写时super调用的位置？-super-dealloc-到底干了啥？"><a href="#Q4：MRC下dealloc重写时super调用的位置？-super-dealloc-到底干了啥？" class="headerlink" title="Q4：MRC下dealloc重写时super调用的位置？[super dealloc]到底干了啥？"></a>Q4：MRC下dealloc重写时super调用的位置？[super dealloc]到底干了啥？</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;MRCPerson dealloc&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 4&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">    [<span class="variable language_">super</span> dealloc]; <span class="comment">//要放在最后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//崩溃写法</span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;MRCPerson dealloc&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 4&quot;</span>, <span class="keyword">self</span>.cat); <span class="comment">//这里野指针崩溃。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dealloc方法就是释放对象自身的内存，以及析构它拥有的所有资源，比如实例变量对象。在MRC下，[super dealloc]必须放在最后。如果你放最开始的地方，那么执行完后对象就已经被销毁了，后面如果还有方法对象的地方将导致崩溃。</p>
<p>还是要看源码[super dealloc]。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4566453/correct-super-dealloc">Correct [super dealloc]</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">ARC下dealloc过程及.cxx_destruct的探究</a>  4星</p>
<h4 id="Q5：一个weak指针指向一个MRC对象，该MRC对象重写了dealloc但不调用-super-dealloc-，当该MRC对象销毁后，再打印该weak指针，会输出什么？nil还是对象地址？"><a href="#Q5：一个weak指针指向一个MRC对象，该MRC对象重写了dealloc但不调用-super-dealloc-，当该MRC对象销毁后，再打印该weak指针，会输出什么？nil还是对象地址？" class="headerlink" title="Q5：一个weak指针指向一个MRC对象，该MRC对象重写了dealloc但不调用[super dealloc]，当该MRC对象销毁后，再打印该weak指针，会输出什么？nil还是对象地址？"></a>Q5：一个weak指针指向一个MRC对象，该MRC对象重写了dealloc但不调用[super dealloc]，当该MRC对象销毁后，再打印该weak指针，会输出什么？nil还是对象地址？</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> test_subclass_do_not_call_super_dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;weakObj:%@&quot;</span>, _wobj);<span class="comment">//断点打在这</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test_subclass_do_not_call_super_dealloc &#123;</span><br><span class="line">    MRCPerson *per = [[MRCPerson alloc] init];</span><br><span class="line">    _wobj = per;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;_wobj:%@&quot;</span>, _wobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MRCPerson不调用[super dealloc]</span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ dealloc&quot;</span>, <span class="keyword">self</span>.class);</span><br><span class="line"><span class="comment">//    [super dealloc];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：输出nil。</p>
<p>分析：对象销毁时如果不调用[super dealloc]，理论上不会清除对象的weak表，自然weak指针也不会被置为nil，因此应该输出对象的地址，然而却输出了nil，这说明某个地方做了一些处理。从上面的分析我们已经知道使用weak指针时，编译器会在前面插入 <code>objc_loadWeakRetained</code> ，使用完后在后面插入 <code>objc_release</code> 。</p>
<p>因此 <code>NSLog(@&quot;weakObj:%@&quot;, _wobj);//断点打在这</code> 等价于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id tmp = objc_loadWeakRetained(&amp;_wobj);  </span><br><span class="line">NSLog(@<span class="string">&quot;weakObj:%@&quot;</span>, tmp);</span><br><span class="line">objc_release(tmp);  </span><br></pre></td></tr></table></figure>
<p>而 objc_loadWeakRetained 源码里会rootTryRetain：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="title function_">objc_loadWeakRetained</span><span class="params">(id *location)</span></span><br><span class="line">&#123;</span><br><span class="line">    id obj;</span><br><span class="line">    id result;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    SideTable *table;</span><br><span class="line">    </span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">// fixme std::atomic this load</span></span><br><span class="line">    obj = *location;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</span><br><span class="line">    </span><br><span class="line">    table = &amp;SideTables()[obj];</span><br><span class="line">    </span><br><span class="line">    table-&gt;lock();</span><br><span class="line">    <span class="keyword">if</span> (*location != obj) &#123;</span><br><span class="line">        table-&gt;unlock();</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result = obj;</span><br><span class="line"></span><br><span class="line">    cls = obj-&gt;ISA();</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;hasCustomRR()) &#123;</span><br><span class="line">        <span class="comment">// Fast case. We know +initialize is complete because</span></span><br><span class="line">        <span class="comment">// default-RR can never be set before then.</span></span><br><span class="line">        ASSERT(cls-&gt;isInitialized());</span><br><span class="line">        <span class="keyword">if</span> (! obj-&gt;rootTryRetain()) &#123;  <span class="comment">//这里rootTryRetain</span></span><br><span class="line">            result = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Slow case. We must check for +initialize and call it outside</span></span><br><span class="line">        <span class="comment">// the lock if necessary in order to avoid deadlocks.</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isInitialized() || _thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">            BOOL (*tryRetain)(id, SEL) = (BOOL(*)(id, SEL))</span><br><span class="line">                class_getMethodImplementation(cls, @selector(retainWeakReference));</span><br><span class="line">            <span class="keyword">if</span> ((IMP)tryRetain == _objc_msgForward) &#123;</span><br><span class="line">                result = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (! (*tryRetain)(obj, @selector(retainWeakReference))) &#123; <span class="comment">//retainWeakReference</span></span><br><span class="line">                result = nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            table-&gt;unlock();</span><br><span class="line">            class_initialize(cls, obj);</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    table-&gt;unlock();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rootTryRetain里会判断如果对象正在销毁，则返回nil，因此导致objc_loadWeakRetained也返回nil。于是tmp等于nil，自然打印的也是nil了。</p>
<p>我们可以重写retainWeakReference，返回yes，再运行一下，这时打印的就是对象的地址了。所以这里的nil并不是因为weak被清，weak指针被置为nil，而是因为objc_loadWeakRetained返回了nil。另外对于MRC来说重写dealloc方法一定要调用super的dealloc，否则销毁工作并没有完全结束，内存会有泄漏。</p>
<h4 id="Q6：如何理解OC中内存管理相关的方法命名规则？"><a href="#Q6：如何理解OC中内存管理相关的方法命名规则？" class="headerlink" title="Q6：如何理解OC中内存管理相关的方法命名规则？"></a>Q6：如何理解OC中内存管理相关的方法命名规则？</h4><p>在OC中对于以alloc/init/new/copy/mutableCopy开头的方法创建返回的对象，是自己拥有的对象需要自己释放。其他开头的方法创建返回的对象，则不是自己拥有的对象不能自己释放，一般而言这样的对象是注册到自动释放池的对象，会在自动释放池销毁时释放，当然在一些特定情况下系统会优化性能避免注册到自动释放池，这一切对于开发者而言是无感知的，即使如此你依然没有拥有该对象不能自己释放。</p>
<p>比如myPerson方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)myPerson &#123;</span><br><span class="line">    ARCPerson *p = [[ARCPerson alloc] init];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>return p;</code> 打好断点，如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914165036.png" style="zoom:50%;" /></p>
<p>在返回时系统会将对象注册到自动释放池里。因此自己不拥有该对象，也就不能调用release方法。</p>
<p>而对于newPerson方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)newPerson &#123;</span><br><span class="line">    ARCPerson *p = [[ARCPerson alloc] init];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914165326.png" style="zoom:50%;" /></p>
<p>没有其他处理，返回的对象是自己拥有的，因此需要自己释放。</p>
<p>再比如getter方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MRCPerson *wobj;</span><br><span class="line"></span><br><span class="line">- (MRCPerson *)wobj &#123;</span><br><span class="line">    <span class="keyword">return</span> _wobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iOSWeakDemo`-[ViewController wobj]:</span><br><span class="line">    <span class="number">0x101e945e0</span> &lt;<span class="number">+0</span>&gt;:  pushq  <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x101e945e1</span> &lt;<span class="number">+1</span>&gt;:  movq   <span class="variable">%rsp</span><span class="punctuation">,</span> <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x101e945e4</span> &lt;<span class="number">+4</span>&gt;:  subq   $<span class="number">0x10</span><span class="punctuation">,</span> <span class="variable">%rsp</span></span><br><span class="line">    <span class="number">0x101e945e8</span> &lt;<span class="number">+8</span>&gt;:  movq   <span class="variable">%rdi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">0x101e945ec</span> &lt;<span class="number">+12</span>&gt;: movq   <span class="variable">%rsi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">10</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">0x101e945f0</span> &lt;<span class="number">+16</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line">-&gt;  <span class="number">0x101e945f4</span> &lt;<span class="number">+20</span>&gt;: movq   <span class="number">0x968d</span>(<span class="variable">%rip</span>)<span class="punctuation">,</span> <span class="variable">%rcx</span>        <span class="comment">; ViewController._wobj</span></span><br><span class="line">    <span class="number">0x101e945fb</span> &lt;<span class="number">+27</span>&gt;: addq   <span class="variable">%rcx</span><span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line">    <span class="number">0x101e945fe</span> &lt;<span class="number">+30</span>&gt;: movq   <span class="variable">%rax</span><span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line">    <span class="number">0x101e94601</span> &lt;<span class="number">+33</span>&gt;: callq  <span class="number">0x101e96024</span>               <span class="comment">; symbol stub for: objc_loadWeakRetained</span></span><br><span class="line">    <span class="number">0x101e94606</span> &lt;<span class="number">+38</span>&gt;: movq   <span class="variable">%rax</span><span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line">    <span class="number">0x101e94609</span> &lt;<span class="number">+41</span>&gt;: addq   $<span class="number">0x10</span><span class="punctuation">,</span> <span class="variable">%rsp</span></span><br><span class="line">    <span class="number">0x101e9460d</span> &lt;<span class="number">+45</span>&gt;: popq   <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x101e9460e</span> &lt;<span class="number">+46</span>&gt;: jmp    <span class="number">0x101e96006</span>               <span class="comment">; symbol stub for: objc_autoreleaseReturnValue</span></span><br></pre></td></tr></table></figure>
<p>因为这里是weak指针，所以这里调用的objc_loadWeakRetained函数。另外还会调用objc_autoreleaseReturnValue注册到自动释放池if needed。</p>
<p>如果是strong属性：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iOSWeakDemo`-[ViewController wobj]:</span><br><span class="line">    <span class="number">0x10529c5f0</span> &lt;<span class="number">+0</span>&gt;:  pushq  <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x10529c5f1</span> &lt;<span class="number">+1</span>&gt;:  movq   <span class="variable">%rsp</span><span class="punctuation">,</span> <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x10529c5f4</span> &lt;<span class="number">+4</span>&gt;:  movq   <span class="variable">%rdi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">0x10529c5f8</span> &lt;<span class="number">+8</span>&gt;:  movq   <span class="variable">%rsi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">10</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">0x10529c5fc</span> &lt;<span class="number">+12</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line">-&gt;  <span class="number">0x10529c600</span> &lt;<span class="number">+16</span>&gt;: movq   <span class="number">0x9689</span>(<span class="variable">%rip</span>)<span class="punctuation">,</span> <span class="variable">%rcx</span>        <span class="comment">; ViewController._wobj</span></span><br><span class="line">    <span class="number">0x10529c607</span> &lt;<span class="number">+23</span>&gt;: movq   (<span class="variable">%rax</span><span class="punctuation">,</span><span class="variable">%rcx</span>)<span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line">    <span class="number">0x10529c60b</span> &lt;<span class="number">+27</span>&gt;: popq   <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x10529c60c</span> &lt;<span class="number">+28</span>&gt;: jmp    <span class="number">0x10529e02c</span>               <span class="comment">; symbol stub for: objc_retainAutoreleaseReturnValue</span></span><br></pre></td></tr></table></figure>
<p>就只有objc_retainAutoreleaseReturnValue了。该函数的作用就是retain+autorelease。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>觉得文章有帮助可以打赏一下哦！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="jekyttt 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag"># 内存管理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/15/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8Bweak%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="prev" title="OC内存管理之weak修饰符实现原理">
      <i class="fa fa-chevron-left"></i> OC内存管理之weak修饰符实现原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/03/%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/" rel="next" title="预处理命令之宏定义">
      预处理命令之宏定义 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC"><span class="nav-text">ARC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strong-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">__strong 修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">__weak 修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autoreleasing%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">__autoreleasing修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unsafe-unretained-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">__unsafe_unretained 修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%96%91%E9%97%AE"><span class="nav-text">疑问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Q0%EF%BC%9AARC-%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%9F%E6%98%AF%E5%90%A6%E4%BB%85%E5%AF%B9-OC-%E6%96%87%E4%BB%B6%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">Q0：ARC 适用范围？是否仅对 OC 文件起作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q1%EF%BC%9A%E6%8A%8A%E4%B8%80%E4%B8%AA-weak-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%BD%93%E5%81%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E7%BB%99%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E5%BD%93%E6%96%B9%E6%B3%95%E5%BC%80%E5%A7%8B%E8%B0%83%E7%94%A8%E6%97%B6%EF%BC%8C%E5%8D%B3%E4%BD%BF%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E9%87%8A%E6%94%BE%E4%BA%86%EF%BC%8C%E6%AD%A4%E5%88%BB%E5%AF%B9%E8%B1%A1%E4%B9%9F%E4%B8%8D%E4%BC%9A%E8%A2%AB%E9%94%80%E6%AF%81%EF%BC%8C%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E5%BD%A2%E5%8F%82%E8%BF%99%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%8F%88%E5%BC%BA%E5%BC%95%E7%94%A8%E4%BA%86%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AF%B9%E8%B1%A1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E9%94%80%E6%AF%81%EF%BC%8C%E8%BF%98%E6%98%AF%E5%9B%A0%E4%B8%BA%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%92%E5%85%A5%E7%9A%84objc-loadWeakRetained%E5%87%BD%E6%95%B0%EF%BC%9F%E8%BF%98%E6%98%AF%E8%AF%B4%E4%B8%A4%E8%80%85%E9%83%BD%E6%9C%89%EF%BC%9F"><span class="nav-text">Q1：把一个 weak 指针变量当做参数传给一个方法，当方法开始调用时，即使对象被其他线程释放了，此刻对象也不会被销毁，原因是什么？是形参这个指针变量又强引用了对象，导致对象不会被销毁，还是因为编译器插入的objc_loadWeakRetained函数？还是说两者都有？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q2%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E7%A9%B6%E7%AB%9F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">Q2：函数的调用过程究竟是怎样的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q3%EF%BC%9A%E5%9C%A8-OC-%E4%B8%AD-obj-hello-%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E4%BC%9A%E5%8F%98%E6%88%90objc-msgSend-obj-quot-hello-quot-%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%8C-void-hello-%E6%96%B9%E6%B3%95%E5%85%B6%E5%AE%9E%E6%98%AF%E6%9A%97%E5%90%AB%E4%BA%86%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E6%98%AF-id-self%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%98%AF-sel-cmd%EF%BC%8C%E9%97%AE-self-%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BC%BA%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-text">Q3：在 OC 中 [obj hello]; 实际上是会变成objc_msgSend(obj, &quot;hello&quot;)的调用，-(void)hello;方法其实是暗含了两个参数的一个是 id self，一个是 sel _cmd，问 self 是否会强引用对象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q4%EF%BC%9AMRC%E4%B8%8Bdealloc%E9%87%8D%E5%86%99%E6%97%B6super%E8%B0%83%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9F-super-dealloc-%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F"><span class="nav-text">Q4：MRC下dealloc重写时super调用的位置？[super dealloc]到底干了啥？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q5%EF%BC%9A%E4%B8%80%E4%B8%AAweak%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AAMRC%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%AF%A5MRC%E5%AF%B9%E8%B1%A1%E9%87%8D%E5%86%99%E4%BA%86dealloc%E4%BD%86%E4%B8%8D%E8%B0%83%E7%94%A8-super-dealloc-%EF%BC%8C%E5%BD%93%E8%AF%A5MRC%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E5%90%8E%EF%BC%8C%E5%86%8D%E6%89%93%E5%8D%B0%E8%AF%A5weak%E6%8C%87%E9%92%88%EF%BC%8C%E4%BC%9A%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88%EF%BC%9Fnil%E8%BF%98%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="nav-text">Q5：一个weak指针指向一个MRC对象，该MRC对象重写了dealloc但不调用[super dealloc]，当该MRC对象销毁后，再打印该weak指针，会输出什么？nil还是对象地址？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q6%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3OC%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%9F"><span class="nav-text">Q6：如何理解OC中内存管理相关的方法命名规则？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jekyttt</p>
  <div class="site-description" itemprop="description">涉猎的编程语言为Objective-C、Swift、C,主要领域为iOS开发.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">116</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xq-120" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xq-120" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/yourname" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jekyttt</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  


    </div>
</body>
</html>
