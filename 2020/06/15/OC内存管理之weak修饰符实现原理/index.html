<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xq-120.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="源码版本：objc4-781 0.weak 修饰符的作用之前的文章提到过 __weak 修饰符作用： 1.当我们将一个对象赋值给一个 __weak 修饰符的指针变量时，编译器会插入 objc_initWeak 或 objc_storeWeak 函数将该弱指针变量从旧对象的weak表剔除（如果之前有指向对象的话）并注册到新对象的weak表里，然后将弱指针指向新对象。 2.当使用附有 __weak 修">
<meta property="og:type" content="article">
<meta property="og:title" content="OC内存管理之weak修饰符实现原理">
<meta property="og:url" content="https://xq-120.github.io/2020/06/15/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8Bweak%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="芝士就是力量">
<meta property="og:description" content="源码版本：objc4-781 0.weak 修饰符的作用之前的文章提到过 __weak 修饰符作用： 1.当我们将一个对象赋值给一个 __weak 修饰符的指针变量时，编译器会插入 objc_initWeak 或 objc_storeWeak 函数将该弱指针变量从旧对象的weak表剔除（如果之前有指向对象的话）并注册到新对象的weak表里，然后将弱指针指向新对象。 2.当使用附有 __weak 修">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/weak%E6%96%AD%E7%82%B9.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/strong%E6%B1%87%E7%BC%96.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/E011FE656F40C3CA194795B0CA107AA9.png">
<meta property="article:published_time" content="2020-06-15T05:41:14.000Z">
<meta property="article:modified_time" content="2024-12-14T07:50:26.469Z">
<meta property="article:author" content="jekyttt">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/weak%E6%96%AD%E7%82%B9.jpg">

<link rel="canonical" href="https://xq-120.github.io/2020/06/15/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8Bweak%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>OC内存管理之weak修饰符实现原理 | 芝士就是力量</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="芝士就是力量" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">芝士就是力量</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">像风一样自由</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/xq-120/xq-120.github.io" class="github-corner" title="XQ on GitHub" aria-label="XQ on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xq-120.github.io/2020/06/15/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8Bweak%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jekyttt">
      <meta itemprop="description" content="涉猎的编程语言为Objective-C、Swift、C,主要领域为iOS开发.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝士就是力量">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OC内存管理之weak修饰符实现原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-15 13:41:14" itemprop="dateCreated datePublished" datetime="2020-06-15T13:41:14+08:00">2020-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-14 15:50:26" itemprop="dateModified" datetime="2024-12-14T15:50:26+08:00">2024-12-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index"><span itemprop="name">OC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>源码版本：<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/objc4-781.tar.gz">objc4-781</a></p>
<h3 id="0-weak-修饰符的作用"><a href="#0-weak-修饰符的作用" class="headerlink" title="0.weak 修饰符的作用"></a>0.weak 修饰符的作用</h3><p>之前的文章提到过 <code>__weak</code> 修饰符作用：</p>
<p>1.当我们将一个对象赋值给一个 <code>__weak</code> 修饰符的指针变量时，编译器会插入 <code>objc_initWeak</code> 或 <code>objc_storeWeak</code> 函数将该弱指针变量从旧对象的weak表剔除（如果之前有指向对象的话）并注册到新对象的weak表里，然后将弱指针指向新对象。</p>
<p>2.当使用附有 <code>__weak</code> 修饰符的变量时，编译器会在使用前插入 <code>objc_loadWeakRetained</code> 函数将对象引用计数+1，保证对象在后面的使用过程中不被释放。并在使用后插入 <code>objc_release(tmp1);</code> 释放对象。</p>
<p>3.当弱引用指针变量超出作用域被废弃时，编译器会插入 <code>objc_destroyWeak</code> 将该指针变量从weak表里移除。</p>
<p>4.当对象销毁时，weak表中对象的所有弱引用指针变量会被赋值为nil，避免了野指针崩溃。比如对nil对象发送消息不会有任何反应，需要注意的是如果是对nil进行解引用还是会崩溃的。</p>
<p>这些功能是assign所不具备的，assign唯一与weak相同的地方就是不会导致对象的引用计数+1。</p>
<p>note：weak 只能用于修饰对象类型。并且只能用于iOS5及以上，在iOS4可以使用 <code>__unsafe_unretained</code> 代替.另外weak在MRC下也是有效果的，不过需要设置 <code>Weak References in Manual Retain Release</code> 为 YES。</p>
<p>今天就来看一下weak的上述功能是如何实现的，在看源码之前，可以带着一些问题，比如：</p>
<p>1.使用weak后为啥对象就不会被retain？</p>
<p>2.为了实现对象销毁时所有指向它的弱引用指针变量将被赋值为nil。你是不是得登记保存一下这些弱引用指针变量的地址？源码又是定义了哪些数据结构完成的。</p>
<p>3.一个 <code>__weak</code> 指针变量如果之前指向了A，后面改为指向B，你是不是得把之前登记的给删除（不删除的话会有什么问题），然后登记到新的对象下，这里就涉及到查找，源码为了提高查找效率又是如何优化的。</p>
<h3 id="1-objc-initWeak"><a href="#1-objc-initWeak" class="headerlink" title="1.objc_initWeak"></a>1.objc_initWeak</h3><p>对如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    XQPerson *p = [XQPerson new];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> XQPerson *wp = p;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;hello:%@&quot;</span>, wp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>__weak XQPerson *wp = p;</code>这一行打好断点。</p>
<p>运行后如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/weak%E6%96%AD%E7%82%B9.jpg" style="zoom:50%;" /></p>
<p>给指针变量添加__weak修饰符后，系统会调用一个objc_initWeak的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="title function_">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数接受两个参数：</p>
<p>location：双重指针变量，对象指针的指针。</p>
<p>newObj：指针变量，指向一个对象，它的值是对象的地址。</p>
<p>当传入的newObj等于nil时，将对象指针变量置为nil。在上述示例代码中<code>*location = nil;</code>就相当于<code>wp = nil;</code>。</p>
<p>接下来可以看下如果是将p赋值给一个__strong类型的指针变量会发生什么：</p>
<p>代码如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="keyword">void</span>)<span class="keyword">viewDidLoad</span> &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    XQModel <span class="operator">*</span>model <span class="operator">=</span> [XQModel <span class="keyword">new</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">id</span> tmp <span class="operator">=</span> model;</span><br><span class="line">    </span><br><span class="line">    NSLog(<span class="string">@&quot;tmp:%@&quot;</span>, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打好断点后运行，会看到如下汇编代码：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/strong%E6%B1%87%E7%BC%96.png" style="zoom:50%;" /></p>
<p>可以看到如果是将model赋值给一个 <code>__strong</code> 类型的指针变量，系统会调用到<code>objc_retain</code>函数，对象的引用计数就会加1。</p>
<p>稍微总结一下：</p>
<p>使用 <code>__weak</code> 修饰符时，系统会调用objc_initWeak函数而没有调用类似<code>objc_retain</code>这样的函数，因此对象的引用计数不会发生改变。</p>
<p>使用 <code>__strong</code> 修饰符时，系统会调用<code>objc_retain</code>函数，对象的引用计数会加1。</p>
<p>在继续 weak 的实现原理之前，需要区分<strong>指向对象的指针变量</strong>和<strong>对象</strong>之间的关系：</p>
<p>指向对象的指针变量是一个变量，它的值是一个地址，这个地址指向某一段内存空间。在上述代码中指针变量 wp 是分配在栈上的，而 wp指向的对象是分配在堆上的。</p>
<p>对象：分配在堆上的一段内存空间，我们需要一个指针变量来引用它，才可以找到并访问这个对象。</p>
<p>它们之间的关系类似于人和人名之间的关系，你可以通过人名找到这个人，但人名不等于人。</p>
<p>后续实现 weak 的数据结构里面要保存的几个关键信息中就包含指针变量的值（即对象的地址）和指针变量的地址。在示例代码中就是保存 wp 的值和 wp自身的地址。</p>
<p>为什么需要保存指针变量的地址呢？因为 weak 修饰符的功能之一就是当对象销毁时将所有指向它的弱引用指针变量赋值为nil。当保存了这些指针变量的地址我们就可以很方便的将这些指针变量赋值为 nil ，而在这个语境下不太可能通过指针变量名来将其置为 nil。</p>
<p>为了实现weak 修饰符的功能，源码中定义了一系列的数据结构。只有充分理解了要干嘛，在看源码时才更有体会。</p>
<h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h3><p>在介绍 weak 的实现前，有一些相关的数据结构需要说明一下：</p>
<h4 id="StripedMap"><a href="#StripedMap" class="headerlink" title="StripedMap"></a>StripedMap</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StripedMap&lt;T&gt; is a map of void* -&gt; T, sized appropriately </span></span><br><span class="line"><span class="comment">// for cache-friendly lock striping. </span></span><br><span class="line"><span class="comment">// For example, this may be used as StripedMap&lt;spinlock_t&gt;</span></span><br><span class="line"><span class="comment">// or as StripedMap&lt;SomeStruct&gt; where SomeStruct stores a spin lock.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StripedMap</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PaddedT</span> &#123;</span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) &#123; </span><br><span class="line">        <span class="keyword">return</span> array[<span class="built_in">indexForPointer</span>(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shortcuts for StripedMaps of locks.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lockAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            array[i].value.<span class="built_in">lock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlockAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            array[i].value.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">forceResetAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            array[i].value.forceReset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">defineLockOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            <span class="built_in">lockdebug_lock_precedes_lock</span>(&amp;array[i<span class="number">-1</span>].value, &amp;array[i].value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">precedeLock</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *newlock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assumes defineLockOrder is also called</span></span><br><span class="line">        <span class="built_in">lockdebug_lock_precedes_lock</span>(&amp;array[StripeCount<span class="number">-1</span>].value, newlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">succeedLock</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *oldlock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assumes defineLockOrder is also called</span></span><br><span class="line">        <span class="built_in">lockdebug_lock_precedes_lock</span>(oldlock, &amp;array[<span class="number">0</span>].value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">void</span> *<span class="title">getLock</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; StripeCount) <span class="keyword">return</span> &amp;array[i].value;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">StripedMap</span>() &#123;</span><br><span class="line">        <span class="comment">// Verify alignment expectations.</span></span><br><span class="line">        <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">0</span>].value;</span><br><span class="line">        <span class="type">uintptr_t</span> delta = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">1</span>].value - base;</span><br><span class="line">        <span class="built_in">ASSERT</span>(delta % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">ASSERT</span>(base % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">StripedMap</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>StripedMap 字面意思是条纹map，是一个哈希表模板类，key 是对象地址，value 是 T 类型实例，T 里面需要有一把自旋锁。StripedMap里面定义了一个长度为 8或者64的数组，数组元素是T 类型实例。</p>
<p>主要的一个函数：将一个地址映射为数组的下标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> addr = reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SideTablesMap"><a href="#SideTablesMap" class="headerlink" title="SideTablesMap"></a>SideTablesMap</h4><p>边表map</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</span><br><span class="line"><span class="function"><span class="type">static</span> StripedMap&lt;SideTable&gt;&amp; <span class="title">SideTables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SideTablesMap.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitInit</span> &#123;</span><br><span class="line">    <span class="built_in">alignas</span>(Type) <span class="type">uint8_t</span> _storage[<span class="built_in">sizeof</span>(Type)]; <span class="comment">//ExplicitInit里有一个数组,数组的长度是sizeof(Type)，而sizeof(StripedMap&lt;SideTable&gt;)在iOS上等于512（8*64），mac上为4096（64*64）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(Ts &amp;&amp;... Args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (_storage) <span class="built_in">Type</span>(std::forward&lt;Ts&gt;(Args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type &amp;<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;Type *&gt;(_storage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SideTablesMap是一个静态全局变量，它是在arr_init函数中初始化的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">arr_init</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage::<span class="built_in">init</span>();</span><br><span class="line">    SideTablesMap.<span class="built_in">init</span>();</span><br><span class="line">    _objc_associations_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而arr_init函数是在map_images_nolock中被调用的，map_images_nolock又是在map_images中被调用的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">map_images_nolock</span><span class="params">(<span class="type">unsigned</span> mhCount, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">map_images</span><span class="params">(<span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> paths[],</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span>;</span><br></pre></td></tr></table></figure>
<p>简而言之，在 runtime 启动时会初始化一个自动释放池AutoreleasePoolPage，一个静态全局变量SideTablesMap，一个关联对象管理器AssociationsManager（保存类别中关联的实例变量）。</p>
<p>SideTablesMap的类型为 <code>ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt;</code> ，C++的类也没怎么看懂，大致可以把SideTablesMap理解为一个全局的hash数组，数组长度为8（iPhone ）或64（Mac），里面存储的是SideTable，因此SideTable不止一个。</p>
<p>源码里一般通过 <code>&amp;SideTables()</code> 获取一个SideTable</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static StripedMap&lt;SideTable&gt;&amp; <span class="built_in">SideTables</span>() &#123;</span><br><span class="line">    return SideTablesMap<span class="selector-class">.get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如：<code>SideTable *newTable = &amp;SideTables()[newObj];</code></p>
<p>通过将传入的对象地址映射为数组index，然后从数组中取出对应的SideTable。</p>
<h4 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h4><p>边表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SideTable</span> &#123;</span><br><span class="line">    <span class="type">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="type">weak_table_t</span> weak_table;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SideTable</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;weak_table, <span class="number">0</span>, <span class="built_in">sizeof</span>(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SideTable</span>() &#123;</span><br><span class="line">        _objc_fatal(<span class="string">&quot;Do not delete SideTable.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; slock.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; slock.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">forceReset</span><span class="params">()</span> </span>&#123; slock.forceReset(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Address-ordered lock discipline for a pair of side tables.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;HaveOld, HaveNew&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">lockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;HaveOld, HaveNew&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">unlockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>slock：自旋锁</p>
<p>refcnts：引用计数表。<strong>哈希表</strong></p>
<p>weak_table：弱引用表。里面有一个成员变量指向一个哈希表</p>
<p>RefcountMap是一个类型别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RefcountMap disguises its pointers because we </span></span><br><span class="line"><span class="comment">// don&#x27;t want the table to act as a root for `leaks`.</span></span><br><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="type">size_t</span>,RefcountMapValuePurgeable&gt; RefcountMap;</span><br></pre></td></tr></table></figure>
<h4 id="DisguisedPtr"><a href="#DisguisedPtr" class="headerlink" title="DisguisedPtr"></a>DisguisedPtr</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisguisedPtr&lt;T&gt; acts like pointer type T*, except the </span></span><br><span class="line"><span class="comment">// stored value is disguised to hide it from tools like `leaks`.</span></span><br><span class="line"><span class="comment">// nil is disguised as itself so zero-filled memory works as expected, </span></span><br><span class="line"><span class="comment">// which means 0x80..00 is also disguised as itself but we don&#x27;t care.</span></span><br><span class="line"><span class="comment">// Note that weak_entry_t knows about this encoding.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisguisedPtr</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title">disguise</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(<span class="type">uintptr_t</span>)ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">undisguise</span><span class="params">(<span class="type">uintptr_t</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*)-val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisguisedPtr</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">DisguisedPtr</span>(T* ptr) </span><br><span class="line">        : <span class="built_in">value</span>(<span class="built_in">disguise</span>(ptr)) &#123; &#125;</span><br><span class="line">    <span class="built_in">DisguisedPtr</span>(<span class="type">const</span> DisguisedPtr&lt;T&gt;&amp; ptr) </span><br><span class="line">        : <span class="built_in">value</span>(ptr.value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; <span class="keyword">operator</span> = (T* rhs) &#123;</span><br><span class="line">        value = <span class="built_in">disguise</span>(rhs);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> DisguisedPtr&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> T* () <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">undisguise</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt; () <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">undisguise</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> * () <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">undisguise</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> [] (<span class="type">size_t</span> i) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">undisguise</span>(value)[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pointer arithmetic operators omitted </span></span><br><span class="line">    <span class="comment">// because we don&#x27;t currently use them anywhere</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指针伪装模板类，<code>DisguisedPtr&lt;T&gt;</code>的作用类似于<code>T *</code>，但不是真正的<code>T *</code>，它里面只有一个无符号整型属性value，并没有一个真的指针成员<code>T *</code>。理论上 value 的值保存被引用对象的地址就可以了，有了对象的地址又有对象的类型，DisguisedPtr的功能已经类似于一个指针变量<code>T *</code>了。</p>
<p>但是DisguisedPtr并没有直接保存被引用对象的地址，而是将其取负后再强转为无符号整数。这么做的目的就是让类似于leaks这样的工具检测不到有这么个东西也保存了对象的地址。</p>
<p>DisguisedPtr中的两个重要方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪装对象的地址</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title">disguise</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(<span class="type">uintptr_t</span>)ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解伪装对象的地址</span></span><br><span class="line"><span class="function"><span class="type">static</span> T* <span class="title">undisguise</span><span class="params">(<span class="type">uintptr_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T*)-val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The address of a __weak variable.</span></span><br><span class="line"><span class="comment">// These pointers are stored disguised so memory analysis tools</span></span><br><span class="line"><span class="comment">// don&#x27;t see lots of interior pointers from the weak table into objects.</span></span><br><span class="line"><span class="keyword">typedef</span> DisguisedPtr&lt;objc_object *&gt; <span class="type">weak_referrer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_MINUS_2 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_MINUS_2 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal structure stored in the weak references table. </span></span><br><span class="line"><span class="comment"> * It maintains and stores</span></span><br><span class="line"><span class="comment"> * a hash set of weak references pointing to an object.</span></span><br><span class="line"><span class="comment"> * If out_of_line_ness != REFERRERS_OUT_OF_LINE then the set</span></span><br><span class="line"><span class="comment"> * is instead a small inline array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEAK_INLINE_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].</span></span><br><span class="line"><span class="comment">// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.</span></span><br><span class="line"><span class="comment">// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00</span></span><br><span class="line"><span class="comment">// (disguised nil or 0x80..00) or 0b11 (any other address).</span></span><br><span class="line"><span class="comment">// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_entry_t</span> &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">weak_referrer_t</span> *referrers; <span class="comment">//哈希表，动态数组</span></span><br><span class="line">            <span class="type">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>; </span><br><span class="line">            <span class="type">uintptr_t</span>        num_refs : PTR_MINUS_2;</span><br><span class="line">            <span class="type">uintptr_t</span>        mask;</span><br><span class="line">            <span class="type">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            <span class="type">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT]; <span class="comment">//普通数组，可以存储4个元素，弱引用&lt;=4时保存在这里。起到优化作用。</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">weak_entry_t</span>&amp; other) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="built_in">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : <span class="built_in">referent</span>(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>weak_entry_t 主要保存了被引用对象自身以及指向它的所有弱引用指针变量的地址。weak entry实体自身被保存在weak表中。</p>
<p>referent：用于保存对象的地址，DisguisedPtr<objc_object>类型，效果类似于objc_object <em>但并不是真正的objc_object </em>类型。</p>
<p>接下来是一个联合，主要用于保存该对象的所有弱引用指针变量的地址。使用联合主要是为了优化存储。</p>
<p>如果弱引用个数&lt;=4，则使用inline_referrers固定数组保存。 </p>
<p>如果弱引用个数&gt;4，则使用动态数组weak_referrer_t *referrers。referrers其实是一个哈希表，存储在里面的弱引用指针变量的地址并不是按顺序依次排列的，而是将弱引用指针变量的地址映射为一个 index，然后存储在 index 上，这样做的好处就是可以快速查找出它在referrers中的位置，否则只能遍历整个数组。这里就是源码为了提高查找效率做的优化。</p>
<p>out_of_line_ness：是否使用动态hash数组标记位</p>
<p>num_refs：hash数组referrers中的元素个数</p>
<p>mask：hash数组长度-1。（注意，这里是hash数组的长度，而不是元素个数。比如，数组长度可能是64，而元素个数仅存了2个）。</p>
<p>max_hash_displacement：可能会发生的hash冲突的最大次数，用于判断是否出现了逻辑错误（hash表中的冲突次数绝不会超过该值）</p>
<h4 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global weak references table. Stores object ids as keys,</span></span><br><span class="line"><span class="comment"> * and weak_entry_t structs as their values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_table_t</span> &#123;</span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries; <span class="comment">//哈希表，容量不够了会扩容</span></span><br><span class="line">    <span class="type">size_t</span>    num_entries;</span><br><span class="line">    <span class="type">uintptr_t</span> mask;</span><br><span class="line">    <span class="type">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>weak_table_t weak表，是一个全局的弱引用表，也是一个哈希表。被引用的对象的地址作为key，weak_entry_t结构体作为值。</p>
<p>weak_entries： 指针变量，指向一个hash数组，数组里存储弱引用对象的相关信息weak_entry_t。初始时为NULL，第一次插入时才会创建一个长度为64的数组并用weak_entries指向该数组，相当于懒加载。如果事先分配一个长度为64的数组，显然是不必要的，因为有可能没有地方使用到weak指针。</p>
<p>num_entries： hash数组中的元素个数</p>
<p>mask：hash数组长度-1（注意，这里是hash数组的长度，而不是元素个数。比如，数组长度可能是64，而元素个数仅存了2个）    </p>
<p>max_hash_displacement：可能会发生的hash冲突的最大次数，用于判断是否出现了逻辑错误（hash表中的冲突次数绝不会超过该值）</p>
<p>ps：在C++里面weak_entry_t就相当于struct weak_entry_t可以省略struct，在C中肯定是没有这样的语法的，我说怎么看起来这么奇怪。</p>
<h3 id="3-weak的实现"><a href="#3-weak的实现" class="headerlink" title="3.weak的实现"></a>3.weak的实现</h3><h4 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h4><p>前面已经知道，使用__weak修饰符时，系统其实是调用了objc_initWeak函数，本节就分析一下objc_initWeak的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id</span></span><br><span class="line"><span class="function"><span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>location的值就是对象指针变量的地址，<code>*location</code> 指向旧对象，newObj指向新对象。后面的大部分操作都和这三个值有关。</p>
<h4 id="storeweak"><a href="#storeweak" class="headerlink" title="storeweak"></a>storeweak</h4><p>objc_initWeak主要调用了storeweak函数，它的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> id </span></span><br><span class="line"><span class="function"><span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) <span class="built_in">ASSERT</span>(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire locks for old and new values.</span></span><br><span class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></span><br><span class="line">    <span class="comment">// Retry if the old value changes underneath us.</span></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;<span class="built_in">SideTables</span>()[oldObj]; <span class="comment">//从SideTablesMap哈希表中获取旧对象的SideTable</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;<span class="built_in">SideTables</span>()[newObj]; <span class="comment">//从SideTablesMap哈希表中获取新对象的SideTable</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::<span class="built_in">lockTwo</span>&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::<span class="built_in">unlockTwo</span>&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a deadlock between the weak reference machinery</span></span><br><span class="line">    <span class="comment">// and the +initialize machinery by ensuring that no </span></span><br><span class="line">    <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;<span class="built_in">isInitialized</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::<span class="built_in">unlockTwo</span>&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            <span class="built_in">class_initialize</span>(cls, (id)newObj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this class is finished with +initialize then we&#x27;re good.</span></span><br><span class="line">            <span class="comment">// If this class is still running +initialize on this thread </span></span><br><span class="line">            <span class="comment">// (i.e. +initialize called storeWeak on an instance of itself)</span></span><br><span class="line">            <span class="comment">// then we may proceed but it will appear initializing and </span></span><br><span class="line">            <span class="comment">// not yet initialized to the check above.</span></span><br><span class="line">            <span class="comment">// Instead set previouslyInitializedClass to recognize it on retry.</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        <span class="built_in">weak_unregister_no_lock</span>(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            <span class="built_in">weak_register_no_lock</span>(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;<span class="built_in">isTaggedPointer</span>()) &#123;</span><br><span class="line">            newObj-&gt;<span class="built_in">setWeaklyReferenced_nolock</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::<span class="built_in">unlockTwo</span>&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> StripedMap&lt;SideTable&gt;&amp; <span class="title">SideTables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SideTablesMap.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>storeWeak的作用大致如下：</p>
<ol>
<li>根据旧对象的地址从SideTablesMap中找到旧SideTable，根据新对象的地址从SideTablesMap中找到新SideTable</li>
<li>加锁，锁上新旧SideTable。因为后面要操作表里面的东西了，保证同一时刻只能由一个线程操作该表。</li>
<li>unregister，从旧的表中移除当前指针变量地址。</li>
<li>register，在新的表中登记当前指针变量地址。</li>
<li>将对象的<code>weakly_referenced</code>标志位置为 true，说明该对象是有弱引用指针的，销毁时需要将它们置为 nil 并移除。完成后将指针变量的值指向新对象。</li>
<li>解锁SideTable</li>
</ol>
<p>另外，unregister或register时可能会进行weak表的减容或扩容。</p>
<p>这里面主要的两个函数就是weak_unregister_no_lock和weak_register_no_lock了。</p>
<h4 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h4><p>先来看weak_register_no_lock:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Registers a new (object, weak pointer) pair. Creates a new weak</span></span><br><span class="line"><span class="comment"> * object entry if it does not exist.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object pointed to by the weak reference.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak pointer address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">id</span> </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="type">id</span> referent_id, </span><br><span class="line">                      <span class="type">id</span> *referrer_id, <span class="type">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">    <span class="type">bool</span> deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (<span class="type">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((<span class="type">id</span>)referent, </span><br><span class="line">                                           <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Cannot form weak reference to instance (%p) of &quot;</span></span><br><span class="line">                        <span class="string">&quot;class %s. It is possible that this object was &quot;</span></span><br><span class="line">                        <span class="string">&quot;over-released, or is in the process of deallocation.&quot;</span>,</span><br><span class="line">                        (<span class="type">void</span>*)referent, object_getClassName((<span class="type">id</span>)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概过程：</p>
<ol>
<li>根据对象的地址从weak_table中找到weak_entry_t，把指针变量的地址保存到weak_entry_t里的数组中。</li>
<li>如果在weak_table没有找到该对象的weak_entry_t，则新创建一个weak_entry_t并把指针变量的地址保存到weak_entry_t里的数组中，扩容weak_table（if needed）,将新创建的weak_entry_t插入到weak_table中</li>
</ol>
<p>正常保存之前会有一些判断，会判断当前对象是否正在销毁，如果正在销毁则根据crashIfDeallocating决定是崩溃还是返回 nil，如果是返回 nil，则指针变量就被赋值为nil 了。对于 objc_initWeak 和 objc_storeWeak函数来说传入的都是DoCrashIfDeallocating，因此<strong>不要在对象的 dealloc 方法里再去弱引用它</strong>。比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="type">id</span> __<span class="keyword">weak</span> obj = <span class="keyword">self</span>; <span class="comment">//实际代码当然不会这么明显，比较隐蔽的一种情况是懒加载的view设置delegate为self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>崩溃：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc[70479]: Cannot form weak reference to<span class="built_in"> instance </span>(0x600001778540) of class ARCPerson. It is possible that this object was over-released,<span class="built_in"> or </span>is in the process of deallocation.</span><br></pre></td></tr></table></figure>
<p>weak_register_no_lock里面调用了很多函数，不过都是哈希表的操作，一个个看。</p>
<h5 id="weak-entry-for-referent"><a href="#weak-entry-for-referent" class="headerlink" title="weak_entry_for_referent"></a>weak_entry_for_referent</h5><p>weak_entry_for_referent：根据对象的地址从weak_table中找到weak_entry_t</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Return the weak reference table entry for the given referent. </span></span><br><span class="line"><span class="comment"> * If there is no entry for referent, return NULL. </span></span><br><span class="line"><span class="comment"> * Performs a lookup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object. Must not be nil.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The table of weak referrers to this object. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(referent);</span><br><span class="line"></span><br><span class="line">    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>首先判断weak_table_t的成员变量weak_entries是否为NULL，如果为NULL说明需要创建哈希数组。</li>
<li>将对象地址hash 化并按位与weak_table-&gt;mask确保不会数组越界，这样就得到一个起始 index。</li>
<li>hash冲突解决，如果 index 处已经有元素但并不等于当前对象，表明存在 hash冲突，则和 index 的下一个位置进行比较。期间如果又找到开始的位置则调用bad_weak_table函数抛出异常。如果超过了最大哈希冲突max_hash_displacement则停止查找也返回 nil，表明哈希表冲突太多了需要扩容了。</li>
</ol>
<p>这里可以看一下对象地址的hash 化：hash_pointer(referent)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title function_">hash_pointer</span><span class="params">(objc_object *key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_hash((<span class="type">uintptr_t</span>)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pointer hash function.</span></span><br><span class="line"><span class="comment">// This is not a terrific hash, but it is fast </span></span><br><span class="line"><span class="comment">// and not outrageously flawed for our purposes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Based on principles from http://locklessinc.com/articles/fast_hash/</span></span><br><span class="line"><span class="comment">// and evaluation ideas from http://floodyberry.com/noncryptohashzoo/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">ptr_hash</span><span class="params">(<span class="type">uint64_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    key *= <span class="number">0x8a970be7488fda55</span>;</span><br><span class="line">    key ^= __builtin_bswap64(key);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">ptr_hash</span><span class="params">(<span class="type">uint32_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    key *= <span class="number">0x5052acdb</span>;</span><br><span class="line">    key ^= __builtin_bswap32(key);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Higher-quality hash function. This is measurably slower in some workloads.</span></span><br><span class="line"><span class="comment">#if __LP64__</span></span><br><span class="line"><span class="comment"> uint32_t ptr_hash(uint64_t key)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    key -= __builtin_bswap64(key);</span></span><br><span class="line"><span class="comment">    key *= 0x8a970be7488fda55;</span></span><br><span class="line"><span class="comment">    key ^= __builtin_bswap64(key);</span></span><br><span class="line"><span class="comment">    key *= 0x8a970be7488fda55;</span></span><br><span class="line"><span class="comment">    key ^= __builtin_bswap64(key);</span></span><br><span class="line"><span class="comment">    return (uint32_t)key;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">static uint32_t ptr_hash(uint32_t key)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    key -= __builtin_bswap32(key);</span></span><br><span class="line"><span class="comment">    key *= 0x5052acdb;</span></span><br><span class="line"><span class="comment">    key ^= __builtin_bswap32(key);</span></span><br><span class="line"><span class="comment">    key *= 0x5052acdb;</span></span><br><span class="line"><span class="comment">    key ^= __builtin_bswap32(key);</span></span><br><span class="line"><span class="comment">    return key;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>系统采用了一个不是很棒但是速度很快的哈希函数，不是很棒表明该哈希函数可能会导致一些哈希冲突，散列的不是很均匀。同时注释里列举了一个高质量的哈希函数，但是在某些情况下速度比较慢的哈希函数。可以看到系统对散列均匀程度与速度之间的权衡。</p>
<h5 id="weak-entry-insert"><a href="#weak-entry-insert" class="headerlink" title="weak_entry_insert"></a>weak_entry_insert</h5><p>weak_entry_insert：往weak表中插入一个元素weak_entry_t</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_entry_insert</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">weak_entry_t</span> *new_entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    ASSERT(weak_entries != nil);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_entries[index].referent != nil) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_entries); <span class="comment">//bad_weak_table就是抛出异常。一般不会到这里</span></span><br><span class="line">        hash_displacement++; <span class="comment">//记录冲突的次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entries[index] = *new_entry;</span><br><span class="line">    weak_table-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">        weak_table-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样先得到一个起始 index，再进行 hash 冲突解决并记录冲突的次数，然后插入到空位置。最后更新哈希表的最大哈希冲突值max_hash_displacement。</p>
<h5 id="weak-grow-maybe"><a href="#weak-grow-maybe" class="headerlink" title="weak_grow_maybe"></a>weak_grow_maybe</h5><p>weak_grow_maybe：扩容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grow the given zone&#x27;s table of weak references if it is full.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_grow_maybe</span><span class="params">(<span class="type">weak_table_t</span> *weak_table)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grow if at least 3/4 full.</span></span><br><span class="line">    <span class="keyword">if</span> (weak_table-&gt;num_entries &gt;= old_size * <span class="number">3</span> / <span class="number">4</span>) &#123;</span><br><span class="line">        weak_resize(weak_table, old_size ? old_size*<span class="number">2</span> : <span class="number">64</span>); <span class="comment">//old_size为0时，则默认设置为64个槽。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>达到最大空间的3/4时进行扩容。扩容时机：插入元素前，会先判断是否需要扩容。</p>
<h5 id="append-referrer"><a href="#append-referrer" class="headerlink" title="append_referrer"></a>append_referrer</h5><p>append_referrer：将指针变量地址添加到weak_entry_t的哈希表里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Add the given referrer to set of weak pointers in this entry.</span></span><br><span class="line"><span class="comment"> * Does not perform duplicate checking (b/c weak pointers are never</span></span><br><span class="line"><span class="comment"> * added to a set twice). </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the set of weak pointers. </span></span><br><span class="line"><span class="comment"> * @param new_referrer The new weak pointer to be added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">append_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **new_referrer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Couldn&#x27;t insert inline. Allocate out of line.</span></span><br><span class="line">        <span class="type">weak_referrer_t</span> *new_referrers = (<span class="type">weak_referrer_t</span> *)</span><br><span class="line">            <span class="built_in">calloc</span>(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(<span class="type">weak_referrer_t</span>));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(entry-&gt;out_of_line());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Grow the entry&#x27;s hash table of referrers. Rehashes each</span></span><br><span class="line"><span class="comment"> * of the referrers.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param entry Weak pointer hash set for a particular object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__attribute__((noinline, used))</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">grow_refs_and_insert</span><span class="params">(<span class="type">weak_entry_t</span> *entry, </span></span><br><span class="line"><span class="params">                                 objc_object **new_referrer)</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(entry-&gt;out_of_line());</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(entry);</span><br><span class="line">    <span class="type">size_t</span> new_size = old_size ? old_size * <span class="number">2</span> : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> num_refs = entry-&gt;num_refs;</span><br><span class="line">    <span class="type">weak_referrer_t</span> *old_refs = entry-&gt;referrers;</span><br><span class="line">    entry-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    entry-&gt;referrers = (<span class="type">weak_referrer_t</span> *)</span><br><span class="line">        <span class="built_in">calloc</span>(TABLE_SIZE(entry), <span class="keyword">sizeof</span>(<span class="type">weak_referrer_t</span>));</span><br><span class="line">    entry-&gt;num_refs = <span class="number">0</span>;</span><br><span class="line">    entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; old_size &amp;&amp; num_refs &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (old_refs[i] != nil) &#123;</span><br><span class="line">            append_referrer(entry, old_refs[i]);</span><br><span class="line">            num_refs--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Insert</span></span><br><span class="line">    append_referrer(entry, new_referrer);</span><br><span class="line">    <span class="keyword">if</span> (old_refs) <span class="built_in">free</span>(old_refs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的参数是 <code>new_referrer</code> ，即我们将要把对象指针变量的地址插入到entry的哈希表里。</p>
<p>这里会先判断有没有超出 <code>out_of_line</code> ，如果没有则插入到一个普通数组，否则插入到一个哈希数组里。</p>
<p>上面是 <code>weak_register_no_lock</code> 的整个逻辑。下面看一下 <code>weak_unregister_no_lock</code> 。</p>
<h4 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><p>weak_unregister_no_lock：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">weak_unregister_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id, </span></span><br><span class="line"><span class="params">                        id *referrer_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="type">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>找到weak_entry</li>
<li>调用remove_referrer移除指针变量地址</li>
<li>判断weak_entry是否为空，为空则从weak_table中将weak_entry也移除。weak_table减容如果可能。</li>
</ol>
<p>这里主要是remove_referrer和weak_entry_remove的调用。</p>
<h5 id="remove-referrer"><a href="#remove-referrer" class="headerlink" title="remove_referrer"></a>remove_referrer</h5><p>remove_referrer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Remove old_referrer from set of referrers, if it&#x27;s present.</span></span><br><span class="line"><span class="comment"> * Does not remove duplicates, because duplicates should not exist. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @todo this is slow if old_referrer is not present. Is this ever the case? </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the referrers.</span></span><br><span class="line"><span class="comment"> * @param old_referrer The referrer to remove. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **old_referrer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                     <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                     <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                     <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                         <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                         <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                         <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很多，但逻辑很简单，就是找到old_referrer这个元素的位置，然后将这个位置的内容置为 nil。注意这里并没有将弱引用指针置位nil。</p>
<h5 id="weak-entry-remove"><a href="#weak-entry-remove" class="headerlink" title="weak_entry_remove"></a>weak_entry_remove</h5><p>weak_entry_remove：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove entry from the zone&#x27;s table of weak references.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_entry_remove</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">weak_entry_t</span> *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// remove entry</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) <span class="built_in">free</span>(entry-&gt;referrers);</span><br><span class="line">    bzero(entry, <span class="keyword">sizeof</span>(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line"></span><br><span class="line">    weak_compact_maybe(weak_table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shrink the table if it is mostly empty.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_compact_maybe</span><span class="params">(<span class="type">weak_table_t</span> *weak_table)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shrink if larger than 1024 buckets and at most 1/16 full.</span></span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= <span class="number">1024</span>  &amp;&amp; old_size / <span class="number">16</span> &gt;= weak_table-&gt;num_entries) &#123;</span><br><span class="line">        weak_resize(weak_table, old_size / <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// leaves new table no more than 1/2 full</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>如果weak_entry_t使用的是哈希数组则释放哈希数组内存</li>
<li>将weak_entry_t自身的内存清零，这样weak_table_t中就腾出来一个可用的位置</li>
<li>将num_entries减 1，即weak_table_t元素个数减 1</li>
<li>如果weak表里面元素个数小于某个值时，则将weak_table_t进行减容</li>
</ol>
<p>减容和扩容都会调用weak_resize：</p>
<h4 id="weak-resize"><a href="#weak-resize" class="headerlink" title="weak_resize"></a>weak_resize</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_resize</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">size_t</span> new_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *old_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    <span class="type">weak_entry_t</span> *new_entries = (<span class="type">weak_entry_t</span> *)</span><br><span class="line">        <span class="built_in">calloc</span>(new_size, <span class="keyword">sizeof</span>(<span class="type">weak_entry_t</span>));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">    weak_table-&gt;weak_entries = new_entries;</span><br><span class="line">    weak_table-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (old_entries) &#123;</span><br><span class="line">        <span class="type">weak_entry_t</span> *entry;</span><br><span class="line">        <span class="type">weak_entry_t</span> *end = old_entries + old_size;</span><br><span class="line">        <span class="keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;referent) &#123;</span><br><span class="line">                weak_entry_insert(weak_table, entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(old_entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>开辟一个新的长度为new_size的内存空间</li>
<li>将旧的哈希表old_entries里的weak_entry_t重新插入（其实就是重新散列）到新的new_entries里，插入前判断entry-&gt;referent是否有值。这样已经清零的内存就不会插入。</li>
</ol>
<p>到此为止objc_initWeak的作用就分析完了。</p>
<p>接下来就是查看当对象销毁时，如何将所有指向它的弱引用指针变量赋值为nil。</p>
<h4 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h4><p>一个对象销毁时会调用dealloc方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123; <span class="comment">//NSObject的dealloc，所以在子类中需要调用super才会执行如weak表的清除，关联对象的释放等。</span></span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;<span class="built_in">rootDealloc</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootDealloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">sidetable_present</span>());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_dispose</span></span><br><span class="line"><span class="comment">* fixme</span></span><br><span class="line"><span class="comment">* Locking: none</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">id </span></span><br><span class="line"><span class="function"><span class="title">object_dispose</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">objc_destructInstance</span>(obj);    </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">        <span class="type">bool</span> assoc = obj-&gt;<span class="built_in">hasAssociatedObjects</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="built_in">object_cxxDestruct</span>(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;<span class="built_in">clearDeallocating</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::clearDeallocating</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        <span class="built_in">sidetable_clearDeallocating</span>(); <span class="comment">//这里面也是清除weak，清除引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">slowpath</span>(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        <span class="built_in">clearDeallocating_slow</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">sidetable_present</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_destructInstance函数作用：</p>
<p>如果有自定义的C++析构方法，则调用C++析构函数。如果有关联对象，则移除关联对象并将其自身从<code>Association Manager</code>的map中移除。调用<code>clearDeallocating</code>方法清除对象的相关引用。</p>
<p>最终会调用clearDeallocating_slow：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Slow path of clearDeallocating() </span></span><br><span class="line"><span class="comment">// for objects with nonpointer isa</span></span><br><span class="line"><span class="comment">// that were ever weakly referenced </span></span><br><span class="line"><span class="comment">// or whose retain count ever overflowed to the side table.</span></span><br><span class="line"><span class="function">NEVER_INLINE <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::clearDeallocating_slow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line">    table.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        <span class="built_in">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.<span class="built_in">erase</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clearDeallocating_slow在获取到SideTable后会加锁，完成清除操作后，SideTable又会释放锁。</p>
<h5 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h5><p>核心函数weak_clear_no_lock：将所有弱引用该对象的指针变量的值置为 nil，并将该 object 的weak_entry_t从 weak 表中移除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Called by dealloc; nils out all weak pointers that point to the </span></span><br><span class="line"><span class="comment"> * provided object so that they can no longer be used.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object being deallocated. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">weak_clear_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    <span class="type">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = <span class="built_in">TABLE_SIZE</span>(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil; <span class="comment">//弱引用指针的值被置位nil.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                             <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                             <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                             <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                             referrer, (<span class="type">void</span>*)*referrer, (<span class="type">void</span>*)referent);</span><br><span class="line">                <span class="built_in">objc_weak_error</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">weak_entry_remove</span>(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>SideTable示意图</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/E011FE656F40C3CA194795B0CA107AA9.png" alt=""></p>
<p>让我们再来看一下下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XQPerson *p = XQPerson.new;</span><br><span class="line">__<span class="keyword">weak</span> XQPerson *wp = p;</span><br></pre></td></tr></table></figure>
<p>对于上面简单的一句 <code>__weak XQPerson *wp = p;</code> 背后执行的逻辑可不少。</p>
<p>首先会根据新旧对象的地址分别从SideTablesMap中获取到新旧对象的SideTable，</p>
<p>然后再根据旧对象的地址从旧对象的SideTable的weak 表中获取到weak entry，然后从weak entry的referrers哈希表中把指针变量移除，</p>
<p>最后再根据新对象的地址从新对象的SideTable的weak 表中获取到weak entry，然后将弱引用指针变量登记到weak entry的referrers哈希表中。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://wangwangok.github.io/2018/05/18/source_code_objc_weak_t/">细看objc-weak源码</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e7a322f6fb9a07ca24f79bb">iOS底层原理：weak的实现原理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013378438/article/details/82790332">Objective-C runtime机制(7)——SideTables, SideTable, weak_table, weak_entry_t</a></p>
<p>哈希算法相关</p>
<p><a target="_blank" rel="noopener" href="https://blog.codinghorror.com/speed-hashing/">Speed Hashing</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.itpub.net/31557372/viewspace-2222260/">扫盲，那些让人蛋疼的Hash概念</a></p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>Q1：OC对象的引用计数是保存在哪的？（已完成）</p>
<p>分析了好几天的 weak 实现，突然想知道OC对象的引用计数到底是保存在哪的，于是便有了这个疑问。这个问题比较大，可能需要一整篇文章才能回答。</p>
<p>简单点讲就是存储在SideTable的RefcountMap（也是一个哈希表）里，不过大多数情况下是存储在对象的isa里。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b4c59a55188251ac9767872">苹果iOS系统源码思考：对象的引用计数存储在哪里？—从runtime源码得到的启示</a></p>
<p><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/">Objective-C 引用计数原理</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ce2b7386fb9a07eff005b4c">理解 ARC 实现原理</a></p>
<p>Q2：为什么 weak 是线程不安全的？（待解决）</p>
<p>源码里好些weak 相关的函数都注释着该函数是线程不安全的，如：objc_initWeak，objc_destroyWeak。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Destroys the relationship between a weak pointer</span></span><br><span class="line"><span class="comment"> * and the object it is referencing in the internal weak</span></span><br><span class="line"><span class="comment"> * table. If the weak pointer is not referencing anything, </span></span><br><span class="line"><span class="comment"> * there is no need to edit the weak table. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param location The weak pointer address. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">objc_destroyWeak</span><span class="params">(id *location)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但本人没遇到过因为 weak 导致的崩溃，也没试出来，看源码发现该加锁的地方也都加锁了，实在看不出来到底是哪个地方会导致线程不安全。</p>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://suhou.github.io/2019/05/14/%E4%BB%8E%E4%B8%80%E4%B8%AAcrash%E7%90%86%E8%A7%A3weak%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE/">从一个crash理解weak的延迟释放</a>   作者其他文章也还不错</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rhythmkay/article/details/86539617">不安全的weak变量</a>  不安全的一个例子，没怎么看懂</p>
<p><a target="_blank" rel="noopener" href="https://debugly.cn/2017/07/17-weakself-in-dealloc-cause-crash.html">在 dealloc 里使用 weak self 引起崩溃？</a></p>
<p><a target="_blank" rel="noopener" href="https://bugs.swift.org/browse/SR-192">Weak properties are not thread safe when reading</a>  不过系统已经解决了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apple/swift/pull/1454">[runtime] Thread safety for weak references #1454</a></p>
<p>查遍了Google都是说因为objc_loadWeakRetained的问题导致的多线程下过度释放，但从资料上显示objc_loadWeakRetained函数已经修复了该问题。所以不太清楚到底还有哪些原因导致weak多线程不安全。</p>
<p>Q3：dealloc 的时候增加引用计数，会防止对象销毁吗？</p>
<p>不能。在dealloc 的时候调用retain，引用计数确实会增加，但不会阻止对象销毁。因为dealloc最终会调用super-dealloc，而super-dealloc从上面的实现可以看到最终会调用free释放内存。可以说dealloc是一个不可逆的行为。</p>
<p>retain只在对象还没销毁的时候才有用。</p>
<p>MRC：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">//在[super dealloc];前写没有问题，虽然此时引用计数会增加，但对象已经在销毁了，super dealloc里最终会调用free。</span></span><br><span class="line"><span class="comment">//    [self retain]; //引用计数会变为2.但没用。</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;retainCount:%lu&quot;, (unsigned long)[self retainCount]); </span></span><br><span class="line">    </span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在[super dealloc];后写会崩溃，因为对象的内存已经free了，这里会野指针崩溃。</span></span><br><span class="line">    [<span class="keyword">self</span> <span class="keyword">retain</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;retainCount:%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)[<span class="keyword">self</span> retainCount]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARC：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    ARCPerson *obj = <span class="keyword">self</span>; <span class="comment">//这里没事，引用计数会变为2.</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;obj:%@&quot;</span>, obj);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;retain count = %ld\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge  <span class="built_in">CFTypeRef</span>)(<span class="keyword">self</span>)));</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> ARCPerson *wObj = <span class="keyword">self</span>; <span class="comment">//这里会崩溃。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;wObj:%@&quot;</span>, wObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q4：weak是否适用于MRC？</p>
<p>适用。weak在MRC下也是有效果的。只不过weak只能在&gt;=iOS5上才能使用。</p>
<p>示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)hello &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MRCCat *cat = [MRCCat new];</span><br><span class="line">        <span class="keyword">self</span>.weakCat = cat;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 1&quot;</span>, <span class="keyword">self</span>.weakCat);</span><br><span class="line">        [cat release];</span><br><span class="line">    &#125; <span class="comment">//weak在MRC下也是有效果的。只不过weak只能在&gt;=iOS5上才能使用。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 2&quot;</span>, <span class="keyword">self</span>.weakCat); <span class="comment">//这里打印为：(null) 2。说明weakCat被置为nil了。</span></span><br><span class="line">    [<span class="keyword">self</span>.weakCat hello];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ hello&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>复习 C 语言里的指针和数组的一些语法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *intPtr = &amp;i; <span class="comment">//可以指向一个int变量，也可以指向一个元素为int的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> intArr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">intArr[<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *intPtrArr[<span class="number">10</span>] = &#123;&amp;i&#125;;</span><br><span class="line">*intPtrArr[<span class="number">0</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *intPtrArr = intArr;</span><br><span class="line">*(intPtrArr+<span class="number">1</span>) = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">intPtr = intArr; <span class="comment">//这里intPtr就指向了一个数组</span></span><br><span class="line">*(intPtr + <span class="number">2</span>) = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **ptrD = &amp;intPtr; <span class="comment">//ptrD指针的指针</span></span><br><span class="line"><span class="type">int</span> **arr[<span class="number">10</span>] = &#123;<span class="literal">NULL</span>&#125;; <span class="comment">//arr是一个数组，元素是指针的指针</span></span><br><span class="line"><span class="type">int</span> ***ptrArr = arr; <span class="comment">//ptrArr是一个指针，指向一个数组，数组的元素是指针的指针</span></span><br><span class="line">arr[<span class="number">0</span>] = ptrD;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = *intPtr;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div class="reward-container">
  <div>觉得文章有帮助可以打赏一下哦！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="jekyttt 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag"># 内存管理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/06/iOS-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8E%9F%E7%90%86%E7%AF%87/" rel="prev" title="iOS 信号量原理篇">
      <i class="fa fa-chevron-left"></i> iOS 信号量原理篇
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/21/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E7%9C%8BARC%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/" rel="next" title="从汇编角度看ARC中的所有权修饰符">
      从汇编角度看ARC中的所有权修饰符 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-weak-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">0.weak 修饰符的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-objc-initWeak"><span class="nav-text">1.objc_initWeak</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">2.数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StripedMap"><span class="nav-text">StripedMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SideTablesMap"><span class="nav-text">SideTablesMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SideTable"><span class="nav-text">SideTable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DisguisedPtr"><span class="nav-text">DisguisedPtr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-entry-t"><span class="nav-text">weak_entry_t</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-table-t"><span class="nav-text">weak_table_t</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-weak%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.weak的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-initWeak"><span class="nav-text">objc_initWeak</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#storeweak"><span class="nav-text">storeweak</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-register-no-lock"><span class="nav-text">weak_register_no_lock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#weak-entry-for-referent"><span class="nav-text">weak_entry_for_referent</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#weak-entry-insert"><span class="nav-text">weak_entry_insert</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#weak-grow-maybe"><span class="nav-text">weak_grow_maybe</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#append-referrer"><span class="nav-text">append_referrer</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-unregister-no-lock"><span class="nav-text">weak_unregister_no_lock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#remove-referrer"><span class="nav-text">remove_referrer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#weak-entry-remove"><span class="nav-text">weak_entry_remove</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-resize"><span class="nav-text">weak_resize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dealloc"><span class="nav-text">dealloc</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#weak-clear-no-lock"><span class="nav-text">weak_clear_no_lock</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="nav-text">4.总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-text">参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%96%91%E9%97%AE"><span class="nav-text">疑问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jekyttt</p>
  <div class="site-description" itemprop="description">涉猎的编程语言为Objective-C、Swift、C,主要领域为iOS开发.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">116</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xq-120" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xq-120" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/yourname" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jekyttt</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  


    </div>
</body>
</html>
