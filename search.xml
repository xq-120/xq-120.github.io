<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OC property、synthesize、dynamic关键字</title>
    <url>/2014/12/13/OC-property%E3%80%81synthesize%E3%80%81dynamic%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>OC的变量：</p>
<p>OC有4种基本数据类型：char，int，float，double。它们又有一些限定词：signed，unsigned，short，long，long long。</p>
<p>实例变量和成员变量是一个概念。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/9acde5b5-688e-4709-8406-b42a5ad1b24e.jpg" alt=""></p>
<h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><p>@property指令作用：声明了一个属性及属性的两个访问器方法。</p>
<p>如果在@implementation块里@synthesize和@dynamic都没写，那么编译器会帮你自动添加@syntheszie property = _property;有一种情况除外:子类属性和父类属性同名.此时会报警告:</p>
<p>“Auto property synthesis will not synthesize property ‘delegate’; it will be implemented by its superclass, use @dynamic to acknowledge intention”</p>
<p>这个时候就需要自己实现属性了.两种常用解决办法:</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">@dynamic</span> <span class="built_in">delegate</span>; <span class="comment">//表示使用父类的实现,此时子类内部将无法访问_delegate.</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="keyword">@synthesize</span> <span class="built_in">delegate</span> = _delegate; <span class="comment">//子类内部可以访问_delegate.</span></span><br></pre></td></tr></table></figure>
<h2 id="synthesize和-dynamic"><a href="#synthesize和-dynamic" class="headerlink" title="@synthesize和@dynamic"></a>@synthesize和@dynamic</h2><p>它们都是用于属性实现的.注意是实现不是声明,声明是@property.</p>
<h3 id="synthesize"><a href="#synthesize" class="headerlink" title="@synthesize"></a>@synthesize</h3><p>1.让编译器为属性自动合成setter/getter方法。如果手动实现了setter/getter方法，则会覆盖自动合成的。</p>
<p>2.为属性<strong>按需合成</strong>一个实例变量。</p>
<p>按需合成的意思就是说如果你有声明一个下划线属性名<code>_property</code>的实例变量,那么编译器会自动把它关联给这个属性,否则的话会帮你自动声明这个实例变量并关联给这个属性.</p>
<p>语法：@synthesize property = ivar; 或 @synthesize property;</p>
<p>eg:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@synthesize</span> firstName = _firstName; <span class="comment">//属性firstName被指定了一个名为_firstName的实例变量.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> lastName; <span class="comment">//属性lastName被指定了一个名为lastName的实例变量.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> age = yearsOld; <span class="comment">//属性age被指定了一个名为yearsOld的实例变量.</span></span><br></pre></td></tr></table></figure>
<h3 id="dynamic"><a href="#dynamic" class="headerlink" title="@dynamic"></a>@dynamic</h3><p>@dynamic关键字功能和@synthesize相反，它是告诉编译器不要自动为这个属性合成setter/getter方法,也不要为属性自动合成一个实例变量(因此在其他方法中是无法使用_property实例变量的).属性的访问器方法将由程序员自己来实现,实现的方式可以是直接提供setter/getter方法的实现,也就是自己在@implementation块里面实现setter/getter方法;也可以是在运行时通过其他机制比如动态的加载一段代码或者通过动态方法解析提供.它可以消除编译器因为找不到属性的访问器方法的实现而产生的警告.使用这个指令的时候你自己必须要清楚的知道这些方法在运行时确实是可用的,如果在运行时依然找到不到这些方法,显然会导致崩溃.</p>
<p>为什么会有dynamic这个关键字？因为系统自动合成的setter/getter方法可能不满足我们的需求，甚至setter/getter方法是通过runtime实现的为了避免重复实现必须要有一种机制阻止系统自动合成setter/getter方法，或者这是一个计算型属性不需要合成相应实例变量。</p>
<p>比如DDLog里面的OSSDDLogFileInfo类中，就有许多这样的属性：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDate</span> *creationDate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDate</span> *modificationDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fileSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="type">BOOL</span> isArchived;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OSSDDLogFileInfo</span> () </span>&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="built_in">NSString</span> *_filePath;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="built_in">NSString</span> *_fileName;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">strong</span> <span class="built_in">NSDictionary</span> *_fileAttributes;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">strong</span> <span class="built_in">NSDate</span> *_creationDate;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="built_in">NSDate</span> *_modificationDate;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _fileSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OSSDDLogFileInfo</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> filePath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> fileName;</span><br><span class="line"><span class="keyword">@dynamic</span> fileAttributes;</span><br><span class="line"><span class="keyword">@dynamic</span> creationDate;</span><br><span class="line"><span class="keyword">@dynamic</span> modificationDate;</span><br><span class="line"><span class="keyword">@dynamic</span> fileSize;</span><br><span class="line"><span class="keyword">@dynamic</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> isArchived;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)age &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> creationDate] timeIntervalSinceNow] * <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDate</span> *)creationDate &#123;</span><br><span class="line">    <span class="keyword">if</span> (_creationDate == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _creationDate = <span class="keyword">self</span>.fileAttributes[<span class="built_in">NSFileCreationDate</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _creationDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)fileSize &#123;</span><br><span class="line">    <span class="keyword">if</span> (_fileSize == <span class="number">0</span>) &#123;</span><br><span class="line">        _fileSize = [<span class="keyword">self</span>.fileAttributes[<span class="built_in">NSFileSize</span>] unsignedLongLongValue];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _fileSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>age只是一个计算型属性，不需要实例变量，所以使用dynamic进行标记。</p>
<p>再比如在CoreData里的NSManagedObject类里面使用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSManagedObject</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> value; <span class="comment">//@dynamic 属性名;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>另一种用法：子类声明父类的同名属性，这时可以使用dynamic指示编译器使用父类的的存取器和实例变量。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">FDAnimalDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDAnimal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> magCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span>&lt;FDAnimalDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)startRun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">FDDogDelegate</span> &lt;<span class="title">FDAnimalDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)fastRun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDDog</span> : <span class="title">FDAnimal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> magCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span>&lt;FDDogDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FDDog</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> delegate; <span class="comment">//指示使用父类的存取器方法，实例变量也使用父类里的。</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看得出来这两个指令功能正好相反.</p>
<p>注意:不能对一个属性同时使用@synthesize和@dynamic.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">@dynamic</span> age;</span><br><span class="line"></span><br><span class="line"><span class="variable">@synthesize</span> age = _age; <span class="regexp">//</span>报错<span class="symbol">:Property</span> <span class="string">&#x27;age&#x27;</span> is already implemented</span><br></pre></td></tr></table></figure>
<p>上面已经说到@synthesize和@dynamic的作用就是实现某个属性.同时使用的话就重复实现了,当然会报错.</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title>UITableViewCell重用导致的图片错乱问题</title>
    <url>/2016/04/24/UITableViewCell%E9%87%8D%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%9B%BE%E7%89%87%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>之前做过一个视频信息列表展示的模块，cell很简单就是左边图片，右边文字信息。当时用的SDWebImage加载图片并没有看到图片错乱的情况。但是，如果是自己写的图片下载器，不注意处理是会导致图片错乱的。</p>
<p>今天写了个Demo，验证及解决这个问题。<br>实验环境：cell依然是左边图片，右边文字信息。图片两张，一张大图片A(风景)，一张小图片B(人物)，<strong>采用自己实现的原始图片下载器</strong>异步下载，block里回调设置cell的图片。要求偶数行的图片是风景，奇数行的图片是人物。<br>整个界面期望如下:<br><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/1503319-0c16709bb58a8af1.webp" style="zoom:50%;" /></p>
<p>但实际可能出现bug，如下图:<br><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/1503319-396836dd909893b1.webp" style="zoom:50%;" /></p>
<h4 id="数据错乱原因分析"><a href="#数据错乱原因分析" class="headerlink" title="数据错乱原因分析"></a>数据错乱原因分析</h4><p>cell上的数据错乱显然是由于cell的重用导致的。由于图片是异步下载的，下载完成才给cell设置，但是在这个过程中用户可能会上下滑动，滑动的时候会导致cell的重用，比如第0行是设置大图片的，第11行是设置小图片的，用户在滑动的过程中，因为cell的重用第11行的cell可能使用的是第0行的cell，这时第0行的block回调设置的cell和第11行的block回调设置的cell是同一个，即cell的重用导致两个block回调时设置的其实是同一个cell上的imageView。这就是问题的关键。</p>
<p>因为图片是异步下载的，你也不知道哪个block会先回调，如果小图片的block先回调那么这个cell的图片就先被设置为小图片，如果后来大图片的block回来了，那么你会看到图片被替换成大图片，这种情况还算比较好，但如果大图片下载失败或者小图片的block最后回调，那么你看到的将是小图片加大图片的文字信息，这时数据就错乱了。</p>
<h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>如果不重用cell，当然是可以解决该问题的，但是内存肯定会浪费不少。</p>
<p>解决的方案有两种：</p>
<p>方案一：在下载完成的回调里进行区分，如果不一致则不设置imageView。</p>
<p>方案二：每次下载前都先取消掉上一次的下载，这样就不会同时有两个block回调，这是很多第三方图片加载库的做法。</p>
<p>如果采用方案一，那么有两种办法进行区分：</p>
<p><strong>1. 通过indexPath来区分</strong></p>
<p>block里截获的indexPath对象是cell在下载前的indexPath，假设为t1时刻的indexPath。而通过<code>[tableView indexPathForCell:cell];</code> 则可以获得cell当前的indexPath，假设为t2时刻的indexPath。如果t1-t2这段时间内cell发生了重用的话，那么这两个indexPath将不一致。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    MyTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@&quot;Cell&quot;</span> forIndexPath:indexPath];</span><br><span class="line">    cell.imgView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;pl&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *urlStr = <span class="keyword">self</span>.urlArr[indexPath.row];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(MyTableViewCell *) weakCell = cell;</span><br><span class="line">    [[XQImageDownloader defaultImageDownloader] downloadImageWithUrlString:urlStr completion:^(<span class="built_in">NSString</span> *imgUrl, <span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            <span class="built_in">NSIndexPath</span> *currentIndexPath = [tableView indexPathForCell:weakCell];</span><br><span class="line">          	<span class="keyword">if</span> (currentIndexPath == <span class="literal">nil</span>) &#123; <span class="comment">//表明cell没在屏幕上显示。</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSInteger</span> currentRow = currentIndexPath.row;</span><br><span class="line">            <span class="built_in">NSInteger</span> originalRow = indexPath.row; <span class="comment">//这里的indexPath是block截获的.</span></span><br><span class="line">            <span class="keyword">if</span> (originalRow != currentRow) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;数据错乱，应该设置的是第%ld个cell上的ImageView,但当前设置的是%ld个cell上的ImageView,cell:%p&quot;</span>, (<span class="type">long</span>)originalRow, currentRow, weakCell);</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;urlStr:%@, imgUrl：%@&quot;</span>, urlStr, imgUrl); <span class="comment">//这里的urlStr==imgUrl，想一想为什么</span></span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            weakCell.imgView.image = image;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;下载图片：%@，error:%@&quot;</span>, urlStr, [error localizedDescription]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    cell.contentLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;这是第%ld个cell:%p&quot;</span>, indexPath.row, cell];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种办法的缺点是如果cell的配置方法是在别处，那么需要传递tableView和indexPath两个参数，对现有代码改动较大，不是很方便。</p>
<p>注意：上述代码中和currentIndexPath比较的indexPath，必须是block截获的，不能直接使用 <code>cell.indexPath</code> （这里假设cell里有一个indexPath属性并在dequeue后就赋值为代理方法的indexPath参数）否则总是相等的。</p>
<p><strong>2. 通过下载的图片URL来区分</strong></p>
<p>下载前先记录当前imageView应该显示的图片URL，当下载完成时再进行比较。这种办法比第一种要方便很多，我们可以写一个UIImageView的类别封装一下。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    MyTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@&quot;Cell&quot;</span> forIndexPath:indexPath];</span><br><span class="line">    cell.imgView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;pl&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *urlStr = <span class="keyword">self</span>.urlArr[indexPath.row];</span><br><span class="line">    cell.imageView.xq_imgUrl = [<span class="built_in">NSURL</span> URLWithString:urlStr]； <span class="comment">//记录当前imageView应该显示的图片URL</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(MyTableViewCell *) weakCell = cell;</span><br><span class="line">    [[XQImageDownloader defaultImageDownloader] downloadImageWithUrlString:urlStr completion:^(<span class="built_in">NSString</span> *imgUrl, <span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (![weakCell.imageView.xq_imgUrl.absoluteString isEqualToString:imgUrl]) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;数据错乱，应该下载的图片url为:%@, 但当前下载的图片url为：%@&quot;</span>, weakCell.imageView.xq_imgUrl, imgUrl);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            weakCell.imgView.image = image;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					  <span class="built_in">NSLog</span>(<span class="string">@&quot;下载图片：%@，error:%@&quot;</span>, urlStr, [error localizedDescription]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    cell.contentLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;这是第%ld个cell:%p&quot;</span>, indexPath.row, cell];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外在下载图片之前先把cell的imageView的image置为nil。<code>cell.imgView.image = nil;</code>可以防止重用的cell万一图片下载失败而导致显示了以前的图片，不过一般都会有占位图片所以这一步可有可无。</p>
<p>如果采用方案二：每次下载前都先取消掉上一次的下载。那么你的图片下载器就需要实现取消下载功能，幸运的是SD或YY这样的图片加载器已经实现了这样的功能。</p>
<p>比如SD：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">    [<span class="keyword">self</span> sd_cancelCurrentImageLoad]; <span class="comment">//下载前先取消掉当前ImageView上之前的下载</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">self</span>.image = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YY：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)yy_setImageWithURL:(<span class="built_in">NSURL</span> *)imageURL</span><br><span class="line">               placeholder:(<span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(YYWebImageOptions)options</span><br><span class="line">                   manager:(YYWebImageManager *)manager</span><br><span class="line">                  progress:(YYWebImageProgressBlock)progress</span><br><span class="line">                 transform:(YYWebImageTransformBlock)transform</span><br><span class="line">                completion:(YYWebImageCompletionBlock)completion &#123;</span><br><span class="line">    <span class="keyword">if</span> ([imageURL isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) imageURL = [<span class="built_in">NSURL</span> URLWithString:(<span class="type">id</span>)imageURL];</span><br><span class="line">    manager = manager ? manager : [YYWebImageManager sharedManager];</span><br><span class="line">    </span><br><span class="line">    _YYWebImageSetter *<span class="keyword">setter</span> = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;_YYWebImageSetterKey);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">setter</span>) &#123;</span><br><span class="line">        <span class="keyword">setter</span> = [_YYWebImageSetter new];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;_YYWebImageSetterKey, <span class="keyword">setter</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    int32_t sentinel = [<span class="keyword">setter</span> cancelWithNewURL:imageURL]; <span class="comment">//下载前先取消掉当前ImageView上之前的下载</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以直接使用这些第三方库就可以了。</p>
<p>注意：如果你使用这些第三方库还出现图片错乱的问题，根本原因是因为重用的cell的imageView没有执行cancel下载操作，至于为啥会没有执行，老中医掐指一算，大概率是因为代码中出现了有if没else的逻辑或者if里用了SD而else里没使用。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>cell上发生数据错乱的控件，大部分都是因为要显示的资源需要异步处理比如图片需要下载后才能设置到imageView上。少部分同步显示资源的控件（比如UILabel）发生数据错乱则一般是因为你的条件判断有问题导致重用的cell上还留有旧的数据，可以重写<code>-prepareForReuse</code>在重用前先清除掉旧数据。</p>
<p>俺在开发过程中遇到的其他一些数据错乱的场景：</p>
<p>cell上的imageView根据条件判断一会加载本地的图片，一会加载网络图片，这个就很典型。</p>
<p>cell上的imageView根据条件判断一会用SDWebImage加载，一会用YYWebImage加载。同一个cell里的imageView千万不要使用两种框架去加载。</p>
<p>以上，MADE BY XQ。</p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UITableViewCell</tag>
        <tag>cell重用问题</tag>
      </tags>
  </entry>
  <entry>
    <title>layoutSubviews的调用时机</title>
    <url>/2017/08/20/layoutSubviews%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="layoutSubviews的调用时机"><a href="#layoutSubviews的调用时机" class="headerlink" title="layoutSubviews的调用时机"></a>layoutSubviews的调用时机</h2><p>方法说明:</p>
<p>该方法在iOS 5.1及更低版本上不执行任何操作。 否则，该方法将使用你设置的约束来确定子视图的大小和位置。</p>
<p>该方法由<code>layoutIfNeeded</code>自动调用,所以我们不能手动去调用它.在需要重新布局子视图时,可以调用<code>[self layoutIfNeeded]</code>或<code>[self setNeedLayout];</code></p>
<h2 id="手动触发layoutSubviews"><a href="#手动触发layoutSubviews" class="headerlink" title="手动触发layoutSubviews"></a>手动触发layoutSubviews</h2><p>调用<code>[self layoutIfNeeded]</code>或<code>[self setNeedLayout];</code>  </p>
<blockquote>
<p><code>layoutIfNeeded</code>与<code>setNeedLayout</code>的区别: </p>
</blockquote>
<p>调用 <code>layoutIfNeeded</code> 会马上执行 <code>layoutSubviews</code> 方法，立即更新视图的布局。但是调用<code>setNeedLayout</code>并不会马上执行<code>layoutSubviews</code>,而是等到runloop结束时调用.</p>
<h2 id="自动触发layoutSubviews"><a href="#自动触发layoutSubviews" class="headerlink" title="自动触发layoutSubviews"></a>自动触发layoutSubviews</h2><p>如果一个viewA还没有被添加到父视图上面去,那么无论你对它进行什么操作(设置frame,添加子视图等等),它的<code>layoutSubviews</code>方法始终是不会被调用的.  </p>
<p>下面情况将会自动触发viewA的<code>layoutSubviews</code>方法:  </p>
<ol>
<li><p>viewA被添加到父视图上.(viewA的和viewA所有子视图的都会被触发).</p>
</li>
<li><p>viewA addSubview会触发<code>layoutSubviews</code>.(viewA的被触发后,如果在 <code>layoutSubviews</code> 的实现中调整了子视图的frame，那么子视图的也会被触发，连锁反应，下面的类同).</p>
</li>
<li><p>viewA上的子视图从viewA上移除,会触发<code>layoutSubviews</code>. </p>
</li>
<li><p>设置viewA的Frame会触发<code>layoutSubviews</code>，当然前提是frame的值设置前后发生了变化. </p>
</li>
<li><p>viewA上的子视图大小(x,y改变没影响)改变时也会触发viewA的<code>layoutSubviews</code>事件. </p>
</li>
<li><p>如果viewA是一个UIScrollView,那么viewA在滚动时会触发它的layoutSubviews方法. </p>
</li>
<li><p>旋转Screen会触发viewController的primary view的layoutSubviews事件.</p>
</li>
</ol>
<p>总之一句话，能影响viewA或viewA内部布局改变的因素都会导致viewA的 <code>layoutSubviews</code>调用。</p>
<p>注意:  </p>
<ul>
<li>init初始化不会触发<code>layoutSubviews</code>,因为此时View还没有被添加到父视图上去.  </li>
<li>一个View的子视图指的是它的直系子视图.</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/">When does layoutSubviews get called?</a></p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>layoutSubviews</tag>
      </tags>
  </entry>
  <entry>
    <title>swift封装打印函数</title>
    <url>/2017/08/21/swift%E5%B0%81%E8%A3%85%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="swift封装打印函数"><a href="#swift封装打印函数" class="headerlink" title="swift封装打印函数"></a>swift封装打印函数</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dateFormatter <span class="operator">=</span> <span class="type">DateFormatter</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志打印</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">DLog</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">message</span>:<span class="type">T</span>, <span class="params">file</span>:<span class="type">String</span> <span class="operator">=</span> <span class="keyword">#file</span>, <span class="params">function</span>:<span class="type">String</span> <span class="operator">=</span> <span class="keyword">#function</span>, <span class="params">line</span>:<span class="type">Int</span> <span class="operator">=</span> <span class="keyword">#line</span>) &#123;</span><br><span class="line">    <span class="keyword">#if</span> <span class="type">DEBUG</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取文件名</span></span><br><span class="line">    <span class="keyword">let</span> fileName <span class="operator">=</span> (file <span class="keyword">as</span> <span class="type">NSString</span>).lastPathComponent</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为日期格式器设置格式字符串</span></span><br><span class="line">    dateFormatter.dateFormat <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span></span><br><span class="line">    <span class="comment">// 使用日期格式器格式化当前日期、时间</span></span><br><span class="line">    <span class="keyword">let</span> datestr <span class="operator">=</span> dateFormatter.string(from: <span class="type">Date</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志内容</span></span><br><span class="line">    <span class="keyword">let</span> consoleStr <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(datestr)</span> [<span class="subst">\(fileName)</span>:<span class="subst">\(line)</span>][<span class="subst">\(function)</span>]<span class="subst">\(message)</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印日志内容</span></span><br><span class="line">    <span class="built_in">print</span>(consoleStr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印对象地址"><a href="#打印对象地址" class="headerlink" title="打印对象地址"></a>打印对象地址</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">pointer</span>(<span class="keyword">_</span> <span class="params">object</span>: <span class="type">AnyObject</span>?) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> object <span class="operator">=</span> object <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="string">&quot;nil&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> opaque: <span class="type">UnsafeMutableRawPointer</span> <span class="operator">=</span> <span class="type">Unmanaged</span>.passUnretained(object).toOpaque()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: opaque)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">DLog</span><span class="params">(self)</span></span></span><br><span class="line"><span class="function"><span class="title">DLog</span><span class="params">(<span class="string">&quot;self p:\(Unmanaged.passUnretained(self).toOpaque())&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>打印如下:  </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2019</span>-<span class="number">02</span>-<span class="number">27</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">57</span>.<span class="number">378</span><span class="meta"> [ViewController.swift:30][viewDidAppear]&lt;demo.ViewController: 0x1059c2170&gt;</span></span><br><span class="line"><span class="meta">2019-02-27 11:58:57.383 [ViewController.swift:31][viewDidAppear]self p:0x00000001059c2170</span></span><br></pre></td></tr></table></figure>
<p>不过还是推荐<a href="http://www.hangge.com/blog/cache/detail_1418.html">Swift - 日志框架XCGLogger的使用详解</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>数值计算</title>
    <url>/2017/08/28/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="四舍五入保留两位小数"><a href="#四舍五入保留两位小数" class="headerlink" title="四舍五入保留两位小数"></a>四舍五入保留两位小数</h2><p><code>NSString *strOdds = [NSString stringWithFormat:@&quot;%.2f&quot;, odds]; //保留两位小数</code><br>该方法会四舍五入保留两位小数,不足两位小数后面补0.如果想在四舍五入时去掉小数点后多余的0,可使用下面的方法:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)roundingAfterPoint:(<span class="built_in">NSInteger</span>)position roudingMode:(<span class="built_in">NSRoundingMode</span>)roundingMode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSDecimalNumberHandler</span> *roundingBehavior = [<span class="built_in">NSDecimalNumberHandler</span> decimalNumberHandlerWithRoundingMode:roundingMode scale:position raiseOnExactness:<span class="literal">NO</span> raiseOnOverflow:<span class="literal">NO</span> raiseOnUnderflow:<span class="literal">NO</span> raiseOnDivideByZero:<span class="literal">NO</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> f_price = <span class="keyword">self</span>.floatValue;</span><br><span class="line">    <span class="built_in">NSDecimalNumber</span> *ouncesDecimal = [[<span class="built_in">NSDecimalNumber</span> alloc] initWithFloat:f_price];</span><br><span class="line">    <span class="built_in">NSDecimalNumber</span> *roundedOunces = [ouncesDecimal decimalNumberByRoundingAccordingToBehavior:roundingBehavior];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *rs = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>,roundedOunces];</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用:<br><code>NSString *rs = [self roundingAfterPoint:2 roudingMode:NSRoundPlain];</code></p>
<p>在进行浮点型数值计算时最好统一类型,比如全部统一为float计算,或全部为double型计算.否则可能会出现误差,导致计算不一致.</p>
<h2 id="浮点型数值取整"><a href="#浮点型数值取整" class="headerlink" title="浮点型数值取整"></a>浮点型数值取整</h2><ul>
<li>round：如果参数是小数，则求本身的四舍五入。</li>
<li>ceil：如果参数是小数，则求最小的整数但不小于本身.</li>
<li>floor：如果参数是小数，则求最大的整数但不大于本身. </li>
</ul>
<p>Example:如果值是3.4的话，则round 3.000000, ceil 4.000000, floor 3.00000</p>
<p>另外,强制取整<code>(int)3.4 = 3</code>,直接丢弃小数位仅保留整数位,类似于floor函数.</p>
]]></content>
      <categories>
        <category>数值计算</category>
      </categories>
      <tags>
        <tag>数值计算</tag>
      </tags>
  </entry>
  <entry>
    <title>UITableView-FDTemplateLayoutCell源码分析</title>
    <url>/2017/09/04/UITableView-FDTemplateLayoutCell%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="高度的计算"><a href="#高度的计算" class="headerlink" title="高度的计算"></a>高度的计算</h2><p>通过从可重用队列里出列一个cell,并将该cell配置好要展示的数据后(ps:在使用时如果有一些会影响cell高度的代码没有包括在配置block里将导致计算不准),开始计算cell的高度:</p>
<ol>
<li><p>给cell添加约束:<br><code>NSLayoutConstraint *widthFenceConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:contentViewWidth];</code><br>对于10.2以上系统还需添加cell上下左右的约束:</p>
 <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSystemVersionEqualOrGreaterThen10_2) &#123;</span><br><span class="line">            <span class="comment">// To avoid confilicts, make width constraint softer than required (1000)</span></span><br><span class="line">            widthFenceConstraint.priority = <span class="built_in">UILayoutPriorityRequired</span> - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Build edge constraints</span></span><br><span class="line">            <span class="built_in">NSLayoutConstraint</span> *leftConstraint = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:cell.contentView attribute:<span class="built_in">NSLayoutAttributeLeft</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:cell attribute:<span class="built_in">NSLayoutAttributeLeft</span> multiplier:<span class="number">1.0</span> constant:<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">NSLayoutConstraint</span> *rightConstraint = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:cell.contentView attribute:<span class="built_in">NSLayoutAttributeRight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:cell attribute:<span class="built_in">NSLayoutAttributeRight</span> multiplier:<span class="number">1.0</span> constant:accessroyWidth];</span><br><span class="line">            <span class="built_in">NSLayoutConstraint</span> *topConstraint = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:cell.contentView attribute:<span class="built_in">NSLayoutAttributeTop</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:cell attribute:<span class="built_in">NSLayoutAttributeTop</span> multiplier:<span class="number">1.0</span> constant:<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">NSLayoutConstraint</span> *bottomConstraint = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:cell.contentView attribute:<span class="built_in">NSLayoutAttributeBottom</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:cell attribute:<span class="built_in">NSLayoutAttributeBottom</span> multiplier:<span class="number">1.0</span> constant:<span class="number">0</span>];</span><br><span class="line">            edgeConstraints = @[leftConstraint, rightConstraint, topConstraint, bottomConstraint];</span><br><span class="line">            [cell addConstraints:edgeConstraints];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用系统API<code>systemLayoutSizeFittingSize</code>计算出高度:<code>fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;</code></p>
</li>
<li><p>移除之前添加的约束:  </p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[cell.contentView removeConstraint:widthFenceConstraint]</span>;</span><br><span class="line">if (isSystemVersionEqualOrGreaterThen10_2) &#123;</span><br><span class="line">    <span class="selector-attr">[cell removeConstraints:edgeConstraints]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终得到cell的高度.</p>
<h2 id="高度缓存的实现"><a href="#高度缓存的实现" class="headerlink" title="高度缓存的实现"></a>高度缓存的实现</h2><p>通过给UITableView增加一个类别<code>(FDIndexPathHeightCache)</code>:  </p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> UITableView (FDIndexPathHeightCache)</span><br><span class="line"><span class="comment">/// Height cache by index path. Generally, you don&#x27;t need to use it directly.</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, readonly) FDIndexPathHeightCache *fd_indexPathHeightCache;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>类别里有一个<code>FDIndexPathHeightCache</code>类型的属性<code>fd_indexPathHeightCache</code>是只读的,用于操作缓存:设置缓存,取出缓存,清除缓存,查询某个缓存是否存在等.<code>FDIndexPathHeightCache</code>内部扩展定义了一个用于保存缓存的二维数组.以后取缓存时是从该二维数组取得.默认高度是-1,即该行cell还未缓存高度.</p>
<h2 id="缓存高度的清除时机"><a href="#缓存高度的清除时机" class="headerlink" title="缓存高度的清除时机"></a>缓存高度的清除时机</h2><p>定义了一个类别<code>FDIndexPathHeightCacheInvalidation</code>,该类别通过method swizzle交换了一些系统方法的实现.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">// All methods that trigger height cache&#x27;s invalidation</span></span><br><span class="line">    SEL selectors[] = &#123;</span><br><span class="line">        <span class="meta">@selector(reloadData)</span>,</span><br><span class="line">        <span class="meta">@selector(insertSections:withRowAnimation:)</span>,</span><br><span class="line">        <span class="meta">@selector(deleteSections:withRowAnimation:)</span>,</span><br><span class="line">        <span class="meta">@selector(reloadSections:withRowAnimation:)</span>,</span><br><span class="line">        <span class="meta">@selector(moveSection:toSection:)</span>,</span><br><span class="line">        <span class="meta">@selector(insertRowsAtIndexPaths:withRowAnimation:)</span>,</span><br><span class="line">        <span class="meta">@selector(deleteRowsAtIndexPaths:withRowAnimation:)</span>,</span><br><span class="line">        <span class="meta">@selector(reloadRowsAtIndexPaths:withRowAnimation:)</span>,</span><br><span class="line">        <span class="meta">@selector(moveRowAtIndexPath:toIndexPath:)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSUInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; sizeof(selectors) / sizeof(SEL); ++index) &#123;</span><br><span class="line">        <span class="type">SEL</span> <span class="variable">originalSelector</span> <span class="operator">=</span> selectors[index];</span><br><span class="line">        <span class="type">SEL</span> <span class="variable">swizzledSelector</span> <span class="operator">=</span> NSSelectorFromString([@<span class="string">&quot;fd_&quot;</span> stringByAppendingString:NSStringFromSelector(originalSelector)]);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">originalMethod</span> <span class="operator">=</span> class_getInstanceMethod(self, originalSelector);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">swizzledMethod</span> <span class="operator">=</span> class_getInstanceMethod(self, swizzledSelector);</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fd_reloadData &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.fd_indexPathHeightCache.automaticallyInvalidateEnabled) &#123;</span><br><span class="line">        [self.fd_indexPathHeightCache enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</span><br><span class="line">            [heightsBySection removeAllObjects];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    FDPrimaryCall([self fd_reloadData];);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用这些可能会影响cell高度的方法时,就会将缓存清除.</p>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>在iOS 10.2以上可能会出现崩溃,崩溃在<code>systemLayoutSizeFittingSize:</code>处.一种解决办法:设置cell中label的preferredMaxLayoutWidth属性.</p>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>UITableView-FDTemplateLayoutCell</tag>
      </tags>
  </entry>
  <entry>
    <title>多个targets的Podfile写法</title>
    <url>/2017/09/08/%E5%A4%9A%E4%B8%AAtargets%E7%9A%84Podfile%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h2 id="多个targets的Podfile写法"><a href="#多个targets的Podfile写法" class="headerlink" title="多个targets的Podfile写法"></a>多个targets的Podfile写法</h2><p>项目里面添加了多个target,每次pod install后,其他target就出现找不到<code>#import &lt;AFNetworking.h&gt;</code>这样的编译错误,花了三个多小时才找到了原因:是因为Podfile文件只给其中一个target配置了,所以导致了上述的问题.<br>正确写法: </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">platform</span> :ios, &#x27;<span class="number">8</span>.<span class="number">0</span>&#x27;</span><br><span class="line"></span><br><span class="line"><span class="attribute">def</span> shared_pods</span><br><span class="line">    <span class="attribute">pod</span> &#x27;AFNetworking&#x27;, &#x27;<span class="number">3</span>.<span class="number">1</span>.<span class="number">0</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;MJExtension&#x27;, &#x27;<span class="number">3</span>.<span class="number">0</span>.<span class="number">13</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;SDWebImage&#x27;, &#x27;<span class="number">4</span>.<span class="number">0</span>.<span class="number">0</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;FMDB&#x27;, &#x27;<span class="number">2</span>.<span class="number">6</span>.<span class="number">2</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;MJRefresh&#x27;, &#x27;<span class="number">3</span>.<span class="number">1</span>.<span class="number">12</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;SDCycleScrollView&#x27;, &#x27;<span class="number">1</span>.<span class="number">66</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;Bugly&#x27;, &#x27;<span class="number">2</span>.<span class="number">4</span>.<span class="number">8</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;MBProgressHUD&#x27;, &#x27;<span class="number">1</span>.<span class="number">0</span>.<span class="number">0</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;Masonry&#x27;, &#x27;<span class="number">1</span>.<span class="number">0</span>.<span class="number">2</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;IQKeyboardManager&#x27;, &#x27;<span class="number">4</span>.<span class="number">0</span>.<span class="number">9</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;TZImagePickerController&#x27;, &#x27;<span class="number">1</span>.<span class="number">7</span>.<span class="number">9</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;RealReachability&#x27;, &#x27;<span class="number">1</span>.<span class="number">1</span>.<span class="number">9</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;MMDrawerController&#x27;, &#x27;<span class="number">0</span>.<span class="number">6</span>.<span class="number">0</span>&#x27;</span><br><span class="line">    <span class="attribute">pod</span> &#x27;UMengAnalytics-NO-IDFA&#x27;</span><br><span class="line"><span class="attribute">end</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">target</span> &#x27;xxx1&#x27; do</span><br><span class="line">    <span class="attribute">shared_pods</span></span><br><span class="line"><span class="attribute">end</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">target</span> &#x27;xxx2&#x27; do</span><br><span class="line">    <span class="attribute">shared_pods</span></span><br><span class="line"><span class="attribute">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考:<a href="http://www.jianshu.com/p/aa24cb9644a0">CocoaPods使用注意事项</a></p>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>can&#39;t find gem cocoapods (&gt;= 0.a)</title>
    <url>/2017/09/10/can&#39;t%20find%20gem%20cocoapods/</url>
    <content><![CDATA[<h2 id="更新ruby后-pod-install出错"><a href="#更新ruby后-pod-install出错" class="headerlink" title="更新ruby后,pod install出错."></a>更新ruby后,pod install出错.</h2><p>xuequandeiMac:KingDynastyGaming xuequan$ pod install<br>提示:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">/Library/Ruby/Site/<span class="number">2.0</span><span class="number">.0</span>/rubygems.rb:<span class="number">270</span>:<span class="keyword">in</span> `find_spec_for_ex<span class="string">e&#x27;: can&#x27;</span>t find gem cocoapods (&gt;= <span class="number">0.</span>a) (Gem::GemNotFoundException) <span class="keyword">from</span> /Library/Ruby/Site/<span class="number">2.0</span><span class="number">.0</span>/rubygems.rb:<span class="number">298</span>:<span class="keyword">in</span> `activate_bin_path<span class="string">&#x27; from /usr/local/bin/pod:22:in `&lt;main&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>解决办法:卸载cocoapods后重新安装</p>
<ol>
<li>sudo gem uninstall cocoapods</li>
<li>gem install cocoapods</li>
<li>pod install</li>
</ol>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift协议</title>
    <url>/2017/09/12/Swift%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="可选实现"><a href="#可选实现" class="headerlink" title="可选实现"></a>可选实现</h3><p>Swift里标记某个方法为可选实现时,需要在协议前添加<code>@objc</code>,并且在可选方法前添加<code>@objc optional</code>.其实也是为了跟OC兼容.<br>eg:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">@objc protocol Iterator &#123;</span><br><span class="line">    func first<span class="function"><span class="params">()</span> -&gt;</span> AnyObject?</span><br><span class="line">    </span><br><span class="line">    func next<span class="function"><span class="params">()</span> -&gt;</span> AnyObject?</span><br><span class="line">    </span><br><span class="line">    @objc optional func isDone<span class="function"><span class="params">()</span> -&gt;</span> Bool</span><br><span class="line">    </span><br><span class="line">    func currentItem<span class="function"><span class="params">()</span> -&gt;</span> AnyObject?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断某个实例是否实现了协议里的可选方法:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i.isDone?() != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(i) 实现了方法isDone&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(i) 没实现方法isDone&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为isDone是可选实现方法,所以调用时需要加?,这样就转为optional chaining处理,如果方法的返回值不为nil,则说明对象实现了协议的可选实现方法.</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods常见问题</title>
    <url>/2017/09/10/CocoaPods%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Q:在用 Cocoapods 做第三方开源库管理的时候，有时候发现查找到的第三方库版本低于github上仓库的最新release版本.<br>A:执行<code>pod update</code>更新本地仓库，完成后，即可搜索到指定的第三方库.  </p>
<p>Q:在使用了<code>pod setup</code>之后，发现好长时间都没有变化，无法从终端上获取<code>pod setup</code>的执行情况.<br>A:这时候可以command+N新建一个窗口，通过<code>sudo ls</code>用管理员权限查看目录,然后<code>cd .cocoapods</code>文件夹，输入<code>du -sh</code>命令查看文件夹大小变化，从而确定<code>pod setup</code>的运行情况.</p>
<p>note:在Podfile文件中的<code>platform :ios, &#39;7.0&#39;</code>,如果你设置的iOS系统过低,可能有的第三方库会下载不下来.所以还是要看一下第三方库的最低版本支持说明.</p>
<p>Q:RuntimeError - [Xcodeproj] Unknown object version.然后是一大堆错误日志.不管是重新从svn checkout一份新的还是怎样,pod install都不能成功.<br>A:一种解决办法:重新安装cocoapods.</p>
<p>Q:pod search xxx，总是失败，提示CDN: trunk URL couldn’t be downloaded … Response: SSL connect error</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">[<span class="operator">!</span>] <span class="params">CDN:</span> trunk Repo update failed <span class="operator">-</span> <span class="number">2</span> error(s):</span><br><span class="line"><span class="params">CDN:</span> trunk URL couldn&#x27;t be <span class="params">downloaded:</span> https:<span class="symbol">//cdn.jsdelivr.net/cocoa/Specs/7/1/d/lottie-ios/4.4.0/lottie-ios.podspec.json</span> <span class="params">Response:</span> SSL connect error</span><br><span class="line"><span class="params">CDN:</span> trunk URL couldn&#x27;t be <span class="params">downloaded:</span> https:<span class="symbol">//cdn.jsdelivr.net/cocoa/Specs/7/1/d/lottie-ios/4.4.1/lottie-ios.podspec.json</span> <span class="params">Response:</span> SSL connect error</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<p>The workaround to get working locally during this outage or CDN issue - guessing a DNS change or something?:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">pod repo <span class="built_in">remove</span> trunk</span><br></pre></td></tr></table></figure>
<p>In <code>Podfile</code></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line"># <span class="keyword">source</span> <span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Then <code>pod install</code> and <code>pod repo update</code> will work again.</p>
<p>Later, when CDN is working again:</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">pod repo<span class="built_in"> add-cdn </span>trunk https://cdn.cocoapods.org/</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/10078#issuecomment-696481185">Intermittent CDN issues</a></p>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>http相关命令工具</title>
    <url>/2017/09/15/http%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>测试某个网址是否使用https:<br><code>nscurl --ats-diagnostics --verbose https://www.baidu.com</code></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title>Swift addTarget函数的Selector参数</title>
    <url>/2017/09/15/Swift%20addTarget%E5%87%BD%E6%95%B0%E7%9A%84Selector%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>Swift里addTarget函数里的Selector参数和OC的不太一样.<br><code>open func addTarget(_ target: Any?, action: Selector, for controlEvents: UIControlEvents)</code><br>根据Selector的定义</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Selector</span> : <span class="title class_ inherited__">ExpressibleByStringLiteral</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Create a selector from a string.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">str</span>: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Create an instance initialized to `value`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">unicodeScalarLiteral</span> <span class="params">value</span>: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Construct a selector from `value`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">extendedGraphemeClusterLiteral</span> <span class="params">value</span>: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Create an instance initialized to `value`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">stringLiteral</span> <span class="params">value</span>: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是一个结构体,并遵守<code>ExpressibleByStringLiteral</code>协议,因此可以直接传递一个字面值字符串.<br>不过这个字符串需要遵循一定的规则:</p>
<ol>
<li>如果函数没有参数,则字符串的格式为”函数名”.</li>
<li>如果函数有参数但省略了参数标签,则字符串的格式为”函数名:”.</li>
<li>如果函数有参数并且没有省略参数标签,则字符串的格式为”函数名With参数标签:”.ps:如果函数使用的是默认参数标签即使用参数名称作为参数标签的,那么字符串的格式为”函数名With参数名称:”</li>
</ol>
<p>举个例子:  </p>
<ol>
<li>没有参数<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">func numberSliderChanged<span class="function"><span class="params">()</span> -&gt;</span> Void &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对应写法:<code>numberSlider.addTarget(self, action: &quot;numberSliderChanged&quot;, for: .valueChanged)</code></li>
<li>省略参数标签<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">numberSliderChanged</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UISlider</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---&quot;</span>, sender.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对应写法:<code>numberSlider.addTarget(self, action: &quot;numberSliderChanged:&quot;, for: .valueChanged)</code></li>
<li>写明了参数标签slider.<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">numberSliderChanged</span>(<span class="params">slider</span> <span class="params">sender</span>: <span class="type">UISlider</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(sender.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对应写法:<code>numberSlider.addTarget(self, action: &quot;numberSliderChangedWithSlider:&quot;, for: .valueChanged)</code></li>
<li>使用默认参数标签<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">numberSliderChanged</span>(<span class="params">sender</span>: <span class="type">UISlider</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sds&quot;</span>, sender.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对应写法:<code>numberSlider.addTarget(self, action: &quot;numberSliderChangedWithSender:&quot;, for: .valueChanged)</code></li>
</ol>
<p>然而这种写法已经废弃,目前swift3.1推荐的是使用<code>#selector</code>,因此上述4写法等价于:<br><code>numberSlider.addTarget(self, action: #selector(numberSliderChanged(sender:)), for: .valueChanged)</code>.<br>当然你也可以传递一个Selector类型的变量:<br><code>numberSlider.addTarget(self, action: Selector.init(stringLiteral: &quot;numberSliderChangedWithSender:&quot;), for: .valueChanged)</code>.不过这种写法依然不是推荐的写法.</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>mac OS配置JAVA环境</title>
    <url>/2017/09/30/mac%20OS%E9%85%8D%E7%BD%AEJAVA%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="mac-OS配置JAVA环境"><a href="#mac-OS配置JAVA环境" class="headerlink" title="mac OS配置JAVA环境"></a>mac OS配置JAVA环境</h2><ul>
<li><p>下载安装最新版的JDK安装包:<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>,安装完成后查看下Java的版本后面配置要用到:<code>java -version</code></p>
  <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">admindeMacBook-Pro:未命名文件夹 admin$ <span class="keyword">java </span>-version</span><br><span class="line"><span class="keyword">java </span>version <span class="string">&quot;1.8.0_144&quot;</span></span><br><span class="line"><span class="keyword">Java(TM) </span>SE Runtime Environment (<span class="keyword">build </span><span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>_144-<span class="keyword">b01)</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">Java </span>HotSpot(TM) <span class="number">64</span>-<span class="keyword">Bit </span>Server VM (<span class="keyword">build </span><span class="number">25</span>.<span class="number">144</span>-<span class="keyword">b01, </span>mixed mode)</span><br></pre></td></tr></table></figure></li>
<li><p>配置环境变量：在命令行中打开<code>sudo vim ~/.bash_profile</code>，在文件后面加入下面内容：</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">JAVA_HOME</span>=<span class="string">&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home&quot;</span> </span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="string">&quot;<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>&quot;</span> </span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CLASSPATH</span>=<span class="string">&quot;.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar&quot;</span></span><br></pre></td></tr></table></figure>
<p>  note:<code>/jdk1.8.0_144.jdk</code>里面的版本字符串需要替换为上面提到的版本字符串.<br>  完成后保存,并使用<code>source ~/.bash_profile</code>应用该变更。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Swift实现removeObject</title>
    <url>/2017/09/15/Swift%E5%AE%9E%E7%8E%B0removeObject/</url>
    <content><![CDATA[<h2 id="Swift实现removeObject"><a href="#Swift实现removeObject" class="headerlink" title="Swift实现removeObject"></a>Swift实现removeObject</h2><p>如果类没有继承自NSObject,那么类必须要实现<code>Equatable</code>协议.否则不需要.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">var</span> subject: <span class="type">Subject</span>!</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">observer</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">subject</span>: <span class="type">Subject</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.subject <span class="operator">=</span> subject</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">update</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Observer</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">Observer</span>, <span class="params">rhs</span>: <span class="type">Observer</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> lhs <span class="operator">===</span> rhs &#123; <span class="comment">//地址相等. ps:&quot;==&quot;值相等.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在通过扩展给Array增加一个<code>removeObject(object: Element)</code>方法:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="keyword">Array</span> <span class="keyword">where</span> Element: Equatable &#123;</span><br><span class="line">    mutating func removeObject(<span class="keyword">object</span>: Element) &#123;</span><br><span class="line">        <span class="keyword">if</span> let <span class="keyword">index</span> = <span class="keyword">index</span>(<span class="keyword">of</span>: <span class="keyword">object</span>) &#123;</span><br><span class="line">            remove(at: <span class="keyword">index</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Array是结构体类型,而removeObject函数会改变结构体的值,所以该函数需要添加mutating关键字.“Notice the use of the mutating keyword in the declaration of SimpleStructure to mark a method that modifies the structure. The declaration of SimpleClass doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.”</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>在mac OS上反编译安卓apk包</title>
    <url>/2017/09/30/%E5%9C%A8mac%20OS%E4%B8%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%AE%89%E5%8D%93apk%E5%8C%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般上架的安卓apk都会做混淆和加固,如果两个都不做那么被别人反编译后就可以直接看到源码了.而混淆后,那些函数名就会变成一些如”a”,”b”,”c”之类无意义的名称,并且还会添加一些无意义的代码逻辑.从而大大提高了破解的难度,但是花点时间还是能够看懂一些逻辑的.因此为了让apk更加难以反编译,加固也很重要.加固后要想反编译则更加费时,费劲.本文仅仅是自己做个记录,所以不牵涉到对加固后的apk进行反编译.</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><a href="https://ibotpeaches.github.io/Apktool/install/">Apktool</a></li>
<li><a href="https://sourceforge.net/projects/dex2jar/files/">dex2jar</a></li>
<li><a href="http://jd.benow.ca/">jd-gui</a></li>
</ul>
<h3 id="Apktool"><a href="#Apktool" class="headerlink" title="Apktool"></a>Apktool</h3><p>资源反编译,获取apk里面的资源.如果你仅仅只是想获取里面的资源,可不必使用该工具,直接解压缩源apk就可以了.<br>note:使用Apktool处理后的和直接解压缩后的里面的文件内容还是不一样的,比如里面的AndroidManifest.xml文件,Apktool处理后的就能够读懂,否则是一些乱码.</p>
<h4 id="Apktool安装"><a href="#Apktool安装" class="headerlink" title="Apktool安装"></a>Apktool安装</h4><p>按照官网说明,下载后会得到两个文件<code>apktool</code>和<code>apktool.jar</code>,需要注意的是必须赋予这两个文件可执行权限.使用命令<code>chmod +x 对应文件名</code>即可.最后将这两个文件拖入<code>/usr/local/bin</code>文件夹中.</p>
<h4 id="Apktool使用"><a href="#Apktool使用" class="headerlink" title="Apktool使用"></a>Apktool使用</h4><p>命令:<code>apktool d 对应apk路径</code>.<br>执行完毕后,会得到一个同名的文件夹,里面就是一些资源了.找到里面的<code>classes.dex</code>文件,后面代码反编译会用到.</p>
<h3 id="dex2jar"><a href="#dex2jar" class="headerlink" title="dex2jar"></a>dex2jar</h3><p>代码反编译,得到<code>classes-dex2jar.jar</code>文件.</p>
<h4 id="dex2jar使用"><a href="#dex2jar使用" class="headerlink" title="dex2jar使用"></a>dex2jar使用</h4><p>下载后会得到一个<code>dex2jar-2.0</code>文件夹.这里需要用到里面的<code>lib</code>,<code>d2j_invoke.sh</code>,<code>d2j-dex2jar.sh</code>.<br>将这三个文件及上面获得的<code>classes.dex</code>文件拖入同一个文件夹目录.<br>使用命令: <code>sh d2j-dex2jar.sh classes.dex</code><br>此时在该目录下会得到一个<code>classes-dex2jar.jar</code>文件.这个文件后面会用到.</p>
<h3 id="jd-gui"><a href="#jd-gui" class="headerlink" title="jd-gui"></a>jd-gui</h3><p>下载后会得到一个<code>jd-gui-osx-1.4.0</code>文件夹,双击里面的<code>JD-GUI</code>文件,打开后将上述<code>classes-dex2jar.jar</code>文件拖入其中.就可以看到啦!<br>note:你的Mac必须安装了Java环境.</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>目录:<br><img src="http://7xqoji.com1.z0.glb.clouddn.com/%E5%AE%89%E8%A3%85apk%E5%8F%8D%E7%BC%96%E8%AF%91%E5%90%8E%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95.png" alt="目录"></p>
<p>部分代码:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a</span>(<span class="params"><span class="built_in">int</span> paramInt, boolean paramBoolean</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    Observable.a(<span class="keyword">new</span> FavoriteBean(Integer.valueOf(paramInt), Boolean.valueOf(paramBoolean))).a(<span class="keyword">new</span> Func1()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">a</span>(<span class="params">FavoriteBean paramAnonymousFavoriteBean</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (paramAnonymousFavoriteBean.getKeepAble().booleanValue()) &#123;</span><br><span class="line">          BasicActivity.f(BasicActivity.<span class="keyword">this</span>).<span class="keyword">add</span>(<span class="number">0</span>, paramAnonymousFavoriteBean.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">          Iterator localIterator = BasicActivity.f(BasicActivity.<span class="keyword">this</span>).iterator();</span><br><span class="line">          <span class="keyword">if</span> (localIterator.hasNext())</span><br><span class="line">          &#123;</span><br><span class="line">            Integer localInteger = (Integer)localIterator.next();</span><br><span class="line">            <span class="keyword">if</span> (!localInteger.<span class="keyword">equals</span>(paramAnonymousFavoriteBean.getId())) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            BasicActivity.f(BasicActivity.<span class="keyword">this</span>).<span class="keyword">remove</span>(localInteger);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).b(Schedulers.computation()).a(AndroidSchedulers.a()).a(<span class="keyword">new</span> Action1()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span>(<span class="params">String paramAnonymousString</span>)</span> &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>CUICatalog-Invalid asset name supplied</title>
    <url>/2017/10/13/CUICatalog-Invalid%20asset%20name%20supplied/</url>
    <content><![CDATA[<h2 id="CUICatalog-Invalid-asset-name-supplied"><a href="#CUICatalog-Invalid-asset-name-supplied" class="headerlink" title="CUICatalog-Invalid asset name supplied"></a>CUICatalog-Invalid asset name supplied</h2><p>iOS11中,<br><code>UIImage *highlightedImage = [UIImage imageNamed:highlightedImageName];</code>如果图片名是nil,或者不存在对应的图片,那么控制台会打印下面的提示信息.一般是因为传了nil或要找的资源不存在导致.</p>
<p>2017-09-27 16:46:33.399319+0800 KingDynastyGaming[48313:2122542] [framework] CUICatalog: Invalid asset name supplied: ‘(null)’</p>
<p>问题就是要找到哪行代码导致出现了提示信息.<br>调试办法:打符号断点:<code>+[UIImage imageNamed:]</code>.在出现这条信息的操作之前使能断点,这样根据函数调用栈就可以看到调用该方法的位置,使用命令<code>po $arg3</code>还可以查看图片的名字即第三个参数的值.</p>
<h3 id="调试命令参数"><a href="#调试命令参数" class="headerlink" title="调试命令参数"></a>调试命令参数</h3><p>The exception object is passed in as the first argument to <code>objc_exception_throw</code>. LLDB provides <code>$arg1..$argn</code> variables to refer to arguments in the correct calling convention, making it simple to print the exception details:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">(lldb) po <span class="variable">$arg1</span></span><br><span class="line">(lldb) po <span class="selector-attr">[$arg1 name]</span></span><br><span class="line">(lldb) po <span class="selector-attr">[$arg1 reason]</span></span><br></pre></td></tr></table></figure>
<p>Make sure to select the objc_exception_throw frame in the call stack before executing these commands. See the “Advanced Debugging and the Address Sanitizer” in the WWDC15 session videos to see this performed on stage.</p>
<p>On the iPhone Simulator, all function arguments are passed on the stack, so the syntax is considerably more horrible. The shortest expression I could construct that gets to it is <code>*(id *)($ebp + 8)</code>. To make things less painful, I suggest using a convenience variable:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$exception</span> = *(<span class="built_in">id</span> *)(<span class="variable">$ebp</span> + 8)</span><br><span class="line">(gdb) po <span class="variable">$exception</span></span><br><span class="line">(gdb) po [<span class="variable">$exception</span> name]</span><br><span class="line">(gdb) po [<span class="variable">$exception</span> reason]</span><br></pre></td></tr></table></figure>
<p>You can also set <code>$exception</code> automatically whenever the breakpoint is triggered by adding a command list to the <code>objc_exception_throw</code> breakpoint.</p>
<p>(Note that in all cases I tested, the exception object was also present in the eax and edx registers at the time the breakpoint hit. I’m not sure that’ll always be the case, though.)</p>
<p>Added from comment below:</p>
<p>In lldb, select the stack frame for objc_exception_throw and then enter this command:</p>
<p><code>(lldb) po *(id *)($esp + 4)</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/3327828/xcode-lldb-how-to-get-information-about-an-exception-that-was-just-thrown">Xcode/LLDB: How to get information about an exception that was just thrown?</a></p>
<p><a href="http://www.clarkcox.com/blog/2009/02/04/inspecting-obj-c-parameters-in-gdb/">Inspecting Obj-C parameters in gdb</a></p>
<p><a href="http://www.jianshu.com/p/f900de4a1495">【OC刨根问底】-Runtime简单粗暴理解</a></p>
<p><a href="http://blog.csdn.net/qq_27074387/article/details/50352613">OC 运行时 (二)</a></p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>Next Theme Tutorial</title>
    <url>/2017/07/20/next-tutorial/</url>
    <content><![CDATA[<blockquote>
<p>NexT is a high quality elegant <a href="https://jekyllrb.com">Jekyll</a> theme ported from <a href="https://github.com/iissnan/hexo-theme-next">Hexo Next</a>. It is crafted from scratch, with love.</p>
</blockquote>
<span id="more"></span>
<p><a href="http://simpleyyt.github.io/jekyll-theme-next/">Live Preview</a></p>
<h2 id="Screenshots"><a href="#Screenshots" class="headerlink" title="Screenshots"></a>Screenshots</h2><ul>
<li><p>Desktop<br><img src="http://iissnan.com/nexus/next/desktop-preview.png" alt="Desktop Preview"></p>
</li>
<li><p>Sidebar</p>
</li>
</ul>
<p><img src="http://iissnan.com/nexus/next/desktop-sidebar-preview.png" alt="Desktop Sidebar Preview"></p>
<ul>
<li>Sidebar (Post details page)</li>
</ul>
<p><img src="http://iissnan.com/nexus/next/desktop-sidebar-toc.png" alt="Desktop Sidebar Preview"></p>
<ul>
<li>Mobile</li>
</ul>
<p><img src="http://iissnan.com/nexus/next/mobile.png" alt="Mobile Preview"></p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Check whether you have <code>Ruby 2.1.0</code> or higher installed:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ruby --version</span><br></pre></td></tr></table></figure>
<p>Install <code>Bundler</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gem install bundler</span><br></pre></td></tr></table></figure>
<p>Clone Jacman theme:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Simpleyyt/jekyll-theme-next.git</span><br><span class="line"><span class="built_in">cd</span> jekyll-theme-next</span><br></pre></td></tr></table></figure>
<p>Install Jekyll and other dependencies from the GitHub Pages gem:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bundle install</span><br></pre></td></tr></table></figure>
<p>Run your Jekyll site locally:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bundle <span class="built_in">exec</span> jekyll server</span><br></pre></td></tr></table></figure>
<p>More Details：<a href="https://help.github.com/articles/setting-up-your-github-pages-site-locally-with-jekyll/">Setting up your GitHub Pages site locally with Jekyll</a></p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><h3 id="Multiple-languages-support-including-English-Russian-French-German-Simplified-Chinese-Traditional-Chinese"><a href="#Multiple-languages-support-including-English-Russian-French-German-Simplified-Chinese-Traditional-Chinese" class="headerlink" title="Multiple languages support, including: English / Russian / French / German / Simplified Chinese / Traditional Chinese."></a>Multiple languages support, including: English / Russian / French / German / Simplified Chinese / Traditional Chinese.</h3><p>Default language is English.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="comment"># language: zh-Hans</span></span><br><span class="line"><span class="comment"># language: fr-FR</span></span><br><span class="line"><span class="comment"># language: zh-hk</span></span><br><span class="line"><span class="comment"># language: zh-tw</span></span><br><span class="line"><span class="comment"># language: ru</span></span><br><span class="line"><span class="comment"># language: de</span></span><br></pre></td></tr></table></figure>
<p>Set <code>language</code> field as following in site <code>_config.yml</code> to change to Chinese.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br></pre></td></tr></table></figure>
<h3 id="Comment-support"><a href="#Comment-support" class="headerlink" title="Comment support."></a>Comment support.</h3><p>NexT has native support for <code>DuoShuo</code> and <code>Disqus</code> comment systems.</p>
<p>Add the following snippets to your <code>_config.yml</code>:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">duoshuo:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">your-duoshuo-shortname</span></span><br></pre></td></tr></table></figure>
<p>OR</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus_shortname:</span> <span class="string">your-disqus-shortname</span></span><br></pre></td></tr></table></figure>
<h3 id="Social-Media"><a href="#Social-Media" class="headerlink" title="Social Media"></a>Social Media</h3><p>NexT can automatically add links to your Social Media accounts:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">your-github-url</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">your-twitter-url</span></span><br><span class="line">  <span class="attr">Weibo:</span> <span class="string">your-weibo-url</span></span><br><span class="line">  <span class="attr">DouBan:</span> <span class="string">your-douban-url</span></span><br><span class="line">  <span class="attr">ZhiHu:</span> <span class="string">your-zhihu-url</span></span><br></pre></td></tr></table></figure>
<h3 id="Feed-link"><a href="#Feed-link" class="headerlink" title="Feed link."></a>Feed link.</h3><blockquote>
<p>Show a feed link.</p>
</blockquote>
<p>Set <code>rss</code> field in theme’s <code>_config.yml</code>, as the following value:</p>
<ol>
<li><code>rss: false</code> will totally disable feed link.</li>
<li><p><code>rss:</code> use sites’ feed link. This is the default option.</p>
<p> Follow the installation instruction in the plugin’s README. After the configuration is done for this plugin, the feed link is ready too.</p>
</li>
<li><p><code>rss: http://your-feed-url</code> set specific feed link.</p>
</li>
</ol>
<h3 id="Up-to-5-code-highlight-themes-built-in"><a href="#Up-to-5-code-highlight-themes-built-in" class="headerlink" title="Up to 5 code highlight themes built-in."></a>Up to 5 code highlight themes built-in.</h3><p>NexT uses <a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme</a> with 5 themes for you to choose from.<br>Next use <code>normal</code> by default. Have a preview about <code>normal</code> and <code>night</code>:</p>
<p><img src="http://iissnan.com/nexus/next/tomorrow-normal.png" alt="Tomorrow Normal Preview"><br><img src="http://iissnan.com/nexus/next/tomorrow-night.png" alt="Tomorrow Night Preview"></p>
<p>Head over to <a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme</a> for more details.</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>NexT comes with few configurations.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Menu configuration.</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Favicon</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Avatar (put the image into next/source/images/)</span></span><br><span class="line"><span class="comment"># can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..)</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/default_avatar.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Code highlight theme</span></span><br><span class="line"><span class="comment"># available: normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fancybox for image gallery</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the date when the site was setup</span></span><br><span class="line"><span class="attr">since:</span> <span class="number">2013</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Browser-support"><a href="#Browser-support" class="headerlink" title="Browser support"></a>Browser support</h2><p><img src="http://iissnan.com/nexus/next/browser-support.png" alt="Browser support"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>didSelectRowAtIndexPath不被调用</title>
    <url>/2017/10/18/didSelectRowAtIndexPath%E4%B8%8D%E8%A2%AB%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="didSelectRowAtIndexPath不被调用"><a href="#didSelectRowAtIndexPath不被调用" class="headerlink" title="didSelectRowAtIndexPath不被调用"></a>didSelectRowAtIndexPath不被调用</h2><p>vc.view上添加一个UITableView,并且vc.view上添加一个UITapGestureRecognizer手势,那么<code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath</code>代理方法将不再被调用.</p>
<p>这是由于<code>UIGestureRecognizer</code>有一个属性:<br><code>@property(nonatomic) BOOL cancelsTouchesInView;</code><br>官方的注释:default is YES. causes touchesCancelled:withEvent: or pressesCancelled:withEvent: to be sent to the view for all touches or presses recognized as part of this gesture immediately before the action method is called.<br>该属性默认是YES,在action方法被调用之前系统会迅速调用View的touchesCancelled:withEvent: or pressesCancelled:withEvent:方法.touches事件将立即被cancel.所有的touches或presses对象将转而被用于手势识别.因此当一个View上添加了一个手势那么该View的touchesEnded方法将不会被调用(只会touchesBegan-&gt;touchesCancelled).</p>
<p>可以推断出:如果一个button上又添加一个tap手势,则最后只会有tap响应,button的target则不会被调用.这是由于手势识别时会cancel掉后面的Touches.因此当用户触摸一个控件时,手势的处理优先于触摸事件的处理.</p>
<p>因此,要想didSelectRowAtIndexPath方法被调用,有两种解决办法:  </p>
<ol>
<li>设置<code>tap.cancelsTouchesInView = NO;</code>让touch事件继续进行,从而让view可以继续处理.</li>
<li><p>实现<code>UIGestureRecognizerDelegate</code>的代理方法</p>
 <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch &#123;</span><br><span class="line">    <span class="keyword">if</span> ([touch.view isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;UITableViewCellContentView&quot;</span>)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当点击到cell.contentView上时,让tap手势不处理touches.</p>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="https://joakimliu.github.io/2017/01/15/iOS的事件处理/">iOS的事件处理</a></p>
<p>Event Handling Guide for iOS </p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title>采用 Modern Objective-C</title>
    <url>/2017/10/21/%E9%87%87%E7%94%A8%20Modern%20Objective-C/</url>
    <content><![CDATA[<h2 id="采用-Modern-Objective-C"><a href="#采用-Modern-Objective-C" class="headerlink" title="采用 Modern Objective-C"></a>采用 Modern Objective-C</h2><p>参考:<a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html">Adopting Modern Objective-C</a></p>
<p>These modernizations <strong>improve type safety, memory management, performance, and other aspects of Objective-C</strong>, making it easier for you to write correct code. It’s important to adopt these changes in your existing and future code to help it become more consistent, readable, and resilient.</p>
<h3 id="instancetype"><a href="#instancetype" class="headerlink" title="instancetype"></a>instancetype</h3><p>Use the instancetype keyword as the return type of methods that return an instance of the class they are called on (or a subclass of that class).<br>Using instancetype instead of id in appropriate places <strong>improves type safety</strong> in your Objective-C code.<br>使用instancetype后,如果给对象发送一条不能识别的消息那么编译器就会提示错误,这样就可以提前解决错误,因此提高了类型安全.参考官方文档上的例子说明.</p>
<p>Note that you should replace id with instancetype for return values only, not elsewhere in your code. Unlike id, the instancetype keyword can be used only as the result type in a method declaration.</p>
<h3 id="property语法"><a href="#property语法" class="headerlink" title="@property语法"></a><code>@property</code>语法</h3><p>使用properties代替实例变量有许多好处.</p>
<ul>
<li>自动合成getter和setter.</li>
<li>更好的声明一系列方法的意图.</li>
<li>Property关键字可以传递额外的信息.比如assign (vs copy), weak, atomic (vs nonatomic), and so on.</li>
</ul>
<p>Property methods follow a simple naming convention. The getter is the name of the property (for example, date), and the setter is the name of the property with the set prefix, written in camel case (for example, setDate). The naming convention for Boolean properties is to declare them with a named getter starting with the word “is”:<br><code>@property (readonly, getter=isBlue) BOOL blue;</code></p>
<h3 id="枚举宏"><a href="#枚举宏" class="headerlink" title="枚举宏"></a>枚举宏</h3><p>使用NS_ENUM 和 NS_OPTIONS宏.when you use enum to define a bitmask use the NS_OPTIONS macro.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewCellStyle</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UITableViewCellStyleDefault</span>,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UITableViewCellStyleValue1</span>,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UITableViewCellStyleValue2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UITableViewCellStyleSubtitle</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIViewAutoresizing</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UIViewAutoresizingNone</span>                 = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
  </entry>
  <entry>
    <title>反转一个字符串</title>
    <url>/2017/11/02/%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="反转一个字符串"><a href="#反转一个字符串" class="headerlink" title="反转一个字符串"></a>反转一个字符串</h3><p>对”hello,world!”,进行反转.<br>错误实现:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转一个字符串</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_ invoke__">reverseString</span>(<span class="type">char</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *rs = src;</span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;<span class="char escape_">\0</span>&#x27;</span>) &#123;</span><br><span class="line">        src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*rs != <span class="string">&#x27;<span class="char escape_">\0</span>&#x27;</span>) &#123;</span><br><span class="line">        *rs++ = *--src; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种思路其实是错的.当rs与src相遇时,字符串已经变为”!dlrowworld!”,再进行替换操作就会出问题了,因为字符”hello,”已经被替换而不存在了.所以不应该使用替换,而应该使用交换.</p>
<p>正确实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转一个字符串</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">reverseString</span><span class="params">(<span class="type">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *forwardPtr = src;</span><br><span class="line">    <span class="type">char</span> *backPtr = src;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*backPtr != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        backPtr++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (forwardPtr &lt; backPtr) &#123;</span><br><span class="line">        <span class="type">char</span> tmp = *forwardPtr;</span><br><span class="line">        *forwardPtr++ = *--backPtr;</span><br><span class="line">        *backPtr = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>操作子视图控制器</title>
    <url>/2017/11/13/%E6%93%8D%E4%BD%9C%E5%AD%90%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="操作子视图控制器"><a href="#操作子视图控制器" class="headerlink" title="操作子视图控制器"></a>操作子视图控制器</h2><p>系统提供了一些方法用于添加和移除子视图控制器:<br>(UIContainerViewControllerProtectedMethods)类别里的:  </p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>addChildViewController:<span class="params">(UIViewController *)</span>childController NS_AVAILABLE_IOS<span class="params">(<span class="number">5_0</span>)</span>;</span><br><span class="line">- <span class="params">(void)</span>removeFromParentViewController NS_AVAILABLE_IOS<span class="params">(<span class="number">5_0</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述两个方法调用后还要配套调用(UIContainerViewControllerCallbacks)类别里的:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)willMoveToParentViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)parent <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line">- (<span class="type">void</span>)didMoveToParentViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)parent <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br></pre></td></tr></table></figure>
<h3 id="addChildViewController-的说明"><a href="#addChildViewController-的说明" class="headerlink" title="addChildViewController:的说明:"></a>addChildViewController:的说明:</h3><ol>
<li><p>If the child controller has a different parent controller, it will first be removed from its current parent<br>by calling removeFromParentViewController.</p>
</li>
<li><p>addChildViewController: will call [child willMoveToParentViewController:self] before adding the<br>child. However, it will not call didMoveToParentViewController:.所以willMoveToParentViewController:就不需要我们自己调用了,但需要我们自己手动调用didMoveToParentViewController:</p>
</li>
</ol>
<h3 id="removeFromParentViewController的说明"><a href="#removeFromParentViewController的说明" class="headerlink" title="removeFromParentViewController的说明:"></a>removeFromParentViewController的说明:</h3><p>removeFromParentViewController does not call [self willMoveToParentViewController:nil] before removing the<br>  child. This is also the responsibilty of the container subclass.subclasses will typically define a method that removes a child in<br>  the reverse manner by first calling [child willMoveToParentViewController:nil].</p>
<h3 id="正确添加和移除一个子视图控制器"><a href="#正确添加和移除一个子视图控制器" class="headerlink" title="正确添加和移除一个子视图控制器"></a>正确添加和移除一个子视图控制器</h3><p>添加一个子视图控制器的方法如下:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[self addChildViewController:quizingVC]</span><span class="comment">;</span></span><br><span class="line"><span class="attr">quizingVC.view.frame</span> = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, self.contentScrollView.frame.size.width, self.contentScrollView.frame.size.height - <span class="number">2</span>*matchStatusBarH)<span class="comment">;</span></span><br><span class="line"><span class="section">[self.contentScrollView addSubview:quizingVC.view]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[quizingVC didMoveToParentViewController:self]</span><span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>移除一个子视图控制器:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先将其父控制器置为nil</span></span><br><span class="line">[<span class="keyword">self</span> willMoveToParentViewController:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他一些操作比如动画.</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//再remove</span></span><br><span class="line">[<span class="keyword">self</span> removeFromParentViewController];</span><br></pre></td></tr></table></figure>
<h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><p>一个控制器只有被添加到父控制器后,父控制器的view的frame(尤其是size)改变时,系统才会调整子控制器的View的frame,并随之自动调用子控制器的viewDidLayoutSubviews方法.这样子控制器的View及其子视图才会有正确的frame.</p>
<p>在嵌套控制器的时候可以测试一下.比如使用<code>CAPSPageMenu</code>第三方库.</p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIViewController</tag>
      </tags>
  </entry>
  <entry>
    <title>removeObject</title>
    <url>/2017/11/12/swift_removeObject/</url>
    <content><![CDATA[<h2 id="给Swift-Array类型扩展removeObject方法"><a href="#给Swift-Array类型扩展removeObject方法" class="headerlink" title="给Swift Array类型扩展removeObject方法"></a>给Swift Array类型扩展removeObject方法</h2><p>由于Array是结构体类型,而removeObject函数会改变结构体的值,所以该函数需要添加mutating关键字.“Notice the use of the mutating keyword in the declaration of SimpleStructure to mark a method that modifies the structure. The declaration of SimpleClass doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.”</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="keyword">Array</span> <span class="keyword">where</span> Element: Equatable &#123;</span><br><span class="line">    mutating func removeObject(<span class="keyword">object</span>: Element) &#123;</span><br><span class="line">        <span class="keyword">if</span> let <span class="keyword">index</span> = <span class="keyword">index</span>(<span class="keyword">of</span>: <span class="keyword">object</span>) &#123;</span><br><span class="line">            remove(at: <span class="keyword">index</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>layoutIfNeeded与layoutSubviews的关系</title>
    <url>/2017/08/16/layoutIfNeeded%E4%B8%8ElayoutSubviews%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>动画<code>-layoutIfNeeded</code>父控制器的self.view,子控制器的子视图如果重写了<code>-layoutSubviews</code>也将动画布局.<br>需求:导航栏根据子VC的tableview的位移动画.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (contentOffsetY <span class="operator">&gt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//上滑</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.headerContainerView mas_updateConstraints:<span class="operator">^</span>(<span class="type">MASConstraintMaker</span> <span class="operator">*</span>make) &#123;</span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>.view.mas_topMargin).with.offset(startY <span class="operator">-</span> endY);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.view setNeedsUpdateConstraints];</span><br><span class="line">    [<span class="keyword">self</span>.view updateConstraintsIfNeeded];</span><br><span class="line">    </span><br><span class="line">    [<span class="type">UIView</span> animateWithDuration:<span class="number">0.3</span> animations:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.contentScrollView.contentInset <span class="operator">=</span> <span class="type">UIEdgeInsetsMake</span>(<span class="operator">-</span>endY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.view layoutIfNeeded]; <span class="comment">//问题点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.headerContainerView.headerView.matchOtherDesBgView.alpha <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.headerContainerView.headerView.team1NameLabel.alpha <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.headerContainerView.headerView.team2NameLabel.alpha <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.headerContainerView.headerView.teamLogoBgView.transform <span class="operator">=</span> <span class="type">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">        <span class="type">CGAffineTransform</span> currentT <span class="operator">=</span> <span class="keyword">self</span>.headerContainerView.headerView.teamLogoBgView.transform;</span><br><span class="line">        <span class="type">CGAffineTransform</span> translation <span class="operator">=</span> <span class="type">CGAffineTransformTranslate</span>(currentT, <span class="number">0</span>, teamLogoBgViewOffsetY);</span><br><span class="line">        <span class="keyword">self</span>.headerContainerView.headerView.teamLogoBgView.transform <span class="operator">=</span> translation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于需要动画的改变父控制器里的view位移,又因为使用了xib,所以动画时需要在动画block里写<code>[self.view layoutIfNeeded];</code>但这句代码导致了子控制器的视图的<code>-layoutSubviews</code>方法被调用.于是子控制器的视图在布局时也会动画的进行(而这种效果不是你需要的从而变成了bug.)<br>这里的bug就是:子控制器里的tableViewCell因为重写了<code>-layoutSubviews</code>,而cell上的子控件<code>KDGMatchDetailItemView</code>也重写了<code>-layoutSubviews</code>.所以<code>KDGMatchDetailItemView</code>在布局时出现动画的往右移动.<br>解决办法:当导航栏收缩后,就不要执行<code>[self.view layoutIfNeeded];</code>加个判断条件:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (contentOffsetY &gt; <span class="number">0</span>  &amp;&amp; self<span class="selector-class">.contentScrollView</span><span class="selector-class">.contentInset</span><span class="selector-class">.top</span> != -endY) &#123;</span><br><span class="line">	<span class="comment">//动画代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统的<code>-layoutIfNeeded</code>的实现应该是调用了视图的<code>-layoutSubviews</code>方法.父视图<code>-layoutSubviews</code>方法的调用可能会引起子视图<code>-layoutSubviews</code>方法的调用.</p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>layoutIfNeeded</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift对象拷贝</title>
    <url>/2017/09/15/Swift%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="Swift对象拷贝"><a href="#Swift对象拷贝" class="headerlink" title="Swift对象拷贝"></a>Swift对象拷贝</h2><h3 id="方法一-实现NSCopying协议"><a href="#方法一-实现NSCopying协议" class="headerlink" title="方法一:实现NSCopying协议"></a>方法一:实现NSCopying协议</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resume</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">NSCopying</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> timeArea: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> company: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//必须要有一个required的初始化方法</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">copy</span>(<span class="params">with</span> <span class="params">zone</span>: <span class="type">NSZone</span>? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="keyword">Any</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> obj <span class="operator">=</span> <span class="built_in">type</span>(of: <span class="keyword">self</span>).<span class="keyword">init</span>(name: name)</span><br><span class="line">        obj.sex <span class="operator">=</span> sex</span><br><span class="line">        obj.age <span class="operator">=</span> age</span><br><span class="line">        obj.timeArea <span class="operator">=</span> timeArea</span><br><span class="line">        obj.company <span class="operator">=</span> company</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用:<br><code>let ben = Resume.init(name: &quot;本初&quot;)</code><br><code>var shu = ben.copy() as! Resume</code></p>
<h3 id="方法二-实现自定义拷贝协议"><a href="#方法二-实现自定义拷贝协议" class="headerlink" title="方法二:实现自定义拷贝协议"></a>方法二:实现自定义拷贝协议</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Copyable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">copied</span>() -&gt; <span class="keyword">Self</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>: <span class="title class_ inherited__">Copyable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> author: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> publish: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//必须要有一个required的初始化方法</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">copied</span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> obj <span class="operator">=</span> <span class="built_in">type</span>(of: <span class="keyword">self</span>).<span class="keyword">init</span>(name: name)</span><br><span class="line">        obj.name <span class="operator">=</span> name</span><br><span class="line">        obj.author <span class="operator">=</span> author</span><br><span class="line">        obj.publish <span class="operator">=</span> publish</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用:<br><code>let sanguo = Book.init(name: &quot;three of kingdom&quot;)</code><br><code>let book = sanguo.copied()</code>  </p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>OC block基本操作--解除引用循环</title>
    <url>/2017/12/02/OC%20block%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C--%E8%A7%A3%E9%99%A4%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h3 id="block截获self情况"><a href="#block截获self情况" class="headerlink" title="block截获self情况."></a>block截获self情况.</h3><p>略.</p>
<h3 id="block截获成员变量时-避免循环引用的几种基本操作"><a href="#block截获成员变量时-避免循环引用的几种基本操作" class="headerlink" title="block截获成员变量时,避免循环引用的几种基本操作."></a>block截获成员变量时,避免循环引用的几种基本操作.</h3><p>下面这段代码如果不做任何处理,在block属性里直接使用成员变量,100%导致循环引用.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">场景:</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>(^MyBlk)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecondViewController</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    Animal *_myAnimal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) MyBlk blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">_myAnimal = [[Animal alloc] init];</span><br><span class="line"><span class="keyword">self</span>.blk = ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, _myAnimal); <span class="comment">//因为实例变量的访问等价于self-&gt;_myAnimal,也等价于(*self)._myAnimal;所以这里会导致block强引用self.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么如何解决呢?有如下几种操作:</p>
<ol>
<li><p>使用__weak typeof(成员变量) weak成员变量 = 成员变量;</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_myAnimal = [[Animal alloc] init];</span><br><span class="line">  __<span class="keyword">weak</span> <span class="keyword">typeof</span>(_myAnimal) weakMyAnimal = _myAnimal;</span><br><span class="line">  <span class="keyword">self</span>.blk = ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, weakMyAnimal);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用局部变量,这样block就不再持有self.于是循环引用便不能形成了.</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_myAnimal = [[Animal alloc] init];</span><br><span class="line">  Animal *tMyAnimal = _myAnimal;</span><br><span class="line">  <span class="keyword">self</span>.blk = ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, tMyAnimal);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>对方法2进行改进,增加__block修饰符.</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_myAnimal = [[Animal alloc] init];</span><br><span class="line">  __block Animal *tMyAnimal = _myAnimal;</span><br><span class="line">  <span class="keyword">self</span>.blk = ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, tMyAnimal);</span><br><span class="line">     tMyAnimal = <span class="literal">nil</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用__weak typeof(self) weakSelf = self;</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_myAnimal = [[Animal alloc] init];</span><br><span class="line">  __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.blk = ^&#123;</span><br><span class="line">     __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">     <span class="keyword">if</span> (!strongSelf) <span class="keyword">return</span> ; <span class="comment">//必须加上判断,否则一旦self在这之前被释放销毁了,那么后面的-&gt;操作将崩溃.</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, strongSelf -&gt; _myAnimal); <span class="comment">//一旦block在执行中,对象被销毁了,很容易造成对NULL指针进行解引用导致崩溃.所以前面的判断是必须的.</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, (*strongSelf)._myAnimal);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>那么这几种办法中哪种才是最佳实践呢?从写法上来看,第一种和第二种以及改进型的第三种要比第四种方便很多.那么第一种方法和第二种方法哪种更好呢?这里就需要知道什么是block以及为什么使用weak修饰符后就可以解除循环引用.</p>
<blockquote>
<p>什么是block</p>
</blockquote>
<p>带有自动变量(局部变量)值的匿名函数就是block.匿名函数就是不带有名称的函数.带有自动变量值在block中的表现就是”截获自动变量值”.</p>
<blockquote>
<p>截获自动变量值</p>
</blockquote>
<p>“截获自动变量值”指的是:在执行block语法时,block语法表达式所使用的自动变量值会被保存到block的结构体实例中(即block自身里).也就是说block结构体会多出来一个成员变量,它的类型就是截获的自动变量的类型.比如自动变量的类型是weak,那么该成员变量的类型也是weak;如果是strong,那么成员变量的类型也是strong.这就是为什么我们使用<code>__weak typeof(self) weakSelf = self;</code>可以让block不强引用self的原因.</p>
<p>现在让我们来比较一下方法一和方法二,方法一使用了weak修饰符,因此block截获的指针变量<code>weakMyAnimal</code>是weak类型的,而weak类型指针是不会强引用指向的对象,这样block也就不会强引用Animal对象.而方法二中将导致block会强引用Animal对象.这就意味着Animal对象的释放还要依赖于block有没有释放,更直白一点就是Animal对象本来可以更早释放的,但是由于block还强引用了它,导致没有被释放.</p>
<p>小问题:如果一个block截获了一个strong类型的指针变量,那么该指针指向的对象什么时候才会被block释放?是block执行完后就被释放还是要等到block被释放后它才会被释放?</p>
<p>答案是选B.这是因为block虽然执行完了,但是block截获的指针变量依然存活(区别于block代码块里定义的局部变量),因此指针指向的对象依然被强引用.要直到block被释放后该对象才会被释放.</p>
<p>是时候比较一下方法二和方法三了.方法三是方法二的改进型.可以看到方法三中,block执行完成后就将截获的指针变量赋值为nil了,从而指向的对象会被立即释放.这是方法二所做不到的.是不是方法三就等价于方法一了呢?显然不等价.要想等价于方法一,要做的事情只有一个:确保该block一定被调用.否则方法三将等价于方法二.</p>
<p>综上,方法一是最佳实践不会引起任何副作用.是不是方法二就不能用了呢?当然不是,只要你能够确信不会引起其他引用循环(ps:在某种情况下方法二会导致引用循环,及在某种情况下方法二即使没有引起引用循环也导致”截获的对象”不能被释放)自然是可以使用的,我就经常使用,因为它写法更简单.</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>OC block基本操作--Block里的strongSelf</title>
    <url>/2017/12/03/OC%20block%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C--Block%E9%87%8C%E7%9A%84strongSelf/</url>
    <content><![CDATA[<h3 id="Block里的strongSelf"><a href="#Block里的strongSelf" class="headerlink" title="Block里的strongSelf"></a>Block里的strongSelf</h3><p>有时我们在看源码时,会发现作者会在block里第一行strong一下weakSelf.以下便是对这种写法的一个探究.</p>
<p>一般在使用block的时候,都会在block外,声明一个weakSelf,来确保block不去持有self.但是这也会引发一个问题,就是如果在block执行之前,self就已经销毁了,那么block里的[weakSelf method],method方法就不会被执行,如果有返回值的话,会返回nil.如果Block里有这样的代码:[arrM addObject:nil],是会崩溃的.所以,如何让block在执行时,self不销毁?</p>
<p>解决办法就是:在block代码块里第一行将weakSelf赋值给一个strong类型指针变量,通常是<code>__strong typeof(weakSelf) strongSelf = weakSelf;</code>.有了strongSelf这样一个强引用指针,以后的代码执行时,便不会出现self==nil的情况,且当block执行完后,局部变量strongSelf清除,self对象被释放.一切看起来似乎很完美.但是如果在<br>__strong typeof(weakSelf) strongSelf = weakSelf;<br>执行之前,self就已经销毁,那么strongSelf将等于nil.上面的崩溃还是会发生.所以必须判断一下strongSelf是否为nil.</p>
<p>综上完整的写法应该如下:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="type">void</span> (^success)(<span class="type">id</span> data, <span class="built_in">NSString</span> *statusInfo) = ^(<span class="built_in">NSArray</span> *data, <span class="built_in">NSString</span> *statusInfo) &#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;block回调了,strongSelf:%@&quot;</span>, strongSelf); </span><br><span class="line">    <span class="built_in">NSString</span> *sd = [strongSelf printSomething]; <span class="comment">//  如果没有前面的判断,这里有可能会因为strongSelf==nil,而导致返回值为nil.从而后面的[mA addObject:sd];会崩溃.</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mA = [[<span class="built_in">NSMutableArray</span> alloc] initWithArray:data];</span><br><span class="line">    [mA addObject:<span class="string">@&quot;dsfds&quot;</span>];</span><br><span class="line">    [mA addObject:sd];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, mA);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, statusInfo);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考1:在Block里写<code>__strong typeof(weakSelf) strongSelf = weakSelf;</code>会不会导致self-Block引用循环?</p>
</blockquote>
<p>答案是不会的,因为strongSelf是Block代码块里定义的一个局部变量,当Block执行完后,局部变量就会销毁,这样就不会有强引用的指针指向self对象.self与Block之间也就不会形成一个引用循环.</p>
<blockquote>
<p>思考2:是不是Block里只能使用weakSelf,不能使用self?</p>
</blockquote>
<p>这个并不是绝对的,使用weakSelf当然是不会有问题的.而如果self不持有Block,那么即使Block里使用self,也不会形成self-Block引用循环,这种情况下在Block里直接使用self也是没有问题的,只不过此时self对象的销毁将依赖于Block的销毁,换句话说就是self对象的生命周期可能会被延长.  </p>
<p>举个例子:<br>vcB里有一个实例变量指向C对象,vcB里用该实例变量调用C类里的方法,参数block代码块里直接使用self(即vcB对象).</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecondViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Animal *myAni;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SecondViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.myAni = [Animal new];</span><br><span class="line">    <span class="type">void</span> (^blk)(Animal *aAnimal) = ^(Animal *aAnimal) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, aAnimal);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self:%@&quot;</span>, <span class="keyword">self</span>); <span class="comment">//Block截获self.</span></span><br><span class="line">    &#125;;</span><br><span class="line">    [<span class="keyword">self</span>.myAni printHello:blk];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)printHello:(<span class="type">void</span>(^)(Animal *aAnimal))paramBlk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="type">void</span> (^blk)(Animal *aAnimal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)printHello:(<span class="type">void</span> (^)(Animal *))paramBlk</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    self.blk = paramBlk;   </span></span><br><span class="line">    paramBlk(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@销毁&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>他们之间的关系就如下图所示,vcB持有C对象,参数block持有vcB对象,从下图可以看出并没有构成一个循环引用,所以虽然在block里直接使用self,但却并没有什么问题.</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/1503319-bc529d12b861570e.webp" style="zoom: 50%;" /></p>
<p>但是如果C类里有个block实例变量,指向了该参数block,那么将导致循环引用.</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>OC block基本操作--Block的声明、赋值与调用</title>
    <url>/2017/12/03/OC%20block%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C--Block%E7%9A%84%E5%A3%B0%E6%98%8E%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Block的声明、赋值与调用"><a href="#Block的声明、赋值与调用" class="headerlink" title="Block的声明、赋值与调用"></a>Block的声明、赋值与调用</h3><h4 id="Block变量的声明"><a href="#Block变量的声明" class="headerlink" title="Block变量的声明"></a>Block变量的声明</h4><p>和C语言的函数指针声明几乎一样,只是将”*”改为”^”.如下:</p>
<p><code>返回值类型</code> <code>(^变量名称)</code> <code>(变量类型 变量1, 变量类型 变量2, ...)</code></p>
<p>例:int (^blkVar)(int a, int b);</p>
<h4 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h4><p>一个Block语法代表一个Block类型变量的值.它的写法和C语言函数的定义很像.仅有两点区别:</p>
<ul>
<li>没有函数名.</li>
<li>在返回值前面加上”^”. </li>
</ul>
<p><code>^</code> <code>返回值</code> <code>(变量类型 变量1, 变量类型 变量2, ...)</code> <code>&#123;... return xx;&#125;</code>. </p>
<p>例:^int (int a, int b){… return 3;}.</p>
<p>Block作为函数参数在C语言里的写法和OC里的写法略有不同.如下:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OC方法</span></span><br><span class="line">- (<span class="built_in">int</span>)addFunc:(<span class="built_in">int</span>(^)(<span class="built_in">int</span> a, <span class="built_in">int</span> b))blkParam :(<span class="built_in">int</span>)addA :(<span class="built_in">int</span>)addB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = blkParam(addA, addB);</span><br><span class="line">    printf(<span class="string">&quot;rs:%d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C函数</span></span><br><span class="line"><span class="built_in">int</span> addFunc(<span class="built_in">int</span> (^blkParam)(<span class="built_in">int</span> a , <span class="built_in">int</span> b), <span class="built_in">int</span> addA, <span class="built_in">int</span> addB)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = blkParam(addA, addB);</span><br><span class="line">    printf(<span class="string">&quot;rs:%d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Block的调用"><a href="#Block的调用" class="headerlink" title="Block的调用"></a>Block的调用</h4><p><code>blk变量(参数1, 参数2, ...);</code></p>
<p>一个比较古怪的Block调用:直接对Block语法调用.</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> aa = ^<span class="keyword">int</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        NSLog(@<span class="string">&quot;<span class="variable">%d</span>&quot;</span>,c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">NSLog(@<span class="string">&quot;aa=<span class="variable">%d</span>&quot;</span>,aa);</span><br></pre></td></tr></table></figure>
<p>很早之前刚接触block的时候,总是在想Block里的代码到底啥时候执行.原来就是block什么时候被调用,什么时候就被执行.</p>
<p>Block也相当于一种变量类型。就像int一样，可以用来定义对应类型的变量。<br>因此</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">[p printWithBlcok:^ViewController *(<span class="built_in">int</span> <span class="built_in">num</span>) &#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;num*cc:%i * %i = %i&quot;</span>,<span class="built_in">num</span>,cc,<span class="built_in">num</span> *cc);</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>里面的printWithBlcok:后的就是一个Block语法(也就是一个Block类型的变量的值)。在这里它作为函数的第一个参数。因此对对象p发送printWithBlcok:消息，将执行该方法的代码，该方法的第一行代码就是调用Block，因此又转而去执行Block中的代码，执行完后，再回到printWithBlcok:方法中，然后继续执行下去。</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift String基本操作</title>
    <url>/2017/11/26/Swift%20String%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Swift-String基本操作"><a href="#Swift-String基本操作" class="headerlink" title="Swift String基本操作"></a>Swift String基本操作</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建字符串  </span></span><br><span class="line">let s1: String = <span class="string">&quot;dsfdsf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s1 &#123;</span><br><span class="line">	<span class="built_in">print</span>(char)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line">let s2 = <span class="string">&quot;dasdfds&quot;</span></span><br><span class="line">let s3 = s1 + s2</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(s3)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算字符串长度</span></span><br><span class="line">let length: Int = s3<span class="selector-class">.count</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;长度:\(length)&quot;</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个字符串是否为空</span></span><br><span class="line">let rs1 = s3<span class="selector-class">.isEmpty</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;是否为空:\(rs1)&quot;</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个字符串转换为大/小写</span></span><br><span class="line">let s4: String = <span class="string">&quot;fsdfdsfsd&quot;</span></span><br><span class="line">let s5 = s4<span class="selector-class">.uppercased</span>() <span class="comment">//返回一个大写的字符串,原字符串不受影响</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;s4:\(s4)&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;s5:\(s5)&quot;</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串截取.字符串截取需要使用String.Index中介</span></span><br><span class="line">let s7: String = <span class="string">&quot;dasd3243232423sfsfdsf13&quot;</span></span><br><span class="line"><span class="comment">//截取前4个字符</span></span><br><span class="line">let s8: Substring = s7<span class="selector-class">.prefix</span>(<span class="number">4</span>) <span class="comment">//返回的是一个Substring类型,因此不能赋值给一个String类型的变量,如果要赋值给lable,需要转换为String类型</span></span><br><span class="line">let <span class="selector-tag">label</span> = UILabel<span class="selector-class">.init</span>()</span><br><span class="line"><span class="selector-tag">label</span><span class="selector-class">.text</span> = String<span class="selector-class">.init</span>(s8) </span><br><span class="line"></span><br><span class="line"><span class="comment">//String和Substring可以直接相加操作,编译器已经做了强制转换.</span></span><br><span class="line">let s9: String = s7 + s8</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取后5个字符</span></span><br><span class="line">let s10: Substring = s7<span class="selector-class">.suffix</span>(<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;s10:\(s10)&quot;</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从第四个(包含)开始截取,截取10个长度的字符</span></span><br><span class="line">let offset4Index: String<span class="selector-class">.Index</span> = s7<span class="selector-class">.index</span>(s7<span class="selector-class">.startIndex</span>, offsetBy: <span class="number">4</span>)</span><br><span class="line">let dest14Index = s7<span class="selector-class">.index</span>(offset4Index, offsetBy: <span class="number">10</span>) <span class="comment">//注意:起点+长度不能越界.</span></span><br><span class="line">let s11: Substring = s7<span class="selector-attr">[offset4Index..&lt;dest14Index]</span> <span class="comment">//返回的是一个Substring类型,因此不能赋值给一个String类型的变量. &quot;..&lt;&quot;表示包含左边,但不包含右边,&quot;...&quot;表示闭区间,两边都包含.</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;s11:\(s11)&quot;</span>)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除最后一个字符.被操作的字符串不能为空字符串.</span></span><br><span class="line"><span class="selector-tag">var</span> s12: String = <span class="string">&quot;sfdsfds&quot;</span></span><br><span class="line">s12<span class="selector-class">.removeLast</span>()</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;s12:\(s12)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>UIScrollView代理方法</title>
    <url>/2017/12/11/UIScrollView%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>将要开始发生拖拽.<br><code>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView</code></p>
<p>将要结束拖拽,velocity:结束时的速度;targetContentOffset:想要滚动到的指定位置.(使用该方法可以让UIScrollView停在我们想要的地方)<br><code>- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset</code></p>
<p>拖拽结束,decelerate=YES:表明拖拽结束的时候,scrollView还有速度,将会减速滑动一段距离,最终停止时会回调scrollViewDidEndDecelerating方法;=NO:表明拖拽结束,scrollView也随即停止,此时不会再回调scrollViewDidEndDecelerating方法.<br><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</code></p>
<p>已经结束减速.表明滚动停止.只有在停止前有速度的时候才会被回调.<br><code>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView</code></p>
<p>已经滚动.scrollView处于滚动状态时,该方法会被频繁调用,因此该方法里面不应该有太复杂的处理.动画scrollToItemAtIndexPath:atScrollPosition:animated:;并不会使该代理方法调用.<br><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</code></p>
<p>called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating. 因为动画原因滚动结束.<br><code>- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView</code></p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title>响应者链</title>
    <url>/2017/12/13/%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/</url>
    <content><![CDATA[<h4 id="响应者对象"><a href="#响应者对象" class="headerlink" title="响应者对象"></a>响应者对象</h4><p>响应者对象（Responder Object）指的是有响应和处理事件能力的对象。A responder object is any instance of the UIResponder class, and common subclasses include UIView, UIViewController, and UIApplication. UIResponder是所有响应者对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的AppDelegate、UIApplication、 UIViewController、UIWindow和所有继承自UIView的UIKit类都直接或间接的继承自UIResponder，所以它们的实例都是可以构成响应者链的响应者对象。</p>
<h4 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h4><p>响应者链就是由一系列的响应者对象构成的一个层次结构。UIResponder对象能够接收触摸事件（其子类当然也能够）。每一个UIResponder对象都有一个指针nextResponder,然后这些链接在一起的对象就组成了响应者链。</p>
<h4 id="系统是如何找到第一响应者的"><a href="#系统是如何找到第一响应者的" class="headerlink" title="系统是如何找到第一响应者的"></a>系统是如何找到第一响应者的</h4><p>当用户点击了某个视图.系统是如何找到用户点击的视图呢?</p>
<p>答案就是对视图进行hitTest.</p>
<p>官方文档:</p>
<p>UIKit uses view-based hit testing to determine where touch events occur. Specifically, UIKit compares the touch location to the bounds of view objects in the view hierarchy. The hitTest:withEvent: method of UIView walks the view hierarchy, looking for the deepest subview that contains the specified touch. That view becomes the first responder for the touch event.</p>
<p>注意:If a touch location is outside of a view’s bounds, the hitTest:withEvent: method ignores that view and all of its subviews. As a result, when a view’s clipsToBounds property is NO, subviews outside of that view’s bounds are not returned even if they happen to contain the touch.</p>
<p>相关API:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">hitTest</span>(<span class="keyword">_</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">UIView</span>? <span class="comment">// recursively calls -pointInside:withEvent:. point is in the receiver&#x27;s coordinate system</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">point</span>(<span class="params">inside</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">Bool</span> <span class="comment">// default returns YES if point is in bounds</span></span><br></pre></td></tr></table></figure>
<p>举个例子:界面如下:</p>
<p>下面的视图为XQ1View,上面有三个子视图分别为XQ10View,XQ11View,XQ12View。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2023-03-29%2016.43.47.png" style="zoom:50%;" /></p>
<h5 id="当用户点击了XQ11View-系统是如何找到它的"><a href="#当用户点击了XQ11View-系统是如何找到它的" class="headerlink" title="当用户点击了XQ11View,系统是如何找到它的?"></a>当用户点击了XQ11View,系统是如何找到它的?</h5><p>具体来说就是:<br>系统会对XQ1View(也就是XQ11View的父视图),发送一条hitTest消息, hitTest会调用pointInside方法.如果XQ1View的pointInside方法返回false则XQ1View的子视图不会被hitTest,XQ1View的hitTest将返回nil,本次hitTest就结束了.若返回true,那么系统将对XQ1View的子视图数组进行一个反向遍历的hitTest检测.因此首先检测的是XQ12View.由于用户实际点击的是XQ11View,所以XQ12View的pointInside会返回false,XQ12View的hitTest将返回nil.接下来将对XQ11View进行hitTest检测,hitTest会调用pointInside方法,而用户恰好点击的是XQ11View,因此pointInside方法返回true,由于XQ11View没有子视图了,因此XQ11View的hitTest将返回自己.hitTest检测结束.于是就找到了.XQ1View的hitTest也将返回XQ11View.可以推断出系统最先是对UIWindow进行hitTest检测的.因此UIWindow的hitTest也将返回XQ11View.于是系统就拿到了第一响应者XQ11View.拿到之后系统会尝试让XQ11View处理事件.接下来就是事件在响应者链中传递了.</p>
<h5 id="如果点击XQ12View超出它父视图的那部分-也让它能够响应事件-该如何实现呢"><a href="#如果点击XQ12View超出它父视图的那部分-也让它能够响应事件-该如何实现呢" class="headerlink" title="如果点击XQ12View超出它父视图的那部分,也让它能够响应事件,该如何实现呢?"></a>如果点击XQ12View超出它父视图的那部分,也让它能够响应事件,该如何实现呢?</h5><p>通过上面的分析,可以知道必须想办法让它的父视图的pointInside返回true.否则都不会对XQ12View进行hitTest检测.实现如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XQ1View</span>: <span class="title class_ inherited__">XQView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">point</span>(<span class="params">inside</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rs <span class="operator">=</span> <span class="keyword">super</span>.point(inside: point, with: event)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>rs &#123;</span><br><span class="line">            <span class="keyword">for</span> subView <span class="keyword">in</span> subviews.reversed() &#123;</span><br><span class="line">                <span class="keyword">let</span> subPoint <span class="operator">=</span> subView.convert(point, from: <span class="keyword">self</span>)</span><br><span class="line">                <span class="keyword">if</span> subView.bounds.contains(subPoint) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:对一个视图进行hitTest前,系统还会有很多判断比如会忽略隐藏(hidden=YES)的视图，禁止用户操作 (userInteractionEnabled=YES)的视图，以及alpha级别小于0.01(alpha&lt;0.01)的视图。这些视图都不会被hitTest检测.</p>
<h4 id="事件是如何在响应者链中传递的"><a href="#事件是如何在响应者链中传递的" class="headerlink" title="事件是如何在响应者链中传递的"></a>事件是如何在响应者链中传递的</h4><p>官方解释:<br>If the text field does not handle an event, UIKit sends the event to the text field’s parent UIView object, followed by the root view of the window. From the root view, the responder chain diverts to the owning view controller before returning to the view’s window.If the window does not handle the event, UIKit delivers the event to the UIApplication object, and possibly to the app delegate if that object is an instance of UIResponder and not already part of the responder chain.</p>
<p>当用户点击了text field,期间会经历那些过程呢?</p>
<p>首先系统会去找第一响应者,找的过程就是上面所述,这里就是text field.找到了第一响应者,那么事件将优先由第一响应者处理.如果text field不处理,那么UIKit会将事件发送给text field的父视图.如果它的父视图也不处理则事件将会沿着响应者链一直往上传递(如果View是作为viewController的根视图,那么该View的next responder将是UIViewController),当传递给UIWindow对象时,如果window也不处理,则事件将传递给UIApplication.UIApplication可能会传给app delegate,前提是app delegate是UIResponder实例,需要注意的是app delegate已经不是响应者链里的一部分了.</p>
<p>一般来说工程的app delegate都是UIResponder实例,所以当AppDelegate也不处理时,那么就再也没有机会处理了,事件将被系统丢弃.</p>
<p>期间只要有一个响应者对象处理了该事件.系统默认将不再传递给next responder,本次事件就算处理成功.</p>
<h4 id="变更响应者链"><a href="#变更响应者链" class="headerlink" title="变更响应者链"></a>变更响应者链</h4><p>You can alter the responder chain by overriding the nextResponder property of your responder objects. Many UIKit classes already override this property and return specific objects.</p>
<p>If you override the nextResponder property for any class, the next responder is the object you return.</p>
<p>几种类型对象的默认nextResponder.</p>
<ol>
<li><p>UIView</p>
<p> If the view is the root view of a view controller, the next responder is the view controller.</p>
<p> If the view is not the root view of a view controller, the next responder is the view’s superview.</p>
</li>
<li><p>UIViewController</p>
<p> If the view controller’s view is the root view of a window, the next responder is the window object.</p>
<p> If the view controller was presented by another view controller, the next responder is the presenting view controller.</p>
<p> (xq注:举例,UINavigationController的根视图控制器vcA点击按钮,跳转到vcB,那么vcB的nextResponder是UIViewControllerWrapperView-&gt;UINavigationTransitionView-&gt;UILayoutContainerView-&gt;UINavigationController,UINavigationController的根视图类型确实是UILayoutContainerView,忽略中间三个系统类,那么vcB的nextResponder就是UINavigationController.注意不是vcA)</p>
</li>
<li><p>UIWindow. The window’s next responder is the application object.</p>
</li>
<li><p>UIApplication. The app object’s next responder is the app delegate, but only if the app delegate is an instance of UIResponder and is not a view, view controller, or the app object itself.</p>
</li>
</ol>
<p>如何把消息发送给next responder？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (touch.tapCount == <span class="number">2</span>) &#123;</span><br><span class="line">        [[<span class="keyword">self</span> nextResponder] touchesBegan:touches withEvent:event];<span class="comment">//这里最好写[self nextResponder]而不是写super</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... Go on to handle touches that are not <span class="type">double</span> taps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIResponder</tag>
      </tags>
  </entry>
  <entry>
    <title>OC MRC之旅</title>
    <url>/2018/02/25/OC%20MRC%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h2 id="OC-MRC之旅"><a href="#OC-MRC之旅" class="headerlink" title="OC MRC之旅"></a>OC MRC之旅</h2><p>先来个例子,计算一下People对象的引用计数.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    People *p = [[People alloc] init]; <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    People *p1 = [p <span class="keyword">retain</span>]; <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    [p release]; <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    [p1 <span class="keyword">retain</span>]; <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;p:%ld&quot;</span>, [p retainCount]);</span><br><span class="line">    </span><br><span class="line">    People *p2 = p;</span><br><span class="line">    p2.firstName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%d算法&quot;</span>, <span class="number">2</span>];</span><br><span class="line">    p2.lastName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%d算法&quot;</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, p2.firstName);</span><br><span class="line">    </span><br><span class="line">    [p2 release]; <span class="comment">//</span></span><br><span class="line">    [p2 release]; <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是: 1 2 1 2 1 0.</p>
<p>注意:指针只是让我们能够访问该对象.p,p1,p2指向的是同一个对象,因此上面的retain,release操作的也是同一个对象.</p>
<p>再来看一下People类:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">People</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">People</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [_firstName release];</span><br><span class="line"><span class="comment">//    [_lastName release];</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;_firstName:%ld&quot;</span>, [_firstName retainCount]); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;_lastName:%ld&quot;</span>, [_lastName retainCount]); <span class="comment">//2</span></span><br><span class="line">    </span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setFirstName:(<span class="built_in">NSString</span> *)firstName</span><br><span class="line">&#123;</span><br><span class="line">    [firstName <span class="keyword">retain</span>];</span><br><span class="line">    [_firstName release];</span><br><span class="line">    _firstName = firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果将上面的<code>[_lastName release];</code>注释掉那么将会导致内存泄漏.为什么会导致这种情况呢?虽然<code>p2.lastName = [NSString stringWithFormat:@&quot;%d算法&quot;, 3];</code>是一个注册到自动释放池的对象,但是由于lastName属性是retain,因此赋值时该字符串对象引用计数会被加1,因此需要在People对象销毁时,释放lastName字符串对象.<br><strong>在MRC环境下,对象销毁时一般需要对自身的属性进行释放.</strong></p>
<p>继续查看在People对象销毁时,<code>_firstName</code>和<code>_lastName</code>的引用计数情况,打印显示<code>_firstName</code>的为1,<code>_lastName</code>的为2.<br>为啥在People的-dealloc方法中<code>_firstName</code>的引用计数不为0却是1呢?<br>这是因为自动释放池还没有被释放,所以它里面注册的对象也还没有被释放故<code>_firstName</code>为1.而<code>_lastName</code>的则为2.</p>
<p>注意:一个对象能够被放到同一个池子中许多次，在这种情况下每放一次都会收到一个 release 消息。</p>
<p>如果你觉得到这里就结束了,那就too young.有一个问题似乎还不是很明朗,那就是自动释放池里的对象什么时候释放?官方文档告诉我们在@autorelease{…}块的结尾处,自动释放池会被drain,里面的对象将被释放.但是纵观上述代码并没有看到一个autorelease块.之所以没有看到是由于我们处于主线程中,而主线程的runloop默认是开启的,你可能会奇怪怎么一个自动释放池还扯到线程和runloop上去了.事实上,自动释放池,线程,runloop有着密切的联系.</p>
<p>那么<strong>主线程中的自动释放池又是什么时候创建，什么时候销毁呢?</strong><br>官方文档又告诉我们:Application Kit会在事件循环的每个循环开始时在主线程上创建一个自动释放池，并在循环结束时drains它，从而释放处理事件时生成的任何自动释放对象。 如果您使用Application Kit，则通常不需要创建自己的池。 但是，如果您的应用程序在事件循环中创建了大量临时自动释放对象，那么创建“本地”自动释放池以帮助最大限度地减少峰值内存占用可能会有所帮助。<br>官方文档总是这么简洁,让人琢磨半天.让俺来解释一下:主线程的runloop默认是开启的,runloop虽然也是一个循环但是他和普通循环有着很大的区别,runloop会让线程在有事干的时候干事,没事干的时候使线程休眠.runloop又是如何知道有事情干了呢?这就是我们事先为runloop添加的各种源.有点扯远了,再扯下去估计要跑题了.所以这里我们暂时不管runloop是如何得知的,反正runloop就是知道了.当程序启动,用户点击屏幕等runloop都会去处理这些事件.处理之前主线程的runloop就会先创建一个自动释放池,等到处理完成时就将自动释放池drain,里面的对象就会被释放,事件处理完毕runloop就退出了,不用担心系统会再次驱动进入runloop.因此如果在事件循环中创建了大量临时自动释放对象,则必须自己手动创建一个自动释放池.否则想等到事件处理完毕让系统来drain,内存可能早就耗尽了,你的APP也就歇菜了.好在自己创建并不麻烦,<code>@autorelease&#123;...&#125;</code>即可.</p>
<p>今天的MRC之旅就到这里.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html">Advanced Memory Management Programming Guide</a></p>
<p><a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=occ">NSAutoreleasePool</a></p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>使用reduce模拟实现map和filter</title>
    <url>/2018/01/26/%E4%BD%BF%E7%94%A8reduce%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0map%E5%92%8Cfilter/</url>
    <content><![CDATA[<h3 id="使用reduce模拟实现map和filter"><a href="#使用reduce模拟实现map和filter" class="headerlink" title="使用reduce模拟实现map和filter"></a>使用reduce模拟实现map和filter</h3><p>首先看一下系统的map和filter功能:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fbArr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mmp = fbArr.<span class="keyword">map</span> &#123; <span class="function"><span class="params">(item)</span> -&gt;</span> Int <span class="keyword">in</span></span><br><span class="line">    item + item</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(mmp)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> cmp = fbArr.filter &#123; <span class="function"><span class="params">(item)</span> -&gt;</span> Bool <span class="keyword">in</span></span><br><span class="line">    item &gt; <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(cmp)</span><br></pre></td></tr></table></figure>
<p>打印如下:</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[2, 2, 4, 6, 10, 16, 26, 42]</span></span><br><span class="line"><span class="string">[8, 13, 21]</span></span><br></pre></td></tr></table></figure>
<p>使用reduce模拟实现map和filter:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">	func map2&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; <span class="selector-attr">[T]</span> &#123;</span><br><span class="line">        <span class="comment">//初始值为空数组, 数组+数组</span></span><br><span class="line">        return <span class="built_in">reduce</span>([], &#123; (result, item) -&gt; <span class="selector-attr">[T]</span> in</span><br><span class="line">            return result + <span class="selector-attr">[transform(item)]</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//简化一下</span></span><br><span class="line">        return <span class="built_in">reduce</span>([], &#123;</span><br><span class="line">            $<span class="number">0</span> + [transform($<span class="number">1</span>)]</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//再简化一下</span></span><br><span class="line">        return <span class="built_in">reduce</span>([]) &#123; $<span class="number">0</span> + <span class="selector-attr">[transform($1)]</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func <span class="built_in">filter2</span>(_ filter: (Element) -&gt; Bool) -&gt; <span class="selector-attr">[Element]</span> &#123;</span><br><span class="line">        return <span class="built_in">reduce</span>([], &#123; (result, item) -&gt; <span class="selector-attr">[Element]</span> in</span><br><span class="line">            return <span class="attribute">filter</span>(item) ? result + <span class="selector-attr">[item]</span> : result</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//简化一下</span></span><br><span class="line">        return <span class="built_in">reduce</span>([]) &#123; <span class="attribute">filter</span>($<span class="number">1</span>) ? $<span class="number">0</span> + <span class="selector-attr">[$1]</span> : $<span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说实话,Swift对闭包的简写有时候感觉有点过了,初次看到这样的写法<code>reduce([]) &#123; filter($1) ? $0 + [$1] : $0 &#125;</code>,有时还得缓缓才知道是啥意思.</p>
<p>使用:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ammp = fbArr.map2 &#123; <span class="function"><span class="params">(item)</span> -&gt;</span> Int <span class="keyword">in</span></span><br><span class="line">    item + item</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(ammp)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> bm = fbArr.filter2 &#123; <span class="function"><span class="params">(item)</span> -&gt;</span> Bool <span class="keyword">in</span></span><br><span class="line">    item &gt; <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(bm)</span><br></pre></td></tr></table></figure>
<p>打印如下:</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[2, 2, 4, 6, 10, 16, 26, 42]</span></span><br><span class="line"><span class="string">[8, 13, 21]</span></span><br></pre></td></tr></table></figure>
<p>虽然仅使用reduce就可以做到map和filter的功能,但是随着数组的增长,复杂度会很大.</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift Array基本操作</title>
    <url>/2017/12/01/Swift%20Array%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Swift-Array基本操作"><a href="#Swift-Array基本操作" class="headerlink" title="Swift Array基本操作"></a>Swift Array基本操作</h2><p>Array使用了copy-on-write技术.Array是结构体类型,因此是值类型.和OC里的NSArray引用类型是不同的.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">let</span> arr1: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;213&quot;</span>, <span class="string">&quot;fdsf&quot;</span>, <span class="string">&quot;sdfdsg&quot;</span>]  <span class="comment">//let定义的是常量,所以arr1不能再进行append操作.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//追加元素</span></span><br><span class="line"><span class="comment">//追加一个元素</span></span><br><span class="line"><span class="keyword">var</span> arr2: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;llllfs&quot;</span>, <span class="string">&quot;dqafas&quot;</span>, <span class="string">&quot;21231&quot;</span>]</span><br><span class="line">arr2 <span class="operator">+=</span> [<span class="string">&quot;sfsdfsd&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr2:<span class="subst">\(arr2)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> arr3: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> arr2</span><br><span class="line">arr3.append(<span class="string">&quot;hhehehe&quot;</span>)  <span class="comment">//append()会改变自身的值.但arr2的值并不会改变,和OC不一样.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr2:<span class="subst">\(arr2)</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr3:<span class="subst">\(arr3)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//追加一个数组的元素</span></span><br><span class="line">arr3.append(contentsOf: [<span class="string">&quot;sfsdf&quot;</span>, <span class="string">&quot;dfsfds&quot;</span>, <span class="string">&quot;dgfdg&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr3:<span class="subst">\(arr3)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> arr4: <span class="type">Array</span>&lt;<span class="type">People</span>&gt; <span class="operator">=</span> [<span class="type">People</span>]()</span><br><span class="line"><span class="keyword">for</span> index: <span class="type">UInt</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">4</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">People</span>.<span class="keyword">init</span>(name: <span class="string">&quot;渣渣辉<span class="subst">\(index)</span>&quot;</span>, sex: <span class="literal">true</span>, age: index <span class="operator">*</span> <span class="type">UInt</span>(arc4random()<span class="operator">%</span><span class="number">20</span>))</span><br><span class="line">    arr4.append(p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr4:<span class="subst">\(arr4)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除元素</span></span><br><span class="line"><span class="keyword">var</span> arr5: <span class="type">Array</span> <span class="operator">=</span> arr4</span><br><span class="line"><span class="comment">//移除最后一个元素</span></span><br><span class="line">arr5.removeLast() <span class="comment">//改变自身.被操作的数组不能为空.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr5:<span class="subst">\(arr5)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除元素,原数组不受影响,得到一个类型为ArraySlice的新数组.</span></span><br><span class="line"><span class="keyword">var</span> arr6: <span class="type">Array</span> <span class="operator">=</span> <span class="type">Array</span>.<span class="keyword">init</span>(arr5.dropLast()) <span class="comment">//ArraySlice转Array</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr5:<span class="subst">\(arr5)</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr6:<span class="subst">\(arr6)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> arr7: <span class="type">ArraySlice</span> <span class="operator">=</span> <span class="type">ArraySlice</span>.<span class="keyword">init</span>(arr4)  <span class="comment">//Array转ArraySlice</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某个范围里的元素</span></span><br><span class="line"><span class="keyword">var</span> arr8: <span class="type">Array</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arr8.removeSubrange(<span class="number">1</span><span class="operator">...</span>) <span class="comment">//移除从第1个位置处开始一直到末尾的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr8:<span class="subst">\(arr8)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> arr9: <span class="type">Array</span> <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line">arr9.removeSubrange(<span class="number">1</span><span class="operator">...</span>) <span class="comment">//如果数组只有一个元素,但移除从第一个位置处的元素并不会越界崩溃.但是移除从第二个位置处的元素将会导致越界崩溃</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr9:<span class="subst">\(arr9)</span>&quot;</span>) <span class="comment">//arr9:[1]</span></span><br><span class="line"><span class="keyword">var</span> arr10: <span class="type">Array</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arr10.removeSubrange(<span class="number">1</span><span class="operator">...</span><span class="number">3</span>) <span class="comment">//移除从第1个位置处开始随后的3个元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr10:<span class="subst">\(arr10)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> arr11: <span class="type">Array</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arr11.removeSubrange(<span class="number">1</span><span class="operator">..&lt;</span><span class="number">3</span>) <span class="comment">//移除从第1个位置处开始随后的2个元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr11:<span class="subst">\(arr11)</span>&quot;</span>)</span><br><span class="line"><span class="comment">//便捷操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">removeLast</span>(<span class="keyword">_</span> <span class="params">n</span>: <span class="type">Int</span>) <span class="comment">//移除后几个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">removeFirst</span>(<span class="keyword">_</span> <span class="params">n</span>: <span class="type">Int</span>) <span class="comment">//移除前几个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">at</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Array</span>.<span class="type">Element</span> <span class="comment">//移除指定某个位置的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">removeAll</span>(<span class="params">keepingCapacity</span> <span class="params">keepCapacity</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="keyword">default</span>) <span class="comment">//移除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tanwanlanyue <span class="operator">=</span> [<span class="string">&quot;渣渣辉&quot;</span>, <span class="string">&quot;纯扰春&quot;</span>, <span class="string">&quot;咕天落&quot;</span>, <span class="string">&quot;森红雷&quot;</span>]</span><br><span class="line"><span class="comment">//“迭代除了第一个元素以外的数组其余部分”</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> tanwanlanyue.dropFirst() &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“迭代除了最后 1 个元素以外的数组”</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> tanwanlanyue.dropLast() &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“遍历数组中的元素和对应的下标”</span></span><br><span class="line"><span class="keyword">for</span> (index, element) <span class="keyword">in</span> tanwanlanyue.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(index, element)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“寻找一个指定元素的位置”</span></span><br><span class="line"><span class="keyword">let</span> idx <span class="operator">=</span> tanwanlanyue.index(of: <span class="string">&quot;咕天落&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> i: <span class="type">Int</span> <span class="operator">=</span> idx<span class="operator">!</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">//使用Where闭包</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> tanwanlanyue.index &#123;</span><br><span class="line">    <span class="variable">$0</span> <span class="operator">==</span> <span class="string">&quot;纯扰春&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> j: <span class="type">Int</span> <span class="operator">=</span> index<span class="operator">!</span> <span class="operator">+</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(j)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> sidx <span class="operator">=</span> tanwanlanyue.index(where: &#123; (item) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    item.hasSuffix(<span class="string">&quot;落&quot;</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(sidx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> didx <span class="operator">=</span> tanwanlanyue.index(where: &#123; (element) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> element.hasPrefix(<span class="string">&quot;渣渣&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(didx)</span><br><span class="line"><span class="comment">//“对数组中的所有元素进行变形,得到一个新数组”</span></span><br><span class="line"><span class="keyword">let</span> tan2 <span class="operator">=</span> tanwanlanyue.map &#123; (item) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> idx <span class="operator">=</span> tanwanlanyue.index(of: item)</span><br><span class="line">    <span class="keyword">return</span> item <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(idx<span class="operator">!</span>)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(tan2)</span><br><span class="line"><span class="comment">//“筛选出符合某个标准的元素,得到一个新数组”</span></span><br><span class="line"><span class="keyword">let</span> tan3 <span class="operator">=</span> tan2.filter &#123; (item) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> ch <span class="operator">=</span> item.last<span class="operator">!</span></span><br><span class="line">    <span class="keyword">return</span> ch <span class="operator">&gt;</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(tan3)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Paula&quot;</span>, <span class="string">&quot;Elena&quot;</span>, <span class="string">&quot;Zoe&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> lastNameEndingInA: <span class="type">String</span>?</span><br><span class="line"><span class="comment">//(for in) + where条件,仅遍历符合条件的元素</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.reversed() <span class="keyword">where</span> name.hasSuffix(<span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">    lastNameEndingInA <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(lastNameEndingInA)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.reversed() <span class="keyword">where</span> name.hasSuffix(<span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> last <span class="operator">=</span> names.last &#123; <span class="variable">$0</span>.hasSuffix(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(last)</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">略.</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">略.</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转</span></span><br><span class="line">略.</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Paula&quot;</span>, <span class="string">&quot;Elena&quot;</span>, <span class="string">&quot;Zoe&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> lastNameEndingInA: <span class="type">String</span>?</span><br><span class="line"><span class="comment">//(for in) + where条件:仅遍历符合条件的元素</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.reversed() <span class="keyword">where</span> name.hasSuffix(<span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">    lastNameEndingInA <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(lastNameEndingInA)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.reversed() <span class="keyword">where</span> name.hasSuffix(<span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swfit提供了三种类型的数组:</p>
<ul>
<li><p>public struct ContiguousArray<Element> : RandomAccessCollection, MutableCollection</p>
</li>
<li><p>public struct ArraySlice<Element> : RandomAccessCollection, MutableCollection</p>
</li>
<li><p>public struct Array<Element> : RandomAccessCollection, MutableCollection</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>OC Category浅析</title>
    <url>/2018/01/19/Category/</url>
    <content><![CDATA[<p>category用结构体category_t表示（在objc-runtime-new.h中可以找到此定义）:</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">category_t</span> &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t <span class="keyword">cls</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">protocol_list_t</span> *protocols;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">property_list_t</span> *instanceProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而类的结构体:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_ivar_list</span> * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_method_list</span> * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_cache</span> * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_protocol_list</span> * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>
<p>MyClass.h</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">MyClass </span>: NSObject</span><br><span class="line"></span><br><span class="line">- (void)printName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="built_in">MyClass</span>(MyAddition)</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">printName</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>
<p>MyClass.m</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)printName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, <span class="string">@&quot;MyClass&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>(<span class="title">MyAddition</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)printName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, <span class="string">@&quot;MyAddition&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>转换为.cpp文件:<code>clang -rewrite-objc MyClass.m</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="comment">/*_method_list_t*/</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> method_count;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_objc_method</span> method_list[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line">	<span class="built_in">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">&quot;printName&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="type">void</span> *)_I_MyClass_MyAddition_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="comment">/*_prop_list_t*/</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count_of_properties;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_prop_t</span> prop_list[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line">	<span class="built_in">sizeof</span>(<span class="type">_prop_t</span>),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;T@\&quot;NSString\&quot;,C,N&quot;</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="keyword">struct</span> <span class="title class_">_class_t</span> OBJC_CLASS_$_MyClass;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">_category_t</span> _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;MyClass&quot;</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_MyClass,</span></span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(<span class="type">void</span> ) &#123;</span><br><span class="line">	_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;.objc_inithooks$B&quot;</span>, long, read, write)</span></span><br><span class="line">__declspec(<span class="built_in">allocate</span>(<span class="string">&quot;.objc_inithooks$B&quot;</span>)) <span class="type">static</span> <span class="type">void</span> *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">	(<span class="type">void</span> *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">_class_t</span> *L_OBJC_LABEL_CLASS_$ [<span class="number">1</span>] __attribute__((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;</span>)))= &#123;</span><br><span class="line">	&amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">_category_t</span> *L_OBJC_LABEL_CATEGORY_$ [<span class="number">1</span>] __attribute__((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;</span>)))= &#123;</span><br><span class="line">	&amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">IMAGE_INFO</span> &#123; <span class="type">unsigned</span> version; <span class="type">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>多个category的情况:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> struct _class_t *L_OBJC_LABEL_CLASS_<span class="variable">$</span> <span class="function">[<span class="number">1</span>] __<span class="title">attribute__</span></span>((used, section (<span class="string">&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;</span>)))= &#123;</span><br><span class="line">	&amp;OBJC_CLASS_<span class="variable">$_MyClass</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> struct _category_t *L_OBJC_LABEL_CATEGORY_<span class="variable">$</span> <span class="function">[<span class="number">2</span>] __<span class="title">attribute__</span></span>((used, section (<span class="string">&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;</span>)))= &#123;</span><br><span class="line">	&amp;_OBJC_<span class="variable">$_CATEGORY_MyClass_</span><span class="variable">$_MyAddition1</span>,</span><br><span class="line">	&amp;_OBJC_<span class="variable">$_CATEGORY_MyClass_</span><span class="variable">$_MyAddition2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="category的加载"><a href="#category的加载" class="headerlink" title="category的加载"></a>category的加载</h3><p>先拿到类的类别数组列表[cat1, cat2, cat3],这个数组元素的顺序是根据编译顺序得来.然后倒序拼装得到一个方法数组列表.最后该方法列表再追加类自身的方法.类别加载结束.因此当有方法覆盖时,执行的将是最后一个编译的类别里的方法.</p>
<p>在类和category中都可以有+load方法，那么有两个问题：</p>
<ol>
<li>在类的+load方法调用的时候，我们可以调用category中声明的方法么？</li>
<li>这么些个+load方法，调用顺序是咋样的呢？</li>
</ol>
<p>A:可以调用，因为附加category到类的工作会先于+load方法的执行.</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">objc</span>[<span class="number">20522</span>]: LOAD: category &#x27;MyClass(MyCategory1)&#x27; scheduled for +load</span><br><span class="line"><span class="attribute">objc</span>[<span class="number">20522</span>]: LOAD: category &#x27;MyClass(MyCategory2)&#x27; scheduled for +load</span><br><span class="line"><span class="attribute">objc</span>[<span class="number">20522</span>]: LOAD: +[MyClass(MyCategory1) load]</span><br><span class="line"></span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">01</span>.<span class="number">451</span> categoryDemo[<span class="number">20522</span>:<span class="number">194333</span>] MyCategory1:&lt;MyClass: <span class="number">0</span>x7f9422c01c30&gt;</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">01</span>.<span class="number">452</span> categoryDemo[<span class="number">20522</span>:<span class="number">194333</span>] &lt;MyClass: <span class="number">0</span>x7f9422c01c30&gt;-MyClass,小明</span><br><span class="line"><span class="attribute">objc</span>[<span class="number">20522</span>]: LOAD: +[MyClass(MyCategory2) load]</span><br><span class="line"></span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">01</span>.<span class="number">453</span> categoryDemo[<span class="number">20522</span>:<span class="number">194333</span>] MyCategory2:&lt;MyClass: <span class="number">0</span>x7f9422f00100&gt;</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">01</span>.<span class="number">453</span> categoryDemo[<span class="number">20522</span>:<span class="number">194333</span>] &lt;MyClass: <span class="number">0</span>x7f9422f00100&gt;-MyClass,小刚</span><br></pre></td></tr></table></figure>
<p>+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。</p>
<p>怎么调用到原来类中被category覆盖掉的方法？<br>category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法.</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">Class currentClass = [MyClass <span class="class"><span class="keyword">class</span>]</span>;</span><br><span class="line">    MyClass *<span class="keyword">my</span> = [[MyClass alloc] init];</span><br><span class="line">    my.name = @<span class="string">&quot;无脑刚&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (currentClass) &#123;</span><br><span class="line">        unsigned <span class="keyword">int</span> methodCount;</span><br><span class="line">        Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);</span><br><span class="line">        IMP lastImp = NULL;</span><br><span class="line">        SEL lastSel = NULL;</span><br><span class="line">        <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">            Method <span class="function"><span class="keyword">method</span> = <span class="title">methodList</span>[<span class="title">i</span>]</span>;</span><br><span class="line">            NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(<span class="function"><span class="keyword">method</span>)) <span class="title">encoding</span>:<span class="title">NSUTF8StringEncoding</span>]</span>;</span><br><span class="line">            NSLog(@<span class="string">&quot;方法:<span class="variable">%@</span>&quot;</span>, methodName);</span><br><span class="line">            <span class="keyword">if</span> ([@<span class="string">&quot;printName&quot;</span> isEqualToString:methodName]) &#123;</span><br><span class="line">                lastImp = method_getImplementation(<span class="function"><span class="keyword">method</span>)</span>;</span><br><span class="line">                lastSel = method_getName(<span class="function"><span class="keyword">method</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        typedef void (*fn)(id,SEL);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (lastImp != NULL) &#123;</span><br><span class="line">            fn f = (fn)lastImp;</span><br><span class="line">            f(<span class="keyword">my</span>,lastSel);</span><br><span class="line">        &#125;</span><br><span class="line">        free(methodList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>打印如下:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">56</span>.<span class="number">436</span> categoryDemo[<span class="number">20716</span>:<span class="number">206487</span>] 方法:printName</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">56</span>.<span class="number">436</span> categoryDemo[<span class="number">20716</span>:<span class="number">206487</span>] 方法:introduceYouselfForCategory2</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">56</span>.<span class="number">437</span> categoryDemo[<span class="number">20716</span>:<span class="number">206487</span>] 方法:printName</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">56</span>.<span class="number">437</span> categoryDemo[<span class="number">20716</span>:<span class="number">206487</span>] 方法:introduceYouselfForCategory1</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">56</span>.<span class="number">437</span> categoryDemo[<span class="number">20716</span>:<span class="number">206487</span>] 方法:printName</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">56</span>.<span class="number">437</span> categoryDemo[<span class="number">20716</span>:<span class="number">206487</span>] 方法:.cxx_destruct</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">56</span>.<span class="number">437</span> categoryDemo[<span class="number">20716</span>:<span class="number">206487</span>] 方法:name</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">56</span>.<span class="number">437</span> categoryDemo[<span class="number">20716</span>:<span class="number">206487</span>] 方法:setName:</span><br><span class="line"><span class="attribute">2018</span>-<span class="number">01</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">56</span>.<span class="number">438</span> categoryDemo[<span class="number">20716</span>:<span class="number">206487</span>] &lt;MyClass: <span class="number">0</span>x7f8a0d618f40&gt;-MyClass,无脑刚</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到调用到了类自身的方法.</p>
<p>在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。</p>
<p>但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？</p>
<p>所有的关联对象都由AssociationsManager管理.<br>AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对.</p>
<p><code>void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy)</code>部分实现:</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create the new association (first time).</span></span><br><span class="line">ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">      <span class="number">_</span><span class="keyword">class</span><span class="number">_</span>setInstancesHaveAssociatedObjects(<span class="number">_</span><span class="keyword">object</span><span class="number">_</span>getClass(<span class="keyword">object</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">void *<span class="title function_ invoke__">objc_destructInstance</span>(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj<span class="punctuation">-&gt;</span><span class="title function_ invoke__">hasCxxDtor</span>();</span><br><span class="line">        <span class="type">bool</span> assoc = !UseGC &amp;&amp; obj<span class="punctuation">-&gt;</span><span class="title function_ invoke__">hasAssociatedObjects</span>();</span><br><span class="line">        <span class="type">bool</span> dealloc = !UseGC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="title function_ invoke__">object_cxxDestruct</span>(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="keyword">if</span> (dealloc) obj<span class="punctuation">-&gt;</span><span class="title function_ invoke__">clearDeallocating</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runtime的销毁对象函数<code>objc_destructInstance</code>里面会判断这个对象有没有关联对象，如果有，会调用<code>_object_remove_assocations</code>做关联对象的清理工作。</p>
<h2 id="关于Method-IMP-SEL-self-cmd"><a href="#关于Method-IMP-SEL-self-cmd" class="headerlink" title="关于Method,IMP,SEL,self,_cmd"></a>关于Method,IMP,SEL,self,_cmd</h2><h3 id="struct-objc-method"><a href="#struct-objc-method" class="headerlink" title="struct objc_method"></a>struct objc_method</h3><p>在runtime.h里有申明.</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">struct objc_method <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">    char * _Nullable method_types                            OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">&#125;</span> </span><br><span class="line"></span><br><span class="line">typedef struct objc_method *<span class="keyword">Method</span>;</span><br></pre></td></tr></table></figure>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h3><p><a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/">苹果开源网址</a></p>
<p><a href="http://blog.sunnyxx.com/2014/03/05/objc_category_secret/">objc category的秘密</a></p>
<p><a href="https://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a></p>
<p><a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-runtime-new.mm.auto.html">macOS 10.13,objc4/objc4-723版本</a>已经找不到attachMethodLists()的实现了.<br><code>static void 
attachMethodLists(Class cls, method_list_t **addedLists, int addedCount, 
                  bool baseMethods, bool methodsFromBundle, 
                  bool flushCaches)</code><br>得看旧版:<a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-runtime-new.mm.auto.html">macOS 10.10,objc4/objc4-646版本</a></p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>Category</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage源码分析</title>
    <url>/2018/03/10/SDWebImage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>版本：SDWebImage v5.11.1</p>
<h3 id="SDWebImage源码分析"><a href="#SDWebImage源码分析" class="headerlink" title="SDWebImage源码分析"></a>SDWebImage源码分析</h3><blockquote>
<p>本文主要分析解决以下几个疑问:</p>
<ol>
<li>同一图片的请求,SD如何从缓存中查找出来(key的命名规则)?或者说查找过程是怎样的?</li>
<li>SD工作过程以及是如何从服务器下载的?</li>
<li>SD是如何缓存图片的?</li>
<li>当空间不足时,它的删除策略是什么(按时间顺序,还是图片质量)?</li>
<li>SD图片缓存机制与系统的NSURLCache的区别,为什么SD说自己的性能要略高于系统的性能?</li>
</ol>
</blockquote>
<h4 id="SDWebImageOptions的枚举值解释"><a href="#SDWebImageOptions的枚举值解释" class="headerlink" title="SDWebImageOptions的枚举值解释"></a>SDWebImageOptions的枚举值解释</h4><p>在使用SD提供的UIImageView类别方法: </p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>sd_setImageWithURL:<span class="params">(NSURL *)</span>url placeholderImage:<span class="params">(UIImage *)</span>placeholder options:<span class="params">(SDWebImageOptions)</span>options progress:<span class="params">(SDWebImageDownloaderProgressBlock)</span>progressBlock completed:<span class="params">(SDWebImageCompletionBlock)</span>completedBlock;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下载图片时,有一个<code>SDWebImageOptions</code>参数,它可以用来配置SD的下载、缓存等行为.该参数是一个枚举,它有很多可选的值.<br>下面将分析每个值的含义:<br><code>SDWebImageRetryFailed = 1 &lt;&lt; 0</code>,SD的注释</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * <span class="keyword">By</span> <span class="keyword">default</span>, <span class="keyword">when</span> a URL fail <span class="keyword">to</span> be downloaded, the URL <span class="built_in">is</span> blacklisted so the library won<span class="comment">&#x27;t keep trying.</span></span><br><span class="line">     * This flag disable this blacklisting.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>翻译:<br>SD默认,当一个URL下载失败后(网址无效的情况导致的下载失败才会进入,其他比如网络差原因导致的失败不会进入黑名单),该URL将会进入黑名单,SD将不会继续尝试下载.该选项将不使能黑名单.即即使该URL下载失败了,也不会进入黑名单,以后可以继续尝试下载.</p>
<p><code>SDWebImageLowPriority = 1 &lt;&lt; 1</code>,SD的注释</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * By default, image downloads are started during UI interactions, this flags disable this feature,</span></span><br><span class="line"><span class="comment">     * leading to delayed download on UIScrollView deceleration for instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<p>翻译:<br>SD默认,当用户点击下载时就开始下载了,但该枚举值将不使能该特性.比如UIScrollView还在减速的时候,即使UI的交互指示要开始下载了,但该枚举值会使SD延后下载.</p>
<p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2</code>,下载的图片不缓存到磁盘,仅缓存到内存.</p>
<p><code>SDWebImageProgressiveDownload = 1 &lt;&lt; 3</code>,SD的注释</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This flag enables progressive download, the image is displayed progressively during download as a browser would do.</span></span><br><span class="line"><span class="comment">     * By default, the image is only displayed once completely downloaded.</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<p>翻译:<br>该枚举值使能了progressive download(显示进度的下载),图片将随着进度一点点显示.SD默认只有当图片完全下载完成后才一次性显示.</p>
<p><code>SDWebImageRefreshCached = 1 &lt;&lt; 4</code>,SD的注释</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed.</span></span><br><span class="line"><span class="comment">     * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation.</span></span><br><span class="line"><span class="comment">     * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics.</span></span><br><span class="line"><span class="comment">     * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Use this flag only if you can&#x27;t make your URLs static with embedded cache busting parameter.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>翻译:  </p>
<ul>
<li>即使图片已经被缓存了,但是根据HTTP响应缓存控制,如果必要的话还是会用远程的图片刷新本地的缓存的图片.</li>
<li>磁盘的缓存将使用系统的NSURLCache处理而不是SDWebImage,所以会导致一个轻微的性能下降.</li>
<li>该枚举值用于处理图片改变但其对应的URL没变的情况.</li>
<li>如果缓存的图片被刷新,那么the completion block会调用两次,第一次是缓存的图片,接着的第二次是最终的图片.</li>
<li>仅当你不能让你的URL为一个静态的地址时(旧图片是网址A,新图片还是网址A)才使用该枚举值.</li>
</ul>
<p><code>SDWebImageContinueInBackground = 1 &lt;&lt; 5</code>,SD的注释</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for</span></span><br><span class="line"><span class="comment">     * extra time in background to let the request finish. If the background task expires the operation will be cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<p>翻译:<br>需要iOS4+,当APP进入后台时,继续图片的下载.该功能的实现是:进入后台时,通过向系统申请额外的时间来让请求完成.如果后台任务到期,操作将被取消.(xq注:有可能取消时,图片还没下载完成.这种情况应该比较少见,主要发生在下载高清图,但网速又不好的情况)</p>
<p><code>SDWebImageHandleCookies = 1 &lt;&lt; 6</code>,处理存储在NSHTTPCookieStore里的cookie.内部通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;实现.</p>
<p><code>SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7</code>,使能允许未信任的SSL证书.主要用于测试环境.生产环境谨慎使用.</p>
<p><code>SDWebImageHighPriority = 1 &lt;&lt; 8</code>,SD的注释</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * By default, images are loaded in the order in which they were queued. This flag moves them to</span></span><br><span class="line"><span class="comment">     * the front of the queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>翻译:<br>SD默认,图片是以它们入列时的顺序下载.该枚举值会将它们移到队列的前面.</p>
<p><code>SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11</code>,SD默认图片下载完成后自动设置imageView,但该枚举值可以让SD不自动设置,而是让程序员手动设置.比如下载完成后还要处理一下才设置到imageView上去.</p>
<h4 id="SD的缓存路径"><a href="#SD的缓存路径" class="headerlink" title="SD的缓存路径"></a>SD的缓存路径</h4><p>SD默认的缓存路径:</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Library</span>/Caches/<span class="keyword">default</span>/com.hackemist.SDWebImageCache.<span class="keyword">default</span>/cf00214b25574df24d89120a11424121.jpg</span><br></pre></td></tr></table></figure>
<p>它是在<code>Library/Caches/</code>目录下创建了<code>default/com.hackemist.SDWebImageCache.default/</code>路径,以后缓存的图片将存储在该路径下.<strong>SD保存图片的命名规则:</strong>通过对URLString md5后,再拼接可能有的后缀名得来.如:cf00214b25574df24d89120a11424121.jpg</p>
<p>系统<code>NSURLCache</code>缓存的路径:<br><code>Library/Caches/bundleIdXXX(APP bundle id)/</code>,然后在<code>bundleIdXXX</code>文件夹下存放缓存:<br><code>Cache.db,Cache.db-shm,Cache.db-wal,fsCachedData/A755FD02-64B3-430C-899D-6AD44E4D3229(图片的名称)</code>.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">[downloader downloadImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://b.zol-img.com.cn/sjbizhi/images/9/230x350/1469533909506.jpg&quot;</span>] options:SDWebImageDownloaderUseNSURLCache progress:<span class="literal">nil</span> completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;error:%@, finished:%d&quot;</span>, error, finished);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, image);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当<code>SDWebImageDownloaderOptions</code>选择<code>SDWebImageDownloaderUseNSURLCache</code>时,SD将采用系统的<code>NSURLCache</code>缓存图片,所以这里即使下载了,但使用SD的类别下载时[self.myImageView sd_setImageWithURL:]由于采用的是另一套查找机制,它没有去查找系统的缓存,所以还得重新下载.</p>
<h4 id="同一图片的请求-SD如何从缓存中查找出来-key的命名规则-或者说查找过程是怎样的"><a href="#同一图片的请求-SD如何从缓存中查找出来-key的命名规则-或者说查找过程是怎样的" class="headerlink" title="同一图片的请求,SD如何从缓存中查找出来(key的命名规则)?或者说查找过程是怎样的?"></a>同一图片的请求,SD如何从缓存中查找出来(key的命名规则)?或者说查找过程是怎样的?</h4><p>SD key的命名规则是怎样的?<br><code>NSString *key = [self cacheKeyForURL:url];</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cacheKeyFilter) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.cacheKeyFilter(url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [url absoluteString];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SD命名cache的key是通过返回URL的absoluteString属性的值.该key在后面的内存查找缓存和磁盘查找缓存都有用到的.</p>
<p>SD自定义了一个缓存类SDImageCache,该类维护着一个内存缓存和一个可选的磁盘缓存.Disk cache的写操作是异步的因此不用担心影响到UI.</p>
<p>维护的内存缓存是一个AutoPurgeCache对象.<code>@interface AutoPurgeCache : NSCache</code>.AutoPurageCache主要是在初始化的时候注册了一个UIApplicationDidReceiveMemoryWarningNotification内存警告的通知.如果收到内存警告通知,则调用<code>-removeAllObjects</code>清空缓存.</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> SDImageCache ()</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSCache *memCache;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString *diskCachePath;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSMutableArray *customPaths;</span><br><span class="line"><span class="variable">@property</span> (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t ioQueue;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Init the memory cache</span></span><br><span class="line"><span class="variable">_memCache</span> = [[AutoPurgeCache alloc] init];</span><br><span class="line"><span class="variable">_memCache</span>.<span class="built_in">name</span> = fullNamespace;</span><br></pre></td></tr></table></figure>
<p>SD下载图片时是将下载封装到一个操作里面的.</p>
<p>SD的主类<code>SDWebImageManager</code>有两个重要的属性</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDImageCache *imageCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloader *imageDownloader;</span><br></pre></td></tr></table></figure>
<p><code>SDImageCache</code>是用来操作缓存的,<code>SDWebImageDownloader</code>是用来下载图片的.</p>
<p>SD通过上面的Key参数和方法<code>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock</code>来查找缓存.</p>
<h4 id="同步查找内存缓存"><a href="#同步查找内存缓存" class="headerlink" title="同步查找内存缓存"></a>同步查找内存缓存</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内存查找比较简单,就是使用NSCache的方法<code>-objectForKey:</code>,如果在内存里找到那么就直接返回图片了.如果没查到,就<strong>异步的从磁盘里查找</strong>.也就是说SD的<code>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock</code>方法是同步的查找内存中缓存,异步的查找磁盘中的缓存.<br>PS:NSCache类似于NSDictionary.它里面存放的对象都是位于内存的.</p>
<h4 id="异步查找磁盘缓存"><a href="#异步查找磁盘缓存" class="headerlink" title="异步查找磁盘缓存"></a>异步查找磁盘缓存</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">	<span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">	    <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">	    <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</span><br><span class="line">	        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">	        [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	        doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="根据Key在磁盘中找到对应的缓存图片"><a href="#根据Key在磁盘中找到对应的缓存图片" class="headerlink" title="根据Key在磁盘中找到对应的缓存图片"></a>根据Key在磁盘中找到对应的缓存图片</h4><p>主要方法:<code>UIImage *diskImage = [self diskImageForKey:key];</code></p>
<p>SD是通过Key得到文件(图片)名的,<code>NSString *filename = [self cachedFileNameForKey:key];</code>方法内部是对key进行md5签名,得到一个签名串,然后再拼接后缀名(如果key里面有后缀的话).这个时候就得到了文件名,再拼接SD自己的存储路径self.diskCachePath(<code>/Library/Caches/default/com.hackemist.SDWebImageCache.default</code>事先指定好的路径名).到这一步就获得了指定key的缓存图片的路径(<code>/Library/Caches/default/com.hackemist.SDWebImageCache.default/cf00214b25574df24d89120a11424121.jpg</code>).通过<code>NSData *data = [NSData dataWithContentsOfFile:defaultPath];</code>读取出文件的数据.最后将NSData转化为UIImage.至此从磁盘查找指定key的缓存图片就到此结束了.<br>PS:<code>[result appendFormat:@&quot;%02x&quot;, digest[i]];</code><br>x/X:表示以十六进制形式输出.<br>02:表示不足两位,前面补0输出;超过两位,则直接输出.</p>
<h3 id="SD是如何缓存图片的"><a href="#SD是如何缓存图片的" class="headerlink" title="SD是如何缓存图片的?"></a>SD是如何缓存图片的?</h3><p>主要是通过<code>SDImageCache</code>类完成缓存功能.<code>SDImageCache</code>提供的接口有:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDImageCache</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Properties</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSCache</span> *memCache; <span class="comment">//里面是关联了一个系统的NSCache对象.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;</span><br><span class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> ioQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>初始化方法:<br><code>+ (SDImageCache *)sharedImageCache;</code>、<code>- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory;</code>提供缓存路径的设置.</p>
</li>
<li><p>存储缓存方法:<br><code>- (void)storeImage:(UIImage *)image forKey:(NSString *)key toDisk:(BOOL)toDisk;</code></p>
</li>
<li><p>获取缓存方法:</p>
<ol>
<li><code>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock;</code></li>
<li><code>- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;</code></li>
<li><code>- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;</code></li>
</ol>
</li>
<li><p>移除缓存的方法:</p>
<ol>
<li><code>- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion;</code></li>
<li><code>- (void)clearDisk;</code></li>
<li><code>- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock;</code></li>
</ol>
</li>
<li><p>查询信息方法(查询某个key的缓存是否存在,查询缓存占用了多少空间):</p>
<ol>
<li><code>- (NSUInteger)getSize;</code></li>
<li><code>- (BOOL)diskImageExistsWithKey:(NSString *)key;</code></li>
<li><code>- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock;</code></li>
</ol>
</li>
</ul>
<p>可以看到这个类的接口功能是比较完善的,有初始化方法、存、取、删、查询信息等方法.并且基本都提供了一个同步的,一个异步的.</p>
<p>当图片下载完成后,就进行缓存:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">	[<span class="keyword">self</span>.imageCache storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">	<span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">	    completedBlock(downloadedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终是将图片的二进制数据写入文件</span></span><br><span class="line"><span class="comment">// Make sure to call form io queue by caller</span></span><br><span class="line">- (<span class="type">void</span>)_storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!imageData || !key) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get cache Path for image key</span></span><br><span class="line">    <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];</span><br><span class="line">    <span class="comment">// transform to NSUrl</span></span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];</span><br><span class="line">    </span><br><span class="line">    [imageData writeToURL:fileURL options:<span class="keyword">self</span>.config.diskCacheWritingOptions error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// disable iCloud backup</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:@YES forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SD清除缓存规则"><a href="#SD清除缓存规则" class="headerlink" title="SD清除缓存规则"></a>SD清除缓存规则</h4><p>SD的缓存清理涉及到两个关键的配置属性:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大缓存时间</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum length of time to keep an image in the cache, in seconds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxCacheAge;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大缓存空间</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum size of the cache, in bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxCacheSize;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setMaxMemoryCost:(<span class="built_in">NSUInteger</span>)maxMemoryCost &#123;</span><br><span class="line">    <span class="keyword">self</span>.memCache.totalCostLimit = maxMemoryCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)maxMemoryCost &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.memCache.totalCostLimit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SD根据这两个属性的值,先删除最旧的文件.删除后若还超出了maxCacheSize,则进一步删除旧文件.不难看出SD清除缓存的策略就是删除旧文件.而其他框架可能会有所不同.比如采用LFU(Least Frequently Used)算法.它是根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>缓存清除时机:app即将干掉,或进入后台时.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Subscribe to app events</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                         selector:<span class="keyword">@selector</span>(deleteOldFiles)</span><br><span class="line">                                             name:<span class="built_in">UIApplicationWillTerminateNotification</span></span><br><span class="line">                                           object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                         selector:<span class="keyword">@selector</span>(backgroundDeleteOldFiles)</span><br><span class="line">                                             name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></span><br><span class="line">                                           object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the long-running task and return immediately.</span></span><br><span class="line">[<span class="keyword">self</span> deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line">    [application endBackgroundTask:bgTask];</span><br><span class="line">    bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="SD图片下载"><a href="#SD图片下载" class="headerlink" title="SD图片下载"></a>SD图片下载</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">SDWebImageCombinedOperation </span>: NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (assign, nonatomic, getter = isCancelled) BOOL cancelled;</span><br><span class="line"><span class="variable">@property</span> (copy, nonatomic) SDWebImageNoParamsBlock cancelBlock;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSOperation *cacheOperation;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p><code>__block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</code><br><code>operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;...&#125;];</code><br><strong>不太明白<code>SDWebImageCombinedOperation</code>的cacheOperation赋值以后有什么用</strong>,好像没有哪个地方将它添加到队列里.仅仅在<code>SDWebImageCombinedOperation</code>的cancel方法里看到用了一下.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)cancel &#123;</span><br><span class="line">    <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cacheOperation) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.cacheOperation cancel];</span><br><span class="line">        <span class="keyword">self</span>.cacheOperation = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cancelBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.cancelBlock();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> this is a temporary fix to #809.</span></span><br><span class="line">        <span class="comment">// Until we can figure the exact cause of the crash, going with the ivar instead of the setter</span></span><br><span class="line"><span class="comment">//        self.cancelBlock = nil;</span></span><br><span class="line">        _cancelBlock = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id &lt;SDWebImageOperation&gt;)</span>loadImageWithURL:<span class="params">(nullable NSURL *)</span>url</span><br><span class="line">                                     options:<span class="params">(SDWebImageOptions)</span>options</span><br><span class="line">                                    progress:<span class="params">(nullable SDWebImageDownloaderProgressBlock)</span>progressBlock</span><br><span class="line">                                   completed:<span class="params">(nullable SDInternalCompletionBlock)</span>completedBlock;</span><br><span class="line">                                   </span><br><span class="line">- <span class="params">(nullable SDWebImageDownloadToken *)</span>addProgressCallback:<span class="params">(SDWebImageDownloaderProgressBlock)</span>progressBlock</span><br><span class="line">                                           completedBlock:<span class="params">(SDWebImageDownloaderCompletedBlock)</span>completedBlock</span><br><span class="line">                                                   forURL:<span class="params">(nullable NSURL *)</span>url</span><br><span class="line">                                           createCallback:<span class="params">(SDWebImageDownloaderOperation *(^)</span><span class="params">(void)</span>)createCallback;</span><br></pre></td></tr></table></figure>
<p>下载的操作就是在该方法中加入到队列里的,代码片段:</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">// Add operation to operation queue only after all configuration done according to Apple&#x27;s doc.</span><br><span class="line">// `addOperation:` does<span class="built_in"> not </span>synchronously<span class="built_in"> execute </span>the `operation.completionBlock` so this will<span class="built_in"> not </span>cause deadlock.</span><br><span class="line">[self.downloadQueue addOperation:operation];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>响应者链hitTest释疑</title>
    <url>/2018/02/28/%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BEhitTest%E9%87%8A%E7%96%91/</url>
    <content><![CDATA[<p>pointInside方法说明：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> point:</span></span><br><span class="line"><span class="comment"> A point that is in the receiver’s local coordinate system (bounds).</span></span><br><span class="line"><span class="comment"> point参数系统已经转为当前视图坐标系的坐标了。比如点击视图的左上角那么point就是（0,0）</span></span><br><span class="line"><span class="comment"> 再往左上坐标可能就是（-3，-4）这样。point可以在视图区域外，但也遵守当前视图坐标系的规则，如果视图的大小为（30,30），那么他的坐标就是（40,42）。</span></span><br><span class="line"><span class="comment"> 视图的bounds:</span></span><br><span class="line"><span class="comment"> 默认情况下视图bounds的x,y都是0，ie:坐标的原点为（0,0）</span></span><br><span class="line"><span class="comment"> + + +&gt;</span></span><br><span class="line"><span class="comment"> +</span></span><br><span class="line"><span class="comment"> +</span></span><br><span class="line"><span class="comment"> 如果更改bounds的x,y为（10,10），ie:坐标的原点将变为（10,10）</span></span><br><span class="line"><span class="comment"> 以视图为坐标系的点会整体偏移（10,10）。也就是以前是(1,5)的点，现在变为(11,15)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = [<span class="keyword">self</span> enlargedRect];</span><br><span class="line">    <span class="type">BOOL</span> rs = <span class="built_in">CGRectContainsPoint</span>(rect, point);</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGRect</span>)enlargedRect &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *topEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;topNameKey);</span><br><span class="line">    <span class="built_in">NSNumber</span> *rightEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;rightNameKey);</span><br><span class="line">    <span class="built_in">NSNumber</span> *bottomEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;bottomNameKey);</span><br><span class="line">    <span class="built_in">NSNumber</span> *leftEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;leftNameKey);</span><br><span class="line">    <span class="keyword">if</span> (topEdge &amp;&amp; rightEdge &amp;&amp; bottomEdge &amp;&amp; leftEdge) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.bounds.origin.x - leftEdge.floatValue,</span><br><span class="line">                          <span class="keyword">self</span>.bounds.origin.y - topEdge.floatValue,</span><br><span class="line">                          <span class="keyword">self</span>.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue,</span><br><span class="line">                          <span class="keyword">self</span>.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.bounds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q:UIButton想要扩大它的响应区域?<br>A:重载UIButton的hitTest或pointInside.<br>重载hitTest:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden == <span class="literal">YES</span> || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CGRect</span> touchRect = <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, <span class="number">-40</span>, <span class="number">-40</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(touchRect, point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或重载pointInside:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="type">BOOL</span> rs = <span class="built_in">CGRectContainsPoint</span>(<span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, <span class="number">-40</span>, <span class="number">-40</span>), point);</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里推荐重写pointInside方法.因为重写hitTest方法需要注意判断view的一些属性:<code>if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;</code>如果不判断会出Bug,比如设置按钮hidden为YES了,但是摸到按钮的区域,按钮的响应方法一样会被调用.而重写pointInside方法则不需要考虑这些.</p>
<p>PS:如果设置了userInteractionEnabled=NO;即使重写hitTest返回按钮自己,按钮的响应方法也不会回调.应该是系统在回调之前又判断了一下该属性的值.</p>
<p>userInteractionEnabled的说明如下:</p>
<blockquote>
<p>When set to NO, touch, press, keyboard, and focus events intended for the view are ignored and removed from the event queue. When set to YES, events are delivered to the view normally. The default value of this property is YES.</p>
<p>During an animation, user interactions are temporarily disabled for all views involved in the animation, regardless of the value in this property. You can disable this behavior by specifying the UIViewAnimationOptionAllowUserInteraction option when configuring the animation.</p>
</blockquote>
<p>当btn作为第一响应者被返回时,如果userInteractionEnabled属性为NO,则与它相关的事件(触摸,按压)都将被忽略.因此btn的响应方法不会被调用.</p>
<p>Q:点击子视图超出父视图的区域仍让子视图响应事件?<br>A:必须重载<strong>父视图(**</strong>父视图<strong><strong>父视图</strong></strong>父视图**三遍!!!)的pointInside方法.这是由于如果父视图的pointInside返回NO的话,其上的子视图就不会进行hitTest,因此重载子视图的相关方法将无效.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">point</span>(<span class="params">inside</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> rs <span class="operator">=</span> <span class="keyword">super</span>.point(inside: point, with: event)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span>rs &#123;</span><br><span class="line">        <span class="keyword">for</span> subView <span class="keyword">in</span> subviews.reversed() &#123;</span><br><span class="line">            <span class="keyword">let</span> subPoint <span class="operator">=</span> subView.convert(point, from: <span class="keyword">self</span>)</span><br><span class="line">            <span class="keyword">if</span> subView.bounds.contains(subPoint) &#123;</span><br><span class="line">                rs <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目中遇到一个场景:collectionViewCell上的按钮超出了cell的边界,想点击按钮超出部分按钮也能够响应事件,按照上述办法重写了collectionViewCell的pointInside方法,但是却没效果.于是又重写了cell的hitTest方法,发现hitTest方法返回的是cell自身,并没有返回button.这下糊涂了,是上面的理论错了吗?上面的理论是没有错的,分析了半天发现根本原因是cell并不是button的父视图,button的父视图是contentView,而contentView的父视图才是cell.虽然cell的pointInside返回了YES,但是contentView的pointInside依然返回的是NO.所以不会再hitTest contentView上的子视图,button自然就没有反应了.真相终于明了,但问题还没解决,如何解决呢?</p>
<p>由于contentView是cell的内部属性没办法自定义,所以这里我们重写cell的hitTest方法,判断如果点击的点位于按钮区域内,则直接将按钮返回.这下点击超出区域按钮也能够响应事件了,完美.</p>
<p>Q:点击subview却让superview响应?<br>A:重载subview的hitTest方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">hitTest</span>(<span class="keyword">_</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>.superview</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q:hitTest和pointInside的关系?<br>A:通过真机调试发现(模拟器可能不准),系统会先调用父视图的hitTest方法,hitTest方法继而会调用pointInside方法,如果pointInside返回YES,那么系统将对其上的子视图重复上面的过程进行hitTest.</p>
<p>hitTest的一种可能实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1.判断自己能否接收事件</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden == <span class="literal">YES</span> || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.判断当前点在不在当前View.</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> pointInside:point withEvent:event]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.从后往前遍历自己的子控件.让子控件重复前两步操作,(把事件传递给,让子控件调用hitTest)</span></span><br><span class="line">    <span class="type">int</span> count = (<span class="type">int</span>)<span class="keyword">self</span>.subviews.count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//取出每一个子控件</span></span><br><span class="line">        <span class="built_in">UIView</span> *chileV =  <span class="keyword">self</span>.subviews[i];</span><br><span class="line">        <span class="comment">//把当前的点转换成子控件坐标系上的点.</span></span><br><span class="line">        <span class="built_in">CGPoint</span> childP = [<span class="keyword">self</span> convertPoint:point toView:chileV];</span><br><span class="line">        <span class="built_in">UIView</span> *fitView = [chileV hitTest:childP withEvent:event];</span><br><span class="line">        <span class="comment">//判断有没有找到最适合的View</span></span><br><span class="line">        <span class="keyword">if</span>(fitView)&#123;</span><br><span class="line">            <span class="keyword">return</span> fitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.没有找到比它自己更适合的View.那么它自己就是最适合的View</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIResponder</tag>
        <tag>响应者链</tag>
      </tags>
  </entry>
  <entry>
    <title>runtime +load与+initialize分析</title>
    <url>/2018/02/26/runtime%20+load%E4%B8%8E+initialize%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>通过一个简单的打印实验就可以发现:</p>
<ul>
<li>+initialize方法和+load调用时机</li>
<li>+initialize在父类,子类,类别之间的关系</li>
<li>+load在父类,子类,类别之间的关系</li>
</ul>
<p>如下表格:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>+load</th>
<th>+initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>被添加到 runtime 时(类被加载时)</td>
<td>第一次调用该类的类方法或实例方法前调用,可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类-&gt;子类-&gt;分类(多个分类间,则按加载顺序)</td>
<td>父类-&gt;分类(多个分类时,是最后一个的被执行)or子类</td>
</tr>
<tr>
<td>是否需要显式调用父类实现</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>自身没实现是否调用父类的实现</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中实现产生的影响</td>
<td>类和分类都执行</td>
<td>覆盖类中的方法，只执行分类的实现</td>
</tr>
</tbody>
</table>
</div>
<p>另:Swizzling should always be done in +load.</p>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><p>文档说明：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">The runtime sends initialize <span class="keyword">to</span> each <span class="keyword">class</span> <span class="keyword">in</span> a <span class="keyword">program</span> just before the <span class="keyword">class</span>, <span class="keyword">or</span> any <span class="keyword">class</span> that inherits from it, <span class="keyword">is</span> sent its first <span class="keyword">message</span> from within the <span class="keyword">program</span>. Superclasses receive this <span class="keyword">message</span> before their subclasses.</span><br><span class="line"></span><br><span class="line">The runtime sends the initialize <span class="keyword">message</span> <span class="keyword">to</span> classes <span class="keyword">in</span> a thread-safe manner. That <span class="keyword">is</span>, initialize <span class="keyword">is</span> run by the first thread <span class="keyword">to</span> send a <span class="keyword">message</span> <span class="keyword">to</span> a <span class="keyword">class</span>, <span class="keyword">and</span> any other thread that tries <span class="keyword">to</span> send a <span class="keyword">message</span> <span class="keyword">to</span> that <span class="keyword">class</span> will block <span class="keyword">until</span> initialize completes.</span><br><span class="line"></span><br><span class="line">The superclass <span class="keyword">implementation</span> may be called multiple times <span class="keyword">if</span> subclasses <span class="keyword">do</span> <span class="keyword">not</span> implement initialize—the runtime will call the <span class="keyword">inherited</span> <span class="keyword">implementation</span>—<span class="keyword">or</span> <span class="keyword">if</span> subclasses explicitly call [super initialize]. <span class="keyword">If</span> you want <span class="keyword">to</span> protect yourself from being run multiple times, you can structure your <span class="keyword">implementation</span> along these lines:</span><br><span class="line">+ (void)initialize <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  if (self == [ClassName self]) &#123;</span></span><br><span class="line"><span class="comment">    // ... do the initialization ...</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Because initialize <span class="keyword">is</span> called <span class="keyword">in</span> a blocking manner, it’s important <span class="keyword">to</span> limit method implementations <span class="keyword">to</span> the minimum amount <span class="keyword">of</span> work necessary possible. Specifically, any code that takes locks that might be required by other classes <span class="keyword">in</span> their initialize methods <span class="keyword">is</span> liable <span class="keyword">to</span> lead <span class="keyword">to</span> deadlocks. Therefore, you should <span class="keyword">not</span> rely <span class="keyword">on</span> initialize <span class="keyword">for</span> complex <span class="keyword">initialization</span>, <span class="keyword">and</span> should instead limit it <span class="keyword">to</span> straightforward, <span class="keyword">class</span> <span class="keyword">local</span> <span class="keyword">initialization</span>.</span><br><span class="line"></span><br><span class="line">Special Considerations</span><br><span class="line">initialize <span class="keyword">is</span> invoked only once per <span class="keyword">class</span>. <span class="keyword">If</span> you want <span class="keyword">to</span> perform independent <span class="keyword">initialization</span> <span class="keyword">for</span> the <span class="keyword">class</span> <span class="keyword">and</span> <span class="keyword">for</span> categories <span class="keyword">of</span> the <span class="keyword">class</span>, you should implement load methods.</span><br></pre></td></tr></table></figure>
<p>有几个点值得说一下：</p>
<p>1、initialize方法是线程安全的。当第一个线程触发initialize执行后，其他线程发送的消息都会被阻塞直到initialize执行完成。</p>
<p>2、父类的实现可能会被执行多次。有时候并不想initialize里的代码执行多次，建议使用dispatch_once保护起来。</p>
<p>3、initialize方法是以同步的方式执行的，所以里面的实现最好尽可能的简单。尤其是涉及到锁的逻辑就需要特别小心，处理不好可能会导致死锁。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://www.jianshu.com/p/872447c6dc3f">Objective-C 深入理解 +load 和 +initialize</a></p>
]]></content>
      <categories>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>+load</tag>
      </tags>
  </entry>
  <entry>
    <title>Allocation Type介绍</title>
    <url>/2018/04/04/Allocation%20Type%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="Allocation-Type介绍"><a href="#Allocation-Type介绍" class="headerlink" title="Allocation Type介绍"></a>Allocation Type介绍</h3><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p>The following allocation type display settings filter the allocations in the detail pane based on their type.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Setting</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>All Heap &amp; Anonymous VM</td>
<td>Shows all malloc heap allocations and interesting VM regions such as graphics- and Core Data-related. Hides mapped files, dylibs, and some large reserved VM regions.</td>
<td></td>
</tr>
<tr>
<td></td>
<td>All Heap Allocations</td>
<td>Shows all malloc heap allocations but no VM regions.</td>
<td></td>
</tr>
<tr>
<td></td>
<td>All VM Regions</td>
<td>Shows all VM regions, including mapped files, dylibs, and the VM regions that include the malloc heap.</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>参考:<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Instrument-Allocations.html">Allocations Instrument</a></p>
<h4 id="论坛上的解释"><a href="#论坛上的解释" class="headerlink" title="论坛上的解释"></a>论坛上的解释</h4><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>All heap allocations consist of the memory allocations your application makes. This is the allocation type you should focus on in Instruments.</p>
<p>All VM regions consist of the virtual memory the operating system reserves for your application. You cannot control the size of the virtual memory the operating system reserves.</p>
<p>All heap and anonymous vm is the sum of the All Heap Allocations and All VM Regions columns.</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>While heap allocations are very important (that’s where all your Swift and Objective-C objects are created), you can’t ignore the importance of VM memory for most apps. I recommend investigating that category because it can grow rather large, and the memory being allocated there “by the operating system” is going to be in response to some task you’ve asked your application to perform.</p>
<p>For instance, when you allocate a large CGImage, a tiny object is allocated on the heap, but the many megabytes of image data is allocated in a separate VM region. In an image-heavy application, your heap may be relatively small but your VM regions may be rather large. In that case, you’d need to take a closer look at the size and number of images your application has loaded at any given moment.</p>
<p>So in general, you need to ensure you are optimizing <strong>all</strong> of your memory usage.</p>
<p>参考:<a href="https://forums.developer.apple.com/thread/21463">[Instruments] Allocation Types</a></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>All Heap Allocations:应用在堆上申请的内存空间,比如你自己的类alloc出来的对象.</p>
<p>All VM Regions:操作系统为你的APP预留出来的虚拟内存.比如APP加载资源文件到内存时,占用的就是这些虚拟内存.因此如果你的APP图片比较多时,这部分内存占用会很大.</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>在一个页面上加载一张140kb的图片.使用Instruments查看实际消耗的内存:<br><img src="http://7xqoji.com1.z0.glb.clouddn.com/%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98@2x.png" alt="加载图片占用的内存"><br>不知道为啥加载到内存后会比磁盘上要大36kb.</p>
<p>加载了一张52kb的图片,Instruments显示消耗64kb.感觉要比原图多占用25%.</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="Mac文件存储单位"><a href="#Mac文件存储单位" class="headerlink" title="Mac文件存储单位"></a>Mac文件存储单位</h5><p>Apple认为1GB=1 000 000 000字节，Microsoft认为1GB=1 073 741 824字节，网络上多用Microsoft的标准。<br>对于电脑而言，1 073 741 824是2的30次方，比1 000 000 000更方便处理，但硬件厂商生产硬盘等设备的时候是按后者来标注容量的。Apple希望用户买一块1TB的硬盘插到电脑上看到的就是1TB而不是931GB，这会带来更好的用户体验，于是Apple在显示容量时遵循了后者的标准。</p>
<p><img src="http://7xqoji.com1.z0.glb.clouddn.com/Mac%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D@2x.png" width="264" height="451" /></p>
]]></content>
      <categories>
        <category>Instruments</category>
      </categories>
      <tags>
        <tag>Allocations</tag>
      </tags>
  </entry>
  <entry>
    <title>私有Pod制作</title>
    <url>/2018/03/22/%E7%A7%81%E6%9C%89pod%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="使用本地pod"><a href="#使用本地pod" class="headerlink" title="使用本地pod"></a>使用本地pod</h3><p>创建Podspec文件:<code>pod spec create XQPerson</code></p>
<p>修改XQPerson.podspec文件:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Pod::Spec.<span class="keyword">new</span> <span class="keyword">do</span> |s|</span><br><span class="line">    s.name         = <span class="string">&quot;XQPerson&quot;</span></span><br><span class="line">    s.version      = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line">    s.summary      = <span class="string">&quot;Use XQPerson to print hello.&quot;</span></span><br><span class="line">    s.description  = &lt;&lt;-DESC</span><br><span class="line">                        A pod used to print hello. <span class="keyword">this</span> is just a simply pod.</span><br><span class="line">                     DESC</span><br><span class="line">    s.homepage     = <span class="string">&quot;https://github.com/tonymillion/Reachability&quot;</span></span><br><span class="line">    s.license      = <span class="string">&quot;MIT&quot;</span></span><br><span class="line">    s.author       = &#123; <span class="string">&quot;xq_120&quot;</span> =&gt; <span class="string">&quot;xq_120455@yahoo.com&quot;</span> &#125;</span><br><span class="line">    s.platform     = :ios, <span class="string">&quot;7.0&quot;</span></span><br><span class="line">    s.source       = &#123; :git =&gt; <span class="string">&quot;/Users/xuequan/Desktop/XQPerson/&quot;</span>, :tag =&gt; <span class="string">&quot;#&#123;s.version&#125;&quot;</span> &#125;</span><br><span class="line">    s.source_files = <span class="string">&quot;XQPerson/*.&#123;h,m&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    s.framework  = <span class="string">&quot;Foundation&quot;</span></span><br><span class="line"><span class="meta"># s.frameworks = <span class="string">&quot;SomeFramework&quot;</span>, <span class="string">&quot;AnotherFramework&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># s.library   = <span class="string">&quot;iconv&quot;</span></span></span><br><span class="line"><span class="meta"># s.libraries = <span class="string">&quot;iconv&quot;</span>, <span class="string">&quot;xml2&quot;</span></span></span><br><span class="line"></span><br><span class="line">    s.requires_arc = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># s.dependency <span class="string">&quot;JSONKit&quot;</span>, <span class="string">&quot;~&gt; 1.4&quot;</span></span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>验证Spec文件:<code>pod lib lint</code>:</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"> -&gt; XQPerson (<span class="number">0.0</span><span class="number">.1</span>)</span><br><span class="line"></span><br><span class="line">XQPerson passed validation.</span><br></pre></td></tr></table></figure>
<p>准备好你的pod文件:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">xuequandeMacBook-Pro:XQPerson xuequan$ tree /Users/xuequan/Desktop/XQPerson -L <span class="number">2</span></span><br><span class="line">/Users/xuequan/Desktop/XQPerson</span><br><span class="line">├── LICENSE</span><br><span class="line">├── XQPerson</span><br><span class="line">│   ├── XQPerson<span class="selector-class">.h</span></span><br><span class="line">│   └── XQPerson<span class="selector-class">.m</span></span><br><span class="line">├── XQPerson<span class="selector-class">.podspec</span></span><br><span class="line">└── XQPersonDemo</span><br><span class="line">    ├── Podfile</span><br><span class="line">    ├── Podfile<span class="selector-class">.lock</span></span><br><span class="line">    ├── Pods</span><br><span class="line">    ├── XQPersonDemo</span><br><span class="line">    ├── XQPersonDemo<span class="selector-class">.xcodeproj</span></span><br><span class="line">    ├── XQPersonDemo<span class="selector-class">.xcworkspace</span></span><br><span class="line">    ├── XQPersonDemoTests</span><br><span class="line">    └── XQPersonDemoUITests</span><br></pre></td></tr></table></figure>
<p>打好tag.</p>
<p>使用本地pods时,Podfile有两种写法:</p>
<ol>
<li>pod ‘XQPerson’, :podspec =&gt; ‘~/Desktop/XQPerson/XQPerson.podspec’  # 指定包含.podspec文件的路径</li>
<li>pod ‘XQPerson’, :path =&gt; ‘~/Desktop/XQPerson’    # 指定podspec文件的路径</li>
</ol>
<p>不过如果<br><code>s.source       = &#123; :git =&gt; &quot;~/Desktop/XQPerson&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</code><br>则指定podspec文件写法,pod install时会安装失败.而指定包含.podspec文件的路径写法不会.</p>
<p>最后pod install:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Analyzing</span> dependencies</span><br><span class="line"><span class="attribute">Downloading</span> dependencies</span><br><span class="line"><span class="attribute">Using</span> XQPerson (<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>)</span><br><span class="line"><span class="attribute">Generating</span> Pods project</span><br><span class="line"><span class="attribute">Integrating</span> client project</span><br><span class="line"><span class="attribute">Sending</span> stats</span><br><span class="line"><span class="attribute">Pod</span> installation complete! There is <span class="number">1</span> dependency from the Podfile and <span class="number">1</span> total pod installed.</span><br></pre></td></tr></table></figure>
<p>至此使用本地pod就完成了.</p>
<h3 id="提交本地pod至远程仓库"><a href="#提交本地pod至远程仓库" class="headerlink" title="提交本地pod至远程仓库"></a>提交本地pod至远程仓库</h3><p>在GitLab上创建一个私有工程XQPerson.</p>
<p>修改<code>XQPerson.podspec</code>中的:</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">s.homepage     = <span class="string">&quot;https://gitlab.com/xq_120/XQPerson&quot;</span></span><br><span class="line">s.source       = &#123; :<span class="function"><span class="params">git</span> =&gt;</span> <span class="string">&quot;https://gitlab.com/xq_120/XQPerson.git&quot;</span>, :<span class="function"><span class="params">tag</span> =&gt;</span> <span class="string">&quot;#&#123;s.version&#125;&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>使用远程地址代替之前的本地路径.<br>重新验证一下<code>XQPerson.podspec</code>文件:<code>pod lib lint</code></p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">xuequandeMacBook-<span class="symbol">Pro:</span>XQPerson xuequan<span class="variable">$ </span>pod <span class="class"><span class="keyword">lib</span> <span class="title">lint</span></span></span><br><span class="line"></span><br><span class="line"> -&gt; XQPerson (<span class="number">0.0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">XQPerson passed validation.</span><br></pre></td></tr></table></figure>
<p>提交文件到远程仓库:</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"><span class="variable">$ </span>git commit -s -m <span class="string">&quot;Initial Commit of Library&quot;</span></span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@gitlab</span>.<span class="symbol">com:</span>xq_120/<span class="title class_">XQPerson</span>.git  <span class="comment">#添加远端仓库</span></span><br><span class="line"><span class="variable">$ </span>git push origin master     <span class="comment">#提交到远端仓库</span></span><br></pre></td></tr></table></figure>
<p>打好tag:</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-m</span> <span class="string">&quot;first release&quot;</span> <span class="number">0.0</span>.<span class="number">1</span></span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure>
<h3 id="创建私有Spec-Repo"><a href="#创建私有Spec-Repo" class="headerlink" title="创建私有Spec Repo"></a>创建私有Spec Repo</h3><p>在GitLab上创建一个git远程仓库用于存储自己的私有podspec文件.其实这就有点类似CocoaPods的官方Spec repo.官方的地址是<code>https://github.com/CocoaPods/Specs.git</code>,只不过官方存储的都是公开的pod的podspec文件.而我们的git远程仓库由于是私有的,因此外部人员就无法访问到.</p>
<p>创建完成之后在Terminal中执行如下命令:<br><code>$ pod repo add XQSpecs https://gitlab.com/xq_120/XQSpecs.git</code></p>
<p>此时如果成功的话进入到<code>~/.cocoapods/repos</code>目录下就可以看到XQSpecs这个目录了。</p>
<h3 id="向Spec-Repo提交podspec"><a href="#向Spec-Repo提交podspec" class="headerlink" title="向Spec Repo提交podspec"></a>向Spec Repo提交podspec</h3><p>向我们的私有Spec Repo提交podspec只需要一个命令:<br><code>$ pod repo push XQSpecs XQPerson.podspec</code></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">xuequandeMacBook-<span class="type">Pro</span>:<span class="type">XQPerson</span> xuequan$ pod repo push <span class="type">XQSpecs</span> <span class="type">XQPerson</span>.podspec</span><br><span class="line"></span><br><span class="line"><span class="type">Validating</span> spec</span><br><span class="line"> -&gt; <span class="type">XQPerson</span> (<span class="number">0.0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Updating</span> the <span class="type">`XQSpecs&#x27;</span> repo</span><br><span class="line"></span><br><span class="line"><span class="type">Already</span> up-<span class="keyword">to</span>-date.</span><br><span class="line"></span><br><span class="line"><span class="type">Adding</span> the spec <span class="keyword">to</span> the <span class="type">`XQSpecs&#x27;</span> repo</span><br><span class="line"></span><br><span class="line"> - [<span class="type">No</span> change] <span class="type">XQPerson</span> (<span class="number">0.0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Pushing</span> the <span class="type">`XQSpecs&#x27;</span> repo</span><br><span class="line"></span><br><span class="line">xuequandeMacBook-<span class="type">Pro</span>:<span class="type">XQPerson</span> xuequan$</span><br></pre></td></tr></table></figure>
<p>完成之后这个组件库就添加到我们的私有Spec Repo中了，可以进入到<code>~/.cocoapods/repos/XQSpecs</code>目录下查看:<code>tree . -l</code></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">.</span></span><br><span class="line"><span class="bullet"></span>├── XQPerson</span><br><span class="line">│   └── 0.0.1</span><br><span class="line">│       └── XQPerson.podspec</span><br></pre></td></tr></table></figure>
<p>再去看我们的Spec Repo远端仓库，也有了一次提交，这个podspec也已经被Push上去了。</p>
<p>至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">-&gt; XQPerson (<span class="number">0.0</span>.<span class="number">1</span>)</span><br><span class="line">   Use XQPerson to print hello.</span><br><span class="line">   pod <span class="string">&#x27;XQPerson&#x27;</span>, <span class="string">&#x27;~&gt; 0.0.1&#x27;</span></span><br><span class="line">   - Homepage: https:<span class="regexp">//gi</span>tlab.com<span class="regexp">/xq_120/</span>XQPerson</span><br><span class="line">   - Source:   https:<span class="regexp">//gi</span>tlab.com<span class="regexp">/xq_120/</span>XQPerson.git</span><br><span class="line">   - Versions: <span class="number">0.0</span>.<span class="number">1</span> [XQSpecs repo]</span><br><span class="line">(<span class="keyword">END</span>)</span><br></pre></td></tr></table></figure>
<p>搜索不到的,将<code>/Users/xuequan/Library/Caches/CocoaPods</code>路径下的<code>search_index.json</code>删除,然后重新搜索(可能需要先更新下Spec repo:<code>pod repo update</code>).</p>
<h3 id="使用远程私有Pod"><a href="#使用远程私有Pod" class="headerlink" title="使用远程私有Pod"></a>使用远程私有Pod</h3><p>Podfile文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">platform :ios, <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&#x27;https://gitlab.com/xq_120/XQSpecs.git&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;tanwanlanyue&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  pod <span class="string">&#x27;XQPerson&#x27;</span>, <span class="string">&#x27;~&gt; 0.0.1&#x27;</span></span><br><span class="line">  pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="string">&#x27;~&gt; 3.2.0&#x27;</span></span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>执行pod install:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">xuequandeMacBook</span>-Pro:tanwanlanyue xuequan$ pod install</span><br><span class="line"><span class="attribute">Analyzing</span> dependencies</span><br><span class="line"><span class="attribute">Downloading</span> dependencies</span><br><span class="line"><span class="attribute">Installing</span> AFNetworking (<span class="number">3</span>.<span class="number">2</span>.<span class="number">0</span>)</span><br><span class="line"><span class="attribute">Installing</span> XQPerson (<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>)</span><br><span class="line"><span class="attribute">Generating</span> Pods project</span><br><span class="line"><span class="attribute">Integrating</span> client project</span><br><span class="line"><span class="attribute">Sending</span> stats</span><br><span class="line"><span class="attribute">Pod</span> installation complete! There are <span class="number">2</span> dependencies from the Podfile and <span class="number">2</span> total pods installed.</span><br><span class="line"><span class="attribute">xuequandeMacBook</span>-Pro:tanwanlanyue xuequan$</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;XQPerson.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    XQPerson *p = [XQPerson new];</span><br><span class="line">    [p printHello]; <span class="comment">//2018-03-22 11:34:17.434385+0800 tanwanlanyue[9186:96648] hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/">使用Cocoapods创建私有podspec</a></p>
<p><a href="https://blog.cnbluebox.com/blog/2014/03/31/cocoapodsdai-ma-guan-li/">Cocoapods代码管理</a></p>
<p><a href="https://www.jianshu.com/p/5cb284934be2">cocoapods进阶</a></p>
<p><a href="https://www.jianshu.com/p/1e5927eeb341">Cocoapods使用私有库中遇到的坑</a></p>
<p><a href="https://www.jianshu.com/p/0c640821b36f">CocoaPods 私有仓库的创建（超详细）</a></p>
<p><a href="https://segmentfault.com/a/1190000007947371">CocoaPods创建公有和私有Pod库方法总结</a></p>
<hr>
<p><a href="https://blog.zengrong.net/post/1746.html">Git查看、删除、重命名远程分支和tag</a></p>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
  </entry>
  <entry>
    <title>Swift静态库注意事项</title>
    <url>/2018/04/12/Swift%E9%9D%99%E6%80%81%E5%BA%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="Swift静态库注意事项"><a href="#Swift静态库注意事项" class="headerlink" title="Swift静态库注意事项"></a>Swift静态库注意事项</h3><p>工程是Swift,OC混编.开发完成后,需要将工程制作为一个静态库.制作完成测试使用时,发现一运行就崩溃.提示:<br>Unknown class KDLHomeLotteryKindCollectionCell in Interface Builder file.应该是宿主工程在加载静态库对应的bundle里的XIB文件时出问题了.</p>
<p>原因分析及解决办法:<br>确定以及肯定的是系统在查找XIB对应的类时没有找到导致的.</p>
<p>在制作静态库和Bundle时,类和XIB文件被分离到各自的target.而XIB文件是被拖入到bundle中的,因此需要更改XIB之前的默认Module设置,尤其是创建时选择Swift语言.否则系统在查找XIB的类时是在Bundle这个Module中找,当然是找不到的,从而在加载时崩溃.</p>
<p>解决办法:<br>需要更改XIB对应类的所属Module为静态库的Module.或者不勾选Inherit Module From Target,并清空Module一栏.</p>
<p>note:Swift创建的XIB默认是选中Inherit Module From Target的.OC创建的XIB文件系统默认没有勾选.</p>
<p>eg:</p>
<p><img src="http://7xqoji.com1.z0.glb.clouddn.com/Swift%E5%88%9B%E5%BB%BAXIB%E6%96%87%E4%BB%B6@2x.png" alt=""></p>
]]></content>
      <categories>
        <category>静态库</category>
      </categories>
  </entry>
  <entry>
    <title>格式化输出导致的疑似bug</title>
    <url>/2018/04/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E5%AF%BC%E8%87%B4%E7%9A%84%E7%96%91%E4%BC%BCbug/</url>
    <content><![CDATA[ <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;123456a&quot;</span>;</span><br><span class="line"><span class="built_in">NSData</span> *dataStr = [str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s %s&quot;</span>, [str UTF8String], dataStr.bytes);</span><br></pre></td></tr></table></figure>
<p>iOS9.0模拟器.<br>输出:123456a 123456a–˝ã˘<br>dataStr.bytes的二进制内容:31 32 33 34 35 36 61 D0 1D 13 FD 8B F9 07 00 10<br>出现上述情况的原因:<br>需要了解%s是如何打印c字符串的.<br>%s打印的时候遇到\0就停止，[str UTF8String]转换的时候，自动在字符数组的最后面加上了\0(A null-terminated UTF8 representation of the string.)，但是data.bytes后面’不一定’是\0，所以打印data.bytes的时候会有额外的内容.</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>格式化打印指令</tag>
      </tags>
  </entry>
  <entry>
    <title>NSData与它的属性bytes</title>
    <url>/2018/07/07/NSData%E4%B8%8E%E5%AE%83%E7%9A%84%E5%B1%9E%E6%80%A7bytes/</url>
    <content><![CDATA[<h4 id="NSData与它的属性bytes"><a href="#NSData与它的属性bytes" class="headerlink" title="NSData与它的属性bytes"></a>NSData与它的属性bytes</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* enString= <span class="string">@&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">NSData</span>* utf8EnData = [enString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bytes属性:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> The -bytes method returns a pointer to a contiguous region of memory managed by the receiver.</span></span><br><span class="line"><span class="comment"> If the regions of memory represented by the receiver are already contiguous, it does so in O(1) time, otherwise it may take longer</span></span><br><span class="line"><span class="comment"> Using -enumerateByteRangesUsingBlock: will be efficient for both contiguous and discontiguous data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">const</span> <span class="type">void</span> *bytes <span class="built_in">NS_RETURNS_INNER_POINTER</span>;</span><br></pre></td></tr></table></figure>
<p>bytes属性指向的是NSData对象装载的内容.NSData装载的二进制内容在内存中的分布可能是连续的一片,也可能是不连续的.使用<code>- (void) enumerateByteRangesUsingBlock:(void (NS_NOESCAPE ^)(const void *bytes, NSRange byteRange, BOOL *stop))block</code>遍历所有的分布区域.</p>
<p>NSData对象本身的地址与装载的二进制内容的地址,如下图:<br><img src="http://7xqoji.com1.z0.glb.clouddn.com/NSData%E4%B8%8Ebytes%E5%B1%9E%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB@2x.png" alt=""><br>可以看到NSData对象本身的地址与二进制内容所在的地址是不同的.二者内存位置相距还挺远的.</p>
<p>查看NSData对象装载的二进制内容方法:<br><img src="http://7xqoji.com1.z0.glb.clouddn.com/%E6%9F%A5%E7%9C%8BNSData%E7%9A%84%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E6%96%B9%E6%B3%95@2x.png" alt=""></p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>NSData</tag>
      </tags>
  </entry>
  <entry>
    <title>SCLAlertView使用</title>
    <url>/2018/07/09/SCLAlertView%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="SCLAlertView使用"><a href="#SCLAlertView使用" class="headerlink" title="SCLAlertView使用"></a>SCLAlertView使用</h2><p>SCLAlertView设置</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)showPopView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提交成功</span></span><br><span class="line">    SCLAlertView *alertView = [[SCLAlertView alloc] initWithNewWindowWidth:<span class="number">310</span>];</span><br><span class="line">    <span class="comment">//去掉顶部圆圈</span></span><br><span class="line">    [alertView removeTopCircle];</span><br><span class="line">    <span class="comment">//按钮水平放置</span></span><br><span class="line">    [alertView setHorizontalButtons:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">//设置出现动画</span></span><br><span class="line">    alertView.showAnimationType = SCLAlertViewShowAnimationSimplyAppear;</span><br><span class="line">    alertView.shouldDismissOnTapOutside = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置title的字体和颜色</span></span><br><span class="line">    alertView.labelTitle.font = [<span class="built_in">UIFont</span> pingFangSCWithSize:<span class="number">16</span>];</span><br><span class="line">    alertView.labelTitle.textColor = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置富文本的subTitle</span></span><br><span class="line">    alertView.attributedFormatBlock = ^<span class="built_in">NSAttributedString</span> *(<span class="built_in">NSString</span> *value) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> attributeString:value subString:<span class="string">@&quot;13812341234&quot;</span> subStrColor:kRedColorRegular font:[<span class="built_in">UIFont</span> pingFangSCWithSize:<span class="number">16</span>] otherStrColor:[<span class="built_in">UIColor</span> colorWithHexString:<span class="string">@&quot;#818181&quot;</span>]];</span><br><span class="line">    &#125;;</span><br><span class="line">    [alertView setBodyTextFontFamily:<span class="string">@&quot;PingFangSC-Regular&quot;</span> withSize:<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//设置普通文本的subTitle</span></span><br><span class="line"><span class="comment">//    alertView.viewText.font = [UIFont pingFangSCWithSize:16];</span></span><br><span class="line"><span class="comment">//    alertView.viewText.textColor = [UIColor colorWithHexString:@&quot;#818181&quot;];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Buttons, top circle and borders的颜色简便方法</span></span><br><span class="line">    alertView.customViewColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    <span class="comment">//统一设置按钮的配置强大方法</span></span><br><span class="line">    alertView.buttonFormatBlock = ^ <span class="built_in">NSDictionary</span> *&#123;</span><br><span class="line">        <span class="keyword">return</span> @&#123;<span class="string">@&quot;backgroundColor&quot;</span>: [<span class="built_in">UIColor</span> cyanColor]&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    SCLButton *authPersonalBtn = [alertView addButton:<span class="string">@&quot;取消&quot;</span> actionBlock:^(<span class="type">void</span>) &#123;</span><br><span class="line">        DLog(<span class="string">@&quot;取消按钮被按下&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    authPersonalBtn.titleLabel.font = [<span class="built_in">UIFont</span> pingFangSCWithSize:<span class="number">16</span>];</span><br><span class="line">    authPersonalBtn.buttonFormatBlock = ^ <span class="built_in">NSDictionary</span> *&#123;</span><br><span class="line">        <span class="keyword">return</span> @&#123;<span class="string">@&quot;backgroundColor&quot;</span>: [<span class="built_in">UIColor</span> whiteColor], <span class="string">@&quot;textColor&quot;</span>: [<span class="built_in">UIColor</span> colorWithHexString:<span class="string">@&quot;#818181&quot;</span>], <span class="string">@&quot;borderWidth&quot;</span>: @<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    SCLButton *authCompanyBtn = [alertView addButton:<span class="string">@&quot;去注册&quot;</span> actionBlock:^(<span class="type">void</span>) &#123;</span><br><span class="line">        DLog(<span class="string">@&quot;去注册按钮被按下&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    authCompanyBtn.titleLabel.font = [<span class="built_in">UIFont</span> pingFangSCWithSize:<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//单独设置某个按钮的配置</span></span><br><span class="line">    authCompanyBtn.buttonFormatBlock = ^ <span class="built_in">NSDictionary</span> *&#123;</span><br><span class="line">        <span class="keyword">return</span> @&#123;<span class="string">@&quot;backgroundColor&quot;</span>: [<span class="built_in">UIColor</span> whiteColor], <span class="string">@&quot;textColor&quot;</span>: [<span class="built_in">UIColor</span> blackColor], <span class="string">@&quot;borderWidth&quot;</span>: @<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [alertView showSuccess:<span class="keyword">self</span> title:<span class="string">@&quot;手机号码未注册&quot;</span> subTitle:<span class="string">@&quot;手机号码 13812341234 未注册， 请注册后再登录。&quot;</span> closeButtonTitle:<span class="literal">nil</span> duration:<span class="number">0.0</span>f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第三方库使用</category>
      </categories>
      <tags>
        <tag>SCLAlertView</tag>
      </tags>
  </entry>
  <entry>
    <title>制作静态库注意事项</title>
    <url>/2018/04/15/%E5%88%B6%E4%BD%9CSDK%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>制作静态库注意事项</p>
<ol>
<li><p>添加前缀防止冲突.<br> 类名,全局定义的变量(如全局变量,全局的枚举定义),类别方法名,宏,通知名称.需要添加前缀防止与宿主冲突.</p>
</li>
<li><p>使用static关键字限制作用域.<br> 对于全局变量,尽可能使用static限制作用域.否则容易与宿主重复定义导致编译错误.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>静态库</category>
      </categories>
      <tags>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods命令介绍</title>
    <url>/2018/03/22/CocoaPods%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="pod-install和pod-update"><a href="#pod-install和pod-update" class="headerlink" title="pod install和pod update"></a>pod install和pod update</h3><h4 id="pod-install"><a href="#pod-install" class="headerlink" title="pod install"></a>pod install</h4><p>每次运行pod install命令，并且有下载安装新的库时，CocoaPods会把这些安装的库的版本都写在Podfile.lock文件里面。这个文件记录你每个安装库的版本号，并且锁定了这些版本。</p>
<p>后面再次运行的时候,它会解析Podfile.lock文件,对于存在在Podfile.lock文件中的则安装Podfile.lock文件中的版本的库而不会去检测该库是否有最新的版本可用,对于不在Podfile.lock文件中的,则根据Podfile文件指定的库版本下载安装.</p>
<p>pod install不会去更新已存在的库的版本.</p>
<p>举个栗子：</p>
<p>IGListKit 有v3.1.0，和v3.1.1两个版本</p>
<p>Podfile如下： <code>pod &#39;IGListKit&#39;, &#39;~&gt; 3.1.0&#39;</code></p>
<p>场景1：第一次安装，无Podfile.lock。</p>
<p>此时执行pod install，你会发现下载并安装的是3.1.1版本。因为Podfile中使用的是 <code>~&gt;</code> ，表明可以使用较新的一个小版本。</p>
<p>场景2：再次安装，有Podfile.lock，且Podfile.lock中的版本为3.1.0。</p>
<p>此时执行pod install，你会发现下载并安装的是3.1.0版本。也就是说这种情况因为能够在Podfile.lock中找到库的版本，所以pod install就直接安装指定的版本了。这个时候如果使用的是pod update，则会安装3.1.1的版本。</p>
<h4 id="pod-update"><a href="#pod-update" class="headerlink" title="pod update"></a>pod update</h4><p>当你运行 pod update PODNAME 命令时，CocoaPods会帮你更新到这个库的新版本，此时CocoaPods 会忽略Podfile.lock里面的限制，它会更新到这个库尽可能的新版本，<strong>只要符合Podfile里面的版本限制</strong>。</p>
<p>如果你运行pod update，后面没有跟库的名字，CocoaPods就会更新每一个Podfile里面的库到尽可能的最新版本。</p>
<p>pod update默认是更新repo的，而pod install是不更新的。所以我们有时候pod update时会特别慢.</p>
<p>举例:<br>当你在Podfile文件中新增一个库时,你应该使用pod install而不是pod update.(因为pod update会更新已存在的库而我们的目的只是想安装一个库所以应该使用pod install)</p>
<p>你只有在想更新某个库的时候才使用pod update.</p>
<h3 id="pod-setup"><a href="#pod-setup" class="headerlink" title="pod setup"></a>pod setup</h3><p>所有的项目的Podspec文件都托管在<code>https://github.com/CocoaPods/Specs</code>。第一次执行pod setup时，CocoaPods会将这些podspec文件clone到本地的 <code>~/.cocoapods/repos</code>目录下，这个文件比较大。所以第一次更新时非常慢，通常需要使用国内的镜像服务器或翻墙。如果clone已存在,则会更新repos文件.</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">xuequandeMacBook-Pro:~ xuequan$ pod setup</span><br><span class="line">Setting up CocoaPods <span class="keyword">master</span> <span class="title">repo</span></span><br><span class="line">  $ /usr/bin/git -C /Users/xuequan/.cocoapods/repos/<span class="keyword">master</span> <span class="title">fetch</span> origin</span><br><span class="line">  --progress</span><br><span class="line">  remote: Counting objects: <span class="number">38172</span>, done.        </span><br><span class="line">  remote: Compressing objects: <span class="number">100</span>% (<span class="number">117</span>/<span class="number">117</span>), done.        </span><br><span class="line">  remote: Total <span class="number">38172</span> (delta <span class="number">13706</span>), reused <span class="number">13672</span> (delta <span class="number">13672</span>), pack-reused <span class="number">24374</span>        </span><br><span class="line">  Receiving objects: <span class="number">100</span>% (<span class="number">38172</span>/<span class="number">38172</span>), <span class="number">4.09</span> MiB | <span class="number">560.00</span> KiB/s, done.</span><br><span class="line">  Resolving deltas: <span class="number">100</span>% (<span class="number">26181</span>/<span class="number">26181</span>), completed with <span class="number">3595</span> local objects.</span><br><span class="line">  From https://github.com/CocoaPods/Specs</span><br><span class="line">     cc16dc96ff1..f42ce3f56e0  <span class="keyword">master</span>     <span class="title">-&gt; origin</span>/<span class="keyword">master</span></span><br><span class="line">  <span class="title">$</span> /usr/bin/git -C /Users/xuequan/.cocoapods/repos/<span class="keyword">master</span> <span class="title">rev-parse</span></span><br><span class="line">  --abbrev-<span class="keyword">ref</span> HEAD</span><br><span class="line">  <span class="keyword">master</span></span><br><span class="line">  <span class="title">$</span> /usr/bin/git -C /Users/xuequan/.cocoapods/repos/<span class="keyword">master</span> <span class="title">reset</span> --hard</span><br><span class="line">  origin/<span class="keyword">master</span></span><br><span class="line">  <span class="title">HEAD</span> is now at f42ce3f56e0 [Add] HLDevice <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">warning: inexact rename detection was skipped due to too many files.</span><br><span class="line">warning: you may want to set your diff.renameLimit variable to at least <span class="number">3856</span> <span class="keyword">and</span> retry the command.</span><br><span class="line"></span><br><span class="line">CocoaPods <span class="number">1.4</span>.<span class="number">0</span> is available.</span><br><span class="line">To update use: `sudo gem install cocoapods`</span><br><span class="line"></span><br><span class="line">For more <span class="literal">inf</span>ormation, see https://blog.cocoapods.org <span class="keyword">and</span> the CHANGELOG for this <span class="keyword">version</span> at https://github.com/CocoaPods/CocoaPods/releases/<span class="keyword">tag</span>/<span class="number">1.4</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Setup completed</span><br></pre></td></tr></table></figure>
<h3 id="pod-search"><a href="#pod-search" class="headerlink" title="pod search"></a>pod search</h3><p>执行该命令后,CocoaPods会在<code>~/Library/Caches/CocoaPods</code>目录下创建<code>search_index.json</code>文件(目前16.6M).当你<code>pod search</code>一个内容时，就在这个本地目录下进行搜索。所以一些较新的pod库可能会搜索不到.比如目前刚出的<code>LKImageKit</code>.<br>解决办法:<br>删除<code>~/Library/Caches/CocoaPods</code>目录下的<code>search_index.json</code>文件.<br>再次执行<code>pod search &#39;xxx&#39;</code>, CocoaPods会重新创建该文件.</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">xuequandeMacBook-Pro:~ xuequan<span class="symbol">$</span> pod search LKImageKit</span><br><span class="line"><span class="function"><span class="title">Creating</span></span> search index <span class="keyword">for</span> spec repo <span class="string">&#x27;artsy&#x27;</span>.. Done!</span><br><span class="line"><span class="function"><span class="title">Creating</span></span> search index <span class="keyword">for</span> spec repo <span class="string">&#x27;brion&#x27;</span>.. Done!</span><br><span class="line"><span class="function"><span class="title">Creating</span></span> search index <span class="keyword">for</span> spec repo <span class="string">&#x27;master&#x27;</span>.. Done!</span><br></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">-&gt; LKImageKit (<span class="number">5.3</span>.<span class="number">1</span>)</span><br><span class="line">   LKImageKit</span><br><span class="line">   pod <span class="string">&#x27;LKImageKit&#x27;</span>, <span class="string">&#x27;~&gt; 5.3.1&#x27;</span></span><br><span class="line">   - Homepage: https:<span class="regexp">//gi</span>thub.com<span class="regexp">/Tencent/</span>LKImageKit</span><br><span class="line">   - Source:   https:<span class="regexp">//gi</span>thub.com<span class="regexp">/Tencent/</span>LKImageKit.git</span><br><span class="line">   - Versions: <span class="number">5.3</span>.<span class="number">1</span> [master repo]</span><br><span class="line">(<span class="keyword">END</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Podfile-lock文件"><a href="#Podfile-lock文件" class="headerlink" title="Podfile.lock文件"></a>Podfile.lock文件</h3><p>该文件在第一次运行pod install后生成,用于跟踪每一个安装的Pod库的版本.当修改了Podfile文件中某个库的版本或pod update被执行,将生成新的Podfile.lock文件.</p>
<p>Q:如何保证项目中的成员使用的pod库版本一致?<br>A:提交Podfile.lock文件.As a reminder, even if your policy is not to commit the Pods folder into your shared repository, you should always commit &amp; push your Podfile.lock file.</p>
<p>总结下就是:</p>
<ul>
<li>忽略Pods文件夹</li>
<li>尽量在Podfile文件中指明库的版本</li>
<li>提交Podfile.lock文件</li>
</ul>
<p>注意:仅在Podfile中写死库的版本并不能保证团队各成员使用的库的版本一致.这是因为第三方库自己有可能也依赖某个库.因此提交Podfile.lock文件才是正解.</p>
<h3 id="Manifest-lock"><a href="#Manifest-lock" class="headerlink" title="Manifest.lock"></a>Manifest.lock</h3><p>Manifest.lock 是 Podfile.lock 的副本，每次只要生成 Podfile.lock 时就会生成一个一样的 Manifest.lock 存储在 Pods 文件夹下。在每次项目 Build 的时候，会跑一下脚本检查一下 Podfile.lock 和 Manifest.lock 是否一致：</p>
<p>Build phases -&gt; [CP] Check Pods Manifest.lock</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">diff <span class="string">&quot;$&#123;PODS_PODFILE_DIR_PATH&#125;/Podfile.lock&quot;</span> <span class="string">&quot;$&#123;PODS_ROOT&#125;/Manifest.lock&quot;</span> &gt; <span class="regexp">/dev/</span>null</span><br><span class="line"><span class="keyword">if</span> [ $? != <span class="number">0</span> ] ; then</span><br><span class="line">    <span class="comment"># print error to STDERR</span></span><br><span class="line">    echo <span class="string">&quot;error: The sandbox is not in sync with the Podfile.lock. Run &#x27;pod install&#x27; or update your CocoaPods installation.&quot;</span> &gt;&amp;<span class="number">2</span></span><br><span class="line">    <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">fi</span><br><span class="line"><span class="comment"># This output is used by Xcode &#x27;outputs&#x27; to avoid re-running this script phase.</span></span><br><span class="line">echo <span class="string">&quot;SUCCESS&quot;</span> &gt; <span class="string">&quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>因此如果你有提交Pods文件夹,那么Manifest.lock也有可能冲突.解决冲突的时候不要忘记它,并且确保Manifest.lock和Podfile.lock一致.</p>
<h3 id="pod库版本号限定"><a href="#pod库版本号限定" class="headerlink" title="pod库版本号限定"></a>pod库版本号限定</h3><p>eg:<br><code>pod &#39;AFNetworking&#39;, &#39;~&gt; 1.0&#39;</code> 版本号可以是1.0，可以是1.1 … 1.9，但必须小于2.</p>
<p>详细介绍如下:</p>
<ul>
<li><code>= 0.1 Version 0.1.</code></li>
<li><code>&gt; 0.1 Any version higher than 0.1.</code></li>
<li><code>&gt;= 0.1 Version 0.1 and any higher version.</code></li>
<li><code>&lt; 0.1 Any version lower than 0.1.</code></li>
<li><code>&lt;= 0.1 Version 0.1 and any lower version.</code></li>
<li><code>~&gt; 0.1.2 Version 0.1.2 and the versions up to 0.2, not including 0.2. This operator works based on the last component that you specify in your version requirement. The example is equal to &gt;= 0.1.2 combined with &lt; 0.2.0 and will always match the latest known version matching your requirements.</code></li>
</ul>
<p><code>pod &#39;AFNetworking&#39;,</code>  // 不指定版本号，任何版本都可以</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://guides.cocoapods.org/using/pod-install-vs-update.html">pod install vs. pod update</a></p>
<p><a href="https://guides.cocoapods.org/syntax/podfile.html#pod">podfile文件语法规则</a></p>
<p><a href="https://objccn.io/issue-6-4/">深入理解 CocoaPods</a>    </p>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
  </entry>
  <entry>
    <title>map和flapMap的一点区别</title>
    <url>/2018/04/09/map%E5%92%8CflapMap%E7%9A%84%E4%B8%80%E7%82%B9%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="Array中的map和flapMap的一点区别"><a href="#Array中的map和flapMap的一点区别" class="headerlink" title="Array中的map和flapMap的一点区别"></a>Array中的map和flapMap的一点区别</h3><p>注意：map和flapMap方法在很多类型里都有定义，一定要看清楚方法声明。</p>
<p>map的声明:<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]</span><br></pre></td></tr></table></figure></p>
<p>它返回的是一个数组.闭包的返回值是一个新数组的元素.  默认情况下，只要闭包有可能返回一个optional类型元素，则map返回的将是一个[T?]数组.</p>
<p>flapMap的声明:  有两种声明</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">swift</span>, deprecated: <span class="number">4.1</span>, renamed: <span class="string">&quot;compactMap(_:)&quot;</span>, message: <span class="string">&quot;Please use compactMap(_:) for the case where closure returns an optional value&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">flatMap</span>&lt;<span class="type">ElementOfResult</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Returns an array containing the concatenated results of calling the</span></span><br><span class="line"><span class="comment">/// given transformation with each element of this sequence.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Use this method to receive a single-level collection when your</span></span><br><span class="line"><span class="comment">/// transformation produces a sequence or collection for each element.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In this example, note the difference in the result of using `map` and</span></span><br><span class="line"><span class="comment">/// `flatMap` with a transformation that returns an array.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     let numbers = [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     let mapped = numbers.map &#123; Array(repeating: $0, count: $0) &#125;</span></span><br><span class="line"><span class="comment">///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     let flatMapped = numbers.flatMap &#123; Array(repeating: $0, count: $0) &#125;</span></span><br><span class="line"><span class="comment">///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In fact, `s.flatMap(transform)`  is equivalent to</span></span><br><span class="line"><span class="comment">/// `Array(s.map(transform).joined())`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter transform: A closure that accepts an element of this</span></span><br><span class="line"><span class="comment">///   sequence as its argument and returns a sequence or collection.</span></span><br><span class="line"><span class="comment">/// - Returns: The resulting flattened array.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Complexity: O(*m* + *n*), where *n* is the length of this sequence</span></span><br><span class="line"><span class="comment">///   and *m* is the length of the result.</span></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">flatMap</span>&lt;<span class="type">SegmentOfResult</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">SegmentOfResult</span> : <span class="type">Sequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">compactMap</span>&lt;<span class="type">ElementOfResult</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>]</span><br></pre></td></tr></table></figure>
<p>二者区别:  </p>
<ol>
<li><p>flatMap可以用来展平一个数组：它把原序列里的元素变为一个序列，然后把这个序列的元素添加到结果序列中，相当于降维了。展的有多平得看transform的实现，不过最少是减一层。</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> links: [[<span class="type">String</span>]] <span class="operator">=</span> [</span><br><span class="line">    [<span class="string">&quot;http://a1&quot;</span>, <span class="string">&quot;http://a2&quot;</span>, <span class="string">&quot;http://a3&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;http://b1&quot;</span>, <span class="string">&quot;http://b2&quot;</span>, <span class="string">&quot;http://b3&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;http://c1&quot;</span>, <span class="string">&quot;http://c2&quot;</span>, <span class="string">&quot;http://c3&quot;</span>],</span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(links)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flapLink <span class="operator">=</span> links.flatMap &#123; (exlinks: [<span class="type">String</span>]) -&gt; [<span class="type">String</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> exlinks <span class="comment">//因为links的元素就是数组所以这里直接返回就可以了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(flapLink)  <span class="comment">//[&quot;http://a1&quot;, &quot;http://a2&quot;, &quot;http://a3&quot;, &quot;http://b1&quot;, &quot;http://b2&quot;, &quot;http://b3&quot;, &quot;http://c1&quot;, &quot;http://c2&quot;, &quot;http://c3&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d3: [[[<span class="type">Int</span>]]] <span class="operator">=</span> [</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]],</span><br><span class="line">    [[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>], [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>]],</span><br><span class="line">    [[<span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>], [<span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>], [<span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>]],</span><br><span class="line">]</span><br><span class="line"><span class="comment">//[[Int]]</span></span><br><span class="line"><span class="keyword">let</span> flapD1 <span class="operator">=</span> d3.flatMap &#123; ele <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> ele</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[Int]</span></span><br><span class="line"><span class="keyword">let</span> flapD2 <span class="operator">=</span> d3.flatMap &#123; ele <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> ele.flatMap&#123;<span class="variable">$0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors <span class="operator">=</span> [<span class="string">&quot;♥&quot;</span>, <span class="string">&quot;♠&quot;</span>, <span class="string">&quot;♦&quot;</span>, <span class="string">&quot;♣&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="string">&quot;J&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;A&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> cards <span class="operator">=</span> colors.flatMap &#123; color <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> numbers.map &#123; num <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(color)</span>-<span class="subst">\(num)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(cards) <span class="comment">//[&quot;♥-J&quot;, &quot;♥-Q&quot;, &quot;♥-K&quot;, &quot;♥-A&quot;, &quot;♠-J&quot;, &quot;♠-Q&quot;, &quot;♠-K&quot;, &quot;♠-A&quot;, &quot;♦-J&quot;, &quot;♦-Q&quot;, &quot;♦-K&quot;, &quot;♦-A&quot;, &quot;♣-J&quot;, &quot;♣-Q&quot;, &quot;♣-K&quot;, &quot;♣-A&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flatMap可以将转化失败的nil元素剔除,而map则不能:</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wq <span class="operator">=</span> [<span class="string">&quot;123&quot;</span>, <span class="string">&quot;fsd&quot;</span>, <span class="string">&quot;dfsd&quot;</span>, <span class="string">&quot;34&quot;</span>]</span><br><span class="line"><span class="comment">//类型是[Int?]</span></span><br><span class="line"><span class="keyword">let</span> wqm <span class="operator">=</span> wq.map &#123; (element) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(element)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(wqm)  <span class="comment">//[Optional(123), nil, nil, Optional(34)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型是[Int]</span></span><br><span class="line"><span class="keyword">let</span> wqfm <span class="operator">=</span> wq.flatMap &#123; (element) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(element)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(wqfm) <span class="comment">//[123, 34]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于剔除nil元素的用法已经被废弃,Apple推荐使用compactMap代替,因此flatMap的用法主要是第一种了.</p>
<h3 id="Optional枚举类型中的map和flatMap"><a href="#Optional枚举类型中的map和flatMap" class="headerlink" title="Optional枚举类型中的map和flatMap"></a>Optional枚举类型中的map和flatMap</h3><p>map:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Evaluates the given closure when this `Optional` instance is not `nil`,</span></span><br><span class="line"><span class="comment">/// passing the unwrapped value as a parameter.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Use the `map` method with a closure that returns a non-optional value.</span></span><br><span class="line"><span class="comment">/// This example performs an arithmetic operation on an</span></span><br><span class="line"><span class="comment">/// optional integer.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     let possibleNumber: Int? = Int(&quot;42&quot;)</span></span><br><span class="line"><span class="comment">///     let possibleSquare = possibleNumber.map &#123; $0 * $0 &#125;</span></span><br><span class="line"><span class="comment">///     print(possibleSquare)</span></span><br><span class="line"><span class="comment">///     // Prints &quot;Optional(1764)&quot;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     let noNumber: Int? = nil</span></span><br><span class="line"><span class="comment">///     let noSquare = noNumber.map &#123; $0 * $0 &#125;</span></span><br><span class="line"><span class="comment">///     print(noSquare)</span></span><br><span class="line"><span class="comment">///     // Prints &quot;nil&quot;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter transform: A closure that takes the unwrapped value</span></span><br><span class="line"><span class="comment">///   of the instance.</span></span><br><span class="line"><span class="comment">/// - Returns: The result of the given closure. If this instance is `nil`,</span></span><br><span class="line"><span class="comment">///   returns `nil`.</span></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: (<span class="type">Wrapped</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?</span><br></pre></td></tr></table></figure>
<p>flatMap:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Evaluates the given closure when this `Optional` instance is not `nil`,</span></span><br><span class="line"><span class="comment">/// passing the unwrapped value as a parameter.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Use the `flatMap` method with a closure that returns an optional value.</span></span><br><span class="line"><span class="comment">/// This example performs an arithmetic operation with an optional result on</span></span><br><span class="line"><span class="comment">/// an optional integer.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     let possibleNumber: Int? = Int(&quot;42&quot;)</span></span><br><span class="line"><span class="comment">///     let nonOverflowingSquare = possibleNumber.flatMap &#123; x -&gt; Int? in</span></span><br><span class="line"><span class="comment">///         let (result, overflowed) = x.multipliedReportingOverflow(by: x)</span></span><br><span class="line"><span class="comment">///         return overflowed ? nil : result</span></span><br><span class="line"><span class="comment">///     &#125;</span></span><br><span class="line"><span class="comment">///     print(nonOverflowingSquare)</span></span><br><span class="line"><span class="comment">///     // Prints &quot;Optional(1764)&quot;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter transform: A closure that takes the unwrapped value</span></span><br><span class="line"><span class="comment">///   of the instance.  </span></span><br><span class="line"><span class="comment">/// - Returns: The result of the given closure. If this instance is `nil`,</span></span><br><span class="line"><span class="comment">///   returns `nil`.</span></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">flatMap</span>&lt;<span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: (<span class="type">Wrapped</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?</span><br></pre></td></tr></table></figure>
<p>上面两个区别仅是闭包参数的返回值不同。不仔细看还真发现不了。如果transform的结果可能为nil则需要使用flatMap。如果不可能为nil则可以使用map。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>map flapMap</tag>
      </tags>
  </entry>
  <entry>
    <title>TTTAttributedLabel使用</title>
    <url>/2018/07/09/TTTAttributedLabel%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="TTTAttributedLabel使用"><a href="#TTTAttributedLabel使用" class="headerlink" title="TTTAttributedLabel使用"></a>TTTAttributedLabel使用</h2><p>Q1:使用pod管理TTTAttributedLabel,在XIB中使用会导致XIB报错并且一片空白.</p>
<p>A:没找到一种好的解决办法,只能不使用XIB.</p>
<p>Q2:使用TTTAttributedLabel,在聊天cell(xib实现)中,点击链接代理方法不被调用,原因是TTTAttributedLabel的touchesCancelled一直被调用了,touchesEnded没被调用.</p>
<p>A2:代码中有添加点击手势导致label的touch事件总是被cancel.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UITapGestureRecognizer</span> *tapGes = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tappedView:)];</span><br><span class="line">tapGes.delegate = <span class="keyword">self</span>;</span><br><span class="line">tapGes.cancelsTouchesInView = <span class="literal">NO</span>; <span class="comment">//重要</span></span><br><span class="line">[<span class="keyword">self</span>.view addGestureRecognizer:tapGes];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>手势与响应者链</p>
<p>父视图上添加了点击手势,有时(不是每次)会导致父视图上的UIButton的action方法不会被调用.<br>原因在于如果父视图识别出了手势,那么会cancel掉UITouch.从而第一响应者会收到touchesCancelled消息.基本上那些原本不接受用户事件的控件比如UILabel即使设置userInteractionEnabled=YES,但它的touchesEnded将不会被调用.而UIControl子类控件他们的action方法有时不会被调用.</p>
</blockquote>
]]></content>
      <categories>
        <category>第三方库使用</category>
      </categories>
      <tags>
        <tag>TTTAttributedLabel</tag>
      </tags>
  </entry>
  <entry>
    <title>UITextField笔记</title>
    <url>/2018/07/09/UITextField%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="UITextField笔记"><a href="#UITextField笔记" class="headerlink" title="UITextField笔记"></a>UITextField笔记</h2><h3 id="监听文本输入变化"><a href="#监听文本输入变化" class="headerlink" title="监听文本输入变化"></a>监听文本输入变化</h3><p>方法1: addTarget — UIControlEventValueChanged</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.passwordTextField addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(passwordTextFieldTextDidChanged:) forControlEvents:<span class="built_in">UIControlEventValueChanged</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法2: 注册通知 — UITextFieldTextDidChangeNotification</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(passwordTextFieldTextDidChanged:) name:<span class="built_in">UITextFieldTextDidChangeNotification</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>note:</p>
<ol>
<li>当点击清空按钮时,只有注册通知的方案,回调方法被调用了.</li>
<li>直接对textField的text属性赋值,<code>textField.text = @&quot;dfsfsd&quot;;</code>是不会触发UIControlEventValueChanged事件,和UITextFieldTextDidChangeNotification通知回调的.可以使用<code>textField.text = @&quot;&quot;;[textField insertText:newString];</code></li>
</ol>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UITextField</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令使用</title>
    <url>/2018/07/09/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure>
<p>执行后，会创建一个.git文件夹</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">➜  gitdemoprj git init</span><br><span class="line">Initialized empty Git repository in <span class="string">/Users/xuequan/Desktop/gitdemoprj/.git/</span></span><br><span class="line">➜  gitdemoprj git:<span class="params">(main)</span> ✗ <span class="keyword">ls</span> -a</span><br><span class="line">.      <span class="string">..</span>     <span class="string">.git</span>   食<span class="string">.md</span></span><br></pre></td></tr></table></figure>
<p>目前默认创建的分支名是main，不是master了。不注意的话后续一些操作比如push等等可能会出错。如果git init时不想使用默认的main分支名怎么办呢？</p>
<p>方法1：在初始化的时候指定分支名</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git init -b <span class="keyword">master</span> <span class="title">//这里指定为master</span>。</span><br></pre></td></tr></table></figure>
<p>方法2：全局设置初始化的分支名称。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> <span class="keyword">init</span>.defaultBranch &lt;name&gt;</span><br><span class="line">示例：</span><br><span class="line">git config --<span class="keyword">global</span> <span class="keyword">init</span>.defaultBranch master</span><br></pre></td></tr></table></figure>
<p>该命令会在~/.gitconfig文件里添加配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[init]</span></span><br><span class="line">	<span class="attr">defaultBranch</span> = master</span><br></pre></td></tr></table></figure>
<p>以后使用git init初始化后默认的就都是master了。</p>
<p>可是我现在已经是main分支了，想修改为master怎么办呢？那只能采用修改分支名的方法嘞。</p>
<p>ps：这个时候查看分支git branch是不会显示任何分支的。因为git的分支必须指向一个commit，没有任何commit就没有任何分支，提交第一个commit后git自动创建master分支。</p>
<p>继续提交操作：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">add</span> .</span><br><span class="line"><span class="symbol">git</span> commit -m <span class="string">&quot;git init&quot;</span></span><br><span class="line"><span class="symbol">git</span> branch</span><br><span class="line">* master  <span class="comment">//出现了。</span></span><br></pre></td></tr></table></figure>
<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">git branch<span class="comment"> //查看本地所有分支</span></span><br><span class="line">git branch -r<span class="comment"> //查看远程所有分支</span></span><br><span class="line">git branch -<span class="keyword">a</span><span class="comment"> //查看本地和远程所有分支</span></span><br></pre></td></tr></table></figure>
<p>如果是远程分支则前面会有<code>remotes/</code></p>
<h2 id="修改分支名"><a href="#修改分支名" class="headerlink" title="修改分支名"></a>修改分支名</h2><p>假设该分支还没有推送到远程，可以使用下面的命令：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">branch </span>-m &lt;name&gt;</span><br><span class="line">示例：</span><br><span class="line">git <span class="keyword">branch </span>-m master</span><br></pre></td></tr></table></figure>
<h2 id="git-中一些选项解释"><a href="#git-中一些选项解释" class="headerlink" title="git 中一些选项解释"></a>git 中一些选项解释</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-d  <span class="attr">--delete</span>：删除</span><br><span class="line">-D  <span class="attr">--delete</span> <span class="attr">--force</span>的快捷键</span><br><span class="line">-f  <span class="attr">--force</span>：强制</span><br><span class="line">-m  <span class="attr">--move</span>：移动或重命名</span><br><span class="line">-M  <span class="attr">--move</span> <span class="attr">--force</span>的快捷键</span><br><span class="line">-<span class="attribute">r</span>  <span class="attr">--remote</span>：远程</span><br><span class="line">-<span class="selector-tag">a</span>  <span class="attr">--all</span>：所有</span><br></pre></td></tr></table></figure>
<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>如果想多人协作，那么就需要给本地仓库添加一个远程仓库。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add </span>&lt;<span class="keyword">shortname&gt; </span>&lt;url&gt;</span><br><span class="line">示例：</span><br><span class="line">git remote <span class="keyword">add </span><span class="keyword">origin </span>xxx.git</span><br></pre></td></tr></table></figure>
<p>shortname就代表url相当于起个名字，方便后续操作。当然如果你不嫌麻烦直接用url也是可以的，有时候也确实会直接用url。</p>
<h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git remote</span><br><span class="line">git remote -v</span><br><span class="line">git remote <span class="built_in">show</span> <span class="built_in">origin</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">➜  gitdemoprj git:(<span class="literal">master</span>) git remote</span><br><span class="line">origin</span><br><span class="line">➜  gitdemoprj git:(<span class="literal">master</span>) git remote -v  //查看远程仓库详细信息，会展示出对应url</span><br><span class="line">origin	example.git (fetch)</span><br><span class="line">origin	example.git (push)</span><br><span class="line">➜  gitdemoprj git:(<span class="literal">master</span>) git remote show origin //更加详细的信息</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: example.git</span><br><span class="line">  Push  URL: example.git</span><br><span class="line">  HEAD branch: <span class="keyword">master</span></span><br><span class="line">  <span class="title">Remote</span> branch:</span><br><span class="line">    <span class="keyword">master</span> <span class="title">tracked</span></span><br><span class="line">  Local <span class="keyword">ref</span> configured for &#x27;git push&#x27;:</span><br><span class="line">    <span class="keyword">master</span> <span class="title">pushes</span> to <span class="keyword">master</span> <span class="title">(up</span> to <span class="keyword">date</span>)</span><br></pre></td></tr></table></figure>
<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p><strong>git push</strong> 命令用于将本地的分支版本上传到远程并合并。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git push <span class="tag">&lt;<span class="name">远程主机名</span>&gt;</span> <span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span>:<span class="tag">&lt;<span class="name">远程分支名</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从这个语法可以知道可以将本地分支推送到远程的别的分支上去，如果远程分支不存在则会自动创建。</p>
<p>如果本地分支名与远程分支名相同，则可以省略冒号：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git push <span class="tag">&lt;<span class="name">远程主机名</span>&gt;</span> <span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git push origin <span class="keyword">master</span> <span class="title">//等价于git</span> push origin <span class="literal">master</span>:<span class="literal">master</span></span><br></pre></td></tr></table></figure>
<p>如果本地版本与远程版本有差异，但又要强制推送可以使用 —force 参数：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> --force <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure>
<p>-f选项需要慎重考虑，但如果一个分支跟踪的都是一些自动生成的东西，那么强制推送就很有用。相当于忽略远程的内容都使用本次提交的。</p>
<p>git push可以将一个完全是本地仓库的内容推送到某个远程仓库的某个分支。这个太强了。</p>
<p>eg：将本地master分支的内容推送到远程仓库<code>git@github.com:example.git</code> 的autopage分支。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">git push -f git<span class="keyword">@github</span>.<span class="attribute">com</span>:example.git <span class="attribute">master</span>:autopage</span><br></pre></td></tr></table></figure>
<h2 id="拉取远程仓库"><a href="#拉取远程仓库" class="headerlink" title="拉取远程仓库"></a>拉取远程仓库</h2><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git pull <span class="tag">&lt;<span class="name">远程主机名</span>&gt;</span> <span class="tag">&lt;<span class="name">远程分支名</span>&gt;</span>:<span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span></span><br><span class="line">git pull //如果远程分支是与当前分支合并，可以简写</span><br></pre></td></tr></table></figure>
<h2 id="设置本地分支跟踪远程分支"><a href="#设置本地分支跟踪远程分支" class="headerlink" title="设置本地分支跟踪远程分支"></a>设置本地分支跟踪远程分支</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/<span class="tag">&lt;<span class="name">远程分支名</span>&gt;</span> <span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span></span><br><span class="line">git branch -u origin/<span class="tag">&lt;<span class="name">远程分支名</span>&gt;</span> <span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加远程仓库后并不意味着分支也已经设置跟踪，有时候需要手动设置。如果没有设置的话，git pull就会提示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">➜  gitdemoprj git:(master) git pull <span class="comment">--verbose</span></span><br><span class="line"><span class="keyword">From</span> github.com:xq<span class="number">-120</span>/gitdemo</span><br><span class="line"> = [up <span class="keyword">to</span> <span class="type">date</span>]      autopage   -&gt; origin/autopage</span><br><span class="line"> = [up <span class="keyword">to</span> <span class="type">date</span>]      master     -&gt; origin/master</span><br><span class="line">There <span class="keyword">is</span> <span class="keyword">no</span> tracking information <span class="keyword">for</span> the <span class="keyword">current</span> branch.</span><br><span class="line">Please specify which branch you want <span class="keyword">to</span> merge <span class="keyword">with</span>.</span><br></pre></td></tr></table></figure>
<p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br><span class="line">//打印</span><br><span class="line">* <span class="keyword">master</span> <span class="title">abae279</span> git init</span><br></pre></td></tr></table></figure>
<p>可以看到本地master分支还没有跟踪任何远程分支。</p>
<p>示例：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">➜  gitdemoprj git:(<span class="literal">master</span>) git branch -u origin/<span class="keyword">master</span> <span class="title">master</span></span><br><span class="line">branch &#x27;<span class="literal">master</span>&#x27; set up to track &#x27;origin/<span class="literal">master</span>&#x27;.</span><br><span class="line"></span><br><span class="line">➜  gitdemoprj git:(<span class="literal">master</span>) git branch -vv</span><br><span class="line">* <span class="keyword">master</span> <span class="title">abae279</span> [origin/<span class="literal">master</span>] git init  //本地<span class="literal">master</span>分支已设置跟踪远程分支origin/<span class="literal">master</span>。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查看tag<code>git tag —list</code></p>
</li>
<li><p>获取指定的tag处代码<code>git checkout tag</code><br>例如：git checkout v0.1.0</p>
</li>
<li><p>创建本地分支<code>git branch 分支名</code></p>
</li>
<li><p>提交本地分支到服务器<code>git push origin &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</code></p>
</li>
<li><p>删除本地分支<code>git branch -d &lt;BranchName&gt;</code><br>注意:处于当前分支是不能进行删除分支自身操作的.</p>
</li>
<li><p>删除远程分支<code>git push origin :分支名</code></p>
</li>
<li><p>根据tag创建分支<code>git branch &lt;new-branch-name&gt; &lt;tag-name&gt;</code>会根据tag创建新的分支.<br>例如:git branch newbranch v1.0 . 会以tag v1.0创建新的分支newbranch.</p>
</li>
<li><p>git ignore文件</p>
<p>如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了。git清除本地缓存命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git rm <span class="operator">-</span>r <span class="comment">--cached .</span></span><br><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git <span class="keyword">commit</span> <span class="operator">-</span>m <span class="string">&#x27;update .gitignore&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><ol>
<li><p>git首次切换到已经存在的分支.<br>先查看分支<code>git branch -a</code>再<code>git checkout origin/dev</code>这个时候已经出现了dev分支，但是我们不在这个分支上.可以执行一下:<br><code>git branch -l</code>看看我们当前处于哪个分支上.这个时候我们再执行一下：<code>git checkout dev</code>就可以了.</p>
</li>
<li><p>如果已经切换过了则只需要<code>git checkout 分支名</code></p>
</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-fatal-refusing-to-merge-unrelated-histories"><a href="#1-fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="1.fatal: refusing to merge unrelated histories"></a>1.fatal: refusing to merge unrelated histories</h3><p>场景描述：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2024-02-11%2012.10.50.png" style="zoom:50%;" /></p>
<p>本地的autopage分支是从master分支拉出来的，然后设置了跟踪远程origin/autopage分支，执行git pull时报上述错误，原因就是远程origin/autopage分支和本地autopage分支没有公共节点，也就是毫不相关，git无法帮你自动进行合并。两个分支的内容如下确实没有任何关系，所以需要自己决定如何合并：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2024-02-11%2012.14.58.png" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2024-02-11%2012.15.13.png" style="zoom:50%;" /></p>
<p>解决办法：加参数—allow-unrelated-histories</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git pull <span class="comment">--allow-unrelated-histories</span></span><br></pre></td></tr></table></figure>
<p>下面是合并后的图表：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2024-02-11%2012.25.50.png" style="zoom:50%;" /></p>
<p>执行完成后远程的内容原封不动保存在本地分支。</p>
<h3 id="2-终端git-status无法显示汉字，而是一堆utf8编码"><a href="#2-终端git-status无法显示汉字，而是一堆utf8编码" class="headerlink" title="2.终端git status无法显示汉字，而是一堆utf8编码"></a>2.终端git status无法显示汉字，而是一堆utf8编码</h3><p>解决办法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013760174128707b935b0be6fc4fc6ace66c4f15618f8d000">多人协作</a></p>
<p><a href="https://blog.csdn.net/qq_39671159/article/details/81261049">git branch不显示本地分支的问题（二）</a></p>
<p><a href="https://www.runoob.com/git/git-push.html">Git教程</a>  4</p>
<p><a href="https://www.progit.cn">Pro Git</a>  5</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>域名简介</title>
    <url>/2018/07/09/%E5%9F%9F%E5%90%8D%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="根域名"><a href="#根域名" class="headerlink" title="根域名"></a>根域名</h2><p>在有些场合，<code>www.example.com</code>被写成<code>www.example.com.</code>，即最后还会多出一个点。这个点就是根域名。</p>
<p>理论上，所有域名查询都必须先查询根域名，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，ICANN 维护着一张列表，里面记载着顶级域名和对应的托管商。</p>
<h2 id="顶级域名-TLDs"><a href="#顶级域名-TLDs" class="headerlink" title="顶级域名(TLDs)"></a>顶级域名(TLDs)</h2><p>Top-level domains，first-level domains.<br>顶级域名是域名的最后一个部分，即是域名最后一点之后的字母，例如在example.com这个域名中，顶级域是.com（或.COM），大小写视为相同。</p>
<h2 id="二级域名-SLD"><a href="#二级域名-SLD" class="headerlink" title="二级域名(SLD)"></a>二级域名(SLD)</h2><p>second-level domain,最靠近顶级域名左侧的字段。如：zh.wikipedia.org中，wikipedia就是二级域名.</p>
<h2 id="父域名、子域名"><a href="#父域名、子域名" class="headerlink" title="父域名、子域名"></a>父域名、子域名</h2><p>这是一个相对概念.<br>如 www.sina.com.cn  和 news.sina.com.cn 都是 sina.com.cn 的子域名（或称为二级域名）， sina.com.cn 就是父域名。</p>
<p>同样，sina.com.cn 其实又可以看作是 .com.cn 的子域名；而 com.cn 又是 .cn 的一个子域名。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/88c8ba682ac7">3分钟搞懂顶级域名|二级域名|子域名|父域名的区别</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2018/05/root-domain.html">根域名的知识</a></p>
<p><a href="https://www.guokeyun.com/news/technology/detail/147.html?navId=22">浅谈域名分级及域名解析过程</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title>图片压缩笔记</title>
    <url>/2018/07/09/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="图片压缩笔记"><a href="#图片压缩笔记" class="headerlink" title="图片压缩笔记"></a>图片压缩笔记</h2><h3 id="压缩方法"><a href="#压缩方法" class="headerlink" title="压缩方法"></a>压缩方法</h3><p>工程里图片压缩方法过程:传入一张图片,压缩后,再转回图片.加上上传到服务器的整个过程如下:<br>UIImage-大力压缩-&gt;NSData(A)-&gt;UIImage-UIImageJPEGRepresentation(img, 1)-&gt;NSData(B)-&gt;服务器.</p>
<p>测试发现dataB要比dataA大很多很多.导致实际上传给服务器的数据远远不止600kb.eg某次上传的头像:4.56Mb(原图,压缩前)-&gt;579.16kb(压缩后)-&gt;2.93Mb(实际上传).实际上传的数据是2.93Mb</p>
<p>因此再转回UIImage是多余且错的.而应该压缩后直接上传服务器,即UIImage-大力压缩-&gt;NSData(A)-&gt;服务器.</p>
<p>正确的压缩方法为:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定压缩阈值,压缩图片</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)za_compressImage:(<span class="built_in">UIImage</span> *)image toMaxFileSize:(<span class="built_in">NSInteger</span>)maxFileSize &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> compression = <span class="number">0.9</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> minCompression = <span class="number">0.1</span>f;</span><br><span class="line">    <span class="built_in">NSData</span> *imageData = <span class="built_in">UIImageJPEGRepresentation</span>(image, compression);</span><br><span class="line">    <span class="keyword">while</span> ([imageData length] &gt; maxFileSize &amp;&amp; compression &gt; minCompression) &#123;</span><br><span class="line">        compression -= <span class="number">0.05</span>;</span><br><span class="line">        imageData = <span class="built_in">UIImageJPEGRepresentation</span>(image, compression);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图片处理</category>
      </categories>
      <tags>
        <tag>图片压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>PINCache使用注意事项</title>
    <url>/2018/07/18/PINCache%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="PINCache使用注意事项"><a href="#PINCache使用注意事项" class="headerlink" title="PINCache使用注意事项"></a>PINCache使用注意事项</h3><p>默认的[PINCache sharedCache] 文件保存在目录/Library/Caches/com.pinterest.PINDiskCache.PINCacheShared 在磁盘空间不足时/Caches目录下的所有文件都会被系统自动清除,不适合存储用户信息,登录状态等相关数据.</p>
<p>诡异BUG<br><strong>现象</strong><br>用户在APP中登录成功后,每隔一段时间(大概2-3个小时),再次打开App后,App没有进入首页而是到了登录页.由于不是必现,所以难以分析其具体原因.</p>
<p><strong>分析解决</strong><br>经过个把星期的纠缠,终于发现原因:在写的时候将登录成功后的token使用[PINCache sharedCache]保存了,而它的默认保存路径就是在/Caches目录下,对于那些磁盘空间一直徘徊在200-300M的手机,系统会周期性的清理各个App的/Caches目录下的所有文件,来释放部分磁盘空间.这时token就被清理了,而启动时是先从文件中取token进行判断,由于已被清除,自然也取不到,因此进入了登录页.解决办法:换一个路径保存就可以了.</p>
]]></content>
      <categories>
        <category>第三方库使用</category>
      </categories>
  </entry>
  <entry>
    <title>navigationBar对self.view的frame影响</title>
    <url>/2018/06/10/navigationBar%E5%AF%B9self.view%E7%9A%84frame%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h3 id="navigationBar对self-view的frame影响"><a href="#navigationBar对self-view的frame影响" class="headerlink" title="navigationBar对self.view的frame影响"></a>navigationBar对self.view的frame影响</h3><p>在iOS7及以上系统,<code>self.navigationController.navigationBar.hidden = NO;</code>的情况下.</p>
<p><strong>设置translucent为YES</strong>.即<code>self.navigationController.navigationBar.translucent = YES;</code></p>
<blockquote>
<p>不隐藏状态栏</p>
</blockquote>
<p>self.view的位置和大小如下:</p>
<p><img src="http://7xqoji.com1.z0.glb.clouddn.com/self.view%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%A4%A7%E5%B0%8F1@2x.png" alt=""></p>
<blockquote>
<p>隐藏状态栏</p>
</blockquote>
<p><img src="http://7xqoji.com1.z0.glb.clouddn.com/self.view%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%A4%A7%E5%B0%8F2@2x.png" alt=""></p>
<p>执行流:<br><img src="http://7xqoji.com1.z0.glb.clouddn.com/navigationBar%E5%AF%B9self.view%E7%9A%84frame%E5%BD%B1%E5%93%8D_3.png" alt=""></p>
<p>translucent为YES时,可以在viewDidLoad中子视图可以使用self.view的frame信息.</p>
<p><strong>设置translucent为NO</strong>,即<code>self.navigationController.navigationBar.translucent = NO;</code></p>
<blockquote>
<p>不隐藏状态栏</p>
</blockquote>
<p>self.view的位置和大小如下:</p>
<p><img src="http://7xqoji.com1.z0.glb.clouddn.com/navigationBar%E5%AF%B9self.view%E7%9A%84frame%E5%BD%B1%E5%93%8D_4.png" alt=""></p>
<blockquote>
<p>隐藏状态栏</p>
</blockquote>
<p><img src="http://7xqoji.com1.z0.glb.clouddn.com/navigationBar%E5%AF%B9self.view%E7%9A%84frame%E5%BD%B1%E5%93%8D_5.png" alt=""></p>
<p>执行流:</p>
<p><img src="http://7xqoji.com1.z0.glb.clouddn.com/navigationBar%E5%AF%B9self.view%E7%9A%84frame%E5%BD%B1%E5%93%8D_6.png" alt=""></p>
<p>self.view在viewDidLoad,viewWillAppear中的origin,size都不对.在viewWillLayoutSubviews,viewDidLayoutSubviews中size是对的,origin不对.在viewDidAppear中origin,size才都对.</p>
<p>因此在这种情况下,self.view的子视图布局最好在viewWillLayoutSubviews中进行调整.</p>
<p>当设置<code>self.navigationController.navigationBar.hidden = YES;</code>时,则navigationBar的translucent属性不再对self.view的frame产生影响.</p>
<h4 id="translucent属性"><a href="#translucent属性" class="headerlink" title="translucent属性"></a>translucent属性</h4><p>由于translucent属性对self.view的frame会产生影响,所以有必要查看它的说明.</p>
<p>官方说明:</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">The <span class="keyword">default</span> value <span class="keyword">is</span> YES. <span class="keyword">If</span> the navigation bar <span class="keyword">has</span> a custom background image, the <span class="keyword">default</span> <span class="keyword">is</span> YES <span class="keyword">if</span> any pixel <span class="keyword">of</span> the image <span class="keyword">has</span> an alpha value <span class="keyword">of</span> less than <span class="number">1.0</span>, <span class="keyword">and</span> NO otherwise.</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you <span class="keyword">set</span> this <span class="keyword">property</span> <span class="keyword">to</span> YES <span class="keyword">on</span> a navigation bar <span class="keyword">with</span> an opaque custom background image, the navigation bar applies a system-defined opacity <span class="keyword">of</span> less than <span class="number">1.0</span> <span class="keyword">to</span> the image.</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you <span class="keyword">set</span> this <span class="keyword">property</span> <span class="keyword">to</span> NO <span class="keyword">on</span> a navigation bar <span class="keyword">with</span> a translucent custom background image, the navigation bar provides an opaque background <span class="keyword">for</span> the image <span class="keyword">using</span> black <span class="keyword">if</span> the navigation bar <span class="keyword">has</span> UIBarStyleBlack style, white <span class="keyword">if</span> the navigation bar <span class="keyword">has</span> UIBarStyleDefault, <span class="keyword">or</span> the navigation bar’s barTintColor <span class="keyword">if</span> a custom value <span class="keyword">is</span> defined.</span><br></pre></td></tr></table></figure>
<p>大意为:<br>该属性默认为YES.但是如果给导航栏设置了一张自定义的背景图片,如果该图片有一个alpha&lt;1的像素.那么该值就为YES,否则为NO.(设置导航栏的背景图片会影响translucent的默认值)</p>
<p>另外如果手动设置了该属性,并且设置了导航栏的背景图,则系统可能会对背景图进行处理:</p>
<ol>
<li>如果设置该属性为YES,但是提供了一张不透明的背景图,系统会对该背景图进行半透明处理.</li>
<li>如果设置该属性为NO,但是提供了一张半透明的背景图,则系统会对该背景图进行不透明处理.具体是根据导航栏的style或者barTintColor进行处理.</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在iOS7及以上系统:</p>
<ol>
<li><p>当导航栏没有被隐藏时,且translucent属性设置为YES,那么,VC的self.view的位置是从(0,0)开始,大小是整个屏幕宽高.而当translucent属性设置为NO时,那么VC的self.view的位置是从导航栏左下角开始,宽是屏幕的宽,高是整个屏幕减去导航栏的CGRectGetMaxY.</p>
</li>
<li><p>导航栏的y值会随着状态栏隐藏与否而有20pt的偏移.</p>
</li>
<li><p>当导航栏被隐藏时,VC的self.view的位置是从(0,0)开始,大小是整个屏幕宽高.</p>
</li>
<li><p>self.view的子视图布局推荐在viewWillLayoutSubviews中进行.因为此时不管translucent为何值,self.view的size都是正确的.</p>
</li>
</ol>
<hr>
<p>吐槽Jekyll</p>
<p>写在</p>
<p>```</p>
<p>Xcode的日志</p>
<p>```</p>
<p>这里面的日志,包含了View的frame打印,居然导致Jekyll构建页面失败,说什么变量未正确关闭,最后只好一张张截图.这解析功能也太差了吧.</p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIViewController</tag>
        <tag>translucent</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS app文件系统介绍</title>
    <url>/2018/07/18/iOS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="iOS-app文件系统"><a href="#iOS-app文件系统" class="headerlink" title="iOS app文件系统"></a>iOS app文件系统</h2><p>app沙盒：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/540C1C9A-29B1-4CD6-ACB3-84610E052426.png" style="zoom:50%;" /></p>
<h3 id="AppName-app"><a href="#AppName-app" class="headerlink" title="AppName.app"></a>AppName.app</h3><p>app的bundle。该目录包含APP程序及开发过程中用到的本地资源。该目录是只读的，不可修改否则APP将无法启动。</p>
<h3 id="Documents目录"><a href="#Documents目录" class="headerlink" title="Documents目录"></a>Documents目录</h3><p>说明：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Use this <span class="built_in">directory</span> <span class="built_in">to</span> store user-generated content. The contents <span class="keyword">of</span> this <span class="built_in">directory</span> can be made available <span class="built_in">to</span> <span class="keyword">the</span> user through <span class="built_in">file</span> sharing; therefore, this <span class="built_in">directory</span> should only contain <span class="built_in">files</span> that you may wish <span class="built_in">to</span> expose <span class="built_in">to</span> <span class="keyword">the</span> user.</span><br><span class="line"></span><br><span class="line">The contents <span class="keyword">of</span> this <span class="built_in">directory</span> are backed up <span class="keyword">by</span> iTunes <span class="keyword">and</span> iCloud.</span><br></pre></td></tr></table></figure>
<p>Documents目录主要放置用户创建的相关内容，比如用户的动态，消息数据库等。Documents目录应该仅存放你想暴露给用户的文件。该目录下的文件都会被备份到iTunes和iCloud。</p>
<h3 id="Library目录"><a href="#Library目录" class="headerlink" title="Library目录"></a>Library目录</h3><p>该目录下有几个系统创建的子目录,用的比较多的是/Caches和/Preferences.</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">/Library</span></span><br><span class="line">	 <span class="string">/Application</span> Support</span><br><span class="line">	 <span class="string">/Caches</span></span><br><span class="line">	 <span class="string">/Preferences</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">This is <span class="keyword">the</span> top-level <span class="built_in">directory</span> <span class="keyword">for</span> <span class="keyword">any</span> <span class="built_in">files</span> that are <span class="keyword">not</span> user data <span class="built_in">files</span>. You typically <span class="built_in">put</span> <span class="built_in">files</span> <span class="keyword">in</span> <span class="literal">one</span> <span class="keyword">of</span> several standard subdirectories. iOS apps commonly use <span class="keyword">the</span> Application Support <span class="keyword">and</span> Caches subdirectories; however, you can <span class="built_in">create</span> custom subdirectories.</span><br><span class="line"></span><br><span class="line">Use <span class="keyword">the</span> Library subdirectories <span class="keyword">for</span> <span class="keyword">any</span> <span class="built_in">files</span> you don’t want exposed <span class="built_in">to</span> <span class="keyword">the</span> user. Your app should <span class="keyword">not</span> use these <span class="built_in">directories</span> <span class="keyword">for</span> user data <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">The contents <span class="keyword">of</span> <span class="keyword">the</span> Library <span class="built_in">directory</span> (<span class="keyword">with</span> <span class="keyword">the</span> exception <span class="keyword">of</span> <span class="keyword">the</span> Caches subdirectory) are backed up <span class="keyword">by</span> iTunes <span class="keyword">and</span> iCloud.</span><br></pre></td></tr></table></figure>
<p>Library目录下面有三个系统创建的子目录分别是Application Support，Caches，Preferences，当然你也可以创建自己的子目录。Library目录下通常放一些不想暴露给用户的文件，比如日志文件。</p>
<p>Library目录下除了Caches文件夹，其他的文件都会被备份到iTunes和iCloud。</p>
<h4 id="Caches目录"><a href="#Caches目录" class="headerlink" title="Caches目录"></a>Caches目录</h4><p>In iOS 5.0 and later, <strong>the system may delete the Caches directory on rare occasions when the system is very low on disk space.</strong> This will never occur while an app is running. However, be aware that restoring from backup is not necessarily the only condition under which the Caches directory can be erased.</p>
<blockquote>
<p>在手机磁盘不足时,系统会周期性的将不在运行状态APP的Caches目录下的所有文件删除.已经亲身经历过是真的,所以不要将重要数据保存在该目录下.否则出bug时你绝对会想不到是这个原因,而且这样的bug复现难度很大.网上有一些文章中说”系统不会清理 cache 目录中的文件”实属误人子弟,也不知道他们是从哪看到的结论.</p>
</blockquote>
<p>由于Caches目录下的文件可能会被系统主动删除，所以Caches目录只适合放一些可重建的，可再次下载的文件，比如图片缓存等。千万不要放不可重建的重要数据，比如存放token信息等，否则出了bug，会很难排查。</p>
<h4 id="Preferences目录"><a href="#Preferences目录" class="headerlink" title="Preferences目录"></a>Preferences目录</h4><p>NSUserDefaults保存的东西就在/Preferences目录.</p>
<h3 id="tmp目录"><a href="#tmp目录" class="headerlink" title="tmp目录"></a>tmp目录</h3><p>说明：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Use this <span class="built_in">directory</span> <span class="built_in">to</span> <span class="built_in">write</span> temporary <span class="built_in">files</span> that <span class="built_in">do</span> <span class="keyword">not</span> need <span class="built_in">to</span> persist between launches <span class="keyword">of</span> your app. Your app should remove <span class="built_in">files</span> <span class="built_in">from</span> this <span class="built_in">directory</span> when they are no longer needed; however, <span class="keyword">the</span> <span class="keyword">system</span> may purge this <span class="built_in">directory</span> when your app is <span class="keyword">not</span> running.</span><br><span class="line"></span><br><span class="line">The contents <span class="keyword">of</span> this <span class="built_in">directory</span> are <span class="keyword">not</span> backed up <span class="keyword">by</span> iTunes <span class="keyword">or</span> iCloud.</span><br></pre></td></tr></table></figure>
<p>由于系统在APP不在运行时会清除该目录下的内容。因此tmp目录只适合存放一些临时文件，比如下载过程中产生的临时文件。这些临时文件不再需要时应该及时删除。</p>
<p>tmp目录下的文件不会被备份到iTunes和iCloud。</p>
<h3 id="获取沙盒路径"><a href="#获取沙盒路径" class="headerlink" title="获取沙盒路径"></a>获取沙盒路径</h3><p>NSHomeDirectory()</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *homePath = <span class="built_in">NSHomeDirectory</span>();</span><br><span class="line">    <span class="built_in">NSString</span> *documentsPath = [homePath stringByAppendingPathComponent:<span class="string">@&quot;Documents&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *libraryPath = [homePath stringByAppendingPathComponent:<span class="string">@&quot;Library&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;documentsPath:%@&quot;</span>, documentsPath);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;libraryPath:%@&quot;</span>, libraryPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *documentsPath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).lastObject;</span><br><span class="line">    <span class="built_in">NSString</span> *libraryPath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).lastObject;</span><br><span class="line">    <span class="built_in">NSString</span> *libraryCachePath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).lastObject;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;documentsPath:%@&quot;</span>, documentsPath);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;libraryPath:%@&quot;</span>, libraryPath);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;libraryCachePath:%@&quot;</span>, libraryCachePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">NSString</span> *cachePath = [<span class="built_in">NSFileManager</span>.defaultManager URLsForDirectory:<span class="built_in">NSCachesDirectory</span> inDomains:<span class="built_in">NSUserDomainMask</span>].lastObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面写法，结果是一样的。</span></span><br></pre></td></tr></table></figure>
<p>注意：NSSearchPathForDirectoriesInDomains函数的最后一个参数必须为YES。</p>
<p>注意：不要想着保存获取到的沙盒路径结果用于下一次使用，因为沙盒路径每次启动都会变化。使用上一次的结果是没法访问到你保存的文件的，你只需要保存相对路径比如：/Library/MyFolder/xxx.file。下一次取的时候使用NSHomeDirectory拼接即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/e6d3f7c4baed">关于 iOS 删除缓存的那些事儿</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW1">官方文档</a></p>
<h2 id="简要笔记"><a href="#简要笔记" class="headerlink" title="简要笔记"></a>简要笔记</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">-沙盒</span><br><span class="line"> -xxx.app app的<span class="keyword">bundle，只读。</span></span><br><span class="line"><span class="keyword"></span> -Documents 存放用户产生的文件，比如IM数据库，用户的作品</span><br><span class="line"> -Library 存放非用户产生的文件，比如日志文件</span><br><span class="line">  -<span class="keyword">Caches </span>缓存文件，比如图片，视频等等，内存不足会被系统删除</span><br><span class="line">  -<span class="keyword">Preferences </span>NSUserDefaults的kv</span><br><span class="line"> -Temp 存放临时文件，比如下载资源时的临时存放，内存不足会被系统删除</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>iOS文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算字符串占用的字节长度</title>
    <url>/2018/07/15/%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E7%94%A8%E7%9A%84%E5%AD%97%E8%8A%82%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="计算字符串占用的字节长度"><a href="#计算字符串占用的字节长度" class="headerlink" title="计算字符串占用的字节长度"></a>计算字符串占用的字节长度</h3><p><strong>前提</strong></p>
<p>需要了解字符的编码规则.使用不同的编码规则会得到不同的结果.</p>
<p><strong>API</strong></p>
<p><code>- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;        // Result in O(n) time; the result is exact. Returns 0 on error (cannot convert to specified encoding, or overflow)</code></p>
<p><strong>示例</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *chString = <span class="string">@&quot;中国abc&quot;</span>;</span><br><span class="line"><span class="built_in">NSUInteger</span> utf8Bytes = [chString lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;utf8Bytes:%ld&quot;</span>, utf8Bytes); <span class="comment">//9</span></span><br><span class="line"><span class="built_in">NSUInteger</span> unicodeBytes = [chString lengthOfBytesUsingEncoding:<span class="built_in">NSUnicodeStringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;unicodeBytes:%ld&quot;</span>, unicodeBytes); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>天朝目前强制使用的是GB18030.</p>
<p>在<code>CFStringEncodingExt.h</code>里面包含了其他编码枚举.如:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">kCFStringEncodingGB_2312_80</span> = <span class="number">0</span>x0630,</span><br><span class="line"><span class="attr">kCFStringEncodingGBK_95</span> = <span class="number">0</span>x0631,		/* annex to GB <span class="number">13000</span>-<span class="number">93</span><span class="comment">; for Windows 95 */</span></span><br><span class="line"><span class="attr">kCFStringEncodingGB_18030_2000</span> = <span class="number">0</span>x0632,</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSStringEncoding</span> GBEncoding = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingGB_18030_2000);</span><br><span class="line"><span class="built_in">NSUInteger</span> gbBytes = [chString lengthOfBytesUsingEncoding: GBEncoding];  <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Printing</span> description of gbCodeChData:</span><br><span class="line"><span class="section">&lt;d6d0b9fa 616263&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意:<strong>将字符串转换为NSData,再获取NSData的length,在使用Unicode编码时它会不等于使用lengthOfBytesUsingEncoding获取到的值.主要是由于大端和小端导致的.Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。如果一个文本文件的头两个字节是FE FF，就表示该文件采用大端方式；如果头两个字节是FF FE，就表示该文件采用小端方式。</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSData</span>* utf8ChData = [chString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSData</span>* unicodeChData = [chString dataUsingEncoding:<span class="built_in">NSUnicodeStringEncoding</span>];</span><br><span class="line"><span class="built_in">NSUInteger</span> utf8ChLength = utf8ChData.length; <span class="comment">//9</span></span><br><span class="line"><span class="built_in">NSUInteger</span> unicodeChLength = unicodeChData.length; <span class="comment">//12.不等于上面的10.这是由于Unicode编码后转为二进制传输时前面要加上FEFF/FFFE这两个字节.</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;utf8ChLength:%ld,unicodeChLength:%ld&quot;</span>, utf8ChLength, unicodeChLength);</span><br></pre></td></tr></table></figure>
<p>打印如下:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Printing</span> description of utf8ChData:</span><br><span class="line"><span class="section">&lt;e4b8ade5 9bbd6162 63&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Printing</span> description of unicodeChData:</span><br><span class="line"><span class="section">&lt;fffe2d4e fd566100 62006300&gt;</span></span><br></pre></td></tr></table></figure>
<p>疑问:</p>
<p>Q1:对于一串编码后得到的二进制数据,接收方如何知道该用哪种方式解码呢?<br>A1:这就需要发送方和接收方事先确定一种编码方式.这样当接收到一串二进制数据后,接收方就知道该使用哪一种方式进行解码了.有点类似于协议.</p>
<p>Q2:对于UTF-16编码在转为二进制后为啥需要在最前面标记是大端还是小端.为什么UTF-8却没有看到?<br>A2:涉及到一个BOM(Byte Order Mark)概念.字面意思就是标记字节顺序的.这个标记是可选的，不过UTF8字节是没有顺序的，所以一些厂家就把它用作了另一种用途,用来检测一个字节流是否是UTF-8编码。微软做了这种检测，但有些软件不做这种检测， 而把它当作正常字符处理。微软在自己的UTF-8格式的文本文件之前加上了EF BB BF三个字节, windows上面的notepad等程序就是根据这三个字节来确定一个文本文件是ASCII的还是UTF-8的, 然而这个只是微软暗自作的标记, 其它平台上并没有对UTF-8文本文件做个这样的标记。(这里感觉微软的做法跟BOM的字面意思差的有点远了.)</p>
<p>也就是说一个UTF-8文件可能有BOM，也可能没有BOM，那么怎么区分呢？<br>三种方法。参考:<a href="http://blog.163.com/result_2205/blog/static/13981945020102954023564/">EF BB BF</a></p>
<ol>
<li>用UltraEdit-32打开文件，切换到十六进制编辑模式，察看文件头部是否有EF BB BF。  </li>
<li>用Dreamweaver打开，察看页面属性，看“包括Unicode签名BOM”前面是否有个勾。</li>
<li>用Windows的记事本打开，选择 “另存为”，看文件的默认编码是UTF-8还是ANSI，如果是ANSI则不带BOM。</li>
</ol>
<p>反正,Mac上对于UTF-8编码的是没有看到EF BB BF这样的字样.PC上可能有.之所以UTF-16需要而UTF-8不需要,是由于二者编码规则的不一样.UTF-16就是原始的Unicode编码,所以就涉及到解读顺序的问题.但UTF-8的规则使得它不存在解读顺序的问题.</p>
<p>Q3:对于一个数字字符串”123”,发送方在TCP传输时是先传高位还是先传低位?接收方的存储顺序是怎样的?读取时的顺序又是怎样的?如何测试?<br>A3:网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。</p>
<p>参考:</p>
<p><a href="https://blog.csdn.net/anningzte/article/details/52125665">大端、小端与网络字节序</a></p>
<p><a href="https://www.cnblogs.com/jacktu/archive/2008/11/24/1339789.html">网络字节序与主机字节序</a></p>
<p>Q4:对于int整型数字123,在内存中是如何存储的?如何测试?</p>
<h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h3><h4 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h4><p>American Standard Code for Information Interchange，美国信息交换标准代码.ASCII码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。<strong>标准ASCII码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符</strong>。</p>
<p>0～31及127(共33个)是控制字符或通信专用字符.它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响.</p>
<p>32～126(共95个)是可显示字符(32是空格），其中48～57为0到9十个阿拉伯数字。<br>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
<p>ASCII编码还是很好理解的,只需查一下表就完事了.可以记住几个常用的如:0x00(0)为null,空字符;0x20(32)为空格;0x30(48)为数字0;0x41(65)为A;0x61(97)为a.</p>
<h4 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h4><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。</p>
<p>Unicode编码的出现就是为了解决这一问题.它将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，这样乱码问题就解决了。</p>
<p><strong>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</strong></p>
<p>Unicode编码系统可分为编码方式和实现方式两个层次。</p>
<blockquote>
<p>Unicode的编码方式</p>
</blockquote>
<p>Unicode的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示2^16（即65536）个字符。基本满足各种语言的使用。实际上当前版本的统一码并未完全使用这16位编码，而是保留了大量空间以作为特殊使用或将来扩展。</p>
<p>可以看到Unicode对汉字支持不怎么好，这也是没办法的， 简体和繁体总共有六七万个汉字，而UCS-2最多能表示65536个，才六万 多个，所以Unicode只能排除一些几乎不用的汉字，好在常用的简体汉字 也不过七千多个，为了能表示所有汉字，Unicode也有UCS-4规范，就是用 4个字节来编码字符.</p>
<p>参考:<a href="https://www.cnblogs.com/csguo/p/7401874.html">Unicode编码表</a></p>
<p>Unicode编码表中的0x4E00-0x9FBF为CJK 统一表意符号 (CJK Unified Ideographs,中日韩统一表意文字).</p>
<blockquote>
<p>Unicode的实现方式</p>
</blockquote>
<p>Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF） </p>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的<strong>可变长度字符编码</strong>，又称万国码，由Ken Thompson于1992年创建。现在已经标准化为RFC 3629。UTF-8用1到6个字节编码Unicode字符。</p>
<blockquote>
<p>UTF-8与Unicode的关系  </p>
</blockquote>
<p>UTF-8 是 Unicode 的实现方式之一。</p>
<h5 id="UTF-8编码规则"><a href="#UTF-8编码规则" class="headerlink" title="UTF-8编码规则"></a>UTF-8编码规则</h5><p>UTF-8 的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>
<p>2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<h4 id="GB-2312—1980"><a href="#GB-2312—1980" class="headerlink" title="GB 2312—1980"></a>GB 2312—1980</h4><p>《信息交换用汉字编码字符集》是由中国国家标准总局1980年发布，1981年5月1日开始实施的一套国家标准，标准号是GB 2312—1980。<br>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB2312。</p>
<p>GB 2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。<br><strong>对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</strong></p>
<p>在使用GB2312的程序中，通常采用EUC储存方法，以便兼容于ASCII。浏览器编码表上的“GB2312”，通常都是指“EUC-CN”表示法。<br>每个汉字及符号以两个字节来表示。第一个字节称为“高位字节”（也称“区字节）”，第二个字节称为“低位字节”（也称“位字节”）。</p>
<p>其他国标码,参考:<a href="https://baike.baidu.com/item/%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E4%BB%A3%E7%A0%81/10870180?fromtitle=%E5%9B%BD%E6%A0%87%E7%A0%81&amp;fromid=9886729">国家标准代码</a></p>
<p>上面这些规定咋也看不懂,暂且先记住对于国标码来说每个汉字及符号以两个字节来表示。其他的方面有空再研究.</p>
<p>参考:<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>openURL打开应用</title>
    <url>/2018/07/18/openURL%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="openURL打开应用"><a href="#openURL打开应用" class="headerlink" title="openURL打开应用"></a>openURL打开应用</h2><h3 id="B应用打开A应用"><a href="#B应用打开A应用" class="headerlink" title="B应用打开A应用"></a>B应用打开A应用</h3><p>需要A应用设置URL Scheme,如testA,并且告知B应用.此时B应用就可以通过”testA://“打开A应用了.</p>
<p>A应用实现方法</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>application:<span class="params">(UIApplication *)</span>app openURL:<span class="params">(NSURL *)</span>url options:<span class="params">(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)</span>options</span><br><span class="line">&#123;</span><br><span class="line">    DLog<span class="params">(@<span class="string">&quot;%@&quot;</span>, app)</span>;</span><br><span class="line">    DLog<span class="params">(@<span class="string">&quot;%@&quot;</span>, url)</span>;</span><br><span class="line">    DLog<span class="params">(@<span class="string">&quot;%@&quot;</span>, options)</span>;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>只能是key=value形式,多个参数使用&amp;连接.<br><code>testA://?key1=value1&amp;key2=value2&amp;key3=value3</code></p>
<p><strong>注意</strong><br>value是一个json字符串时将打不开A应用.这是由于json字符串中的花括号和冒号都是保留字符.<br><code>testA://?p=&#123;&quot;type&quot;:2,&quot;detail&quot;:&#123;&quot;backAction&quot;:1&#125;&#125;</code></p>
<p>可以把json字符串百分号编码后传递,如下:<br><code>testA://?p=%7B%22type%22%3A2%2C%22detail%22%3A%7B%22backAction%22%3A1%7D%7D</code></p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
  </entry>
  <entry>
    <title>不小心重写了父类的某个方法导致的崩溃</title>
    <url>/2018/07/20/%E4%B8%8D%E5%B0%8F%E5%BF%83%E9%87%8D%E5%86%99%E4%BA%86%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B4%A9%E6%BA%83/</url>
    <content><![CDATA[<h3 id="不小心重写了父类的某个方法导致的崩溃"><a href="#不小心重写了父类的某个方法导致的崩溃" class="headerlink" title="不小心重写了父类的某个方法导致的崩溃"></a>不小心重写了父类的某个方法导致的崩溃</h3><p>ZAEButton类里有一个commonInit方法,该方法会注册KVO “enabled”.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> commonInit];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)commonInit</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;enabled&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;enabled&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ZAECountDownButton类为ZAEButton的子类,如果不仔细看父类的实现的话,可能也会定义一个commonInit方法.此时就是重写了该方法,虽然这并不是你的意愿.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> commonInit];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)commonInit</span><br><span class="line">&#123;</span><br><span class="line">    _duration = <span class="number">30</span>;</span><br><span class="line">    _autoCountDown = <span class="literal">YES</span>;</span><br><span class="line">    _timerStartState = ZAECountDownButtonTimerStartStateFromBegining;</span><br><span class="line">    [<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonDidClicked:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    _activityView = [[<span class="built_in">UIActivityIndicatorView</span> alloc] initWithActivityIndicatorStyle:<span class="built_in">UIActivityIndicatorViewStyleGray</span>];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:_activityView];</span><br><span class="line">    _activityView.center = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.bounds.size.width/<span class="number">2.0</span>, <span class="keyword">self</span>.bounds.size.height/<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>崩溃就这样产生了:</p>
<p>当实例化一个ZAECountDownButton对象,调用到[super initWithFrame:frame]时,由于子类和父类都有一个commonInit方法,子类会覆盖父类的方法,最终调用的是子类的commonInit方法.此时,子类就不会注册kvo,而当对象销毁时,会执行到父类的dealloc方法移除KVO,于是程序会因为KVO注册—移除不匹配而导致崩溃.</p>
<p>这或许就是有些框架中父类的初始化方法都有”_”的缘故吧.</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
  </entry>
  <entry>
    <title>定时器启示录</title>
    <url>/2018/09/21/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%90%AF%E7%A4%BA%E5%BD%95/</url>
    <content><![CDATA[<p>早些时候看过一些分析定时器内存方面的文章，但在遇到这个bug前我是不屑的。不就是定时器强引用ViewController，而ViewController再用strong属性去引用定时器，必然会导致循环引用么。解决办法也很简单，只需使用weak属性去引用定时器即可。然而这一次的经历却证明我还是图样，我单知道使用weak属性不会导致循环引用，我没注意到此时的定时器在无形中延长了ViewController的生命周期。这就为这个bug埋下了隐患。</p>
<p>记录一下bug的解决总是有必要的。</p>
<p>下午的一次自测中，偶尔发现观众端听不到主播端的声音。我先是诧异，接着是很不安，因为墨菲定律告诉我们：如果你担心某种情况发生，那么它就更有可能发生。最开始以为是主播端的问题，便仔细检查了主播端的代码，又加入了另一台手机设置为观众，作为对照。运行之后发现对照组是好的，但刚才那台手机的问题仍然偶现。这就说明主播端的推流是没问题的。接下来的工作便是在问题手机上尽可能找到复现的操作，以便根据操作路径定位大致原因。在某次频繁进入离开直播房间时，APP直接卡死了，再无任何交互的响应。问题开始变得严重，时间也一分一秒的流逝在这一次次的调试中，一晃下班时间快到了，周围开始变的嘈杂，安卓兄弟开始催我下班还说要带我上王者但我是不信的。我整理了下东西，但又不想在节前留下些许问题，便又坐了回去。等到周围开始安静时，夕阳已经西下。我努力回想之前的操作，发现只在直播预约状态下，问题才会重现。于是在页面的dealloc函数中打好断点，点击返回，果然函数没有被调用。这说明页面依然被某个对象持有而没有释放。在检查了所有Block回调都使用的是weakSelf后，最后只剩下定时器了。</p>
<p>问题的根源算是找到了。原来在直播预约状态下会启动一个定时器，但在点击返回时忘记invalid定时器了。这让定时器延长了ViewController的生命周期。加上invalid后，问题搞定，收工。回家的路上碰巧遇到了K君，便给K君讲述了这个问题，K君听后哈哈大笑说：加上invalid只能解决这一次的bug，却不能避免下一次又忘记，而且根据页面dealloc函数里逻辑的不同，bug的外在表现形式也必然不同，到时候又得花费不少的时间找bug啊。闻道于朝，不禁感叹K君的身经百战。</p>
<p>回到家后，打开谷歌又搜到了早些时候看过的那些文章，感慨颇多。系统的<code>NSTimer</code>简单却又不那么简单：</p>
<ol>
<li><p>不注意使用的话有循环引用的隐患。因为NSTimer会强引用target，如果target再强引用NSTimer那么就会发生循环引用。比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_normal_timer1 &#123;</span><br><span class="line">    <span class="keyword">self</span>.normalStrongTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSome) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.normalStrongTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">    [<span class="keyword">self</span>.normalStrongTimer fire];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就会发生循环引用。此时即使页面返回，但是因为循环引用，ViewController的dealloc将不会被执行，因此invalidate不能放在dealloc里，只能在其他时机比如viewDidDisappear里调用。所以一般使用weak来弱引用定时器，这样就可以在dealloc里调用invalidate。</p>
</li>
<li><p>需要在合适的地方invalid定时器，否则定时器会一直强引用target从而延长target的生命周期。</p>
<p>在开发中很容易忘记invalid定时器，一旦忘记invalid定时器，定时器就会延长target的生命周期，比如页面返回了但实际还没有被销毁，从而产生一些诡异问题。这也是使用NSTimer必须注意的地方。</p>
</li>
<li><p>使用时必须保证有一个活跃的runloop，并且需要指定mode。在子线程中使用不是很方便。</p>
</li>
<li><p>精度可能不够。</p>
</li>
<li><p>网上的一个说法：创建和撤销必须在同一个线程上，在多线程环境下使用不便。(这一条存疑，经过验证在子线程创建一个定时器，在另一个子线程invalidate并没有发现什么问题)</p>
</li>
<li><p>iOS10开始支持block使用，同样在使用block时一定要注意循环引用。</p>
</li>
</ol>
<p>为了从根本上避免上述问题，一个弱引用target的、能够在自身销毁时自动invalid的定时器想必是极好的，但又该如何实现呢？好在互联网在经过这么多年的发展，第三方开源库从未像现在这般丰富，唾手可得。不多时，便在GitHub上找到了<a href="https://github。com/mindsnacks/MSWeakTimer">MSWeakTimer</a>。</p>
<p><code>MSWeakTimer</code>提供了和系统<code>NSTimer</code>一致的接口，好的代码就该这样美美与共，和而不同：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) MSWeakTimer *weakTimer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.weakTimer = [MSWeakTimer scheduledTimerWithTimeInterval:<span class="number">3</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSome) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span> dispatchQueue:dispatch_get_main_queue()];</span><br><span class="line"><span class="comment">//立即触发回调方法</span></span><br><span class="line">[<span class="keyword">self</span>.weakTimer fire];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)doSome &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;++++++%@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于<code>MSWeakTimer</code>的实现原理自然是和<code>NSTimer</code>不同的：通过封装GCD定时器实现<code>NSTimer</code>的功能，但内部却是弱引用target，不仅如此<code>MSWeakTimer</code>还支持在其他线程中执行回调函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MSWeakTimer</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        uint32_t timerIsInvalidated;</span><br><span class="line">    &#125; _timerFlags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> timeInterval;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> target; <span class="comment">//弱引用target</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL selector;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> userInfo;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> repeats;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, ms_gcd_property_qualifier) <span class="built_in">dispatch_queue_t</span> privateSerialQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, ms_gcd_property_qualifier) dispatch_source_t timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//自身销毁时invalidate掉定时器</span></span><br><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">self</span> invalidate];</span><br><span class="line"></span><br><span class="line">  ms_release_gcd_object(_privateSerialQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用<code>MSWeakTimer</code>时，就可以避免因忘记invalid定时器，导致ViewController生命周期被延长不能及时销毁而产生的bug。从这之后，我便不再遇到和<code>NSTimer</code>相关的bug了。</p>
<div style="text-align: right"> 二零一八年九月二十一日 </div> 

]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>NSTimer</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS APP后台运行时间探究及延长</title>
    <url>/2018/11/25/iOS%20APP%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E6%8E%A2%E7%A9%B6%E5%8F%8A%E5%BB%B6%E9%95%BF/</url>
    <content><![CDATA[<p>实验设备:iPhone7plus iOS12.1</p>
<p>问题:发现市面上很多APP进入后台后,过了16min甚至20min后,再次点击APP,都能够保持在原来的页面.而我们自己的APP,进入后台过个三分钟就被kill掉了,再次进入都是重新启动.<br>网易新闻APP,主站APP,喜马拉雅APP都不会.为什么我们的APP在挂起后会这么快被系统从内存中清理?而别的APP却不会.</p>
<p>目前app,没有做任何特别处理,申请的权限也很常规,如下:</p>
<p><img src="https://portal.qiniu.com/" alt="APP后台模式"></p>
<p>解决:经过不断的分析,最终发现是代码中在向系统申请后台运行时间错误使用导致,在调用<code>beginBackgroundTaskWithExpirationHandler</code>后,没有配对调用<code>endBackgroundTask:</code>.</p>
<p>吐槽:有时候工程一大,出现一些BUG真的很难分析原因.</p>
<h3 id="向系统申请后台运行时间"><a href="#向系统申请后台运行时间" class="headerlink" title="向系统申请后台运行时间"></a>向系统申请后台运行时间</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)backgroundDoSomethings &#123;</span><br><span class="line">    <span class="built_in">UIApplication</span> *application = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">    __block <span class="built_in">UIBackgroundTaskIdentifier</span> bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        <span class="comment">// Clean up any unfinished task business by marking where you</span></span><br><span class="line">        <span class="comment">// stopped or ending the task outright.</span></span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start the long-running task and return immediately.</span></span><br><span class="line">    [<span class="keyword">self</span> doSomethingWithCompletionBlock:^&#123;</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)doSomethingWithCompletionBlock:(<span class="type">void</span> (^)(<span class="type">void</span>))completion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;开始睡&quot;</span>);</span><br><span class="line">        sleep(<span class="number">175</span>); <span class="comment">//200x 170√ 180x 175√</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;睡醒&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实测运行的时间大致在175s左右,小于180s.即通过<code>beginBackgroundTaskWithExpirationHandler:</code>方法可以向系统申请大约180s的后台运行时间.</p>
<p>相关方法:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIBackgroundTaskIdentifier</span>)beginBackgroundTaskWithExpirationHandler:(<span class="type">void</span>(^ __<span class="keyword">nullable</span>)(<span class="type">void</span>))handler  <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0) <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line">- (<span class="built_in">UIBackgroundTaskIdentifier</span>)beginBackgroundTaskWithName:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)taskName expirationHandler:(<span class="type">void</span>(^ __<span class="keyword">nullable</span>)(<span class="type">void</span>))handler <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0) <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line">- (<span class="type">void</span>)endBackgroundTask:(<span class="built_in">UIBackgroundTaskIdentifier</span>)identifier <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0) <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意</strong>:<br><code>beginBackgroundTaskWithExpirationHandler</code>一定要与<code>endBackgroundTask</code>配对使用,否则时间到后系统将直接kill掉你的APP.</p>
<h3 id="如何延长APP后台运行时间-甚至无限长"><a href="#如何延长APP后台运行时间-甚至无限长" class="headerlink" title="如何延长APP后台运行时间?甚至无限长."></a>如何延长APP后台运行时间?甚至无限长.</h3><p>以后有空研究.</p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>后台运行</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS崩溃日志堆栈解析</title>
    <url>/2018/12/05/iOS%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E5%A0%86%E6%A0%88%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="iOS崩溃日志堆栈解析"><a href="#iOS崩溃日志堆栈解析" class="headerlink" title="iOS崩溃日志堆栈解析"></a>iOS崩溃日志堆栈解析</h3><p>本文只为自己查看方便.</p>
<h4 id="dSYM-文件"><a href="#dSYM-文件" class="headerlink" title=".dSYM 文件"></a>.dSYM 文件</h4><p>我们调试的 symbols 会包含在这个文件中。</p>
<p>每次编译项目的时候都会生成一个新的 dSYM 文件，我们应该保存每个正式发布版本的 dSYM 文件，以备我们更好的调试问题。一般是在我们 Archives 时保存对应的版本文件的，里面也有对应的 .dSYM 和 .app 文件。</p>
<h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>注意:.dSYM 、.crash文件,二者的UUID必须一致解析才有意义.</p>
<h5 id="获取-UUID"><a href="#获取-UUID" class="headerlink" title="获取 UUID"></a>获取 UUID</h5><p>.crash UUID</p>
<p><code>grep --after-context=2 &quot;Binary Images:&quot; *crash</code></p>
<p>.dSYM UUID</p>
<p><code>dwarfdump --uuid myCrashDemo.app.dSYM</code></p>
<p>.app UUID</p>
<p><code>dwarfdump --uuid myCrashDemo.app/myCrashDemo</code></p>
<h4 id="使用symbolicatecrash进行解析"><a href="#使用symbolicatecrash进行解析" class="headerlink" title="使用symbolicatecrash进行解析"></a>使用symbolicatecrash进行解析</h4><p>symbolicatecrash 是 Xcode 自带的 crash 日志分析工具.</p>
<p>首先查找到它的路径:</p>
<p><code>find /Applications/Xcode.app -name symbolicatecrash</code></p>
<p>把 symbolicatecrash 拷贝出来，放到一个文件夹下。</p>
<p>有两种方式解析:</p>
<ol>
<li><code>symbolicatecrash</code> + <code>.dSYM</code> + <code>.crash</code></li>
<li><code>symbolicatecrash</code> + <code>.app</code> + <code>.crash</code></li>
</ol>
<p><strong>利用 dSYM</strong></p>
<p>将 .dSYM 、.crash 及 symbolicatecrash 放到同一个文件下，执行命令：</p>
<p><code>./symbolicatecrash .crash文件路径 .dSYM文件路径 &gt; 名字.crash</code></p>
<p><strong>利用 app</strong></p>
<p>将 .app 、.crash 及 symbolicatecrash 放到同一个文件下，执行命令：</p>
<p><code>./symbolicatecrash .crash文件路径 .app/appName 路径 &gt; 名字.crash</code></p>
<p>可能会报错误：</p>
<p><code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</code></p>
<p>执行下命令就行：</p>
<p><code>export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</code></p>
<p>然后再重新生成下新的 .crash 文件就行。</p>
<h4 id="使用命令行工具-atos"><a href="#使用命令行工具-atos" class="headerlink" title="使用命令行工具 atos"></a>使用命令行工具 atos</h4><p>同样也有两种方式</p>
<ol>
<li><code>.dSYM</code> + <code>.crash</code></li>
<li><code>.app</code> + <code>.crash</code></li>
</ol>
<p>.dSYM方式</p>
<p><code>xcrun atos -o ./myCrashDemo.app.dSYM/Contents/Resources/DWARF/myCrashDemo -arch 指令集(armv7或arm64) -l Slide地址</code></p>
<p>接着输入错误的内存地址,即可看到.</p>
<p>.app方式</p>
<p><code>xcrun atos -o myCrashDemo.app/myCrashDemo -arch 指令集(armv7或arm64) -l Slide地址</code></p>
<p>接着输入错误的内存地址.</p>
<p>GitHub 上有个<code>dSYMTools</code>工具封装了<code>atos</code>命令，可以辅助我们解析.</p>
<p>使用很方便,只要拖入dSYM文件,然后将错误地址以及Slide Address输入工具的文本框中即可.</p>
<h4 id="Slide-address查看"><a href="#Slide-address查看" class="headerlink" title="Slide address查看"></a>Slide address查看</h4><p>在崩溃日志里面找到 Binary IImages: 这一块，Binary IImages: 下面第一行就是加载应用可执行文件的信息，大致如下：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">Binary <span class="params">Images:</span></span><br><span class="line"><span class="number">0</span>x100878000 <span class="operator">-</span> <span class="number">0</span>x10087ffff myCrashDemo arm64  <span class="symbol">&lt;dc8bc710db863d2ca08180537af8015e&gt;</span> <span class="symbol">/var/containers/Bundle/Application/3BCB5A1C-9BD8-44CD-84EE-39128C005B9F/myCrashDemo.app/myCrashDemo</span></span><br><span class="line"><span class="number">0</span>x100938000 <span class="operator">-</span> <span class="number">0</span>x10099bfff dyld arm64  <span class="symbol">&lt;fc36be383ccf330abe42940868e68937&gt;</span> <span class="symbol">/usr/lib/dyld</span></span><br><span class="line"><span class="number">0</span>x102478000 <span class="operator">-</span> <span class="number">0</span>x102483fff libobjc-trampolines.dylib arm64  <span class="symbol">&lt;a8cd788cc9113887ae254bd47d58c7c1&gt;</span> <span class="symbol">/usr/lib/libobjc-trampolines.dylib</span></span><br><span class="line"><span class="number">0</span>x239546000 <span class="operator">-</span> <span class="number">0</span>x239547fff libSystem.B.dylib arm64  <span class="symbol">&lt;b3dbcc8e41b03e51b7e65d2800dcdea9&gt;</span> <span class="symbol">/usr/lib/libSystem.B.dylib</span></span><br><span class="line"><span class="number">0</span>x239548000 <span class="operator">-</span> <span class="number">0</span>x2395a2fff libc<span class="operator">++</span>.<span class="number">1</span>.dylib arm64  <span class="symbol">&lt;c406443c983a33829b164c441b7c2af4&gt;</span> <span class="symbol">/usr/lib/libc++.1.dylib</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中 0x100878000 就是 slide address。<br>arm64 指的是 arm64 架构下，uuid 是 dc8bc710db863d2ca08180537af8015e.</p>
<h4 id="错误的内存地址查看"><a href="#错误的内存地址查看" class="headerlink" title="错误的内存地址查看"></a>错误的内存地址查看</h4><p>内存地址是 Last Exception Backtraces 中每一行的第一个地址，分析其他行的时候你要看下是不是自己应用可执行文件那行，因为你这个 slide address 只对应到自己那个可执行文件，系统的一些库的 slide address 都不一样的。<br>其实分析一个 crash 文件并不要很长时间，只需要找到自己可执行文件对应的那行内存地址，slide address，和 arch type 这三个信息就可以了，并不是每一行错误信息都需要看。</p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>崩溃日志解析</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重添加元素Block方式实现</title>
    <url>/2018/09/28/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>有时候我们需要该元素不在该数组中时才添加.</p>
<p>由于使用场景还算比较多,所以自己简单封装了一下.这里用block作为过滤条件,使用还是很方便的.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMutableArray</span> (<span class="title">Tool</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 数组去重添加单个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param anObject 被添加的元素</span></span><br><span class="line"><span class="comment"> @param filterBlk 过滤条件.element为原数组的元素,anObject为被添加的元素.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)addObject:(<span class="type">id</span>)anObject filter:(<span class="type">BOOL</span> (^)(<span class="type">id</span> element, <span class="type">id</span> anObject))filterBlk;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 数组去重添加一个数组里的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param otherArray 被添加的数组</span></span><br><span class="line"><span class="comment"> @param filterBlk 过滤条件.element为原数组的元素,anObject为被添加的数组的元素.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)addObjectsFromArray:(<span class="built_in">NSArray</span> *)otherArray filter:(<span class="type">BOOL</span> (^)(<span class="type">id</span> element, <span class="type">id</span> anObject))filterBlk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSMutableArray</span> (<span class="title">Tool</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addObject:(<span class="type">id</span>)anObject filter:(<span class="type">BOOL</span> (^)(<span class="type">id</span>, <span class="type">id</span>))filterBlk</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (anObject == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> isExist = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filterBlk(obj, anObject)) &#123;</span><br><span class="line">            isExist = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!isExist) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addObject:anObject];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addObjectsFromArray:(<span class="built_in">NSArray</span> *)otherArray filter:(<span class="type">BOOL</span> (^)(<span class="type">id</span>, <span class="type">id</span>))filterBlk</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (otherArray.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">id</span> element <span class="keyword">in</span> otherArray) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addObject:element filter:filterBlk];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用如下:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *mArr = [@[<span class="string">@&quot;3&quot;</span>, <span class="string">@&quot;4&quot;</span>, <span class="string">@&quot;5&quot;</span>, <span class="string">@&quot;33&quot;</span>, <span class="string">@&quot;7&quot;</span>] mutableCopy];</span><br><span class="line">[mArr addObject:<span class="string">@&quot;57&quot;</span> filter:^<span class="type">BOOL</span>(<span class="built_in">NSString</span> *element, <span class="built_in">NSString</span> *anObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> ![element isEqualToString:anObject]; <span class="comment">//不等于其中任何一个元素才添加</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, mArr);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSArray</span> *arr = @[<span class="string">@&quot;1&quot;</span>, <span class="string">@&quot;2&quot;</span>, <span class="string">@&quot;3&quot;</span>, <span class="string">@&quot;13&quot;</span>, <span class="string">@&quot;7&quot;</span>];</span><br><span class="line">[mArr addObjectsFromArray:arr filter:^<span class="type">BOOL</span>(<span class="built_in">NSString</span> *element, <span class="built_in">NSString</span> *anObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> ![element isEqualToString:anObject]; <span class="comment">//不等于其中任何一个元素才添加</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, mArr);</span><br></pre></td></tr></table></figure>
<p>打印如下:</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">52</span>:<span class="number">39.060469</span>+<span class="number">0800</span> testDemo[<span class="number">94995</span>:<span class="number">18270135</span>] (</span><br><span class="line"><span class="built_in">    3,</span></span><br><span class="line"><span class="built_in">    4,</span></span><br><span class="line"><span class="built_in">    5,</span></span><br><span class="line"><span class="built_in">    33,</span></span><br><span class="line"><span class="built_in">    7,</span></span><br><span class="line">    <span class="number">57</span></span><br><span class="line">)</span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">52</span>:<span class="number">39.060571</span>+<span class="number">0800</span> testDemo[<span class="number">94995</span>:<span class="number">18270135</span>] (</span><br><span class="line"><span class="built_in">    3,</span></span><br><span class="line"><span class="built_in">    4,</span></span><br><span class="line"><span class="built_in">    5,</span></span><br><span class="line"><span class="built_in">    33,</span></span><br><span class="line"><span class="built_in">    7,</span></span><br><span class="line"><span class="built_in">    57,</span></span><br><span class="line"><span class="built_in">    1,</span></span><br><span class="line"><span class="built_in">    2,</span></span><br><span class="line">    <span class="number">13</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>也可以使用模型中的某个属性作为判断条件:</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line">[<span class="variable">audienceList</span> <span class="variable">addObjectsFromArray</span>:<span class="variable">self</span>.<span class="property">audienceList</span> <span class="variable">filter</span>:<span class="operator">^</span><span class="title function_">BOOL</span>(<span class="params">ZAEAudienceModel</span> *<span class="params">element</span>, <span class="params">ZAEAudienceModel</span> *<span class="params">anObject</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="operator">!</span>[<span class="variable">element</span>.<span class="property">userID</span> isEqualToString:<span class="variable">anObject</span>.<span class="property">userID</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>NSMutableArray</tag>
      </tags>
  </entry>
  <entry>
    <title>清理APP缓存</title>
    <url>/2018/12/07/%E6%B8%85%E7%90%86APP%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h4 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h4><p>主要是删除/Caches目录下的内容.如果其他路径上的文件可以删除也可以包含进来.</p>
<p>iOS 文件系统也得了解一下<br><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW12">iOS 文件系统</a></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSUInteger</span>)getCachesSize &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> *cachePath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">    <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [fileManager enumeratorAtPath:cachePath]; <span class="comment">//枚举指定目录的所有文件包括文件夹.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([fileName isEqualToString:<span class="string">@&quot;Snapshots&quot;</span>]) &#123;  <span class="comment">//&quot;/Snapshots&quot;是系统生成的,删了也会再自动创建,所以就不计算了.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSString</span> *filePath = [cachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *attrs = [fileManager attributesOfItemAtPath:filePath error:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//        NSLog(@&quot;fileType:%@, fileName:%@&quot;, [attrs objectForKey:NSFileType], fileName);</span></span><br><span class="line"><span class="comment">//        NSLog(@&quot;filePath:%@&quot;, filePath);</span></span><br><span class="line">        size += [attrs fileSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)clearCachesWithCompletionHandler:(<span class="type">void</span>(^)(<span class="type">void</span>))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">        <span class="built_in">NSString</span> * cachePath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [fileManager enumeratorAtPath:cachePath];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([fileName isEqualToString:<span class="string">@&quot;Snapshots&quot;</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSString</span> *filePath = [cachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            <span class="type">BOOL</span> removeRs = [fileManager removeItemAtPath:filePath error:<span class="literal">nil</span>];</span><br><span class="line">            <span class="keyword">if</span> (!removeRs) &#123;</span><br><span class="line">                <span class="built_in">NSDictionary</span> *attrs = [fileManager attributesOfItemAtPath:filePath error:<span class="literal">nil</span>];</span><br><span class="line">                DLog(<span class="string">@&quot;移除文件失败:fileType:%@, fileName:%@&quot;</span>, [attrs objectForKey:<span class="built_in">NSFileType</span>], fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">                completionHandler();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>/Library/Caches/Snapshots/com.AppName/UIApplicationAutomaticSnapshotDefault-LandscapeLeft.png</code><br>“/Snapshots”该目录保存的是按下home键时系统对当前屏幕生成的一张快照.</p>
<p>参考:<a href="https://www.virtuesecurity.com/ios-background-screen-caching-2/">IOS BACKGROUND SCREEN CACHING</a></p>
<p><code>- (BOOL)removeItemAtPath:(NSString *)path error:(NSError * _Nullable *)error;</code>会移除文件或目录</p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS APP生命周期</title>
    <url>/2018/12/09/iOS%20App%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>问题:APP进入后台后大概三分钟就被系统kill掉了,再次进入都是重新启动,对用户体验有一定影响.</p>
<p>为了解决这个问题,首先来了解一下一个APP的生命周期.</p>
<h4 id="一、iOS-APP生命周期"><a href="#一、iOS-APP生命周期" class="headerlink" title="一、iOS APP生命周期"></a>一、iOS APP生命周期</h4><p>一个iOS APP生命周期大概有五种状态.</p>
<p>如下图:</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20210713102802.png" alt=""></p>
<ul>
<li><strong>Not running</strong>:app还没运行.</li>
<li><strong>Inactive</strong>:app运行在前台但不能接收事件.</li>
<li><strong>Active</strong>:app运行在前台并且能够接收事件.</li>
<li><strong>Backgroud</strong>:程序在后台并且能够执行代码,大多数程序进入这个状态后会在这个状态上停留一会(一般就几秒钟,如果有申请后台运行大概会停留180s).时间到之后会进入挂起状态(Suspended).但有几种特定类型的APP可以长期处于Backgroud状态.</li>
<li><strong>Suspended</strong>:程序在后台不能执行代码.系统会自动把程序变成这个状态而且不会发出通知.当挂起时,程序还是停留在内存中的,当系统内存低时,系统就把挂起的程序清除掉,为前台程序提供更多的内存,并且不会发出任何通知.</li>
</ul>
<p>从上面的图可以看出如果挂起的应用所占用的内存还没有被系统回收,则点击APP图标时,应用会进入后台,然后进入前台,此时看到的仍然是上一次的界面.但当挂起的应用所占用的内存已经被系统回收,则点击APP图标时,相当于重新启动.</p>
<p>了解了APP的生命周期后,可以看到挂起的应用只有在内存紧张的情况下才会被系统清理,这种情况是我们无法控制的.因此出现上述bug极有可能是程序还在运行时就被系统kill掉了.系统主动kill掉一个APP的情况并不多见,主要有如下几种:</p>
<ul>
<li>APP出现闪退</li>
<li>APP内存峰值过高</li>
<li>APP长时间没有响应事件</li>
<li>某些特殊API的错误使用</li>
</ul>
<p>由于APP是在后台运行一段时间后被kill掉的,因此极有可能是某些特殊API的错误使用导致的,最终发现是向系统申请后台运行时间的API错误使用导致.</p>
<p><strong>可长期处于后台状态的应用类型</strong></p>
<p>对于需要执行更多执行时间的任务，必须请求特定权限才能在后台运行它们而不会被挂起。在iOS中，只允许在后台运行特定的应用类型：</p>
<ul>
<li>在后台播放用户可听内容的应用，例如音乐播放器应用</li>
<li>在后台录制音频内容的应用程序</li>
<li>可让用户随时了解其位置的应用，例如导航应用</li>
<li>支持互联网协议语音（VoIP）的应用</li>
<li>需要定期下载和处理新内容的应用</li>
<li>从外部配件接收定期更新的应用程序</li>
</ul>
<h4 id="二、如何向系统申请后台运行时间"><a href="#二、如何向系统申请后台运行时间" class="headerlink" title="二、如何向系统申请后台运行时间"></a>二、如何向系统申请后台运行时间</h4><p>相关方法:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIBackgroundTaskIdentifier</span>)beginBackgroundTaskWithExpirationHandler:(<span class="type">void</span>(^ __<span class="keyword">nullable</span>)(<span class="type">void</span>))handler  <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0) <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line">- (<span class="built_in">UIBackgroundTaskIdentifier</span>)beginBackgroundTaskWithName:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)taskName expirationHandler:(<span class="type">void</span>(^ __<span class="keyword">nullable</span>)(<span class="type">void</span>))handler <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0) <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line">- (<span class="type">void</span>)endBackgroundTask:(<span class="built_in">UIBackgroundTaskIdentifier</span>)identifier <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0) <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br></pre></td></tr></table></figure>
<p>通过<code>beginBackgroundTaskWithExpirationHandler:</code>方法可以向系统申请大约180s(iOS7)的后台运行时间,或者600s（iOS6）运行时间用以处理后台操作.</p>
<p>示例:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)backgroundDoSomethings &#123;</span><br><span class="line">    <span class="built_in">UIApplication</span> *application = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">    __block <span class="built_in">UIBackgroundTaskIdentifier</span> bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        <span class="comment">// Clean up any unfinished task business by marking where you</span></span><br><span class="line">        <span class="comment">// stopped or ending the task outright.</span></span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start the long-running task and return immediately.</span></span><br><span class="line">    [<span class="keyword">self</span> doSomethingWithCompletionBlock:^&#123;</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)doSomethingWithCompletionBlock:(<span class="type">void</span> (^)(<span class="type">void</span>))completion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;开始睡&quot;</span>);</span><br><span class="line">        sleep(<span class="number">175</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;睡醒&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意</strong>:<br><code>beginBackgroundTaskWithExpirationHandler</code>一定要与<code>endBackgroundTask</code>配对使用,否则时间到后系统将直接kill掉你的APP,从而导致开头出现的问题.</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html#//apple_ref/doc/uid/TP40007072-CH2-SW1">App Programming Guide for iOS</a></p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>App生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS UIApplicationState状态变化</title>
    <url>/2018/12/09/iOS%20UIApplicationState%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<p>实验设备:iPhone5s,10.3.3系统.</p>
<p>应用状态:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIApplicationState</span>) &#123;</span><br><span class="line">    <span class="built_in">UIApplicationStateActive</span>, <span class="comment">//0</span></span><br><span class="line">    <span class="built_in">UIApplicationStateInactive</span>, <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">UIApplicationStateBackground</span> <span class="comment">//2</span></span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">4</span>_0);</span><br></pre></td></tr></table></figure>
<p>APP未启动,点击图片执行顺序:</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">默认	<span class="number">23</span>:<span class="number">07</span>:<span class="number">51.443320</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate application:didFinishLaunchingWithOptions:]  应用状态:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">默认	<span class="number">23</span>:<span class="number">07</span>:<span class="number">51.515796</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationDidBecomeActive:]  应用状态:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在应用处于UIApplicationStateActive时,分别进行如下操作:</p>
<h4 id="1-按下home键"><a href="#1-按下home键" class="headerlink" title="1.按下home键"></a>1.按下home键</h4><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">默认	<span class="number">23</span>:<span class="number">09</span>:<span class="number">50.067690</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationWillResignActive:]  应用状态:<span class="number">0</span></span><br><span class="line">默认	<span class="number">23</span>:<span class="number">09:50.602224</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationDidEnterBackground:]  应用状态:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>1.1处于后台时,再点击图标</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">默认	<span class="number">23</span>:<span class="number">11</span>:<span class="number">34.897752</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationWillEnterForeground:]  应用状态:<span class="number">2</span></span><br><span class="line">默认	<span class="number">23</span>:<span class="number">11:35.218295</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationDidBecomeActive:]  应用状态:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>1.2处于后台时,双击home进入多任务界面点击自身</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">默认	<span class="number">23</span>:<span class="number">19</span>:<span class="number">12.051002</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationWillEnterForeground:]  应用状态:<span class="number">2</span></span><br><span class="line">默认	<span class="number">23</span>:<span class="number">19</span>:<span class="number">13.286377</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationDidBecomeActive:]  应用状态:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-按下锁屏键"><a href="#2-按下锁屏键" class="headerlink" title="2. 按下锁屏键"></a>2. 按下锁屏键</h4><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">默认	<span class="number">23</span>:<span class="number">13</span>:<span class="number">07.542846</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationWillResignActive:]  应用状态:<span class="number">0</span></span><br><span class="line">默认	<span class="number">23</span>:<span class="number">13</span>:<span class="number">07.543049</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationDidEnterBackground:]  应用状态:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>2.1解锁</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">默认	<span class="number">23</span>:<span class="number">17:48.176320</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationWillEnterForeground:]  应用状态:<span class="number">2</span></span><br><span class="line">默认	<span class="number">23</span>:<span class="number">17:48.872183</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationDidBecomeActive:]  应用状态:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="3-双击home进入多任务界面"><a href="#3-双击home进入多任务界面" class="headerlink" title="3. 双击home进入多任务界面"></a>3. 双击home进入多任务界面</h4><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">默认	<span class="number">23</span>:<span class="number">14</span>:<span class="number">28.340768</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationWillResignActive:]  应用状态:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>3.1多任务点击其他APP</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">默认	<span class="number">23</span>:<span class="number">15</span>:<span class="number">14.853798</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationDidEnterBackground:]  应用状态:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>3.2多任务点击自身</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">默认	<span class="number">23</span>:<span class="number">15</span>:<span class="number">53.643633</span> +<span class="number">0800</span>	pictureInMemory	-[AppDelegate applicationDidBecomeActive:]  应用状态:<span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIApplicationState</tag>
      </tags>
  </entry>
  <entry>
    <title>UIBarButtonItem坑</title>
    <url>/2018/12/19/UIBarButtonItem%E5%9D%91/</url>
    <content><![CDATA[<p>使用系统设置,在iOS11.4上会出现点击时,文字变大,颜色变为蓝色.所以使用按钮还是靠谱些.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIBarButtonItem</span> *allReadItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithTitle:<span class="string">@&quot;全部已读&quot;</span> style:<span class="built_in">UIBarButtonItemStylePlain</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(allReadItemDidClicked:)];</span><br><span class="line">[allReadItem setTitleTextAttributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> pingFangSCWithSize:<span class="number">14</span>], <span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> colorWithHexString:<span class="string">@&quot;#333333&quot;</span>]&#125; forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">self</span>.navigationItem.rightBarButtonItem = allReadItem;</span><br></pre></td></tr></table></figure>
<p>解决办法使用自定义按钮:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    btn.titleLabel.font = [<span class="built_in">UIFont</span> pingFangSCWithSize:<span class="number">14</span>];</span><br><span class="line">    [btn setTitle:<span class="string">@&quot;全部已读&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [btn setTitleColor:[<span class="built_in">UIColor</span> colorWithHexString:<span class="string">@&quot;#333333&quot;</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(allReadItemDidClicked:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [btn sizeToFit]; <span class="comment">//需要设置一下否则在iOS10会没有大小.</span></span><br><span class="line">    <span class="built_in">UIBarButtonItem</span> *allReadItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithCustomView:btn];</span><br><span class="line">    <span class="keyword">self</span>.navigationItem.rightBarButtonItem = allReadItem;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIBarButtonItem</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage内存暴涨分析与解决</title>
    <url>/2018/02/14/2018-2-14-SDWebImage%E5%86%85%E5%AD%98%E6%9A%B4%E6%B6%A8%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>使用SDWebImage加载图片,当列表有很多页,图片很多时,可能会导致内存暴涨:<br><img src="http://7xqoji.com1.z0.glb.clouddn.com/SDWebImage_%E5%86%85%E5%AD%98%E6%9A%B4%E6%B6%A8.jpg" alt="内存暴涨"></p>
<p>产生内存暴涨的代码:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从磁盘获取图片,并缓存到内存.</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diskImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解压图片</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)diskImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</span><br><span class="line">        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldDecompressImages) &#123;</span><br><span class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(<span class="literal">NO</span>)&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关闭缓存图片到内存的功能:<br><code>[[SDImageCache sharedImageCache].config setShouldCacheImagesInMemory:NO];</code></p>
<p>效果如下:<br><img src="http://7xqoji.com1.z0.glb.clouddn.com/SDWebImage_%E5%86%85%E5%AD%98%E6%AD%A3%E5%B8%B8.jpg" alt="内存正常"><br>此时虽然内存不再异常,但滑动过程中会明显看到图片填充时的闪动,用户体验想当不好.</p>
<p>比较好的办法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">- (void)initSDWebImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-attr">[[SDImageCache sharedImageCache]</span><span class="selector-class">.config</span> setShouldDecompressImages:NO];</span><br><span class="line">    <span class="selector-attr">[[SDWebImageDownloader sharedDownloader]</span> setShouldDecompressImages:NO];</span><br><span class="line">    <span class="selector-attr">[[SDImageCache sharedImageCache]</span> setMaxMemoryCost:<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置一个内存缓存最大值,需要注意的是系统并不会精确的使用该值进行限定.这样设置之后,内存基本在70-90M之间浮动.不会再像之前飙到3-400M还停不下来.<br>如果设置为10 <em> 1024 </em> 1024,那么内存基本在30-50M之间.并且用户体验还行.</p>
]]></content>
      <categories>
        <category>第三方库使用</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>从JSONSerialization崩溃到搞懂Swift的try-catch</title>
    <url>/2019/03/03/%E4%BB%8EJSONSerialization%E5%B4%A9%E6%BA%83%E5%88%B0%E6%90%9E%E6%87%82Swift%E7%9A%84try-catch/</url>
    <content><![CDATA[<p>今天学习了下Swift中的try-catch,突然发现在json序列化时try-catch不好使了,下面的代码依然会导致崩溃,try-catch并不能catch住.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">Decodable</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">var</span> height: <span class="type">Float</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">var</span> weight: <span class="type">Float</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">var</span> sex: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">init</span>(<span class="params">firstName</span>: <span class="type">String</span>, <span class="params">lastName</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.firstName <span class="operator">=</span> firstName</span><br><span class="line">        <span class="keyword">self</span>.lastName <span class="operator">=</span> lastName</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dict <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>: <span class="type">People</span>.<span class="keyword">init</span>(firstName: <span class="string">&quot;x&quot;</span>, lastName: <span class="string">&quot;q&quot;</span>)]</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> jsonData <span class="operator">=</span> <span class="keyword">try</span> <span class="type">JSONSerialization</span>.data(withJSONObject: dict, options: [])</span><br><span class="line">    <span class="built_in">print</span>(jsonData)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了下方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">func</span> <span class="title function_">data</span>(withJSONObject obj: <span class="keyword">Any</span>, options opt: <span class="type">JSONSerialization</span>.<span class="type">WritingOptions</span> <span class="operator">=</span> []) <span class="keyword">throws</span> -&gt; <span class="type">Data</span></span><br></pre></td></tr></table></figure>
<p>的说明:</p>
<blockquote>
<p>If obj will not produce valid JSON, an exception is thrown. This exception is thrown prior to parsing and represents a programming error, not an internal error. You should check whether the input will produce valid JSON before calling this method by using isValidJSONObject(_:).</p>
</blockquote>
<p>大意是如果obj参数不是一个合法的JSON,那么将抛出一个异常.该异常代表的是一个编程错误而不是解析时的内部错误,它在解析之前就被抛出了.估计这种异常是无法捕获的.所以最好先调用<code>isValidJSONObject</code>判断下是不是一个合法的JSON,再进行序列化.</p>
<p>类似的这样的错误也是捕捉不到的.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ot: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> os <span class="operator">=</span> <span class="keyword">try</span> ot<span class="operator">!</span></span><br><span class="line">    <span class="built_in">print</span>(os)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码依旧崩溃.</p>
<p>看来以后使用try-catch得注意下了.</p>
<h3 id="try-catch能够捕获什么样的错误呢"><a href="#try-catch能够捕获什么样的错误呢" class="headerlink" title="try-catch能够捕获什么样的错误呢?"></a>try-catch能够捕获什么样的错误呢?</h3><p>编程错误也就是异常都是不能捕获的.比如对nil强制解包,数组越界,非法参数等.<br>只有可恢复的错误才可以捕获.</p>
<p><a href="https://stackoverflow.com/questions/24010569/error-handling-in-swift-language">Error-Handling in Swift-Language
</a></p>
<p>但在OC中是可以捕获异常的:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;@try&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *s = <span class="string">@&quot;xx&quot;</span>;</span><br><span class="line">    s = [s stringByAppendingString:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;exception:%@&quot;</span>, exception);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@finally</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;@finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码加了try-catch后就不会崩溃.</p>
<p>Swfit中的try-catch只是用来进行错误处理的,因此只能捕获错误,不能捕获异常.</p>
<h3 id="Swift的错误处理（Error-handling）"><a href="#Swift的错误处理（Error-handling）" class="headerlink" title="Swift的错误处理（Error handling）"></a>Swift的错误处理（Error handling）</h3><p>错误处理（Error handling）是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。</p>
<p>某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。</p>
<p>举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。</p>
<blockquote>
<p>Swift中的错误处理类似于其他语言中的异常处理,比如都使用try，catch和throw关键字。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及unwinding调用栈(即调用栈展开)，这是一个计算代价高昂的过程。就此而言，throw语句的性能是可以和return语句相媲美的。</p>
</blockquote>
<p>由此可见Swift中的错误处理和异常处理不是同一个东西,只不过使用的关键字相同.</p>
<h3 id="throw、throws、rethrows"><a href="#throw、throws、rethrows" class="headerlink" title="throw、throws、rethrows"></a>throw、throws、rethrows</h3><p>throw：用于抛出一个错误。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">parseObject</span>&lt;<span class="type">T</span>: <span class="type">Decodable</span>&gt;(<span class="params">data</span>: <span class="type">Data</span>?) <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> d <span class="operator">=</span> data <span class="keyword">else</span> &#123;<span class="keyword">throw</span> <span class="type">BusinessError</span>.<span class="keyword">init</span>(code: <span class="type">BusinessError</span>.<span class="type">SuperLike</span>.badParam, message: <span class="string">&quot;无数据&quot;</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">T</span>.<span class="keyword">self</span>, from: d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>throws：用于向外抛出错误。用于函数声明，表示该函数内部自身会抛出错误，调用函数时外部需要使用try对错误进行处理，如果外部函数也不想处理该错误，那么外部函数在声明时也要添加throws。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">func</span> <span class="title function_">test_parse</span>() <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123; <span class="comment">//自身不处理，继续往外抛</span></span><br><span class="line">    <span class="keyword">let</span> user: <span class="type">User</span> <span class="operator">=</span> <span class="keyword">try</span> parseObject(data: <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">func</span> <span class="title function_">test_parse1</span>() -&gt; <span class="type">User</span>? &#123; <span class="comment">//自身处理。try?</span></span><br><span class="line">    <span class="keyword">let</span> user: <span class="type">User</span>? <span class="operator">=</span> <span class="keyword">try?</span> parseObject(data: <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">func</span> <span class="title function_">test_parse2</span>() -&gt; <span class="type">User</span>? &#123; <span class="comment">//自身处理。do-catch</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> user: <span class="type">User</span> <span class="operator">=</span> <span class="keyword">try</span> parseObject(data: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">test_error</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> user <span class="operator">=</span> <span class="keyword">try?</span> test_parse()</span><br><span class="line">    <span class="keyword">let</span> user1 <span class="operator">=</span> test_parse1()</span><br><span class="line">    <span class="keyword">let</span> user2 <span class="operator">=</span> test_parse2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">let</span> arr1 <span class="operator">=</span> arr.map &#123; ele <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>.<span class="keyword">init</span>(ele)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr2 <span class="operator">=</span> arr.map &#123; ele <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> user: <span class="type">User</span>? <span class="operator">=</span> <span class="keyword">try?</span> parseObject(data: <span class="literal">nil</span>)  <span class="comment">//闭包内部需要try处理，否则外部需要try处理。</span></span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rethrows：用于向外传递错误。用于函数声明，函数本身不会抛出错误，但闭包参数会抛出错误，调用函数时如果闭包内部处理了则外部不需要再使用try对错误进行处理。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 <span class="operator">=</span> arr.map &#123; ele <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>.<span class="keyword">init</span>(ele)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[User?]</span></span><br><span class="line"><span class="keyword">let</span> arr2 <span class="operator">=</span> arr.map &#123; ele <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> user: <span class="type">User</span>? <span class="operator">=</span> <span class="keyword">try?</span> parseObject(data: <span class="literal">nil</span>)  <span class="comment">//闭包内部需要try处理，否则外部需要try处理。</span></span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>OC与Swift混编</title>
    <url>/2019/04/07/OC%E4%B8%8ESwift%E6%B7%B7%E7%BC%96/</url>
    <content><![CDATA[<h2 id="1-混编设置"><a href="#1-混编设置" class="headerlink" title="1.混编设置"></a>1.混编设置</h2><p>新建一个桥接文件<code>工程名-Bridging-Header.h</code>.到此为止,混编设置差不多就完事了.<br>该文件在第一次新建Swift文件时,系统会提示是否建立桥接文件,选择是即可.也可自行创建,但自行创建还需要设置路径略微麻烦.</p>
<h3 id="1-1-Swift调用OC"><a href="#1-1-Swift调用OC" class="headerlink" title="1.1 Swift调用OC"></a>1.1 Swift调用OC</h3><p>在桥接文件中导入需要调用的OC类的头文件即可.这样就可以在Swift的类里使用OC的类了.</p>
<p>举例:</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Use this file to import your target&#x27;s public headers that you would like to expose to Swift.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在Swift里调用OC,需要在桥接文件里导入OC头文件</span></span><br><span class="line"><span class="comment">//调用自身module里的OC代码</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">&quot;AppDelegate.h&quot;</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">&quot;ZAEGradientView.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Pod管理的OC库</span></span><br><span class="line">#<span class="keyword">import</span> &lt;MJRefresh/MJRefresh.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;YYModel/YYModel.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;ZACommon/UIViewController+FRCustomNavigationBarItem.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;ZACommon/InnerBandCore.h&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:对于pod管理的OC库,导入头文件时推荐使用<code>&lt;&gt;</code>而非<code>&quot;&quot;</code>.如<code>#import &lt;ZACommon/UIViewController+FRCustomNavigationBarItem.h&gt;</code>,不要写为<code>#import &quot;UIViewController+FRCustomNavigationBarItem.h&quot;</code>,否则可能导致编译通不过.</p>
</blockquote>
<h3 id="1-2-OC调用Swift"><a href="#1-2-OC调用Swift" class="headerlink" title="1.2 OC调用Swift"></a>1.2 OC调用Swift</h3><p>需要在OC的类里写上<code>import &quot;xxx-Swift.h&quot;</code>.(xxx为项目名称).也可以写在PCH文件中.<br>如:<code>#import &quot;EmotionCounsel-Swift.h&quot;</code></p>
<p>官方文档:</p>
<p><a href="https://developer.apple.com/documentation/swift/migrating_your_objective-c_code_to_swift">Migrating Your Objective-C Code to Swift</a></p>
<p><a href="https://developer.apple.com/documentation/swift#2984801">Swift-Build apps using a powerful open language.</a></p>
<h2 id="2-混编问题"><a href="#2-混编问题" class="headerlink" title="2.混编问题"></a>2.混编问题</h2><p>混编出现的问题大致有两类:</p>
<ul>
<li>头文件引用问题</li>
<li>语法兼容性问题</li>
</ul>
<h3 id="2-1头文件引用问题"><a href="#2-1头文件引用问题" class="headerlink" title="2.1头文件引用问题"></a>2.1头文件引用问题</h3><p>头文件问题可能会引起一系列的编译报错.</p>
<h4 id="头文件循环引用"><a href="#头文件循环引用" class="headerlink" title="头文件循环引用"></a>头文件循环引用</h4><p>Swift使用了OC的某个类,该类的头文件中又想使用Swift的类.将导致Swift与OC互相引用头文件,从而引起编译错误.<br>解决办法:如果一定要在OC的.h文件中使用Swift的类，那就前置声明一下Swift的类名，<code>@class swift-className</code>，然后在.m文件中再导入“xxx-Swift.h”头文件。<br>建议:在OC要调用Swift类的地方,桥接文件能写在.m文件中就不要写在.h文件.</p>
<h4 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h4><p>Swift中使用了OC的<code>ZAEContactDetailViewController</code>,<code>ZAEContactDetailViewController</code>又想使用Swift中的类.这样将会导致头文件循环引用.从而编译器会报未知类型等其他莫名的错误.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZAEDiscoverViewController</span>: <span class="title class_ inherited__">ZAEViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">touchesBegan</span>(<span class="keyword">_</span> <span class="params">touches</span>: <span class="type">Set</span>&lt;<span class="type">UITouch</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) &#123;</span><br><span class="line">        <span class="keyword">let</span> detailVC <span class="operator">=</span> <span class="type">ZAEContactDetailViewController</span>.<span class="keyword">init</span>()</span><br><span class="line">        navigationController<span class="operator">?</span>.pushViewController(detailVC, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">import</span> &quot;ZAEViewController.h&quot;</span><br><span class="line"></span><br><span class="line"><span class="type">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">ZAEContactDetailViewController</span> : <span class="type">ZAEViewController</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">People</span> <span class="operator">*</span>people; <span class="comment">//People为swift的类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>
<p>编译器会报错:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Property <span class="keyword">with</span> <span class="string">&#x27;retain (or strong)&#x27;</span> <span class="keyword">attribute</span> must be <span class="keyword">of</span> <span class="keyword">object</span> <span class="keyword">type</span></span><br><span class="line"><span class="type">Unknown</span> <span class="keyword">type</span> <span class="type">name</span> <span class="string">&#x27;People&#x27;</span></span><br></pre></td></tr></table></figure>
<p>解决办法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ZAEViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">People</span>; //使用@<span class="title">class</span> 前置声明一下即可.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZAEContactDetailViewController</span> : <span class="title">ZAEViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) People *people; <span class="comment">//People为swift的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="case2-OC-h文件需要遵守Swift协议，然后又需要在Swift中引用该OC类。"><a href="#case2-OC-h文件需要遵守Swift协议，然后又需要在Swift中引用该OC类。" class="headerlink" title="case2:OC.h文件需要遵守Swift协议，然后又需要在Swift中引用该OC类。"></a>case2:OC.h文件需要遵守Swift协议，然后又需要在Swift中引用该OC类。</h4><p>像上面那样前向引用，但前向引用协议后，会发现OC.h文件中会有警告。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">GKPageListViewDelegate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SYANewPersonProfileBaseListViewController</span> : <span class="title">UIViewController</span> &lt;<span class="title">GKPageListViewDelegate</span>&gt; //警告：<span class="title">cannot</span> <span class="title">find</span> <span class="title">protocol</span> <span class="title">definition</span> <span class="title">for</span> &#x27;<span class="title">GKPageListViewDelegate</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="type">void</span>(^scrollCallBack)(<span class="built_in">UIScrollView</span> *scrollView);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> userId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) SYAUserInfo *userInfo;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)requestPhotoAlbum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>办法1：屏蔽警告。没有什么太好的办法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">GKPageListViewDelegate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="comment">// To get rid of &#x27;No protocol definition found&#x27; warnings which are not accurate</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Weverything&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SYANewPersonProfileBaseListViewController</span> : <span class="title">UIViewController</span> &lt;<span class="title">GKPageListViewDelegate</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br></pre></td></tr></table></figure>
<p>办法2：用Swift给OC类添加扩展实现协议。这个肯定没警告了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SYANewPersonProfileBaseListViewController</span>: <span class="title class_ inherited__">GKPageListViewDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">listScrollView</span>() -&gt; <span class="type">UIScrollView</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;Must be implemented by Concrete subclass.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">listViewDidScroll</span>(<span class="params">callBack</span>: <span class="keyword">@escaping</span> (<span class="type">UIScrollView</span>) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.scrollCallBack <span class="operator">=</span> callBack</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">listView</span>() -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://developer.apple.com/forums/thread/36454">Pragma ignore missing protocol definition</a></p>
<h4 id="case3-OC类-h文件需要使用swift文件中的枚举，然后swift类又需要使用该OC类。导致头文件循环"><a href="#case3-OC类-h文件需要使用swift文件中的枚举，然后swift类又需要使用该OC类。导致头文件循环" class="headerlink" title="case3:OC类.h文件需要使用swift文件中的枚举，然后swift类又需要使用该OC类。导致头文件循环"></a>case3:OC类.h文件需要使用swift文件中的枚举，然后swift类又需要使用该OC类。导致头文件循环</h4><p>目前没找到什么好的办法。只能是把OC .h使用到的枚举类型改为NSInteger类型。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)initWithStatus:(<span class="type">NSInteger</span>)status;</span><br></pre></td></tr></table></figure>
<h3 id="2-2语法兼容性问题"><a href="#2-2语法兼容性问题" class="headerlink" title="2.2语法兼容性问题"></a>2.2语法兼容性问题</h3><p>Swift相比OC来说是一门高级语言.Swift里面许多的高级功能是OC没有的,要想顺利混编,则必须使用二者都有的功能.所以在编写代码的时候,如果这个类可能被OC调用,那么需要避免使用Swift的特有功能或者高级语法.下面许多问题,大部分也是因为OC无法支持而导致的.</p>
<h4 id="OC与Swift类的相互调用"><a href="#OC与Swift类的相互调用" class="headerlink" title="OC与Swift类的相互调用"></a>OC与Swift类的相互调用</h4><ul>
<li><p>OC类不能继承Swift的类（即使Swift的类继承自NSObject，也添加了@objc，那也不能）,但Swift可以继承OC的类.</p>
</li>
<li><p>要想Swift的类能在OC中可访问,则必须继承自OC的类.如果想在OC中访问Swift类的属性或方法,则需要在Swift的属性前添加@objc关键字.举个栗子:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必须继承于 NSObject	</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>: <span class="title class_ inherited__">NSObject</span> &#123;</span><br><span class="line">  		<span class="comment">// 想公开给OC的要使用 @objc 修饰</span></span><br><span class="line">	    <span class="keyword">@objc</span> <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">	    <span class="keyword">@objc</span> <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">	    <span class="keyword">@objc</span> <span class="keyword">var</span> sex: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">@objc</span> <span class="keyword">init</span>(<span class="params">firstName</span>: <span class="type">String</span>, <span class="params">lastName</span>: <span class="type">String</span>) &#123;</span><br><span class="line">	        <span class="keyword">self</span>.firstName <span class="operator">=</span> firstName</span><br><span class="line">	        <span class="keyword">self</span>.lastName <span class="operator">=</span> lastName</span><br><span class="line">	        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="OC中调用Swift的struct"><a href="#OC中调用Swift的struct" class="headerlink" title="OC中调用Swift的struct"></a>OC中调用Swift的struct</h4><p>OC不能直接调用Swift中的struct，如果想在OC中调用struct的属性，那怎么办呢？<br>解决办法:可以封装一个Swift的类,在类里写个方法来返回struct中的值.</p>
<h4 id="OC中使用Swift的全局变量"><a href="#OC中使用Swift的全局变量" class="headerlink" title="OC中使用Swift的全局变量"></a>OC中使用Swift的全局变量</h4><p>OC不能直接使用Swift的全局变量.<br>解决办法:可以封装一个Swift的类,然后将全局变量作为类方法的返回值.在OC中使用该封装类.</p>
<p>举个栗子:有如下两个Swift的全局变量</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="params">dateFormatter:</span> DateFormatter <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> formatter <span class="operator">=</span> DateFormatter()</span><br><span class="line">    <span class="attr">formatter.dateFormat</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span></span><br><span class="line">    return formatter</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> notFoundCode <span class="operator">=</span> <span class="number">404</span></span><br></pre></td></tr></table></figure>
<p>想在OC中使用,则需要封装一个Swift的类如下:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">ZAEGlobal</span>: <span class="selector-tag">NSObject</span> &#123;</span><br><span class="line">    <span class="variable">@objc</span> static let gNotFoundCode = notFoundCode</span><br><span class="line">    <span class="variable">@objc</span> static let gDateFormatter = dateFormatter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用如下:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">NSLog(@<span class="string">&quot;gNotFoundCode = %ld&quot;</span>, (<span class="name">long</span>)ZAEGlobal.gNotFoundCode)<span class="comment">;  </span></span><br><span class="line">NSLog(@<span class="string">&quot;日期:%@&quot;</span>, [ZAEGlobal.gDateFormatter stringFromDate<span class="symbol">:NSDate</span>.date])<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>而Swift导入OC头文件后可以直接调用OC中定义的全局变量.</p>
<h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>Swift自身不支持宏定义.仅能在Swift中使用简单的宏.<br>解决办法:将原本OC中不需要接受参数的宏，定义成let常量，将需要接受参数的宏定义成函数即可.可以给我们的项目添加一个Const.swift文件，然后定义这些公共的常量和函数.由于我们的整个项目共享命名空间，我们就可以在项目内的任何地方直接使用Const.swift中定义的这些公共的常量和函数.</p>
<p>举个例子:<br><code>#define kSeperatorLineViewHeight 0.5</code><br>这种简单的宏可以直接在Swift中使用.</p>
<p>但下面这种<br><code>#define rgba(r,g,b,a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:a]</code><br>就不能在Swift中直接使用.需要定义为一个函数:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">rgba</span>(<span class="params">r</span>: <span class="type">CGFloat</span>, <span class="params">g</span>: <span class="type">CGFloat</span>, <span class="params">b</span>: <span class="type">CGFloat</span>, <span class="params">a</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIColor</span>.<span class="keyword">init</span>(red: r<span class="regexp">/255.0, green: g/</span><span class="number">255.0</span>, blue: b<span class="operator">/</span><span class="number">255.0</span>, alpha: a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>Swift的枚举非常强大.但OC的枚举基本沿用C的枚举定义.这就意味着如果想在OC类中使用Swift的枚举,那么在编写Swift的枚举时只能使用低配版的枚举定义,这样系统才能转换成OC能支持的枚举,才能够在OC中使用.</p>
<h5 id="OC使用Swift枚举"><a href="#OC使用Swift枚举" class="headerlink" title="OC使用Swift枚举"></a>OC使用Swift枚举</h5><p>OC只能使用低配版Swift枚举.</p>
<p>举个例子:下面的Swift的枚举就可以在OC中使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">enum</span> <span class="title class_">ZAEPayType</span>: <span class="title class_ inherited__">Int</span> &#123;</span><br><span class="line">    <span class="comment">//全款付清</span></span><br><span class="line">    <span class="keyword">case</span> fullPayment <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分期支付</span></span><br><span class="line">    <span class="keyword">case</span> instalmentPayment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举ZAEPayType必须要指明原始值类型为Int,不能省略,也不能为String或其他类型.还需要加上<code>@objc</code></p>
<p>如下的Swift枚举<code>DateFormatterType</code>就不能在OC中使用:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DateFormatterType &#123;</span><br><span class="line">    <span class="keyword">case</span> formatterType1</span><br><span class="line">    <span class="keyword">case</span> formatterType2</span><br><span class="line">    <span class="keyword">case</span> formatterType3</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> formatterTypeString: <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> self &#123;</span><br><span class="line">        <span class="keyword">case</span> .formatterType1:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .formatterType2:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;yyyy-MM-dd&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .formatterType3:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;yyyy.MM.dd&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使加上<code>@objc</code>也会导致编译出错.</p>
<h5 id="Swift使用OC的枚举"><a href="#Swift使用OC的枚举" class="headerlink" title="Swift使用OC的枚举"></a>Swift使用OC的枚举</h5><p>OC里面有两种形式定义的枚举分别为<code>typedef NS_ENUM</code>,<code>typedef NS_OPTIONS</code>.在Swift中使用<code>NS_ENUM</code>的OC枚举与OC中无异.但<code>NS_OPTIONS</code>则有些差异.</p>
<p>举个栗子:</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">//聊天内容类型</span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">ZAEMsgChatContentType</span>) &#123;</span><br><span class="line">    <span class="type">ZAEMsgChatContentTypeUnknow</span> = 0,  //未知</span><br><span class="line">    <span class="type">ZAEMsgChatContentTypePlainText</span>,   //纯文本消息</span><br><span class="line">    <span class="type">ZAEMsgChatContentTypePicture</span>,  //图片消息</span><br><span class="line">    <span class="type">ZAEMsgChatContentTypeVoice</span>,  //语音消息</span><br><span class="line">    <span class="type">ZAEMsgChatContentTypeVideo</span>,  //视频消息</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// <span class="type">Image</span> cache <span class="keyword">type</span></span><br><span class="line">typedef <span class="type">NS_OPTIONS</span>(<span class="type">NSUInteger</span>, <span class="type">YYImageCacheType</span>) &#123;</span><br><span class="line">    /// <span class="type">No</span> value.</span><br><span class="line">    <span class="type">YYImageCacheTypeNone</span>   = 0,</span><br><span class="line">    </span><br><span class="line">    /// <span class="type">Get</span>/store image with memory cache.</span><br><span class="line">    <span class="type">YYImageCacheTypeMemory</span> = 1 &lt;&lt; 0,</span><br><span class="line">    </span><br><span class="line">    /// <span class="type">Get</span>/store image with disk cache.</span><br><span class="line">    <span class="type">YYImageCacheTypeDisk</span>   = 1 &lt;&lt; 1,</span><br><span class="line">    </span><br><span class="line">    /// <span class="type">Get</span>/store image with both memory cache and disk cache.</span><br><span class="line">    <span class="type">YYImageCacheTypeAll</span>    = <span class="type">YYImageCacheTypeMemory</span> | <span class="type">YYImageCacheTypeDisk</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其转换为Swift的接口如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//聊天内容类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ZAEMsgChatContentType</span> : <span class="title class_ inherited__">Int</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> unknow <span class="comment">//未知</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> plainText <span class="comment">//纯文本消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> picture <span class="comment">//图片消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> voice <span class="comment">//语音消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> video <span class="comment">//视频消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Image cache type</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">YYImageCacheType</span> : <span class="title class_ inherited__">OptionSet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">rawValue</span>: <span class="type">UInt</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Get/store image with memory cache.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> memory: <span class="type">YYImageCacheType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Get/store image with disk cache.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> disk: <span class="type">YYImageCacheType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Get/store image with both memory cache and disk cache.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> all: <span class="type">YYImageCacheType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从转换接口可以看出对于使用<code>NS_OPTIONS</code>定义的OC枚举对应的Swift其实是一个结构体,<br>对于入参是<code>NS_OPTIONS</code>定义的OC枚举,OC中的写法是<code>YYImageCacheTypeMemory | YYImageCacheTypeDisk</code>,但在Swift中却是传入一个数组.<br><code>let cacheType: [YYImageCacheType] = [.memory, .disk]</code></p>
<p>反之,在Swift中定义一个功能类似于<code>NS_OPTIONS</code>的OC枚举,需要定义一个struct,而不是enum.</p>
<p>总之,在编写代码的时候,如果这个类可能被OC调用,那么需要避免使用Swift的特有功能或者高级语法,否则在OC中就用不了.</p>
<h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><p>模型解析框架。如果使用的是OC实现的模型解析框架，在Swift中使用时需要在类前加@objcMembers，要不然解析的属性值是空的。</p>
<p>比如下面使用的是MJExtension。SYATimelineMessageModel类前需要加@objcMembers。</p>
<p>ps:被@objcMembers修饰的类，会默认为类、子类、类扩展和子类扩展的所有属性和方法都加上@objc。当然如果想让某一个扩展关闭@objc，则可以用@nonobjc进行修饰。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">enum</span> <span class="title class_">SYATimelineMessageType</span>: <span class="title class_ inherited__">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> comment <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> reply</span><br><span class="line">    <span class="keyword">case</span> praise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@objcMembers</span> <span class="keyword">class</span> <span class="title class_">SYATimelineMessageModel</span>: <span class="title class_ inherited__">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> avatar: <span class="type">String</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> v <span class="operator">=</span> user_info<span class="operator">?</span>.photo &#123;</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> nickname: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> v <span class="operator">=</span> user_info<span class="operator">?</span>.nickname &#123;</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> news_id: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">/// 新消息类型 1：新评论 2：新回复 3：新点赞</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> news_type: <span class="type">SYATimelineMessageType</span> <span class="operator">=</span> .comment</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> user_info: <span class="type">SYAUserInfo</span>?</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> moment: <span class="type">SYATimelineItem</span>?</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> comments: <span class="type">SYATimelineCommentItem</span>?</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> like: <span class="type">SYATimelineLikeItem</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - 本地字段</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> cellHeight: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OC，nullable标记</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span> (NSURL <span class="emphasis">*)getAvatarResourceURLWithPartial:(NSString *</span>)partialUrl;</span><br></pre></td></tr></table></figure>
<p>上面这个方法可能会返回nil,但是没有标记为nullable。</p>
<p>在Swift调用时生成了一个nil的URL，虽然SD的方法url可以传nil，但还是崩溃了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">avatarImageView.sd_setImage(with: <span class="built_in">NSURL</span>.getAvatarResourceURL(withPartial: model.avatar), placeholderImage: <span class="built_in">UIImage</span>.lightGrayPlaceholder())</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>这说明Swift-OC桥接时nil检查很严格，OC没标记为nullable，那么Swift认为不会有空对象，然而如果实际OC返回了空对象那么桥接就会崩溃。</p>
<p>修复：添加nullable。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)getAvatarResourceURLWithPartial:(<span class="built_in">NSString</span> *)partialUrl;</span><br></pre></td></tr></table></figure>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>Xcode 16.1对OC类生成Swift接口，生成的API只有几个，明明有很多个的，原因不明。但是Swift里实际是可以访问的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XQNavigationBarView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIButton</span> *backButton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">UIView</span> *titleView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *titleFont;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *titleColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSAttributedString</span> *attributeTitle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="type">void</span>(^backActionBlock)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)navigationBar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成的API：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">XQNavigationBarView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> backActionBlock: (() -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">class</span> <span class="keyword">func</span> <span class="title function_">navigationBar</span>() -&gt; <span class="keyword">Self</span><span class="operator">!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903844758077453">Objective-C Swift 混编的模块二进制化 1：��础知识</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>混编</tag>
      </tags>
  </entry>
  <entry>
    <title>理解OC中的SEL、IMP、Method</title>
    <url>/2019/05/04/%E7%90%86%E8%A7%A3OC%E4%B8%AD%E7%9A%84SEL%E3%80%81IMP%E3%80%81Method/</url>
    <content><![CDATA[<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>Defines an opaque type that represents a method selector.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_selector</span> *SEL;</span><br></pre></td></tr></table></figure>
<p>SEL是一种数据类型,代表一个方法选择器(要是觉得不好理解,可以类比一下int,int是整型类型,代表一个整数).方法选择器就是运行时中方法的名称,它是一个注册到(或映射到)Objective-C运行时里的一个C字符串.选择器由编译器生成,在系统加载类的时候由runtime自动进行映射.</p>
<p>按照文档说明,选择器是在编译期间生成的,在加载类的时候映射为runtime中的一个C字符串.</p>
<p>给对象发送一条消息<code>[obj xxxMethod];</code>,其实是调用了<code>objc_msgSend(obj, @selector(xxxMethod));</code>.</p>
<p><code>objc_msgSend</code>的声明如下:<br><code>OBJC_EXPORT id _Nullable
objc_msgSend(id _Nullable self, SEL _Nonnull op, ...);</code><br>它的第二个参数的类型就是SEL.说明它是真实存在的.</p>
<p>相关的API:</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向runtime system注册一个方法名。如果方法名已经注册，则返回已经注册的SEL</span></span><br><span class="line">SEL sel_registerName(<span class="keyword">const</span> char *str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//功能同上</span></span><br><span class="line">SEL sel_getUid(<span class="keyword">const</span> char *str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用OC编译器指令.功能同上,也是向runtime system注册一个方法名.</span></span><br><span class="line">@<span class="keyword">selector</span>(&lt;#<span class="keyword">selector</span>#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用OC字符串构造.功能同上</span></span><br><span class="line">SEL NSSelectorFromString(NSString *aSelectorName)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Method结构体获取</span></span><br><span class="line">SEL _Nonnull method_getName(<span class="keyword">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个选择器</span></span><br><span class="line">BOOL sel_isEqual ( SEL lhs, SEL rhs )<span class="punctuation">;</span></span><br><span class="line"><span class="comment">//判断方法名是否映射到某个函数实现上</span></span><br><span class="line">BOOL sel_isMapped(SEL sel)<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SEL</span> <span class="variable">hasBookSEL</span> <span class="operator">=</span> <span class="meta">@selector(hasBook:)</span>; <span class="comment">//hasBook:是Person类的一个实例方法.</span></span><br><span class="line"><span class="comment">//sel_getName:hasBook:, p:0x10c230538</span></span><br><span class="line">NSLog(@<span class="string">&quot;sel_getName:%s, p:%p&quot;</span>, sel_getName(hasBookSEL), hasBookSEL);</span><br><span class="line"></span><br><span class="line"><span class="type">SEL</span> <span class="variable">sel0</span> <span class="operator">=</span> sel_registerName(<span class="string">&quot;myRegisterName&quot;</span>);</span><br><span class="line"><span class="type">SEL</span> <span class="variable">sel1</span> <span class="operator">=</span> sel_getUid(<span class="string">&quot;myGetUid&quot;</span>);</span><br><span class="line"><span class="type">SEL</span> <span class="variable">sel2</span> <span class="operator">=</span> <span class="meta">@selector(hello:)</span>;</span><br><span class="line"><span class="type">SEL</span> <span class="variable">sel3</span> <span class="operator">=</span> NSSelectorFromString(@<span class="string">&quot;mySelectorFromString&quot;</span>); </span><br><span class="line"><span class="comment">//sel0:0x10c232634, sel1:0x10c232643, sel2:0x10c7be0eb, sel3:0x600003e78500.</span></span><br><span class="line">NSLog(@<span class="string">&quot;sel0:%p, sel1:%p, sel2:%p, sel3:%p&quot;</span>, sel0, sel1, sel2, sel3);</span><br><span class="line"><span class="keyword">if</span> (sel_isMapped(sel2)) &#123; <span class="comment">//都是true</span></span><br><span class="line">    NSLog(@<span class="string">&quot;已经映射&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前三种方式得到的sel地址相差不大,但使用<code>NSSelectorFromString()</code>得到的sel地址却相差很大.可能的原因是前三种是在编译期间生成的.而使用<code>NSSelectorFromString()</code>得到的sel是在运行时才生成(待验证).</p>
<p>上述代码只是向runtime注册了方法名,并没有关联一个物理的函数实现(IMP).所以不要看到一个选择器就觉得一定有一个对应的物理函数实现.选择子SEL和物理函数实现IMP实际上是相互独立的,这给OC的动态性提供了基础.</p>
<p>我们都知道一条成功的消息发送最终是要调到一个物理函数的,因此消息发送的过程就是runtime根据选择子SEL找物理函数实现IMP的过程.在消息发送的过程中当一个选择子最终无法找到一个对应的IMP时,系统就会抛出著名的<code>unrecognized selector sent to instance</code>崩溃.</p>
<p>这就引出了一个问题,怎么通过一个SEL找到一个IMP?这个时候就需要查看类的结构体<code>struct objc_class</code>的构成了,如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_ivar_list</span> * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_method_list</span> * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_cache</span> * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_protocol_list</span> * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>
<p>可以看到它里面有一个<code>struct objc_method_list * _Nullable * _Nullable methodLists</code>方法列表的成员变量,继续查看方法列表结构体,如下:</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">objc_method</span> &#123;</span><br><span class="line">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    char * _Nullable method_types                            OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">objc_method_list</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">objc_method_list</span> * _Nullable obsolete             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">objc_method</span> method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们终于看到了一个<code>struct objc_method</code>的结构体,这就是后面要说到的Method类型.看到Method类型的成员变量我们就知道OC语言的设计者是怎么看待在.m文件中写的那一个个物理函数了:</p>
<p>一个物理函数={选择子(方法名)+方法类型(将返回值类型,参数类型编码后的一个C字符串)+函数指针IMP}=一个Method实例.</p>
<p>由上可知,一个类拥有一个方法列表,给类的实例发送一条消息的过程简单点讲就是根据该消息选择子在方法列表里找对应的Method,找到了就调用Method实例里的IMP,执行函数就完事了.当然实际情况要稍微复杂些:如果在自身类里没找到会继续沿着继承链往上找,最后可能还会进入消息转发.这里就不展开讲了,网上有很多.</p>
<p>给类动态的添加一个方法:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	<span class="type">BOOL</span> rs = class_addMethod(Person.class, sel2, (IMP)hello, <span class="string">&quot;B@:@&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (rs) &#123;</span><br><span class="line">	    <span class="built_in">NSLog</span>(<span class="string">@&quot;添加方法成功&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Person *p = [Person new];</span><br><span class="line">	[p performSelector:sel2 withObject:<span class="string">@&quot;小明&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">BOOL</span> hello(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *name) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@, hello:%@&quot;</span>, <span class="keyword">self</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>A pointer to the function of a method implementation.</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef id _Nullable (*<span class="type">IMP</span>)(id _Nonnull, <span class="type">SEL</span> _Nonnull, ...); </span><br></pre></td></tr></table></figure>
<p>IMP是一个函数指针,指向方法实现的具体函数首地址.</p>
<p>eg:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">IMP imp0 = class_getMethodImplementation(Person.class, <span class="keyword">@selector</span>(hasBook:));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>, imp0);</span><br><span class="line">    </span><br><span class="line">Method method = class_getInstanceMethod(Person.class, <span class="keyword">@selector</span>(hasBook:));</span><br><span class="line">IMP imp1 = method_getImplementation(method);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>, imp1);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1. 需要将Enable Strict Checking of objc_msgSend Calls 设置为NO</span></span><br><span class="line"><span class="comment"> 2. 必须将imp1类型强转后再调用.</span></span><br><span class="line"><span class="comment"> id rs1 = imp1([Person new], @selector(hasBook:), @&quot;wind&quot;);</span></span><br><span class="line"><span class="comment"> 会导致崩溃:Thread 1: EXC_BAD_ACCESS (code=1, address=0x7d8)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 通过IMP直接调用函数.这里传入了什么SEL形参值,那么执行的函数读取_cmd的值就是什么.甚至可以传NULL,但最好还是传原始方法选择器.</span></span><br><span class="line"><span class="comment"> imp1是和Person类相关联的.因此第0个参数传Person类型对象,第1个参数传Person里的方法,才有意义.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">BOOL</span> rs = ((<span class="type">BOOL</span> (*)(<span class="type">id</span>, SEL, <span class="built_in">NSString</span> *))imp1)([Person new], <span class="keyword">@selector</span>(hasBook:), <span class="string">@&quot;Gone with the wind&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rs) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;has book: Gone with the wind&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;not found book:Gone with the wind&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 使用imp_implementationWithBlock()生成一个IMP,并调用IMP.由于imp2是通过imp_implementationWithBlock()函数得来和上面的imp0的产生方式完全不同,因此imp2并不和任何类有啥关联,故它的前两个参数基本上可任意传.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">IMP imp2 = imp_implementationWithBlock(^<span class="type">BOOL</span>(<span class="type">id</span> object, <span class="built_in">NSString</span> *arg) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;object:%@, arg:%@&quot;</span>, object, arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">BOOL</span> rss = ((<span class="type">BOOL</span> (*)(<span class="type">id</span>, SEL, <span class="built_in">NSString</span> *))imp2)([Person new], <span class="keyword">@selector</span>(placeholderSEL:), <span class="string">@&quot;Gone with the wind&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rss) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;has book: Gone with the wind&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;not found book:Gone with the wind&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">rss = [Person.new hasBook:<span class="string">@&quot;Gone with the wind&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>通过IMP直接调用对应函数,需要注意两点:</p>
<ol>
<li>需要将Enable Strict Checking of objc_msgSend Calls 设置为NO</li>
<li>必须将IMP类型强转后再调用.否则会导致崩溃:<code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x7d8)</code></li>
</ol>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method in a class definition.</span></span><br><span class="line">typedef struct objc_method *<span class="keyword">Method</span>;</span><br><span class="line"></span><br><span class="line">struct objc_method <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">    char * _Nullable method_types                            OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">&#125;</span>                                                            OBJC2_UNAVAILABLE<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<p>Method是一种数据类型,代表类里面定义的一个方法.个人觉得将一个物理方法抽象为一个Method实例,简直是秀啊.这样只需要更改Method实例里的IMP成员变量的值,不就调到另外一个物理函数了吗,这样不就动态起来了吗,果然是优秀的设计!事实上Method系列API就提供了这些骚操作:</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Method里的IMP</span></span><br><span class="line">OBJC_EXPORT IMP _Nonnull</span><br><span class="line">method_getImplementation(<span class="keyword">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一个新的IMP</span></span><br><span class="line">OBJC_EXPORT IMP _Nonnull</span><br><span class="line">method_setImplementation(<span class="keyword">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m</span>, <span class="title function_">IMP</span> _<span class="title function_">Nonnull</span> <span class="title function_">imp</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法交换.就是那个黑魔法.</span></span><br><span class="line">OBJC_EXPORT void</span><br><span class="line">method_exchangeImplementations(<span class="keyword">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m1</span>, <span class="title function_">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m2</span>);</span><br></pre></td></tr></table></figure>
<p>由于OBJC2_UNAVAILABLE,即使得到了Method指针也不能直接访问结构体里的成员变量.只能通过API来获取.</p>
<p>eg:</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Method</span> <span class="title function_">method</span> = <span class="title function_">class_getInstanceMethod</span><span class="params">(Person.class, @<span class="keyword">selector</span>(hasBook:)</span>);</span><br><span class="line"></span><br><span class="line">SEL name = method_getName(<span class="keyword">method</span>);</span><br></pre></td></tr></table></figure>
<p>相关API:</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="keyword">Method</span> <span class="title function_">class_getInstanceMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line"><span class="keyword">Method</span> <span class="title function_">class_getClassMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line"><span class="keyword">Method</span> * <span class="title function_">class_copyMethodList</span> <span class="params">( <span class="keyword">Class</span> cls, unsigned int *outCount )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法名</span></span><br><span class="line">OBJC_EXPORT SEL _Nonnull</span><br><span class="line">method_getName(<span class="keyword">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m</span>) </span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(10.5, 2.0, 9.0, 1.0, 2.0)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IMP  </span></span><br><span class="line">OBJC_EXPORT IMP _Nonnull</span><br><span class="line">method_getImplementation(<span class="keyword">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m</span>) </span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(10.5, 2.0, 9.0, 1.0, 2.0)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取函数参数和返回值类型.(包含在返回的字符串中)</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">const</span> char * _Nullable</span><br><span class="line">method_getTypeEncoding(<span class="keyword">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m</span>) </span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(10.5, 2.0, 9.0, 1.0, 2.0)</span>;</span><br><span class="line">    </span><br><span class="line">OBJC_EXPORT void</span><br><span class="line">method_getReturnType(<span class="keyword">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m</span>, <span class="title function_">char</span> * _<span class="title function_">Nonnull</span> <span class="title function_">dst</span>, <span class="title function_">size_t</span> <span class="title function_">dst_len</span>) </span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(10.5, 2.0, 9.0, 1.0, 2.0)</span>;</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">- (void)methodApi</span><br><span class="line">&#123;</span><br><span class="line">    Method <span class="function"><span class="keyword">method</span> = <span class="title">class_getInstanceMethod</span></span>(Person.class, @selector(hasBook:));</span><br><span class="line">    SEL name = method_getName(<span class="function"><span class="keyword">method</span>)</span>;</span><br><span class="line">    NSLog(@<span class="string">&quot;sel:<span class="variable">%@</span>&quot;</span>, NSStringFromSelector(name));</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span>打印方法的参数和返回值类型编码</span><br><span class="line">    const char *types = method_getTypeEncoding(<span class="function"><span class="keyword">method</span>)</span>;</span><br><span class="line">    NSLog(@<span class="string">&quot;TypeEncoding:<span class="variable">%s</span>&quot;</span>, types); <span class="regexp">//</span><span class="string">&quot;B24<span class="variable">@0</span>:8<span class="variable">@16</span>&quot;</span>,不看数字就是<span class="string">&quot;B<span class="variable">@:</span>@&quot;</span>,即<span class="string">&quot;BOOL id SEL id&quot;</span>.表明返回值为BOOL类型,第<span class="number">0</span>个参数的类型是对象类型,第<span class="number">1</span>个参数的类型是SEL类型,第<span class="number">2</span>个参数的类型也是对象类型.中间夹杂的数字估计是偏移量.第<span class="number">0</span>个参数偏移量自然是<span class="number">0</span>,长度<span class="number">8</span>字节.于是第二个参数的偏移量自然是<span class="number">8</span>.以此类推.</span><br><span class="line">    </span><br><span class="line">    //打印参数个数</span><br><span class="line">    NSUInteger args = method_getNumberOfArguments(<span class="function"><span class="keyword">method</span>)</span>;</span><br><span class="line">    NSLog(@<span class="string">&quot;参数个数:<span class="variable">%lu</span>&quot;</span>, args);</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span>打印返回值的类型编码</span><br><span class="line">    char returnType;</span><br><span class="line">    method_getReturnType(<span class="function"><span class="keyword">method</span>, &amp;<span class="title">returnType</span>, 1)</span>;</span><br><span class="line">    char *rt = method_copyReturnType(<span class="function"><span class="keyword">method</span>)</span>;</span><br><span class="line">    NSLog(@<span class="string">&quot;returnType:<span class="variable">%c</span> <span class="variable">%s</span>&quot;</span>, returnType, rt);</span><br><span class="line">    free(rt); <span class="regexp">//</span>必须调用free,否则内存泄漏.</span><br><span class="line">    </span><br><span class="line">    //打印参数的类型编码</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args; i++) &#123;</span><br><span class="line">        char argType;</span><br><span class="line">        method_getArgumentType(<span class="function"><span class="keyword">method</span>, <span class="title">i</span>, &amp;<span class="title">argType</span>, 1)</span>;</span><br><span class="line">        NSLog(@<span class="string">&quot;argType<span class="variable">%d</span>:<span class="variable">%c</span>&quot;</span>, i, argType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args; i++) &#123;</span><br><span class="line">        char *arg = method_copyArgumentType(<span class="function"><span class="keyword">method</span>, <span class="title">i</span>)</span>;</span><br><span class="line">        NSLog(@<span class="string">&quot;argType<span class="variable">%d</span>:<span class="variable">%s</span>&quot;</span>, i, arg);</span><br><span class="line">        free(arg); <span class="regexp">//</span>必须调用free,否则内存泄漏.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //也可以使用NSMethodSignature对象来获取某个参数的类型编码或返回值编码</span><br><span class="line">    NSMethodSignature *methodSig = [Person instanceMethodSignatureForSelector:name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>根据上面的简单介绍,我们知道了:<br>SEL是一种数据类型,代表一个方法选择器.<br>IMP是一个函数指针,指向方法实现的具体函数首地址.<br>Method是一种数据类型,代表类里面定义的一个方法.<br>正是抽象出了这么几种数据类型,才让我们能够如此方便的运用runtime,使用各种黑科技.</p>
<p>最后以解决一个小问题,再次温习一下这三个概念,并结束本文.</p>
<p>问题:假设有一个SDK,我们仅知道这个SDK里面有一个私有类名叫”Person”,以及它的一个方法:<code>- (BOOL)hasBook:(NSString *)book;</code>,假设该方法的实现如下:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)hasBook:(<span class="built_in">NSString</span> *)book</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([book isEqualToString:<span class="string">@&quot;Gone with the wind&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在想要重写该方法的内部实现要求:当传入的参数为”Romance Of The Three Kingdoms”返回YES,否则还走原来的逻辑.如何做才可以办到?</p>
<p>解:其实如果Person不是私有类,我们只需要继承它,然后重写<code>hasBook:</code>方法,在里面来个if-else就完事了.但是现在Person是私有类,没办法继承,此路不通.同样的类别也不行,再说类别里的方法会覆盖原来的实现,基本上没法调用到原来的实现,所以类别也是行不通的.目前看来只有runtime可能有点用,现在就让我们使用上述API来搞定这个问题.</p>
<p>通过runtime我们可以获取到一个类的Method,有了Method就可以获取到原始IMP,然后我们还可以给Method设置一个新的IMP,在新的IMP里调用原始IMP.这样上述问题就解决了.</p>
<p>咱们先写个调用Person的hasBook:的方法,方便后面测试:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)invokeHasBookWithPerson:(<span class="type">id</span>)person param:(<span class="built_in">NSString</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    SEL seletor = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;hasBook:&quot;</span>);</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *methodSig = [person methodSignatureForSelector:seletor];</span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSig];</span><br><span class="line">    [invocation setArgument:&amp;param atIndex:<span class="number">2</span>];</span><br><span class="line">    [invocation setSelector:seletor];</span><br><span class="line">    [invocation setTarget:person];</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    <span class="comment">//调用后才可以去获取返回值.</span></span><br><span class="line">    <span class="type">BOOL</span> rs = <span class="literal">NO</span>;</span><br><span class="line">    [invocation getReturnValue:&amp;rs];</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为啥使用NSInvocation而不直接使用performSelector,是因为:</p>
<blockquote>
<p><code>- (id)performSelector:(SEL)aSelector;</code><br><code>- (id)performSelector:(SEL)aSelector withObject:(id)object;</code><br>performSelector系列方法,被执行的选择器的返回值必须是对象类型.否则将崩溃.参数也必须是对象类型,否则被执行的选择器得到的将是无效参数.如果是非对象类型,则只能使用NSInvocation.</p>
</blockquote>
<p>继续扯回来,这样正常的写法<code>[Person.new hasBook:@&quot;xxx&quot;];</code>变为:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> person = [<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;Person&quot;</span>) new];</span><br><span class="line"><span class="type">BOOL</span> rst1 = [<span class="keyword">self</span> invokeHasBookWithPerson:person param:<span class="string">@&quot;Romance Of The Three Kingdoms&quot;</span>];</span><br><span class="line"><span class="type">BOOL</span> rst2 = [<span class="keyword">self</span> invokeHasBookWithPerson:person param:<span class="string">@&quot;Gone with the wind&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;rst1:%d, rst2:%d&quot;</span>, rst1, rst2);</span><br></pre></td></tr></table></figure>
<p>打印为rst1:0, rst2:1.说明目前走的是以前的实现.</p>
<p>接下来就是获取原始IMP,以及设置新IMP.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Method method = class_getInstanceMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;Person&quot;</span>), <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;hasBook:&quot;</span>));</span><br><span class="line"><span class="comment">//获取原始IMP</span></span><br><span class="line">IMP imp1 = method_getImplementation(method);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;imp1:%p&quot;</span>, imp1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置新IMP</span></span><br><span class="line">method_setImplementation(method, imp_implementationWithBlock(^<span class="type">BOOL</span>(<span class="type">id</span> object, <span class="built_in">NSString</span> *arg) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;object:%@, arg:%@&quot;</span>, object, arg);</span><br><span class="line">    <span class="keyword">if</span> ([arg isEqualToString:<span class="string">@&quot;Romance Of The Three Kingdoms&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用原来的实现.</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">BOOL</span> (*)(<span class="type">id</span>, SEL, <span class="built_in">NSString</span> *))imp1)(object, <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;hasBook:&quot;</span>), arg);</span><br><span class="line">&#125;));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//测试效果</span></span><br><span class="line"><span class="type">id</span> person = [<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;Person&quot;</span>) new];</span><br><span class="line"><span class="type">BOOL</span> rst1 = [<span class="keyword">self</span> invokeHasBookWithPerson:person param:<span class="string">@&quot;Romance Of The Three Kingdoms&quot;</span>];</span><br><span class="line"><span class="type">BOOL</span> rst2 = [<span class="keyword">self</span> invokeHasBookWithPerson:person param:<span class="string">@&quot;Gone with the wind&quot;</span>];</span><br><span class="line"><span class="type">BOOL</span> rst3 = [<span class="keyword">self</span> invokeHasBookWithPerson:person param:<span class="string">@&quot;xxx&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;rst1:%d, rst2:%d&quot;</span>, rst1, rst2);</span><br></pre></td></tr></table></figure>
<p>打印结果:rst1:1, rst2:1, rst3:0.是预期的效果.问题解决.</p>
<p>其实我们还可以对上面的重写操作封装一下,这样如果其他类也有这样的需求,那么只需要改动Block的实现就可以了:</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">BOOL overideImplemention(Class <span class="class"><span class="keyword">class</span>, <span class="title">SEL</span> <span class="title">selector</span>, <span class="title">id</span> (^<span class="title">impBlk</span>)(<span class="title">Class</span> <span class="title">cls</span>, <span class="title">SEL</span> <span class="title">sel</span>, <span class="title">IMP</span> <span class="title">imp</span>)) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="class"><span class="keyword">class</span> == <span class="title">Nil</span> || <span class="title">selector</span> == <span class="title">NULL</span> || <span class="title">impBlk</span> == <span class="title">nil</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Method <span class="function"><span class="keyword">method</span> = <span class="title">class_getInstanceMethod</span></span>(<span class="keyword">class</span>, selector);</span><br><span class="line">    <span class="keyword">if</span> (<span class="function"><span class="keyword">method</span> == <span class="title">NULL</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    IMP originalIMP = method_getImplementation(<span class="function"><span class="keyword">method</span>)</span>;</span><br><span class="line">    method_setImplementation(<span class="function"><span class="keyword">method</span>, <span class="title">imp_implementationWithBlock</span></span>(impBlk(<span class="keyword">class</span>, selector, originalIMP)));</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">&#123;</span><br><span class="line">	BOOL isOveride = overideImplemention(NSClassFromString(@<span class="string">&quot;Person&quot;</span>), NSSelectorFromString(@<span class="string">&quot;hasBook:&quot;</span>), ^id(__unsafe_unretained Class cls, SEL sel, IMP imp) &#123;</span><br><span class="line">        <span class="keyword">return</span> ^BOOL(id object, NSString *arg) &#123;</span><br><span class="line">            <span class="keyword">if</span> (![object isKindOfClass:cls]) &#123;</span><br><span class="line">                <span class="keyword">return</span> NO;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ([arg isEqualToString:@<span class="string">&quot;Romance Of The Three Kingdoms&quot;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> YES;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //调用原始方法</span><br><span class="line">            <span class="keyword">return</span> ((BOOL (*)(id, SEL, NSString *))imp)(object, sel, arg);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (isOveride) &#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;重写成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL rst4 = [self invokeHasBookWithPerson:person param:@<span class="string">&quot;Romance Of The Three Kingdoms&quot;</span>];</span><br><span class="line">    BOOL rst5 = [self invokeHasBookWithPerson:person param:@<span class="string">&quot;Gone with the wind&quot;</span>];</span><br><span class="line">    BOOL rst6 = [self invokeHasBookWithPerson:person param:@<span class="string">&quot;Journey to the West&quot;</span>];</span><br><span class="line">    NSLog(@<span class="string">&quot;rst4:<span class="variable">%d</span>, rst5:<span class="variable">%d</span>, rst6:<span class="variable">%d</span>&quot;</span>, rst4, rst5, rst6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印:rst4:1, rst5:1, rst6:0.也是一样的效果.<br>经过重写,原SDK里的<code>hasBook:</code>消息也会走到我们新设置的IMP,如果我们不在新IMP里调用原IMP,那么程序将不再执行以前的实现.这就是runtime,是不是很强大.</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://developer.apple.com/documentation/objectivec/sel?language=occ">SEL的官方文档说明</a></p>
<p><a href="https://draveness.me/message">从源代码看 ObjC 中消息的发送</a></p>
<p><a href="https://awhisper.github.io/2015/12/31/%E5%B0%9D%E8%AF%95%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84performSelector-msgSend/">尝试手写一个更好用的performSelector-msgSend</a></p>
]]></content>
      <categories>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>SEL、IMP、Method</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 事件分发与手势识别</title>
    <url>/2019/05/19/iOS%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%B8%8E%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h3 id="iOS-事件分发与手势识别"><a href="#iOS-事件分发与手势识别" class="headerlink" title="iOS 事件分发与手势识别"></a>iOS 事件分发与手势识别</h3><p>在讲事件的分发之前,有三个概念不得不提:响应者对象, nextResponder, 响应者链.</p>
<h4 id="响应者对象"><a href="#响应者对象" class="headerlink" title="响应者对象"></a>响应者对象</h4><p>在iOS系统中，能够响应并处理事件的对象称之为responder object, UIResponder是所有responder对象的基类。<br>UIApplication,UIViewController,UIView和所有继承自UIView的UIKit类(包括UIWindow,继承自UIView)都直接或间接的继承自UIResponder,所以它们的实例都是responder object对象。</p>
<h4 id="nextResponder"><a href="#nextResponder" class="headerlink" title="nextResponder"></a>nextResponder</h4><p>有UIResponder的文档如下:</p>
<blockquote>
<p>The UIResponder class does not store or set the next responder automatically, so this method returns nil by default. Subclasses must override this method and return an appropriate next responder.</p>
</blockquote>
<p>UIResponder自身默认返回的是nil.但子类必须重写这个方法并且返回一个合适的nextResponder.UIView的默认实现:通常情况下是它的父视图,但是如果view是作为ViewController的rootView,那么它的nextResponder就是ViewController. ViewController的默认实现:返回它管理的view的父视图.</p>
<h4 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h4><p>app的视图结构是一个N叉树(一个视图可以有多个子视图，一个子视图同一时刻只有一个父视图),而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点。当叶节点成为第一响应者的时候，从这个叶节点开始往其父节点开始追朔出一条链，这一条链就是当前活跃的响应者链。</p>
<p>响应者链的链头是叶节点,链尾是UIApplication(如果AppDelegate也继承自UIResponsder,那么UIApplication会将事件代理给它).</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)didTapped:(<span class="built_in">UIGestureRecognizer</span> *)sender &#123;</span><br><span class="line">    <span class="comment">//拿到第一响应者，根据nextResponder就可以拿到整个响应者链。</span></span><br><span class="line">    <span class="built_in">UIResponder</span> *view = sender.view;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (view != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;第%d个：%@&quot;</span>, i, view);</span><br><span class="line">        </span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        view = view.nextResponder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  链头</span><br><span class="line">第一响应者---&gt;xxx---&gt;xxx---...--&gt;<span class="built_in">UIWindow</span>---&gt;<span class="built_in">UIApplication</span>---&gt;AppDelegate(可能)</span><br></pre></td></tr></table></figure>
<p>介绍完这个三个概念后,开始正文.</p>
<h4 id="第一响应者的查找"><a href="#第一响应者的查找" class="headerlink" title="第一响应者的查找"></a>第一响应者的查找</h4><p>简单点讲就是当前window(这里指的是keyWindow)会对其上的视图进行hitTest检测. hitTest方法会返回第一响应者.</p>
<p>复杂点讲就是发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中.UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理.通常,先发送事件给应用程序的主窗口（keyWindow）.主窗口会在视图层次结构中进行hitTest检测来找到一个最合适的视图处理触摸事件，这也是整个事件处理过程的第一步。找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。</p>
<p>hitTest的一种可能实现:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//首先判断是否可以接收事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden == <span class="literal">YES</span> || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//然后判断触摸点是否在当前视图上</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event] == <span class="literal">NO</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//循环遍历所有子视图，查找是否有最合适的视图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="keyword">self</span>.subviews.count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> *childView = <span class="keyword">self</span>.subviews[i];</span><br><span class="line">        <span class="comment">//转换点到子视图坐标系上</span></span><br><span class="line">        <span class="built_in">CGPoint</span> childPoint = [<span class="keyword">self</span> convertPoint:point toView:childView];</span><br><span class="line">        <span class="comment">//递归查找是否存在最合适的view</span></span><br><span class="line">        <span class="built_in">UIView</span> *fitView = [childView hitTest:childPoint withEvent:event];</span><br><span class="line">        <span class="comment">//如果返回非空，说明子视图中找到了最合适的view，那么返回它</span></span><br><span class="line">        <span class="keyword">if</span> (fitView) &#123;</span><br><span class="line">            <span class="keyword">return</span> fitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束，仍旧没有合适的子视图可以处理事件，那么就认为自己是最合适的view</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>note:重写hitTest方法要注意开始的三个条件判断,否则可能会出一些bug:比如重写button的hitTest方法但没有加上述判断,就会导致明明已经隐藏了button,但如果摸到了该button,那么该button的target-action方法将会被调用,这应该是你不希望的.</p>
<h4 id="触摸事件处理的整体过程"><a href="#触摸事件处理的整体过程" class="headerlink" title="触摸事件处理的整体过程"></a>触摸事件处理的整体过程</h4><ol>
<li><p>用户点击屏幕后产生一个触摸事件，经过一系列的hitTest过程后，会找到最合适的视图控件来处理这个事件</p>
</li>
<li><p>找到最合适的视图控件后，就会调用控件的touches方法来做具体的事件处理touchesBegan…touchesMoved…touchedEnded…</p>
</li>
<li><p>UIResponder的这些touches方法的默认实现是将事件顺着响应者链条向上传递，将事件交给nextResponder进行处理。如果最终都没有响应者处理，该事件就被抛弃。(如果你不想将事件交给nextResponder处理,那么在处理事件的时候不调用super就可以了,事件的处理到这个节点也就结束了)</p>
</li>
</ol>
<blockquote>
<p>note:在定制UIView子类的上述事件处理方法时，如果需要将事件传递给next responder,可以直接调用super的对应事件处理方法，这样事件将会传递给next responder,即使用<br><code>[super touchesBegan:touches withEvent:event];</code><br>不建议直接向nextResponder发送消息，这样可能会漏掉父类对这一事件的其他处理。<br><code>[self.nextResponder touchesBegan:touches withEvent:event];</code></p>
<p>为什么调用super，nextResponder会收到touch消息？super的意思是调用父类的实现，网上的一种说法是UIView的touch方法实现会将touch事件转发给nextResponder。</p>
</blockquote>
<p>父视图UIView上有一个按钮UIButton，点击btn，父视图上的touches系列方法是不会调用的，说明UIButton处理事件后没有调用super。</p>
<h4 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h4><p>有文档曰:</p>
<blockquote>
<p>Gesture recognizers receive touch and press events before their view does. If a view’s gesture recognizers fail to recognize a sequence of touches, UIKit sends the touches to the view. If the view does not handle the touches, UIKit passes them up the responder chain. For more information about using gesture recognizer’s to handle events, see Handling UIKit Gestures.</p>
</blockquote>
<p>又有<a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer">UIGestureRecognizer</a>文档曰:</p>
<blockquote>
<p>A window delivers touch events to a gesture recognizer before it delivers them to the hit-tested view attached to the gesture recognizer. Generally, if a gesture recognizer analyzes the stream of touches in a multi-touch sequence and doesn’t recognize its gesture, the view receives the full complement of touches. If a gesture recognizer recognizes its gesture, the remaining touches for the view are cancelled.</p>
</blockquote>
<p>字里行间透露着一句话：手势识别器拥有优先处理事件的权利。</p>
<p>手势识别的过程基本上是这样子的：当找到第一响应者view后，window会先让view上的手势识别器处理事件，当view上的手势识别器识别失败后，view才会接收到全部的touch。否则如果手势识别成功，view将收到touchCancel回调。<strong>与此同时</strong>（是否同时不太确定）系统也会沿着响应者链让所有链上的responder上的手势识别器处理事件,如果其中某个手势识别器识别成功,那么第一响应者将收到touchCancel回调.不同responder上的手势识别器可能会同时识别成功.而<code>shouldRecognizeSimultaneouslyWithGestureRecognizer</code>代理方法默认返回false.因此默认情况下最终只会有一个识别成功,即响应者链上最前面的responder上的手势的action方法被调用.</p>
<p>举个例子，如下图：XQView0_1上添加tap手势，XQView0_1_0的touch系列方法不调用super，点击XQView0_1_0。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/D82CF040-A5D9-4113-8ED7-97040B67CB6A.png" alt=""></p>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">03</span>-<span class="number">31</span> <span class="number">12</span>:<span class="number">56</span>:<span class="number">06</span>.<span class="number">719888</span>+<span class="number">0800</span> ResponderChainDemo[<span class="number">26161</span>:<span class="number">2476848</span>] touchesBegan:&lt;XQView0_1_0: <span class="number">0</span>x129b1d340; frame = (<span class="number">20</span> <span class="number">19</span>.<span class="number">6667</span>; <span class="number">35</span> <span class="number">35</span>); autoresize = RM+BM; backgroundColor = &lt;UIDynamicModifiedColor: <span class="number">0</span>x60000274de30; contrast = normal, baseColor = &lt;UIDynamicCatalogSystemColor: <span class="number">0</span>x600003c71100; name = systemTealColor&gt;&gt;; layer = &lt;CALayer: <span class="number">0</span>x6000029aba00&gt;&gt;</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">03</span>-<span class="number">31</span> <span class="number">12</span>:<span class="number">56</span>:<span class="number">06</span>.<span class="number">720824</span>+<span class="number">0800</span> ResponderChainDemo[<span class="number">26161</span>:<span class="number">2476848</span>] didTapped</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">03</span>-<span class="number">31</span> <span class="number">12</span>:<span class="number">56</span>:<span class="number">06</span>.<span class="number">721124</span>+<span class="number">0800</span> ResponderChainDemo[<span class="number">26161</span>:<span class="number">2476848</span>] touchesCancelled:&lt;XQView0_1_0: <span class="number">0</span>x129b1d340; frame = (<span class="number">20</span> <span class="number">19</span>.<span class="number">6667</span>; <span class="number">35</span> <span class="number">35</span>); autoresize = RM+BM; backgroundColor = &lt;UIDynamicModifiedColor: <span class="number">0</span>x60000274de30; contrast = normal, baseColor = &lt;UIDynamicCatalogSystemColor: <span class="number">0</span>x600003c71100; name = systemTealColor&gt;&gt;; layer = &lt;CALayer: <span class="number">0</span>x6000029aba00&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，即使XQView0_1_0不调用super，XQView0_1上的手势也能识别成功，并且识别成功后XQView0_1_0收到touchesCancelled消息。</p>
<p>猜想实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIResponder</span> *firstResponderView = a;</span><br><span class="line"><span class="built_in">NSArray</span> *responders = @[a, b, c, ..., <span class="built_in">UIWindow</span>, <span class="built_in">UIApplication</span>, AppDelegate];</span><br><span class="line"></span><br><span class="line">firstResponderView.touchBegin</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行手势识别</span></span><br><span class="line"><span class="type">BOOL</span> hasRec = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> responders &#123;</span><br><span class="line">    item.gestureRecognizers 开始识别手势</span><br><span class="line">    <span class="keyword">if</span> 识别成功 &#123;</span><br><span class="line">        hasRec = <span class="literal">YES</span>;</span><br><span class="line">        调用ges的target-action方法。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasRec &#123;</span><br><span class="line">    firstResponderView.touchCancelled</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//将touch事件全部交给firstResponderView处理。</span></span><br><span class="line">    firstResponderView.touchMoved</span><br><span class="line">    firstResponderView.touchEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UIWindow的派发事件方法:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)sendEvent:(UIEvent *)event;                    // <span class="keyword">called</span> <span class="keyword">by</span> UIApplication <span class="keyword">to</span> dispatch events <span class="keyword">to</span> views inside the <span class="keyword">window</span></span><br></pre></td></tr></table></figure>
<p>如果第一响应者是UIControl,情况会有所不同.</p>
<p>有<a href="https://developer.apple.com/documentation/uikit/uicontrol">UIControl</a>的文档如下:</p>
<blockquote>
<p>The target object can be any object, but it is typically the view controller whose root view contains the control. <strong>If you specify nil for the target object, the control searches the responder chain for an object that defines the specified action method.</strong></p>
</blockquote>
<p>当你指定target为nil的时候,系统会沿着响应者链寻找一个实现了action方法的响应者对象并调用action方法.上面说到手势识别器识别成功后,响应者链上的view将收到touchCancel回调.这里就有冲突了.最终的结果就是nextResponder上的手势识别器(cancelsTouchesInView = true,就是那种自己处理完后不让view处理的识别器)将不处理, 所有touch由UIControl处理,处理完后调用action方法.</p>
<p>比如:父view上添加tap手势,父view上添加一个UIButton.点击button,响应的是button的target-action,而不是tap的target-action.如果父view上的tap cancelsTouchesInView = false,则两者都会被调用.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5d396ef7518825453b605afa">深入理解 iOS 事件机制</a>   TODO：跟着作者的demo做一遍，加深理解</p>
<p><a href="https://www.jianshu.com/p/74a2f44840fa">iOS事件分发机制与实践</a></p>
<p><a href="https://www.jianshu.com/p/ef33cc31a614">iOS响应者链、事件的传递</a></p>
<p><a href="https://www.jianshu.com/p/77139b374313">详解iOS触摸事件与手势识别</a></p>
<p><a href="https://blog.csdn.net/zhoupengju/article/details/52250135">iOS事件响应者链之被忽视的手势识别器工作原理</a>  作者的思考挺有意思的</p>
<p>官方文档：</p>
<p><a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer">UIGestureRecognizer</a></p>
<p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events">Using Responders and the Responder Chain to Handle Events</a></p>
<p><a href="https://developer.apple.com/documentation/uikit/uiresponder/1621099-nextresponder?language=objc">nextResponder</a></p>
<p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer/about_the_gesture_recognizer_state_machine">About the Gesture Recognizer State Machine</a>  讲解手势识别器状态机的。如果要实现自定义的手势识别器建议看看。</p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIResponder</tag>
        <tag>事件分发</tag>
        <tag>手势识别</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌套页面手势冲突解决</title>
    <url>/2019/08/04/%E5%B5%8C%E5%A5%97%E9%A1%B5%E9%9D%A2%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h4 id="BUG场景"><a href="#BUG场景" class="headerlink" title="BUG场景"></a>BUG场景</h4><p>mainTableView嵌套listTableView.mainTableView的headerView里有左右滑动的collectionView(eg:轮播图).此时mainTableView的下拉刷新就会和collectionView的左右滑动起冲突.collectionView左右滑时,mainTableView可能会跟着一起动.</p>
<p>为了实现吸顶效果,mainTableView是允许同时识别多个手势的.而这恰恰是引起手势冲突的原因.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MainTableView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许多个手势</span></span><br><span class="line">- (<span class="type">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>由于mainTableView只能上下滑动,因此可以判断如果otherGestureRecognizer所在的view在左右滑动则不让mainTableView的手势同时识别.</p>
<p>这里有一个不好处理的地方就是在某些精心构造的滑动下,point可能为(0,0),</p>
<blockquote>
<p>偶现时的日志:</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="number">201</span>9-<span class="number">0</span>8-<span class="number">03</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">52.661593</span><span class="operator">+</span><span class="number">0800</span> xxx[<span class="number">20938</span>:<span class="number">1512558</span>] </span><br><span class="line">view:<span class="operator">&lt;</span><span class="params">MainTableView:</span> <span class="number">0</span>x1070c3c00; <span class="attr">baseClass</span> <span class="operator">=</span> UITableView; <span class="attr">frame</span> <span class="operator">=</span> (<span class="number">0</span> <span class="number">0</span>; <span class="number">414</span> <span class="number">623</span>); <span class="attr">clipsToBounds</span> <span class="operator">=</span> YES; <span class="attr">gestureRecognizers</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="params">NSArray:</span> <span class="number">0</span>x282b5dce0<span class="operator">&gt;</span>; <span class="attr">layer</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="params">CALayer:</span> <span class="number">0</span>x28258a980<span class="operator">&gt;</span>; <span class="params">contentOffset:</span> &#123;<span class="number">0</span>, <span class="operator">-</span><span class="number">3.3333333333333335</span>&#125;; <span class="params">contentSize:</span> &#123;<span class="number">414</span>, <span class="number">1418</span>&#125;; <span class="params">adjustedContentInset:</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;<span class="operator">&gt;</span></span><br><span class="line">ges:<span class="operator">&lt;</span><span class="params">UIScrollViewPanGestureRecognizer:</span> <span class="number">0</span>x106d75500; <span class="attr">state</span> <span class="operator">=</span> Changed; <span class="attr">delaysTouchesEnded</span> <span class="operator">=</span> NO; <span class="attr">view</span> <span class="operator">=</span> <span class="operator">&lt;</span>GKPageTableView <span class="number">0</span>x1070c3c00<span class="operator">&gt;</span>; <span class="attr">target</span><span class="operator">=</span> <span class="operator">&lt;</span>(action<span class="operator">=</span>handlePan:, target<span class="operator">=</span><span class="operator">&lt;</span>GKPageTableView <span class="number">0</span>x1070c3c00<span class="operator">&gt;</span>)<span class="operator">&gt;</span><span class="operator">&gt;</span></span><br><span class="line">otherView:<span class="operator">&lt;</span><span class="params">UICollectionView:</span> <span class="number">0</span>x1079cea00; <span class="attr">frame</span> <span class="operator">=</span> (<span class="number">0</span> <span class="number">0</span>; <span class="number">414</span> <span class="number">165.6</span>); <span class="attr">clipsToBounds</span> <span class="operator">=</span> YES; <span class="attr">gestureRecognizers</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="params">NSArray:</span> <span class="number">0</span>x282b03930<span class="operator">&gt;</span>; <span class="attr">layer</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="params">CALayer:</span> <span class="number">0</span>x2825528c0<span class="operator">&gt;</span>; <span class="params">contentOffset:</span> &#123;<span class="number">64584</span>, <span class="number">0</span>&#125;; <span class="params">contentSize:</span> &#123;<span class="number">124200</span>, <span class="number">165.60000000000002</span>&#125;; <span class="params">adjustedContentInset:</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;<span class="operator">&gt;</span> collection view <span class="params">layout:</span> <span class="operator">&lt;</span><span class="params">UICollectionViewFlowLayout:</span> <span class="number">0</span>x111c20eb0<span class="operator">&gt;</span></span><br><span class="line">otherGes:<span class="operator">&lt;</span><span class="params">UIScrollViewPanGestureRecognizer:</span> <span class="number">0</span>x106c7aaa0; <span class="attr">state</span> <span class="operator">=</span> Began; <span class="attr">delaysTouchesEnded</span> <span class="operator">=</span> NO; <span class="attr">view</span> <span class="operator">=</span> <span class="operator">&lt;</span>UICollectionView <span class="number">0</span>x1079cea00<span class="operator">&gt;</span>; <span class="attr">target</span><span class="operator">=</span> <span class="operator">&lt;</span>(action<span class="operator">=</span>handlePan:, target<span class="operator">=</span><span class="operator">&lt;</span>UICollectionView <span class="number">0</span>x1079cea00<span class="operator">&gt;</span>)<span class="operator">&gt;</span>; <span class="attr">must-fail</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="operator">&lt;</span><span class="params">UIScrollViewPagingSwipeGestureRecognizer:</span> <span class="number">0</span>x111c210d0; <span class="attr">state</span> <span class="operator">=</span> Failed; <span class="attr">view</span> <span class="operator">=</span> <span class="operator">&lt;</span>UICollectionView <span class="number">0</span>x1079cea00<span class="operator">&gt;</span>; <span class="attr">target</span><span class="operator">=</span> <span class="operator">&lt;</span>(action<span class="operator">=</span>_handleSwipe:, target<span class="operator">=</span><span class="operator">&lt;</span>UICollectionView <span class="number">0</span>x1079cea00<span class="operator">&gt;</span>)<span class="operator">&gt;</span><span class="operator">&gt;</span></span><br><span class="line">    &#125;<span class="operator">&gt;</span></span><br><span class="line"><span class="number">201</span>9-<span class="number">0</span>8-<span class="number">03</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">52.662988</span><span class="operator">+</span><span class="number">0800</span> EmotionCounsel[<span class="number">20938</span>:<span class="number">1512558</span>] </span><br><span class="line">移动的位置:&#123;<span class="number">0</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此时就没办法判断出otherGestureRecognizer.view是不是在左右滑动了.所以加了一个else判断避免这种情况.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MainTableView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许多个手势</span></span><br><span class="line">- (<span class="type">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([gestureRecognizer isKindOfClass:[<span class="built_in">UIPanGestureRecognizer</span> <span class="keyword">class</span>]] &amp;&amp; [otherGestureRecognizer isKindOfClass:[<span class="built_in">UIPanGestureRecognizer</span> <span class="keyword">class</span>]] &amp;&amp; otherGestureRecognizer.view != <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">UIPanGestureRecognizer</span> *otherPanGes = (<span class="built_in">UIPanGestureRecognizer</span> *)otherGestureRecognizer;</span><br><span class="line">        <span class="built_in">CGPoint</span> point = [otherPanGes translationInView:otherPanGes.view];</span><br><span class="line">        <span class="built_in">UIGestureRecognizerState</span> otherState = otherPanGes.state;</span><br><span class="line">        <span class="keyword">if</span> (otherState == <span class="built_in">UIGestureRecognizerStatePossible</span> || otherState == <span class="built_in">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fabs(point.x) &gt; <span class="number">0</span>) &#123; <span class="comment">//如果在水平左右滑动</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ([otherGestureRecognizer.view isKindOfClass:[<span class="built_in">UICollectionView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                    <span class="built_in">UICollectionView</span> *otherView = (<span class="built_in">UICollectionView</span> *)otherGestureRecognizer.view;</span><br><span class="line">                    <span class="keyword">if</span> ([otherView.collectionViewLayout isKindOfClass:[<span class="built_in">UICollectionViewFlowLayout</span> <span class="keyword">class</span>]] &amp;&amp; [(<span class="built_in">UICollectionViewFlowLayout</span> *)otherView.collectionViewLayout scrollDirection] == <span class="built_in">UICollectionViewScrollDirectionHorizontal</span>) &#123;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@&quot;正在滑动左右滚动视图!!!!!!&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@&quot;UICollectionView的其他布局&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;其他视图&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>手势冲突</tag>
      </tags>
  </entry>
  <entry>
    <title>音频打断处理</title>
    <url>/2019/07/12/%E9%9F%B3%E9%A2%91%E6%89%93%E6%96%AD%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="音频打断处理"><a href="#音频打断处理" class="headerlink" title="音频打断处理"></a>音频打断处理</h4><p>音频打断通知:</p>
<p><code>AVAudioSessionInterruptionNotification</code></p>
<p>音频会话被系统打断时会收到该通知.打断开始会收到该通知,打断结束也会收到该通知.可以通过userInfo里的<code>AVAudioSessionInterruptionTypeKey</code>key查看打断的类型:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">AVAudioSessionInterruptionType</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">AVAudioSessionInterruptionTypeBegan</span> = <span class="number">1</span>,  <span class="comment">/* the system has interrupted your audio session */</span></span><br><span class="line">	<span class="built_in">AVAudioSessionInterruptionTypeEnded</span> = <span class="number">0</span>,  <span class="comment">/* the interruption has ended */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* keys for AVAudioSessionInterruptionNotification */</span></span><br><span class="line"><span class="comment">/* Value is an NSNumber representing an AVAudioSessionInterruptionType */</span></span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionInterruptionTypeKey</span> API_AVAILABLE(ios(<span class="number">6.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(macos);</span><br></pre></td></tr></table></figure>
<p>如果是打断结束类型,则userInfo里会有一个<code>AVAudioSessionInterruptionOptions</code>key,它的值是<code>AVAudioSessionInterruptionOptions</code>枚举类型.用于表示打断结束后是否应该继续播放.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For use with AVAudioSessionInterruptionNotification */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">AVAudioSessionInterruptionOptions</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">AVAudioSessionInterruptionOptionShouldResume</span> = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果打断是因为应用被挂起,则userInfo里会有一个<code>AVAudioSessionInterruptionWasSuspendedKey</code>key,并且值是true.(这个key有点奇葩)</p>
<p>使用如下:</p>
<p>注册<code>AVAudioSessionInterruptionNotification</code>通知:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(playerAudioBeInterrupted:) name:<span class="built_in">AVAudioSessionInterruptionNotification</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>处理通知:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)playerAudioBeInterrupted:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo = notification.userInfo;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;音频打断userInfo:%@&quot;</span>, userInfo);</span><br><span class="line">    <span class="built_in">AVAudioSessionInterruptionType</span> interruptionType = [userInfo[<span class="built_in">AVAudioSessionInterruptionTypeKey</span>] integerValue];</span><br><span class="line">    <span class="keyword">if</span> (interruptionType == <span class="built_in">AVAudioSessionInterruptionTypeBegan</span>) &#123;<span class="comment">//打断开始</span></span><br><span class="line">        <span class="comment">//这个时候要暂停播放器</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interruptionType == <span class="built_in">AVAudioSessionInterruptionTypeEnded</span>) &#123;<span class="comment">//打断结束</span></span><br><span class="line">        <span class="built_in">AVAudioSessionInterruptionOptions</span> options = [userInfo[<span class="built_in">AVAudioSessionInterruptionOptionKey</span>] integerValue];</span><br><span class="line">        <span class="keyword">if</span> (options == <span class="built_in">AVAudioSessionInterruptionOptionShouldResume</span>) &#123; <span class="comment">//可以继续播放</span></span><br><span class="line">            <span class="comment">//继续播放</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//不处理</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;未知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:在开发的时候遇到一个坑:<br>在app内听音乐,点暂停,然后进入后台一段时间,再从后台进入前台时,音乐居然自动播放了.<br>最后找到原因:上述操作后,在进入前台时会收到<code>AVAudioSessionInterruptionNotification</code>通知.之前代码在打断结束的判断中没有继续判断是否应该恢复播放,而直接调用了play方法,导致上述bug.</p>
<p>打印日志如下:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">04</span>:<span class="number">56.847796</span> +<span class="number">0800</span>	EmotionCounsel	app did resume</span><br><span class="line"><span class="number">19</span>:<span class="number">04</span>:<span class="number">56.850945</span> +<span class="number">0800</span>	EmotionCounsel	<span class="built_in">AVAudioSession</span>.mm:<span class="number">2136</span>:-[<span class="built_in">AVAudioSession</span> privateInterruptionWithInfo:]: Posting <span class="built_in">AVAudioSessionInterruptionNotification</span> (Begin Interruption). Was suspended:<span class="number">1</span></span><br><span class="line"><span class="number">19</span>:<span class="number">04</span>:<span class="number">56.851301</span> +<span class="number">0800</span>	EmotionCounsel	音频打断userInfo:&#123;</span><br><span class="line">    <span class="built_in">AVAudioSessionInterruptionTypeKey</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">AVAudioSessionInterruptionWasSuspendedKey</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">19</span>:<span class="number">04</span>:<span class="number">56.851538</span> +<span class="number">0800</span>	EmotionCounsel	<span class="built_in">AVAudioSession</span>.mm:<span class="number">2156</span>:-[<span class="built_in">AVAudioSession</span> privateInterruptionWithInfo:]: Posting <span class="built_in">AVAudioSessionInterruptionNotification</span> (End Interruption). Resumable:<span class="number">0</span></span><br><span class="line"><span class="number">19</span>:<span class="number">04</span>:<span class="number">56.851616</span> +<span class="number">0800</span>	EmotionCounsel	音频打断userInfo:&#123;</span><br><span class="line">    <span class="built_in">AVAudioSessionInterruptionOptionKey</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">AVAudioSessionInterruptionTypeKey</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音频打断</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频编码格式和文件格式</title>
    <url>/2018/12/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="音视频文件格式和编码格式"><a href="#音视频文件格式和编码格式" class="headerlink" title="音视频文件格式和编码格式"></a>音视频文件格式和编码格式</h3><p>主要是搞清楚两个概念：编码格式和文件格式。</p>
<p>由于音视频的原始数据都很大，不方便存储与传输，所以就有各种各样的编码技术或算法对其进行编码以达到减少数据的目的，这些编码技术就叫编码格式，有些编码格式解码后能够完全恢复为原始数据，因此这些编码格式也被称为无损压缩，而有些编码格式解码后不能恢复为原来的数据因此也被称为有损压缩。</p>
<p>我们通常说的音视频格式准确地讲应该是音视频文件格式。音视频文件格式它是一个容器里面包含了音频、视频、字幕等，有时也被称为封装格式。有些文件格式只能装载特定编码格式的数据，而有些文件格式既可以装载A编码格式的数据，也可以装载B编码格式的数据，不过这也会带来一些问题比如某个播放器只能播放装载A编码格式的.mp4文件，这时如果你给他一个装载B编码格式的.mp4文件那么这个播放器就会播放失败。对于音频文件，虽然一种音频文件格式可以支持多种编码，例如AVI文件格式，但多数的音频文件仅支持一种音频编码。</p>
<p>音视频文件的名字后面都会有一个扩展名，这个扩展名就代表它是什么文件格式，扩展名的作用就是告诉操作系统应该使用什么样的软件来打开该文件，对于音视频文件改变扩展名并不影响内部数据的编码格式，反而还会误导操作系统，导致文件打开失败，如果想改变编码格式则需要专门的格式转换软件。</p>
<p>编码技术是会不断发展迭代的，所以经常会看到一个编码技术下面可能还会分好几个子类。另外编码格式有各个厂商推出的，也有标准组织推出的，也有个人推出的。这也导致了市面上出现了各种编码格式，每种编码格式又会对应一种文件格式，这就造成了新手在一堆格式名称里晕头转向。我们所说的格式一般指文件格式，但有些时候又是指编码格式，造成这种现象的原因主要是大部分文件格式只支持一种编码格式，这个时候文件格式和编码格式可以看做是同一个东西。</p>
<p>一个音频文件的播放过程：</p>
<p>音频文件——&gt;解封装——-&gt;解码———&gt;渲染播放</p>
<p>视频播放则要复杂一些，主要是音频和视频的同步。</p>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2024-05-22%2013.02.10.png" style="zoom:50%;" /></p>
<p>图片文件，音频文件，视频文件感觉都是一个套路。</p>
<p>常见音频文件格式：</p>
<ul>
<li>无损格式，例如WAV，PCM，ALS，ALAC，TAK，FLAC，APE，WavPack(WV)</li>
<li>有损格式，例如MP3，AAC，WMA，Ogg Vorbis</li>
</ul>
<h3 id="AVPlayer支持的格式"><a href="#AVPlayer支持的格式" class="headerlink" title="AVPlayer支持的格式"></a>AVPlayer支持的格式</h3><p>可以通过这几个API查看文件是否支持播放</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">  @method		audiovisualTypes</span></span><br><span class="line"><span class="comment">  @abstract		Provides the file types the AVURLAsset class understands.</span></span><br><span class="line"><span class="comment">  @result		An NSArray of UTIs identifying the file types the AVURLAsset class understands.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVFileType</span>&gt; *)audiovisualTypes API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), tvos(<span class="number">9.0</span>), watchos(<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">  @method		audiovisualMIMETypes</span></span><br><span class="line"><span class="comment">  @abstract		Provides the MIME types the AVURLAsset class understands.</span></span><br><span class="line"><span class="comment">  @result		An NSArray of NSStrings containing MIME types the AVURLAsset class understands.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)audiovisualMIMETypes API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), tvos(<span class="number">9.0</span>), watchos(<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">  @method		isPlayableExtendedMIMEType:</span></span><br><span class="line"><span class="comment">  @abstract		Returns YES if asset is playable with the codec(s) and container type specified in extendedMIMEType. Returns NO otherwise.</span></span><br><span class="line"><span class="comment">  @param		extendedMIMEType</span></span><br><span class="line"><span class="comment">  @result		YES or NO.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isPlayableExtendedMIMEType: (<span class="built_in">NSString</span> *)extendedMIMEType API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), tvos(<span class="number">9.0</span>), watchos(<span class="number">1.0</span>));</span><br></pre></td></tr></table></figure>
<p>支持的格式，MIME打印：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&quot;<span class="selector-tag">audio</span>/vnd<span class="selector-class">.wave</span>&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/aacp&quot;,</span><br><span class="line">&quot;<span class="selector-tag">video</span>/<span class="number">3</span>gpp2&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/mpeg3&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/mp3&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-caf&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/mpeg&quot;,</span><br><span class="line">&quot;<span class="selector-tag">video</span>/quicktime&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-mpeg3&quot;,</span><br><span class="line">&quot;<span class="selector-tag">video</span>/mp4&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/wav&quot;,</span><br><span class="line">&quot;<span class="selector-tag">video</span>/avi&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/flac&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/mp4&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-mpg&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/scpls&quot;,</span><br><span class="line">&quot;<span class="selector-tag">video</span>/<span class="attribute">x</span>-m4v&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-wav&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-aiff&quot;,</span><br><span class="line">&quot;application/ttml+xml&quot;,</span><br><span class="line">&quot;application/vnd<span class="selector-class">.apple</span><span class="selector-class">.mpegurl</span>&quot;,</span><br><span class="line">&quot;<span class="selector-tag">video</span>/<span class="number">3</span>gpp&quot;,</span><br><span class="line">&quot;<span class="selector-tag">text</span>/vtt&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/usac&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-mpeg&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/wave&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-m4r&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-mp3&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/AMR&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/aiff&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="number">3</span>gpp2&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/aac&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/mpg&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/mpegurl&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-m4b&quot;,</span><br><span class="line">&quot;application/mp4&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-m4p&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-scpls&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-mpegurl&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-aac&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="number">3</span>gpp&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/basic&quot;,</span><br><span class="line">&quot;<span class="selector-tag">audio</span>/<span class="attribute">x</span>-m4a&quot;,</span><br><span class="line">&quot;application/<span class="attribute">x</span>-mpegurl&quot;</span><br></pre></td></tr></table></figure>
<p>很明显不支持ogg、wma、ape(一种无损压缩编码格式)、flv、rm这些音频格式。网上很多文章都是瞎写的拷贝的百度百科的，只因为百度百科有一个词条AVPlayer，但是此AVPlayer（是一个播放器）不是彼AVPlayer（iOS里的一个框架）。所以还是用系统API检查一下看看是不是支持。</p>
<p>iOS支持的音频文件格式  </p>
<p>iOS supports the audio file formats listed in Table 2-1. For information on audio data formats available in iOS, see Codecs.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Format name</th>
<th>Format filename extensions</th>
</tr>
</thead>
<tbody>
<tr>
<td>AIFF</td>
<td>.aif, .aiff</td>
</tr>
<tr>
<td>CAF</td>
<td>.caf</td>
</tr>
<tr>
<td>MPEG-1, layer 3</td>
<td>.mp3</td>
</tr>
<tr>
<td>MPEG-2 or MPEG-4 ADTS</td>
<td>.aac</td>
</tr>
<tr>
<td>MPEG-4</td>
<td>.m4a, .mp4</td>
</tr>
<tr>
<td>WAV</td>
<td>.wav</td>
</tr>
</tbody>
</table>
</div>
<p>基本上就是mpeg系列再加上少数几个其他格式。</p>
<h3 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h3><p>PCM：又称脉冲编码调制（也叫音频裸数据）。<strong>PCM音频数据是未经压缩的音频采样数据裸流</strong>，它是由模拟信号经过采样、量化、编码转换成的标准的数字音频数据。</p>
<h3 id="AIFF"><a href="#AIFF" class="headerlink" title="AIFF"></a>AIFF</h3><p>音频交换文件格式（Audio Interchange File Format，缩写为AIFF）,苹果公司开发。一个标准的AIFF文件中的音频应是线性PCM，还有一种被称为AIFF-C或AIFC的使用各种压缩编解码器的变体。</p>
<p><strong>是否压缩</strong></p>
<p>无压缩。</p>
<p><strong>文件扩展名</strong></p>
<p>标准AIFF文件的扩展名是.aiff或.aif，压缩过的AIFF文件的扩展名应是.aifc。</p>
<h3 id="WAV"><a href="#WAV" class="headerlink" title="WAV"></a>WAV</h3><p>WAV 是 Microsoft 和 IBM 为 PC 开发的一种声音文件格式，它符合 RIFF（Resource Interchange File Format）文件规范，用于保存 Windows 平台的音频信息资源，被 Windows 平台及其应用程序所广泛支持。WAVE 文件通常只是一个具有单个 “WAVE” 块的 RIFF 文件，该块有两个子块（”fmt” 子数据块和 ”data” 子数据块）</p>
<p>该格式的实质就是在 PCM 文件的前面加了一个文件头。</p>
<p><strong>是否压缩</strong></p>
<p>无压缩。</p>
<p><strong>文件扩展名</strong></p>
<p>.wav</p>
<h3 id="CAF"><a href="#CAF" class="headerlink" title="CAF"></a>CAF</h3><p>Core Audio Format，即核心音频格式，是苹果公司为了消除<a href="https://www.wenjianbaike.com/aiff.html">.AIFF</a>和<a href="https://www.wenjianbaike.com/wav.html">.WAV</a>格式的局限而开发的音频格式。CAF文件结构的灵活性以及可以记录的多种类型的元数据使它几乎可以与任何类型的音频数据一起使用。</p>
<p>这种文件格式就是典型的一对多的文件格式。你不知道它里面存储的是啥类型的编码格式数据。</p>
<p><strong>文件扩展名</strong></p>
<p>.caf</p>
<h3 id="WMA"><a href="#WMA" class="headerlink" title="WMA"></a><strong>WMA</strong></h3><p>Windows Media Audio，是微软公司开发的一系列音频编解码器，也指相应的数字音频编码格式。</p>
<p><strong>是否压缩</strong></p>
<p>有损压缩。(并不绝对，因为一种编解码格式下面可能有好几种子类型，而其中一种子类型可能支持无损压缩。为了方便如果大部分都是有损压缩，就当做有损压缩了)</p>
<p><strong>文件扩展名</strong></p>
<p>.wma</p>
<h3 id="MPEG"><a href="#MPEG" class="headerlink" title="MPEG"></a>MPEG</h3><p>MPEG：动态影像专家小组，Moving Picture Experts Group，简称MPEG，是一个源自ISO与IEC等国际组织的工作小组，用以制定影音压缩及传输的规格标准。</p>
<p>MPEG小组到目前为止，已有以下和音视频相关的标准：MPEG-1、MPEG-2、MPEG-3、MPEG-4、MPEG-7、MPEG-21。MPEG-1是MPEG组织制定的第一个视频和音频有损压缩标准。</p>
<p>可以看到MPEG已经制定了很多标准了，这些标准涵盖了很多方面，因此每个标准下面又包含很多个部分。比如MPEG-1包含5个part，Part 2是video部分，Part 3是audio部分，audio部分下面又包含3个Layer，其中MPEG-1 Audio Layer III，就是第一版的MP3。</p>
<p>MPEG-2标准是对MPEG-1标准的补充和扩展。MPEG-2 Part7部分引入了AAC，AAC在MPEG-4的Part 3中也有定义。</p>
<h4 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h4><p>MPEG-1 Audio Layer III</p>
<p><strong>是否压缩</strong></p>
<p>有损压缩。</p>
<p><strong>文件扩展名</strong></p>
<p>.mp3，实际上由于MPEG-1标准下包含很多子标准所以跟MPEG-1有关的文件扩展名非常多。</p>
<p><a href="https://en.wikipedia.org/wiki/MPEG-1">MPEG-1</a> </p>
<p><a href="https://en.wikipedia.org/wiki/MPEG-2">MPEG-2</a></p>
<p><a href="https://en.wikipedia.org/wiki/MPEG-4">MPEG-4</a></p>
<p>MPEG-4相关的文件扩展名可以参考：<a href="https://en.wikipedia.org/wiki/MPEG-4_Part_14">MPEG-4_Part_14的Filename extensions</a> ，扩展名是真的多。</p>
<h3 id="AAC"><a href="#AAC" class="headerlink" title="AAC"></a>AAC</h3><p>AAC是高级音频编码（Advanced Audio Coding）的缩写，出现于1997年，最初是基于MPEG-2的音频编码技术，目的是取代MP3格式。2000年，MPEG-4标准出台，AAC重新集成了其它技术包括SBR或PS特性，目前AAC可以定义为⼀种由 MPEG-4 标准定义的有损音频压缩格式。</p>
<p><strong>是否压缩</strong></p>
<p>有损压缩。</p>
<p><strong>ACC 音频文件格式类型</strong></p>
<p>AAC的音频文件格式有ADIF 和 ADTS：</p>
<p><strong>ADIF</strong>：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行，这种格式常用在磁盘文件中。</p>
<p><strong>ADTS</strong>：Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。</p>
<p>简单说，ADTS可以在任意帧解码，也就是说它每一帧都有头信息。ADIF只有一个统一的头，所以必须得到所有的数据后解码。这两种的header的格式也是不同的，一般编码后的和抽取出的都是ADTS格式的音频流。</p>
<p><strong>文件扩展名</strong></p>
<p>.aac</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/6844903725291552775">AVPlayer支持的视频格式</a>   ⭐️⭐️⭐️</p>
<p><a href="https://www.cnblogs.com/booksky/p/5213198.html">浅谈iOS视频开发</a>  ⭐️⭐️⭐️</p>
<p><a href="https://blog.csdn.net/bsplover/article/details/7426480">常见音频编码格式总结</a></p>
<p><a href="http://blog.51cto.com/huangfu3342/1613795">音视频封装格式、编码格式知识</a></p>
<p><a href="https://www.cnblogs.com/renhui/p/10412630.html">音视频编解码技术（二）：AAC 音频编码技术</a>  比较详细</p>
<p><a href="https://www.wenjianbaike.com/aac.html">.AAC文件扩展名</a></p>
<p><a href="https://www.cnblogs.com/renhui/p/12148330.html">多媒体文件格式（五）：PCM / WAV 格式</a>   比较详细</p>
<p><a href="https://zhuanlan.zhihu.com/p/396273481">PCM数据格式你该知道一切</a></p>
<p><a href="https://www.jianshu.com/p/e568f94cdf6a">PCM数据格式</a></p>
<p><a href="https://blog.csdn.net/u010650845/article/details/53520426">MP3文件结构解析(超详细)</a></p>
<p><a href="https://www.cnblogs.com/ranson7zop/p/7655474.html#!comments">MP3格式音频文件结构解析</a></p>
<p><a href="https://en.wikipedia.org/wiki/Comparison_of_audio_coding_formats">Comparison of audio coding formats</a></p>
<p><a href="https://damiansheldon.github.io/blog/audio-and-video-file-format.html">音频和视频格式</a></p>
<p><a href="https://www.jianshu.com/p/4d611897526b">关于CAF文件</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>OC懒加载与Swift懒加载</title>
    <url>/2019/09/01/OC%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8ESwift%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="OC懒加载与Swift懒加载"><a href="#OC懒加载与Swift懒加载" class="headerlink" title="OC懒加载与Swift懒加载"></a>OC懒加载与Swift懒加载</h3><h4 id="OC懒加载"><a href="#OC懒加载" class="headerlink" title="OC懒加载"></a>OC懒加载</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)redView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_redView <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        _redView <span class="operator">=</span> [[<span class="type">UIView</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        _redView.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">        _redView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.redColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _redView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:在懒加载的实现中尽量避免懒加载循环.即A懒加载B,B又懒加载A.这样会导致互相调用而死循环或者偏离预期结果.</p>
<p>错误示例1:会导致调用死循环.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)redView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_redView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.blackView.frame.size.width + <span class="number">100</span>, <span class="number">200</span>)];</span><br><span class="line">        view.backgroundColor = <span class="built_in">UIColor</span>.redColor;</span><br><span class="line">        _redView = view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _redView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)blackView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_blackView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="keyword">self</span>.redView.frame.size.height + <span class="number">100</span>)];</span><br><span class="line">        view.backgroundColor = <span class="built_in">UIColor</span>.blackColor;</span><br><span class="line">        _blackView = view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _blackView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>错误示例2:示例2其实和示例1是一回事.也会导致调用死循环.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)redView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_redView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _redView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.blackView.frame.size.width + <span class="number">100</span>, <span class="number">200</span>)];</span><br><span class="line">        _redView.backgroundColor = <span class="built_in">UIColor</span>.redColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _redView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)blackView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_blackView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _blackView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="keyword">self</span>.redView.frame.size.height + <span class="number">100</span>)];</span><br><span class="line">        _blackView.backgroundColor = <span class="built_in">UIColor</span>.blackColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _blackView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误示例3:程序会在<code>[self.view addSubview:self.redView];</code>这一行崩溃:<code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x0)</code></p>
<p>原因在于:对于一个OC对象,alloc之后必须调用init方法完成初始化.对象只有在初始化完成之后才能继续使用.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.redView];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.blackView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)redView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_redView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _redView = [<span class="built_in">UIView</span> alloc];</span><br><span class="line">        _redView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.blackView.frame.size.width + <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">        _redView.backgroundColor = <span class="built_in">UIColor</span>.redColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _redView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)blackView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_blackView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _blackView = [<span class="built_in">UIView</span> alloc];</span><br><span class="line">        _blackView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="keyword">self</span>.redView.frame.size.height + <span class="number">100</span>);</span><br><span class="line">        _blackView.backgroundColor = <span class="built_in">UIColor</span>.blackColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _blackView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误示例4:程序虽然不会崩溃,但二者的frame会和你的预期不同,因此不建议这么做.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)redView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_redView <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        _redView <span class="operator">=</span> [[<span class="type">UIView</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        _redView.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.blackView.frame.size.width <span class="operator">+</span> <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">        _redView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.redColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _redView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)blackView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_blackView <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        _blackView <span class="operator">=</span> [[<span class="type">UIView</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        _blackView.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="keyword">self</span>.redView.frame.size.height <span class="operator">+</span> <span class="number">100</span>);</span><br><span class="line">        _blackView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.blackColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _blackView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种更隐秘的懒加载调用懒加载:子视图懒加载中使用了self.view,而self.view也是懒加载的.虽然在大多数情况下self.view会先于子视图加载,从而不会出现什么问题.但也有一些特殊情况下会出现子视图先于self.view访问.从而出现一些bug.</p>
<p>eg: 子视图redView使用了self.view的frame信息.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XQViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *redView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XQViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XQViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = <span class="built_in">UIColor</span>.whiteColor;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.redView];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;添加的view:%@&quot;</span>, _redView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)redView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_redView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _redView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">200</span>, <span class="keyword">self</span>.view.frame.size.width, <span class="number">200</span>)];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, _redView);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _redView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//在某个地方我们先访问了子控件,并调用了子控件的某个方法.</span></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    XQViewController *vc = [XQViewController.alloc init];</span><br><span class="line">    vc.redView.backgroundColor = <span class="built_in">UIColor</span>.redColor;</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">YES</span> completion:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>打印如下:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2019</span>-<span class="number">09</span>-<span class="number">01</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">08</span>.<span class="number">512351</span>+<span class="number">0800</span> OCDemo[<span class="number">70734</span>:<span class="number">2950590</span>] &lt;UIView: <span class="number">0</span>x7fd353f14610; frame = (<span class="number">0</span> <span class="number">200</span>; <span class="number">375</span> <span class="number">200</span>); layer = &lt;CALayer: <span class="number">0</span>x600002d6dae0&gt;&gt;</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">09</span>-<span class="number">01</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">08</span>.<span class="number">512753</span>+<span class="number">0800</span> OCDemo[<span class="number">70734</span>:<span class="number">2950590</span>] 添加的view:&lt;UIView: <span class="number">0</span>x7fd353f14610; frame = (<span class="number">0</span> <span class="number">200</span>; <span class="number">375</span> <span class="number">200</span>); layer = &lt;CALayer: <span class="number">0</span>x600002d6dae0&gt;&gt;</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">09</span>-<span class="number">01</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">08</span>.<span class="number">512946</span>+<span class="number">0800</span> OCDemo[<span class="number">70734</span>:<span class="number">2950590</span>] &lt;UIView: <span class="number">0</span>x7fd353f0a1f0; frame = (<span class="number">0</span> <span class="number">200</span>; <span class="number">375</span> <span class="number">200</span>); layer = &lt;CALayer: <span class="number">0</span>x600002d75960&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这个时候self.redView和self.view上添加的redView其实是两个不同的对象.因此界面上并不会出现红色的视图.</p>
<p>解决办法有两种:</p>
<ol>
<li>手动提前self.view的加载.如:<code>[vc loadViewIfNeeded];</code></li>
<li>避免在子控件中使用self.view</li>
</ol>
<h4 id="Swift懒加载"><a href="#Swift懒加载" class="headerlink" title="Swift懒加载"></a>Swift懒加载</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> blackView: <span class="type">UIView</span>? <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">300</span>, width: <span class="number">200</span>, height: <span class="number">100</span>))</span><br><span class="line">    view.backgroundColor <span class="operator">=</span> .black</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>Swift的懒加载实现只会执行一次,如果在某个地方将blackView置为nil后,懒加载的实现不会被再次执行.blackView就一直是nil了.</p>
<p>同样:在懒加载的实现中尽量避免相互懒加载.</p>
<p>错误示例:死循环</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> redView: <span class="type">UIView</span> <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="keyword">self</span>.blackView.frame.size.width <span class="operator">+</span> <span class="number">100</span>, height: <span class="number">200</span>))</span><br><span class="line">    view.backgroundColor <span class="operator">=</span> .red</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> blackView: <span class="type">UIView</span> <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">300</span>, width: <span class="number">200</span>, height: <span class="keyword">self</span>.redView.frame.size.height <span class="operator">+</span> <span class="number">100</span>))</span><br><span class="line">    view.backgroundColor <span class="operator">=</span> .black</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>相同点:对象在真正使用时才会被初始化.</p>
<p>不同点:OC的懒加载实现可能会被多次调用.当属性的实例变量变为nil时会再次执行.而Swift的懒加载实现只会被执行一次,如果在某个地方将变量置为nil后,懒加载的实现不会被再次执行.变量就一直是nil了.</p>
<p>注意点:在懒加载的实现中尽量避免懒加载循环.即A懒加载B,B又懒加载A.这样会导致互相调用而死循环或者偏离预期结果.</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title>OC nullability特性</title>
    <url>/2019/10/01/OC%20nullability%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="OC-nullability特性"><a href="#OC-nullability特性" class="headerlink" title="OC nullability特性"></a>OC nullability特性</h3><p>众所周知,Swift语言是严格区分可选和非可选变量的.比如<code>UIView</code>和<code>UIView?</code>.而在之前的OC中却没有这个概念,二者都使用<code>UIView*</code>表示.由于Swift编译器无法根据<code>UIView*</code>判断该变量是否是可选的.因此该类型在Swift中被解释为隐式解包<code>UIView!</code>.而在Swift中对一个值为nil的可选变量进行强制解包时将导致崩溃.因此你必须时刻警惕<code>UIView!</code>变量在某处会不会被赋值为nil.这不仅带来使用上的不便,而且也影响编程体验.因此有必要让OC兼容Swift的Optional特性,方便OC的类在Swift中的使用.于是在Xcode 6.3 开始官方便给OC添加了nullability功能.</p>
<p>nullability 特性包含<code>_Nullable</code> 和 <code>_Nonnull</code>这两种修饰符.<code>_Nullable</code>表明该变量可以为nil或NULL值.而<code>_Nonnull</code>表明该变量不能为nil值.两个变种写法<code>nullable</code>,<code>nonnull</code>.</p>
<p>示例如下:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> myCase  4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> myCase == 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *version;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">long</span> words;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *publicID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *url;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *author;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Swift接口如下:</span></span><br><span class="line"><span class="comment">open class Book : NSObject &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public init!(name: String!)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    open var name: String!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    open var version: String!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    open var words: Int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    open var publicID: String!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    open var url: String!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    open var author: Person!</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> myCase == 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐写法.属性都不可为nil</span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *version;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">long</span> words;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *publicID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *url;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *author;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> myCase == 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐写法,个别属性可为nil</span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *version;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">long</span> words;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *publicID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *url;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *author;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> myCase == 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全部自己手动定义</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> * _Nonnull)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * _Nonnull name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *version;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">long</span> words;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSNumber</span> *barCode;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *publicID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *url;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) Person *author;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;Person *&gt; *seeker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="nullability特性对OC编码的影响"><a href="#nullability特性对OC编码的影响" class="headerlink" title="nullability特性对OC编码的影响"></a>nullability特性对OC编码的影响</h4><p>在OC中即使标明为<code>_Nonnull</code>,你依然可以给它一个nil值,但编译器会给出警告,仅仅是警告.因此在OC中不要对<code>_Nonnull</code>修饰的变量抱有一定不为nil的幻想,否则该崩还得崩.</p>
<p>nullability特性只是一种约定,在开发的过程中我们要遵守这一约定.如果一个变量是nonnull的,我们在init方法中一定要给它一个初始值,并且在使用过程中不要给它赋值为nil.</p>
<h4 id="nullability特性对OC-Swift混编的影响"><a href="#nullability特性对OC-Swift混编的影响" class="headerlink" title="nullability特性对OC,Swift混编的影响"></a>nullability特性对OC,Swift混编的影响</h4><p>nullability特性其实主要还是为了方便OC的类在Swift中的使用.</p>
<p>一个<code>_Nonnull</code>修饰的OC变量,它在OC代码中可能会被赋值为nil,当它在Swift中使用时nil会变成<code>&lt;uninitialized&gt;</code>对象.奇怪的是如果是nil的NSString则会被自动转换为空字符<code>&quot;&quot;</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">Person</span> : <span class="type">NSObject</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>) <span class="type">NSString</span> <span class="operator">*</span>name;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>) <span class="type">NSString</span> <span class="operator">*</span>sex;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)hello;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">Book</span> : <span class="type">NSObject</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (nonnull instancetype)initWithName:(<span class="type">NSString</span> <span class="operator">*</span> _Nonnull)name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>) <span class="type">NSString</span> <span class="operator">*</span> _Nonnull name;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>, nonnull) <span class="type">NSString</span> <span class="operator">*</span>version;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, assign) long words;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong, nonnull) <span class="type">NSNumber</span> <span class="operator">*</span>barCode;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>, nullable) <span class="type">NSString</span> <span class="operator">*</span>publicID;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>, nullable) <span class="type">NSString</span> <span class="operator">*</span>url;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong, nonnull) <span class="type">Person</span> <span class="operator">*</span>author;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong, nonnull) <span class="type">NSMutableArray</span>&lt;<span class="type">Person</span> *&gt; <span class="operator">*</span>seeker;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">printBook</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name <span class="operator">=</span> book.name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> version <span class="operator">=</span> book.version</span><br><span class="line">    <span class="built_in">print</span>(version)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> seeker: <span class="type">NSMutableArray</span> <span class="operator">=</span> book.seeker</span><br><span class="line">    seeker.add(<span class="string">&quot;sd&quot;</span>) <span class="comment">//没效果</span></span><br><span class="line">    <span class="built_in">print</span>(seeker) <span class="comment">//崩溃:Thread 1: EXC_BAD_ACCESS (code=1, address=0x0)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> num: <span class="type">NSNumber</span> <span class="operator">=</span> book.barCode</span><br><span class="line"><span class="comment">//        print(num) //崩溃</span></span><br><span class="line">    <span class="keyword">let</span> i <span class="operator">=</span> num.intValue <span class="comment">//0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> author <span class="operator">=</span> book.author</span><br><span class="line">    <span class="keyword">let</span> authorName <span class="operator">=</span> author.name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> publicID <span class="operator">=</span> book.publicID <span class="operator">??</span> <span class="string">&quot;unknown&quot;</span></span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> book.url <span class="operator">??</span> <span class="string">&quot;unknown&quot;</span></span><br><span class="line">    <span class="keyword">let</span> string <span class="operator">=</span> name <span class="operator">+</span> <span class="string">&quot;-&quot;</span> <span class="operator">+</span> version <span class="operator">+</span> <span class="string">&quot;-&quot;</span> <span class="operator">+</span> authorName <span class="operator">+</span> <span class="string">&quot;-&quot;</span> <span class="operator">+</span> publicID <span class="operator">+</span> <span class="string">&quot;-&quot;</span> <span class="operator">+</span> url</span><br><span class="line">    </span><br><span class="line">    author.hello() <span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">let</span> des <span class="operator">=</span> <span class="type">String</span>.<span class="keyword">init</span>(describing: author) <span class="comment">//空字符串</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;des:<span class="subst">\(des)</span>&quot;</span>)</span><br><span class="line"><span class="comment">//        print(author) //崩溃</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//        let s: AnyClass = type(of: author) //崩溃</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> arr: [<span class="type">Person</span>] <span class="operator">=</span> []</span><br><span class="line">    arr.append(author)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(author)</span>&quot;</span>, <span class="string">&quot;arr个数:<span class="subst">\(arr.count)</span>&quot;</span>, arr)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(string)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"> arr个数:<span class="number">1</span> []</span><br><span class="line">三国---<span class="literal">unknown</span>-<span class="literal">unknown</span></span><br></pre></td></tr></table></figure>
<p>其中的authorName将会是空字符串<code>&quot;&quot;</code>;而author将会是<code>&lt;uninitialized&gt;</code>,其实就是一个nil对象,给它发送消息没有什么问题,但调用Swift中的某些方法比如<code>print(author)</code>或<code>type(of: author)</code>将导致野指针崩溃:<code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x0)</code>.</p>
<blockquote>
<p>OC和Swift语言其他的一些设计差别</p>
</blockquote>
<p>Swift中,如果一个变量没有被初始化,它是不能被使用的,编译器会报错.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="selector-tag">var</span> peron: Person</span><br><span class="line">	peron.<span class="built_in">hello</span>() //Variable <span class="string">&#x27;peron&#x27;</span> used before being initialized</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但OC中,声明一个变量后没有给它一个值也能够给它发送消息.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	Person *p;</span><br><span class="line">    [<span class="meta">p hello</span>];</span><br><span class="line">    Class cls = p.<span class="keyword">class</span>;</span><br><span class="line">    NSLog(<span class="string">@&quot;cls:%@&quot;</span>, cls);	 <span class="comment">// cls:(null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出Swift对初始化是非常严格的.而OC基本没啥限制.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>nullability特性只是一种约定,在开发的过程中我们要遵守这一约定.如果一个变量是nonnull的,我们在初始化方法中一定要给它一个初始值,并且在使用过程中不要给它赋值为nil.</p>
<p>OC,Swift混编时,为了使用方便并减少可能的解包崩溃,推荐使用nullability特性,旧的OC代码也有必要添加.</p>
<p>在Swift中尽量不使用强制解包.</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>nullability</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift中的AnyClass、AnyObject、Any</title>
    <url>/2019/09/13/Swift%E4%B8%AD%E7%9A%84AnyClass%E3%80%81AnyObject%E3%80%81Any/</url>
    <content><![CDATA[<p>1.AnyObject</p>
<p>定义:<br>public typealias AnyObject</p>
<p>说明:<br>The protocol to which all classes implicitly conform.</p>
<p>AnyObject can be used as the concrete type for an instance of any class, class type, or class-only protocol.</p>
<p>The flexible behavior of the <code>AnyObject</code> protocol is similar to<br>Objective-C’s <code>id</code> type.</p>
<p>AnyObject:用于表示任意类,元类的实例的具体类型.</p>
<p>对于”123”或123这些基础数据类型在Swift中是结构体类型,所以这里需要将其强转为AnyObject类型,此时它们的类型将是<br>OC的NSTaggedPointerString和__NSCFNumber等对象类型.不强转的话编译会出错.</p>
<p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FDEItemModel</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> anyA: <span class="type">AnyObject</span> <span class="operator">=</span> <span class="type">FDEItemModel</span>.<span class="keyword">init</span>() <span class="comment">//对象，类的实例</span></span><br><span class="line"><span class="keyword">let</span> anyB: <span class="type">AnyObject</span> <span class="operator">=</span> <span class="type">FDEItemModel</span>.<span class="keyword">self</span> <span class="comment">//类对象，元类的实例</span></span><br><span class="line"><span class="keyword">let</span> anyC: <span class="type">AnyObject</span> <span class="operator">=</span> <span class="type">FDEItemModel</span>.<span class="keyword">init</span>().<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> defaulA <span class="operator">=</span> <span class="type">FDEItemModel</span>.<span class="keyword">init</span>()  <span class="comment">//FDEItemModel</span></span><br><span class="line"><span class="keyword">let</span> defaulB <span class="operator">=</span> <span class="type">FDEItemModel</span>.<span class="keyword">self</span> <span class="comment">//FDEItemModel.Type</span></span><br><span class="line"><span class="keyword">let</span> defaulC <span class="operator">=</span> <span class="type">FDEItemModel</span>.<span class="keyword">init</span>().<span class="keyword">self</span> <span class="comment">//FDEItemModel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1: [<span class="type">AnyObject</span>] <span class="operator">=</span> [<span class="string">&quot;123&quot;</span> <span class="keyword">as</span> <span class="type">AnyObject</span>, <span class="number">123</span> <span class="keyword">as</span> <span class="type">AnyObject</span>, [<span class="number">123</span>] <span class="keyword">as</span> <span class="type">AnyObject</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> arr2: [<span class="type">AnyObject</span>] <span class="operator">=</span> [<span class="type">NSString</span>(<span class="string">&quot;123&quot;</span>),</span><br><span class="line">                             <span class="type">NSNumber</span>(<span class="number">123</span>),</span><br><span class="line">                             <span class="literal">true</span> <span class="keyword">as</span> <span class="type">AnyObject</span>,</span><br><span class="line">                             <span class="type">People</span>.<span class="keyword">init</span>(),</span><br><span class="line">                             <span class="type">People</span>.<span class="keyword">self</span></span><br><span class="line">                             ]</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">[<span class="number">123</span>, <span class="number">123</span>, <span class="number">1</span>, <span class="operator">&lt;</span><span class="type">OSHybridDemo</span>.<span class="type">People</span>: <span class="number">0x600002348b90</span><span class="operator">&gt;</span>, <span class="type">OSHybridDemo</span>.<span class="type">People</span>]</span><br></pre></td></tr></table></figure>
<p>在使用AnyObject 对象时要特别注意如果你需要调用它的属性则最好先downcast为实际的类型，如果不downcast那么系统可能获取的是其他类的同名属性，得到的值将是nil。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node1 <span class="operator">=</span> <span class="type">BinaryTreeNode</span>.<span class="keyword">init</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> node2 <span class="operator">=</span> <span class="type">BinaryTreeNode</span>.<span class="keyword">init</span>(<span class="number">2</span>)</span><br><span class="line">node1.left <span class="operator">=</span> node2</span><br><span class="line"><span class="keyword">let</span> curr: <span class="type">AnyObject</span> <span class="operator">=</span> node1</span><br><span class="line"><span class="keyword">let</span> left: <span class="type">AnyObject</span>? <span class="operator">=</span> curr.left  <span class="comment">//不会报错</span></span><br><span class="line"><span class="keyword">let</span> left1: <span class="type">AnyObject</span>? <span class="operator">=</span> (curr <span class="keyword">as!</span> <span class="type">BinaryTreeNode</span>).left</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;left:<span class="subst">\(left)</span>, left1:<span class="subst">\(left1<span class="operator">!</span>)</span>&quot;</span>) <span class="comment">//left:nil, left1:AlgorithmUtils.BinaryTreeNode</span></span><br></pre></td></tr></table></figure>
<p>2.AnyClass</p>
<p>定义:<br>typealias AnyClass = AnyObject.Type</p>
<p>说明:<br>The protocol to which all class types implicitly conform.</p>
<p>You can use the AnyClass protocol as the concrete type for an instance of any class.</p>
<p>AnyClass:用于表示任意元类的实例的具体类型.</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anyB: <span class="type">AnyObject</span> <span class="operator">=</span> <span class="type">People</span>.<span class="keyword">self</span></span><br><span class="line"><span class="keyword">let</span> anyC: <span class="type">AnyClass</span> <span class="operator">=</span> <span class="type">People</span>.<span class="keyword">self</span></span><br><span class="line"><span class="keyword">let</span> anyD: <span class="type">AnyClass</span> <span class="operator">=</span> <span class="type">FDEItemModel</span>.<span class="keyword">init</span>() <span class="comment">//报错：Cannot convert value of type &#x27;FDEItemModel&#x27; to specified type &#x27;AnyClass&#x27; (aka &#x27;any AnyObject.Type&#x27;)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> obj1 <span class="operator">=</span> (anyB <span class="keyword">as!</span> <span class="type">People</span>.<span class="keyword">Type</span>).<span class="keyword">init</span>()</span><br><span class="line"><span class="keyword">let</span> obj2 <span class="operator">=</span> (anyC <span class="keyword">as!</span> <span class="type">People</span>.<span class="keyword">Type</span>).<span class="keyword">init</span>()</span><br></pre></td></tr></table></figure>
<p>3.Any</p>
<p>Any:用于表示任意类型.</p>
<p>之所以出现Any主要是由于AnyObject只能表示类的实例.而 Swift 中所有的基本类型，包括 Array 和 Dictionary 这些传统意义上会是 class 的东西，统统都是 struct 类型，并不能由 AnyObject 来表示，于是 Apple 提出了一个更为特殊的 Any，除了 class 以外，它还可以表示包括 struct 和 enum 在内的所有类型。</p>
<p><code>let a: AnyObject = Int.init(2.0)</code> 会编译错误，需要强转为AnyObject，此时a的实际类型将不再是Int而是<code>__NSCFNumber</code> ，这表明系统会将这些struct转为对应的OC类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">AnyObject</span> <span class="operator">=</span> <span class="type">Int</span>.<span class="keyword">init</span>(<span class="number">2.0</span>) <span class="keyword">as</span> <span class="type">AnyObject</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a type:<span class="subst">\(<span class="built_in">type</span>(of: a))</span>&quot;</span>) <span class="comment">//a type:__NSCFNumber</span></span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> c <span class="operator">=</span> a <span class="keyword">as!</span> <span class="type">Int</span> <span class="operator">+</span> b</span><br></pre></td></tr></table></figure>
<p>三者之间的关系:</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20230302190146.png" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>AnyClass、AnyObject、Any</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 访问控制</title>
    <url>/2019/09/15/Swift%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="Swift-访问控制"><a href="#Swift-访问控制" class="headerlink" title="Swift 访问控制"></a>Swift 访问控制</h3><p>继承是针对类的，重写是针对类的方法的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>In Module</th>
<th>Out Module</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>可访问,可继承,可重写</td>
<td>可访问,可继承,可重写</td>
</tr>
<tr>
<td>public</td>
<td>可访问,可继承,可重写</td>
<td>可访问</td>
</tr>
<tr>
<td>internal</td>
<td>可访问,可继承,可重写</td>
<td>X</td>
</tr>
<tr>
<td>fileprivate</td>
<td>在同一源文件里可访问,可继承,可重写</td>
<td>X</td>
</tr>
<tr>
<td>private</td>
<td>如果修饰的是类中的成员，则成员只能在<strong>自身定义里</strong>或<strong>同一源文件中的自身扩展里</strong>可访问（也就是不能被重写了），如果修饰的是类则在同一源文件里可访问,可继承</td>
<td>X</td>
</tr>
</tbody>
</table>
</div>
<p>open只能用于修饰类和类的成员(属性,方法和下标)，不能修饰协议、全局变量/常量、结构体、枚举等等（这些可以使用public修饰）。系统禁止的原因可能是因为这些类型都是值类型本身就无法继承和重写，刚好就是public的作用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Only classes and overridable class members can be declared &#x27;open&#x27;; use &#x27;public&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">protocol</span> <span class="title class_">MyProtocol</span>: <span class="title class_ inherited__">AnyObject</span> &#123; <span class="comment">//报错</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">let</span> kAPIKey <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span> <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123; <span class="comment">//报错</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于初始化器如果需要对外公开,则只能使用public.如果子类的初始化器和父类的初始化器签名相同则子类还需要加上override关键字.是不是感觉有点疑惑,不是说public的在其他Module只能访问吗,为啥public修饰的初始化器在其他Module还可以override?无他—龟腚.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Machine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> numberID: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">numberID</span>: <span class="type">String</span>) &#123; <span class="comment">//这里报错:Only classes and overridable class members can be declared &#x27;open&#x27;; use &#x27;public&#x27;</span></span><br><span class="line">        <span class="keyword">self</span>.numberID <span class="operator">=</span> numberID</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一找到的解释如下:</p>
<p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md">Allow distinguishing between public access and public overridability</a></p>
<p>Initializers do not participate in open checking; they cannot be declared open, and there are no restrictions on providing an initializer that has the same signature as an initializer in the superclass. This is true even of required initializers. A class’s initializers provide an interface for constructing instances of that class that is logically distinct from the interface of its superclass, even when signatures happen to match and there are well-understood patterns of delegation. Constructing an object of a subclass necessarily involves running code associated with that subclass, and there is no value in arbitrarily restricting what initializers the subclass may declare.</p>
<p>大意就是初始化器不参与open检查,并且它们也不能被声明为open.没有啥限制说子类的初始化器不能和父类的初始化器相同(实际上如果相同又必须添加override简直哔了狗).</p>
<blockquote>
<p>fileprivate 和 private 区别</p>
</blockquote>
<p>fileprivate只要在同一源文件那么就可以访问。而private则范围更窄只能在自身定义里或同一源文件中的自身扩展里。举个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MATBaseViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="type">DLog</span>(<span class="string">&quot;<span class="subst">\(<span class="keyword">self</span>)</span>销毁&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        view.backgroundColor <span class="operator">=</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">MATBaseViewController</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printInfo</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">self</span>.name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">self</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="title class_ inherited__">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> vc <span class="operator">=</span> <span class="type">MATBaseViewController</span>.<span class="keyword">init</span>()</span><br><span class="line">        vc.name <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span> <span class="comment">//name可以被访问到，但是age不能。age只能在MATBaseViewController自身定义里或同一文件的MATBaseViewController自身扩展里，</span></span><br><span class="line"><span class="comment">//        vc.age = 3  //&#x27;age&#x27; is inaccessible due to &#x27;private&#x27; protection level</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问级别规则"><a href="#访问级别规则" class="headerlink" title="访问级别规则"></a>访问级别规则</h3><blockquote>
<p>访问级别遵循的一般规则</p>
</blockquote>
<p>不能在一个较低访问级别实体中定义一个较高访问级别的实体.</p>
<p>比如一个public的变量就不能定义在一个internal或private的类型中.一个函数的访问级别不能超过它的参数和返回值的类型的访问级别.</p>
<blockquote>
<p>默认的访问级别</p>
</blockquote>
<p>默认的访问级别是internal。也就是说即使你定义的是一个public的类型,它的成员默认的访问级别也只是internal而不是public.</p>
<p>private或fileprivate的类型里面的成员的默认访问级别则只有fileprivate。</p>
<p>比如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Food</span>: <span class="title class_ inherited__">NSObject</span> &#123; <span class="comment">//同一源文件里可访问,可继承</span></span><br><span class="line">    <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">hello</span>() &#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">run</span>() &#123; <span class="comment">//还是需要加private 否则子类里还是能重写。</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Orange</span>: <span class="title class_ inherited__">Food</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">hello</span>() &#123; </span><br><span class="line">      	<span class="keyword">super</span>.hello()</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Method does not override any method from its superclass</span></span><br><span class="line"><span class="comment">//    override func run() &#123;</span></span><br><span class="line"><span class="comment">//        print(name)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有更多23个规则,可以在官方的Swift编程指南中找到.感觉Swift虽然号称简洁优雅,但是背后的规则细节不是一般的多.</p>
<h3 id="framework访问控制"><a href="#framework访问控制" class="headerlink" title="framework访问控制"></a>framework访问控制</h3><p>在制作对外使用的SDK时,如果某些类或方法需要暴露给外部使用,可以在对应类或方法前添加open或public修饰符.</p>
<p>不过Swift的SDK和OC的SDK不同的地方在于Swift SDK没有对外公开的头文件概念,这个很好理解,因为Swift本身就没有头文件.Swift会根据你所使用的访问控制修饰符自动生成对外接口.</p>
<p>当其他Module import我们的SDK后.可以点击进去查看我们提供的API.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> MyFrameworkDemo  <span class="comment">//这个是SDK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>: <span class="title class_ inherited__">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">_</span> <span class="operator">=</span> <span class="type">Car</span>(with: <span class="string">&quot;sd&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> m <span class="operator">=</span> <span class="type">Machine</span>.<span class="keyword">init</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">        m.numberID <span class="operator">=</span> <span class="string">&quot;df&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击进去查看系统生成的对外接口文件内容:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">MyFrameworkDemoVersionNumber</span>: <span class="type">Double</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> open_name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> public_wheel: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">with</span> <span class="params">name</span>: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">public_run</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">open_hello</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Machine</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> numberID: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">numberID</span>: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意:根据上述表总结,可以看出系统只会将open或public修饰的类或方法生成到对外接口文件中.而internal及以下修饰的类将不会出现在对外接口文件中.</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift、OC反射</title>
    <url>/2019/09/12/Swift%E3%80%81OC%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="Swift、OC反射"><a href="#Swift、OC反射" class="headerlink" title="Swift、OC反射"></a>Swift、OC反射</h3><p>反射即根据类名字符串,生成对应实例对象的过程.</p>
<p>分为两步:</p>
<ol>
<li>根据字符串,得到对应的类对象.</li>
<li>通过类对象调用初始化方法生成一个实例.</li>
</ol>
<h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><p>OC:</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> <span class="title">OBJC_SWIFT_UNAVAILABLE</span>(&quot;<span class="title">use</span> &#x27;<span class="title">aClass</span>.<span class="title">self</span>&#x27; <span class="title">instead</span>&quot;)</span>;</span><br><span class="line">- (Class)<span class="class"><span class="keyword">class</span> <span class="title">OBJC_SWIFT_UNAVAILABLE</span>(&quot;<span class="title">use</span> &#x27;<span class="title">type</span>(<span class="title">of</span>: <span class="title">anObject</span>)&#x27; <span class="title">instead</span>&quot;)</span>;</span><br></pre></td></tr></table></figure>
<p>这俩方法都是返回一个类对象.    </p>
<p>Swift:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">aClass<span class="selector-class">.self</span></span><br><span class="line"><span class="function"><span class="title">type</span><span class="params">(of: anObject)</span></span></span><br></pre></td></tr></table></figure>
<p>举个例子,打印类对象:</p>
<p>OC类在OC类里打印:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">XQMessageTableViewCell</span> *ocCell = [[<span class="title class_">XQMessageTableViewCell</span> alloc] <span class="symbol">initWithStyle:</span><span class="title class_">UITableViewCellStyleValue1</span> <span class="symbol">reuseIdentifier:</span>@<span class="string">&quot;yyy&quot;</span>];</span><br><span class="line"><span class="title class_">NSLog</span>(@<span class="string">&quot;+class方法:%@ -class方法:%@ classString:%@ obj:%@&quot;</span>, <span class="title class_">XQMessageTableViewCell</span>.<span class="keyword">class</span>, ocCell.<span class="keyword">class</span>, <span class="title class_">NSStringFromClass</span>(<span class="title class_">XQMessageTableViewCell</span>.<span class="keyword">class</span>), ocCell);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="number">2019</span>-09-<span class="number">12</span> <span class="number">16</span><span class="symbol">:</span><span class="number">23</span><span class="symbol">:</span><span class="number">18.539301</span>+0800 <span class="title class_">OSHybridDemo</span>[<span class="number">33893</span><span class="symbol">:</span><span class="number">5942155</span>] +<span class="keyword">class</span>方法<span class="symbol">:XQMessageTableViewCell</span> -<span class="keyword">class</span>方法<span class="symbol">:XQMessageTableViewCell</span> <span class="symbol">classString:</span><span class="title class_">XQMessageTableViewCell</span> <span class="symbol">obj:</span>&lt;<span class="title class_">XQMessageTableViewCell</span>: <span class="number">0x7fa743821a00</span>; baseClass = <span class="title class_">UITableViewCell</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">320</span> <span class="number">44</span>); layer = &lt;<span class="title class_">CALayer</span>: <span class="number">0x600002940d40</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>Swift类在OC类里打印:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">XQTableViewCell</span> *swtCell = [[<span class="title class_">XQTableViewCell</span> alloc] <span class="symbol">initWithStyle:</span><span class="title class_">UITableViewCellStyleValue1</span> <span class="symbol">reuseIdentifier:</span>@<span class="string">&quot;xxx&quot;</span>];</span><br><span class="line"><span class="title class_">NSLog</span>(@<span class="string">&quot;+class方法:%@ -class方法:%@ classString:%@ obj:%@&quot;</span>, <span class="title class_">XQTableViewCell</span>.<span class="keyword">class</span>, swtCell.<span class="keyword">class</span>, <span class="title class_">NSStringFromClass</span>(<span class="title class_">XQTableViewCell</span>.<span class="keyword">class</span>), swtCell);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="number">2019</span>-09-<span class="number">12</span> <span class="number">16</span><span class="symbol">:</span><span class="number">24</span><span class="symbol">:</span><span class="number">32.637695</span>+0800 <span class="title class_">OSHybridDemo</span>[<span class="number">33981</span><span class="symbol">:</span><span class="number">5943715</span>] +<span class="keyword">class</span>方法<span class="symbol">:OSHybridDemo</span>.<span class="title class_">XQTableViewCell</span> -<span class="keyword">class</span>方法<span class="symbol">:OSHybridDemo</span>.<span class="title class_">XQTableViewCell</span> <span class="symbol">classString:</span><span class="title class_">OSHybridDemo</span>.<span class="title class_">XQTableViewCell</span> <span class="symbol">obj:</span>&lt;<span class="title class_">OSHybridDemo</span>.<span class="title class_">XQTableViewCell</span>: <span class="number">0x7ffab705e200</span>; baseClass = <span class="title class_">UITableViewCell</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">320</span> <span class="number">44</span>); layer = &lt;<span class="title class_">CALayer</span>: <span class="number">0x60000251a6e0</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>Swift类在Swift类里打印:</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">let</span> people = <span class="type">People</span>.init()</span><br><span class="line"><span class="title">print</span>(<span class="type">People</span>.self, <span class="keyword">type</span>(of: people), <span class="type">NSStringFromClass</span>(<span class="type">People</span>.self), <span class="type">String</span>.init(describing: <span class="type">People</span>.self), people) //<span class="type">NSStringFromClass</span>(<span class="type">People</span>.self)有命名空间,而<span class="type">String</span>.init(describing: <span class="type">People</span>.self)没有命名空间</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">People</span> <span class="type">People</span> <span class="type">OSHybridDemo</span>.<span class="type">People</span> <span class="type">People</span> &lt;<span class="type">OSHybridDemo</span>.<span class="type">People</span>: <span class="number">0x60000157ec10</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到使用NSStringFromClass(People.self)有命名空间,而String.init(describing: People.self)没有命名空间.</p>
<p>OC类在Swift类里打印:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ocObj <span class="operator">=</span> <span class="type">XQMessageTableViewCell</span>.<span class="keyword">init</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="type">XQMessageTableViewCell</span>.<span class="keyword">self</span>, <span class="built_in">type</span>(of: ocObj), <span class="type">NSStringFromClass</span>(<span class="type">XQMessageTableViewCell</span>.<span class="keyword">self</span>), <span class="type">String</span>.<span class="keyword">init</span>(describing: <span class="type">XQMessageTableViewCell</span>.<span class="keyword">self</span>), ocObj)</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="type">XQMessageTableViewCell</span> <span class="type">XQMessageTableViewCell</span> <span class="type">XQMessageTableViewCell</span> <span class="type">XQMessageTableViewCell</span> <span class="operator">&lt;</span><span class="type">XQMessageTableViewCell</span>: <span class="number">0x7fcad001b600</span>; baseClass <span class="operator">=</span> <span class="type">UITableViewCell</span>; frame <span class="operator">=</span> (<span class="number">0</span> <span class="number">0</span>; <span class="number">320</span> <span class="number">44</span>); layer <span class="operator">=</span> <span class="operator">&lt;</span><span class="type">CALayer</span>: <span class="number">0x600000f517c0</span><span class="operator">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结:</p>
<p>使用NSStringFromClass()获取类名时,对于Swift类系统会在类名前添加命名空间.而OC没有这一概念所以没有命名空间.</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>系统提供的方法如下:</p>
<p>OC:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> *<span class="built_in">NSStringFromClass</span>(Class aClass);</span><br><span class="line">FOUNDATION_EXPORT Class _Nullable <span class="built_in">NSClassFromString</span>(<span class="built_in">NSString</span> *aClassName);</span><br></pre></td></tr></table></figure>
<p>Swift:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">NSStringFromClass</span>(<span class="keyword">_</span> <span class="params">aClass</span>: <span class="type">AnyClass</span>) -&gt; <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">NSClassFromString</span>(<span class="keyword">_</span> <span class="params">aClassName</span>: <span class="type">String</span>) -&gt; <span class="type">AnyClass</span>?</span><br></pre></td></tr></table></figure>
<p>已知一个OC类名,如果需要通过该类名字符串来创建一个实例,无需指定命名空间.和之前写法一样.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ocCls: <span class="type">AnyClass</span>? <span class="operator">=</span> <span class="type">NSClassFromString</span>(<span class="string">&quot;XQMessageTableViewCell&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> ocConcreteCls: <span class="type">XQMessageTableViewCell</span>.<span class="keyword">Type</span> <span class="operator">=</span> ocCls <span class="keyword">as!</span> <span class="type">XQMessageTableViewCell</span>.<span class="keyword">Type</span></span><br><span class="line"><span class="keyword">let</span> aocObj <span class="operator">=</span> ocConcreteCls.<span class="keyword">init</span>(style: .default, reuseIdentifier: <span class="string">&quot;reuseIdentifier&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(aocObj)</span><br></pre></td></tr></table></figure>
<p>已知一个Swift类名,通过该类名字符串来创建一个实例:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> namespace <span class="operator">=</span> <span class="type">Bundle</span>.main.infoDictionary<span class="operator">!</span>[<span class="string">&quot;CFBundleExecutable&quot;</span>] <span class="keyword">as!</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">let</span> s2: <span class="type">People</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">NSClassFromString</span>(namespace <span class="operator">+</span> <span class="string">&quot;.&quot;</span> <span class="operator">+</span> <span class="string">&quot;People&quot;</span>) <span class="keyword">as!</span> <span class="type">People</span>.<span class="keyword">Type</span></span><br><span class="line"><span class="keyword">let</span> s2obj <span class="operator">=</span> s2.<span class="keyword">init</span>()</span><br><span class="line"><span class="built_in">print</span>(s2obj)</span><br></pre></td></tr></table></figure>
<p>对于Swift的类,如果需要通过该类名字符串来创建一个实例,则必须指定命名空间.</p>
<p>错误写法:没有拼接命名空间.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftCls: <span class="type">AnyClass</span>? <span class="operator">=</span> <span class="type">NSClassFromString</span>(<span class="string">&quot;People&quot;</span>) <span class="comment">//这里其实是nil.</span></span><br><span class="line"><span class="keyword">let</span> swiftConcreteCls: <span class="type">People</span>.<span class="keyword">Type</span> <span class="operator">=</span> swiftCls <span class="keyword">as!</span> <span class="type">People</span>.<span class="keyword">Type</span> </span><br><span class="line"><span class="keyword">let</span> swiftobj <span class="operator">=</span> swiftConcreteCls.<span class="keyword">init</span>()</span><br><span class="line"><span class="built_in">print</span>(swiftobj)</span><br></pre></td></tr></table></figure>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对于混编工程,为了使用方便,可以使用下面的封装方法.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZAEClassUtil</span>: <span class="title class_ inherited__">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">getClassType</span>(<span class="params">namespace</span>: <span class="type">String</span>?, <span class="params">className</span>: <span class="type">String</span>) -&gt; <span class="type">AnyClass</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> rs: <span class="type">AnyClass</span>? <span class="operator">=</span> <span class="type">NSClassFromString</span>(className)</span><br><span class="line">        <span class="keyword">if</span> rs <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> ns <span class="operator">=</span> namespace <span class="operator">??</span> <span class="type">Bundle</span>.main.infoDictionary<span class="operator">!</span>[<span class="string">&quot;CFBundleExecutable&quot;</span>] <span class="keyword">as!</span> <span class="type">String</span></span><br><span class="line">            rs <span class="operator">=</span> <span class="type">NSClassFromString</span>(ns <span class="operator">+</span> <span class="string">&quot;.&quot;</span> <span class="operator">+</span> className) <span class="comment">//如果类名对应的是Swift类则必须要拼接命名空间,如果是OC的则不需要.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">getClassString</span>(<span class="params">cls</span>: <span class="type">AnyClass</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> name <span class="operator">=</span> <span class="type">NSStringFromClass</span>(cls)</span><br><span class="line">        <span class="keyword">if</span> (name.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> name.components(separatedBy: <span class="string">&quot;.&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s3: <span class="type">XQRedView</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">ZAEClassUtil</span>.getClassType(namespace: <span class="literal">nil</span>, className: <span class="string">&quot;XQRedView&quot;</span>) <span class="keyword">as!</span> <span class="type">XQRedView</span>.<span class="keyword">Type</span></span><br><span class="line"><span class="keyword">let</span> s3obj <span class="operator">=</span> s3.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"><span class="built_in">print</span>(s3obj)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> s4: <span class="type">XQMessageTableViewCell</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">ZAEClassUtil</span>.getClassType(namespace: <span class="literal">nil</span>, className: <span class="string">&quot;XQMessageTableViewCell&quot;</span>) <span class="keyword">as!</span> <span class="type">XQMessageTableViewCell</span>.<span class="keyword">Type</span></span><br><span class="line"><span class="keyword">let</span> s4obj <span class="operator">=</span> s4.<span class="keyword">init</span>(style: .default, reuseIdentifier: <span class="string">&quot;reuseIdentifier&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s4obj, <span class="type">ZAEClassUtil</span>.getClassString(cls: s4))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>VPN搭建</title>
    <url>/2019/10/03/VPN%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="IP及端口检测"><a href="#IP及端口检测" class="headerlink" title="IP及端口检测"></a>IP及端口检测</h3><blockquote>
<p>检测购买的vps IP是否被墙</p>
</blockquote>
<p>检测IP是否被墙:<a href="http://ping.chinaz.com">站长工具</a>或者使用ping命令。延迟太大的IP（400+ms）建议还是换一个。</p>
<p>检测端口在国内是否开放:<a href="http://coolaf.com/tool/port">在线检测域名或者ip的端口是否开放</a> 。搭建完后可以再检查下配置的端口是否在国内开放。其他检测网址：<a href="https://www.toolsdaquan.com/ipcheck/">IP可用性检测工具</a></p>
<p>检测端口在国外是否开放:<a href="https://www.yougetsignal.com/tools/open-ports/">you get signal</a> 。这个其实没什么必要。</p>
<h3 id="搭建ss"><a href="#搭建ss" class="headerlink" title="搭建ss"></a>搭建ss</h3><p>首先你需要一台服务器，以便在服务器上搭建ss。可以在vultr上购买一个vps，也可以在其他供应商购买。下面是基于vultr的vps搭建ss，用于Mac端fq.</p>
<p>在正式配置vps之前,务必先确保vps的IP及端口22没有被墙.否则下面的操作白搭.因为首先你得在墙内能够访问你的vps.</p>
<p>目前有两种方式搭建ss，一种是基于C的shadowsocks-libev（以下简称c-ss），一种是基于Python的Shadowsocks-Python（以下简称p-ss）。</p>
<h3 id="基于C的shadowsocks-libev：（推荐）"><a href="#基于C的shadowsocks-libev：（推荐）" class="headerlink" title="基于C的shadowsocks-libev：（推荐）"></a>基于C的shadowsocks-libev：（推荐）</h3><p>基于Python的shadowsocks-server,目前已经不再维护，因此很容易就被q。这个是基于C的。</p>
<p>注意：以下安装是在centos7上的，不是这个系统或版本的不建议尝试，肯定会有不兼容的地方。另外安装的库的版本最好也别随意升级，否则也会出各种兼容问题，很浪费时间。当然如果你是高手爱折腾可以试试装在centos9上或者升级安装库版本啥的。</p>
<p>主要参考：</p>
<p><a href="http://fhaoer.com/20190617-shadowsocks-libev/">安装并配置shadowsocks-libev（yum源方式）</a>  没了</p>
<p><a href="https://www.shopee6.com/web/web-tutorial/centos7-bbr.html">CentOS7升级新版内核开启BBR加速最新图文教程</a>  没了</p>
<p><a href="https://www.zhoulujun.cn/html/tools/NetTools/throughGFW/8459.html">搞懂SSR(3)：Centos 7安装配置shadowsocks-libev记录—非一键脚本</a></p>
<p><a href="https://tie.pub/2019/11/how-to-deploy-google-bbr-on-centos-7/">怎样在 CentOS 7 上部署 Google BBR</a></p>
<p>步骤：</p>
<ol>
<li>安装常用工具</li>
<li>安装编译工具gcc</li>
<li>安装加密库libsodium</li>
<li>安装tls库mbedtls</li>
<li>安装混淆插件 simple-obfs</li>
<li>安装ss (采用的是编译源码的安装方式，和其他地方的安装方式不一样)</li>
<li>创建账号配置文件</li>
<li>开放防火墙端口</li>
<li>开启服务</li>
<li>加速优化bbr</li>
</ol>
<p>ps:有这么多步骤是因为采用的是源码编译安装的方式。</p>
<p>具体如下：</p>
<p>1.安装常用工具</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> git wget vim -y</span><br></pre></td></tr></table></figure>
<p>这里安装了git，wget，vim。</p>
<p>2.安装编译工具gcc</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">yum install epel-release gcc gettext <span class="built_in">auto</span>conf libtool <span class="built_in">auto</span>make make asciidoc xmlto c-ares-devel libev-devel pcre-devel -y</span><br></pre></td></tr></table></figure>
<p>ps:上面是一行命令。安装了很多个软件包。</p>
<p>3.安装加密库libsodium</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LIBSODIUM_VER=1.0.17</span><br><span class="line">wget https://download.libsodium.org/libsodium/releases/libsodium-<span class="variable">$LIBSODIUM_VER</span>.tar.gz</span><br><span class="line">tar xvf libsodium-<span class="variable">$LIBSODIUM_VER</span>.tar.gz</span><br><span class="line"><span class="built_in">pushd</span> libsodium-<span class="variable">$LIBSODIUM_VER</span></span><br><span class="line">./configure --prefix=/usr &amp;&amp; make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>
<p>4.安装mbedtls</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">wget</span> https://github.com/Mbed-TLS/mbedtls/archive/refs/tags/mbedtls-<span class="number">2</span>.<span class="number">6</span>.<span class="number">0</span>.tar.gz</span><br><span class="line"><span class="attribute">tar</span> xvf mbedtls-<span class="number">2</span>.<span class="number">6</span>.<span class="number">0</span>.tar.gz</span><br><span class="line"><span class="attribute">pushd</span> mbedtls-mbedtls-<span class="number">2</span>.<span class="number">6</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">make</span> SHARED=<span class="number">1</span> CFLAGS=-fPIC</span><br><span class="line"><span class="attribute">sudo</span> make DESTDIR=/usr install</span><br><span class="line"><span class="attribute">popd</span></span><br><span class="line"><span class="attribute">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>
<p>ps：mbedtls的版本不要下最新的，否则编译的时候会报错：“错误：只允许在 C99 模式下使用‘for’循环初始化声明”。有时候解决了这里但后面安装ss的时候sudo make install一直报错。除非你有填坑的能力，否则建议还是使用2.6.0版本的。</p>
<p>ps：填坑网上教程。以下是网上过时的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> MBEDTLS_VER=2.6.0</span><br><span class="line">wget https://tls.mbed.org/download/mbedtls-<span class="variable">$MBEDTLS_VER</span>-gpl.tgz</span><br><span class="line">tar xvf mbedtls-<span class="variable">$MBEDTLS_VER</span>-gpl.tgz</span><br><span class="line"><span class="built_in">pushd</span> mbedtls-<span class="variable">$MBEDTLS_VER</span></span><br><span class="line">make SHARED=1 CFLAGS=-fPIC</span><br><span class="line"><span class="built_in">sudo</span> make DESTDIR=/usr install</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>
<p>这一步<code>wget https://tls.mbed.org/download/mbedtls-$MBEDTLS_VER-gpl.tgz</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@Tokyo6Dollor ~</span>]<span class="meta"># file mbedtls-2.6.0-gpl.tgz</span></span><br><span class="line">mbedtls<span class="number">-2.6</span><span class="number">.0</span>-gpl.tgz: HTML document, ASCII text, <span class="keyword">with</span> very <span class="built_in">long</span> lines</span><br></pre></td></tr></table></figure>
<p>下载地址无效了，导致下载的其实是一个网页。后面解压缩自然失败。找了一圈资料，看到一个备用下载地址：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">https</span>://down.<span class="number">24</span>kplus.com/linux/mbedtls/mbedtls-<span class="number">2</span>.<span class="number">16</span>.<span class="number">3</span>-gpl.tgz</span><br></pre></td></tr></table></figure>
<p>结果发现现在备用地址也不行了，建议直接去github上下载，<a href="https://github.com/Mbed-TLS/mbedtls">Mbed-TLS</a> .</p>
<p>5.安装混淆插件</p>
<p>首先安装编译必须的软件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> zlib-devel openssl-devel -y</span><br></pre></td></tr></table></figure>
<p>安装 simple-obfs</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="string">//github.com/shadowsocks/simple-obfs.git</span></span><br><span class="line"><span class="keyword">cd</span> simple-obfs</span><br><span class="line">git submodule update <span class="params">--init</span> <span class="params">--recursive</span></span><br><span class="line"><span class="string">./autogen.sh</span></span><br><span class="line"><span class="string">./configure</span> &amp;&amp; make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>6.安装ss</p>
<p>下载源码:</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="string">//github.com/shadowsocks/shadowsocks-libev.git</span></span><br><span class="line"><span class="keyword">cd</span> shadowsocks-libev</span><br><span class="line">git submodule update <span class="params">--init</span> <span class="params">--recursive</span></span><br></pre></td></tr></table></figure>
<p>编译源码并安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> shadowsocks-libev //确保是在 ss 目录中执行编译。已经在了就不用管</span><br><span class="line">./autogen.sh &amp;&amp; ./configure &amp;&amp; make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>
<p>ps：sudo make install 提示。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">[root@centos7<span class="number">-5</span> <span class="keyword">shadowsocks-libev]# </span>sudo make <span class="keyword">install</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">make:</span> *** 没有规则可以创建目标“<span class="keyword">install”。 </span>停止。</span><br></pre></td></tr></table></figure>
<p>mbedtls版本不对，用了最新版的v3.2.1，换回2.6.0就没问题了，这里搞了一天。</p>
<p>7.创建账号配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /etc/shadowsocks-libev</span><br><span class="line">vim /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port_password&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;port1&quot;</span><span class="punctuation">:</span><span class="string">&quot;pass1&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;port2&quot;</span><span class="punctuation">:</span><span class="string">&quot;pass2&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;chacha20-ietf-poly1305&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;tcp_and_udp&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;workers&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;plugin&quot;</span><span class="punctuation">:</span><span class="string">&quot;obfs-server&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;plugin_opts&quot;</span><span class="punctuation">:</span><span class="string">&quot;obfs=http;fast-open&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>该替换的替换。这里是多端口的配置。</p>
<p>注意：上面包含了 simple-obfs 混淆插件，如果没有安装该插件，请去掉最后两行。</p>
<p>8.开放防火墙端口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=xxx/udp </span><br><span class="line">firewall-cmd --permanent <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=xxx/tcp </span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>xxx为端口号，请替换为你的实际端口。</p>
<p>9.开启服务</p>
<p>通过使用创建好的配置文件来启动</p>
<p>单个端口号配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ss-server -c /etc/shadowsocks-libev/config.json &amp;</span><br></pre></td></tr></table></figure>
<p>多个端口号配置：（上面配的是多端口，这里使用下面的命令）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ss-manager -c /etc/shadowsocks-libev/config.json &amp;</span><br></pre></td></tr></table></figure>
<p>注意：这里并没有设置开机自启动，因此如果重启了服务器那么必须要重新启动ss服务。</p>
<h4 id="c-ss多端口配置"><a href="#c-ss多端口配置" class="headerlink" title="c-ss多端口配置"></a>c-ss多端口配置</h4><p>上面看到采用源码的安装方式可以支持多端口的配置文件。</p>
<p>如果使用的是别人封装的脚本安装可能不支持多端口，这时可以创建多个配置文件达到多端口的效果。这里网上也有很多教程。</p>
<h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><p>坑1：shadowsocks-libev的配置文件的server被我写成了127.0.0.1结果翻不了墙，外部检测端口的结果是关闭的。</p>
<p>正确如下，设置为0.0.0.0即可：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>坑2：有时候搭建完成了，ip端口也都没被q，但是就是打不开Google，或者非常慢。不太清楚什么情况。</p>
<p>感觉可能是shadowsocks客户端有问题，重启电脑后，可以打开Google了。还遇到一个奇葩问题，配置完后可以打开Google，但是开启bbr后就完全翻不了墙。所以现在暂时先不开起bbr了。用了一段时间后发现还是不行了，ip和端口也都没被封，不知道什么原因了。</p>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p><strong>查看开启的端口:</strong>  </p>
<p><code>firewall-cmd --list-ports</code></p>
<p><strong>开启特定端口:</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=4500/udp </span><br><span class="line">firewall-cmd --permanent <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=4500/tcp </span><br></pre></td></tr></table></figure>
<p>对应的<strong>删除特定端口:</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent <span class="attribute">--zone</span>=public <span class="attribute">--remove-port</span>=4500/udp </span><br><span class="line">firewall-cmd --permanent <span class="attribute">--zone</span>=public <span class="attribute">--remove-port</span>=4500/tcp </span><br></pre></td></tr></table></figure>
<p><strong>使端口生效</strong>： <code>firewall-cmd --reload</code> </p>
<p><strong>查看防火墙状态</strong>：<code>firewall-cmd --state</code></p>
<p><strong>启动防火墙</strong>: <code>systemctl start firewalld.service</code>  </p>
<p><strong>重启防火墙:</strong>  <code>systemctl restart firewalld.service</code></p>
<p>如果提示:</p>
<p><code>Failed to start firewalld.service: Unit is masked.</code></p>
<p>这是由于firewalld服务被锁定了.</p>
<p>取消firewalld的锁定: <code>systemctl unmask firewalld</code>.</p>
<p>重新锁定firewalld时执行命令: <code>systemctl mask firewalld</code></p>
<p><strong>参考</strong>:</p>
<p><a href="https://blog.csdn.net/zll_0405/article/details/81208606">CentOS7开启防火墙及特定端口</a></p>
<h3 id="BBR加速"><a href="#BBR加速" class="headerlink" title="BBR加速"></a>BBR加速</h3><p><a href="https://blog.naibabiji.com/skill/centos7-an-zhuang-bbr.html">CentOS7安装新版内核和开启BBR加速教程_BBR2一键包</a> </p>
<p>步骤：</p>
<p>1.升级服务器内核版本</p>
<p>2.安装BBR</p>
<p>具体如下：</p>
<p>1.升级服务器内核版本</p>
<p>1.1首先是查看当前服务器的内核版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -sr</span><br></pre></td></tr></table></figure>
<p>BBR内核要求是4.9+，通常来说你通过上面这个命令出来的内核版本是在3.几。比如：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Linux</span> <span class="number">3</span>.<span class="number">10</span>.<span class="number">0</span>-<span class="number">1160</span>.<span class="number">71</span>.<span class="number">1</span>.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>1.2 升级</p>
<p>直接参考上面的链接，很详细。</p>
<p>2.安装BBR</p>
<p>要在新安装好的CentOS7上面启用新内核，只需要复制下面的代码执行就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;net.core.default_qdisc=fq&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;net.ipv4.tcp_congestion_control=bbr&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure>
<p>然后输入下面的命令查看是否开启BBR成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>
<p>成功的话应该是下面这种输出</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">net.ipv4.tcp_available_congestion_control</span> = re<span class="literal">no</span> cubic bbr</span><br></pre></td></tr></table></figure>
<h3 id="iPhone翻墙"><a href="#iPhone翻墙" class="headerlink" title="iPhone翻墙"></a>iPhone翻墙</h3><p>手机翻墙有两种方式：</p>
<ol>
<li><p>通过在设置app里添加配置文件。这个比较复杂，这里就不介绍了。</p>
</li>
<li><p>安装专门的app，在app里填之前的配置信息，这个最简单。（推荐使用）</p>
</li>
</ol>
<p>下面是第一种方式：</p>
<p>搭建IPsec/L2TP VPN</p>
<p><a href="https://wistbean.github.io/ipsec,l2tp_vpn.html#%E4%BD%BF%E7%94%A8-IPsec-L2TP-%E8%84%9A%E6%9C%AC%E6%90%AD%E5%BB%BA">CentOS快速搭建一个属于自己的IPsec/L2TP VPN</a></p>
<p>第二种方式：</p>
<p>下载APP：potatso lite，需要登录美区账号下载。下载后填写配置信息即可。</p>
<h3 id="基于Python的Shadowsocks-Python（不推荐，容易被封端口）"><a href="#基于Python的Shadowsocks-Python（不推荐，容易被封端口）" class="headerlink" title="基于Python的Shadowsocks-Python（不推荐，容易被封端口）"></a>基于Python的Shadowsocks-Python（不推荐，容易被封端口）</h3><p><a href="https://wistbean.github.io/vultr-vps-bbr-ss.html">使用vultr(vps)搭建ss并开启BBR快速上网教程 超简单10分钟搞定</a></p>
<p><a href="https://www.ailophy.com/2018/07/14/vpn/">从零开始于Vultr上搭建属于自己的VPN服务器【CentOS7+Shadowsocks+serverspeeder加速+防坑指北】【适合新手】</a></p>
<h4 id="p-ss多端口配置"><a href="#p-ss多端口配置" class="headerlink" title="p-ss多端口配置"></a>p-ss多端口配置</h4><p>默认情况下只会有一个端口。</p>
<p>多端口格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_address&quot;</span><span class="punctuation">:</span><span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span><span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port_password&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;xxx端口&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx密码&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;xxx端口&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx密码&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;xxx端口&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx密码&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;aes-256-cfb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>最后要记得重启下shadowsocks：<code>service shadowsocks restart</code> </p>
<p>相关命令：<br>启动：service shadowsocks start<br>停止：service shadowsocks stop<br>重启：service shadowsocks restart<br>状态：service shadowsocks status</p>
<p>如果你的vps开启了防火墙,则还需要开启特定端口.否则可能连接不上.开启防火墙端口移步防火墙部分。</p>
<h4 id="p-ss的代理端口被墙解决"><a href="#p-ss的代理端口被墙解决" class="headerlink" title="p-ss的代理端口被墙解决"></a>p-ss的代理端口被墙解决</h4><p>解决办法:登录<code>ssh root@&lt;ip&gt;</code>,更换SS服务端口.</p>
<p>编辑ShadowSocks配置文件:<code>vi /etc/shadowsocks.json</code> 。修改端口，保存。</p>
<p>重启服务：<code>ssserver -c /etc/shadowsocks.json -d restart</code></p>
<p>别忘了如果你的vps开启了防火墙,则还需要在防火墙中开启上述端口.</p>
<p>参考:</p>
<p><a href="https://www.flyzy2005.com/fan-qiang/tcp-blocked/">服务器IP能Ping通，SSH能连接，代理却连不上的说明与解决</a></p>
<p><a href="https://www.sinocalife.com/change-ports-to-prevent-ss-from-banning">ShadowSocks：更改SS端口号防止被墙</a></p>
<h3 id="坑-1"><a href="#坑-1" class="headerlink" title="坑"></a>坑</h3><p>坑1： <code>ssh root@&lt;ip&gt;</code> 登录不上  </p>
<p>登录不上的原因有很多。可以分别尝试下面的解决办法：</p>
<p>1.使用vps服务商自身提供的网页版终端登录一次，激活22端口。</p>
<p>2.可能是重新购买的vps和上一次的IP相同导致.需要将本地 <code>/.ssh/known_hosts</code> 之前的那一条记录删除掉.重启终端.</p>
<p>坑2：按照网上的教程步骤总是失败提示<code>[Error] libsodium-1.0.17 install failed</code>  </p>
<p>发现是网上的脚本不支持centOS8,而购买vps时默认是centOS8,所以在购买时需要手动选择为centOS7.最好的办法是研究一下脚本内容,自己整.</p>
<p>因此，在按照教程步骤前，一定要看清楚，操作系统的版本是不是一致，否则可能会导致各种适配问题。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><h4 id="1-如何查看端口在被哪个程序or进程使用？"><a href="#1-如何查看端口在被哪个程序or进程使用？" class="headerlink" title="1. 如何查看端口在被哪个程序or进程使用？"></a>1. 如何查看端口在被哪个程序or进程使用？</h4><p>检查端口被哪个进程占用：<code>netstat -lnp|grep 80   #80端口，自行更换；如：8888</code> ，打印如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tcp</span>        <span class="number">0</span>      <span class="number">0</span> <span class="number">0.0.0.0:18388</span>           <span class="number">0.0.0.0</span>:*               LISTEN      <span class="number">982</span>/python</span><br><span class="line"><span class="attribute">tcp</span>        <span class="number">0</span>      <span class="number">0</span> <span class="number">0.0.0.0:8388</span>            <span class="number">0.0.0.0</span>:*               LISTEN      <span class="number">911</span>/ss-server</span><br><span class="line"><span class="attribute">udp</span>        <span class="number">0</span>      <span class="number">0</span> <span class="number">0.0.0.0:18388</span>           <span class="number">0.0.0.0</span>:*                           <span class="number">982</span>/python</span><br><span class="line"><span class="attribute">udp</span>        <span class="number">0</span>      <span class="number">0</span> <span class="number">0.0.0.0:8388</span>            <span class="number">0.0.0.0</span>:*                           <span class="number">911</span>/ss-server</span><br></pre></td></tr></table></figure>
<p>安装：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> net-tools</span><br></pre></td></tr></table></figure>
<h4 id="2-firewall的—add-port命令是不是真的开启了一个端口？"><a href="#2-firewall的—add-port命令是不是真的开启了一个端口？" class="headerlink" title="2. firewall的—add-port命令是不是真的开启了一个端口？"></a>2. firewall的—add-port命令是不是真的开启了一个端口？</h4><h4 id="3-服务器开启一个端口但不绑定任何应用外部能访问到吗？"><a href="#3-服务器开启一个端口但不绑定任何应用外部能访问到吗？" class="headerlink" title="3. 服务器开启一个端口但不绑定任何应用外部能访问到吗？"></a>3. 服务器开启一个端口但不绑定任何应用外部能访问到吗？</h4><p>使用 <code>firewall-cmd --zone=public --add-port=4500/udp --permanent</code> 添加了一个端口，但外部检测却是关闭什么原因？</p>
<p>一个端口开启后但不绑定任何应用程序，那么对于外部来说这个端口依然是关闭的，因为检测肯定是依据某个协议来检测的，如果端口没有绑定任何应用，那自然就不会有任何回应，因此对于外部来说这个端口等同于关闭，虽然内部查看该端口其实是开启的。—个人猜测，可能是完全错误的。</p>
<h4 id="4-0-0-0-0-和-127-0-0-1的区别"><a href="#4-0-0-0-0-和-127-0-0-1的区别" class="headerlink" title="4. 0.0.0.0 和 127.0.0.1的区别"></a>4. 0.0.0.0 和 127.0.0.1的区别</h4><p><a href="https://www.jianshu.com/p/ad7cd1d5be45">彻底明白ip地址，区分localhost、127.0.0.1和0.0.0.0</a></p>
<h4 id="5-shadowsocks是如何被检测和封锁的"><a href="#5-shadowsocks是如何被检测和封锁的" class="headerlink" title="5. shadowsocks是如何被检测和封锁的"></a>5. shadowsocks是如何被检测和封锁的</h4><p><a href="https://pincong.rocks/article/12173">【还Shadowsocks一个清白】Shadowsocks是如何被检测和封锁的，兼谈ss配置策略</a></p>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>OC BOOL类型</title>
    <url>/2019/11/25/OC%20BOOL%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>下面的代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">char</span> rs = <span class="number">240</span>;</span><br><span class="line"><span class="type">BOOL</span> rs1 = <span class="number">240</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d %d&quot;</span>, rs, rs1);</span><br></pre></td></tr></table></figure>
<p>在32位机,如iPhone5c上输出为:<code>-16 -16</code>.<br>在64位机,如iPhone6s上输出为:<code>-16 1</code>.</p>
<p>在SDK <code>usr/include/objc/objc.h</code>里的定义:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Type to represent a boolean value.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__OBJC_BOOL_IS_BOOL)</span></span><br><span class="line">    <span class="comment">// Honor __OBJC_BOOL_IS_BOOL when available.</span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> __OBJC_BOOL_IS_BOOL</span></span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> OBJC_BOOL_IS_BOOL 1</span></span><br><span class="line"><span class="meta">#   <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> OBJC_BOOL_IS_BOOL 0</span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// __OBJC_BOOL_IS_BOOL not set.</span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> TARGET_OS_OSX || TARGET_OS_MACCATALYST || ((TARGET_OS_IOS || 0) &amp;&amp; !__LP64__ &amp;&amp; !__ARM_ARCH_7K)</span></span><br><span class="line"><span class="meta">#      <span class="keyword">define</span> OBJC_BOOL_IS_BOOL 0</span></span><br><span class="line"><span class="meta">#   <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#      <span class="keyword">define</span> OBJC_BOOL_IS_BOOL 1</span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OBJC_BOOL_IS_BOOL</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">bool</span> <span class="type">BOOL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> OBJC_BOOL_IS_CHAR 1</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">BOOL</span>; </span><br><span class="line">    <span class="comment">// BOOL is explicitly signed so @encode(BOOL) == &quot;c&quot; rather than &quot;C&quot; </span></span><br><span class="line">    <span class="comment">// even if -funsigned-char is used.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJC_BOOL_DEFINED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_feature(objc_bool)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES __objc_yes</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO  __objc_no</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES ((BOOL)1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO  ((BOOL)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大概意思就是:<br>默认情况下,在32位iPhone上,BOOL就是signed char类型（1个字节。-128 ~ 127）<br>在64位iPhone上,BOOL就是bool类型.而bool类型的值有两种true(1)和false(0).任何不为0的数强转为bool类型，均转为true(即非0都为真).</p>
<p>另外:</p>
<p><code>- (id)performSelector:(SEL)aSelector withObject:(id)object;</code>参数问题.<br>结论:performSelector的object参数只能为对象类型,其selector参数对应方法的参数也必须为对象类型,如果为基本数据类型则值不可预知,这个时候只能使用NSInvocation.</p>
<p>测试代码如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.val= <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)changeMyVal:(<span class="type">BOOL</span>)param &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, param);</span><br><span class="line">    <span class="keyword">self</span>.val = param;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, <span class="keyword">self</span>.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)changeNumber:(<span class="type">int</span>)param &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, param);</span><br><span class="line">    <span class="keyword">self</span>.num = param;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, <span class="keyword">self</span>.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)changeNumberObj:(<span class="built_in">NSNumber</span> *)param &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, param.intValue);</span><br><span class="line">    <span class="keyword">self</span>.num = param.intValue;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, <span class="keyword">self</span>.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> touchesBegan:touches withEvent:event];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//performSelector的object参数只能为对象类型,其selector参数对应方法的参数也必须为对象类型,如果为基本数据类型则值不可预知.</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(changeMyVal:) withObject:@(<span class="number">0</span>) afterDelay:<span class="number">2</span>]; <span class="comment">//self.val的值每次运行随机0或1</span></span><br><span class="line"><span class="comment">//    [self performSelector:@selector(changeMyVal:) withObject:@(1) afterDelay:2]; //self.val的值每次运行随机0或1.大多数情况下是0</span></span><br><span class="line"><span class="comment">//    [self performSelector:@selector(changeMyVal:) withObject:@(234) afterDelay:2]; //self.val的值每次运行随机0或1.</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    [self performSelector:@selector(changeNumber:) withObject:@(25) afterDelay:2]; //self.num = -1985119076;(每次运行都不一样的)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    [self performSelector:@selector(changeNumberObj:) withObject:@(25) afterDelay:2]; //self.num = 25;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>BOOL类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown更改图片大小</title>
    <url>/2020/01/26/Markdown%E6%9B%B4%E6%94%B9%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<h4 id="更改图片链接上的宽和高-需要服务器支持"><a href="#更改图片链接上的宽和高-需要服务器支持" class="headerlink" title="更改图片链接上的宽和高(需要服务器支持)"></a>更改图片链接上的宽和高(需要服务器支持)</h4><p>原始图像:</p>
<p><code>![loading.png](http://upload-images.jianshu.io/upload_images/1503319-c696a9cd1495d68f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1503319-c696a9cd1495d68f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.png"></p>
<p>更改大小:</p>
<p><code>![loading.png](http://upload-images.jianshu.io/upload_images/1503319-c696a9cd1495d68f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200)</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1503319-c696a9cd1495d68f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="loading.png">  </p>
<p>只需要将后面的宽度更改就可以了.这种改链接有效果的原因是因为服务器根据图片链接对原图进行了缩放并返回.这种方案需要服务器支持对图片链接的识别并进行对应的缩放.</p>
<h4 id="使用HTML-img标签并设置width和height"><a href="#使用HTML-img标签并设置width和height" class="headerlink" title="使用HTML img标签并设置width和height"></a>使用HTML img标签并设置width和height</h4><p>Markdown语法:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;img src<span class="operator">=</span><span class="string">&quot;http://p1-ks3.532106.com/33f925f1f92649678221088fdfb531a1.jpg&quot;</span> alt<span class="operator">=</span><span class="string">&quot;图片替换文本&quot;</span> width<span class="operator">=</span><span class="string">&quot;500&quot;</span> height<span class="operator">=</span><span class="string">&quot;313&quot;</span> align<span class="operator">=</span><span class="string">&quot;bottom&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>只需要更改上面的属性width或height的值就可以了,<code>align=&quot;bottom&quot;</code>可以省略或根据需要设置其他值如<code>top , bottom , middle , left , right</code>.</p>
<p>原始图像效果:<br><img src="http://p1-ks3.532106.com/33f925f1f92649678221088fdfb531a1.jpg" alt="mytest.jpg"></p>
<p>更改后</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;img src<span class="operator">=</span><span class="string">&quot;http://p1-ks3.532106.com/33f925f1f92649678221088fdfb531a1.jpg&quot;</span> alt<span class="operator">=</span><span class="string">&quot;图片替换文本&quot;</span> width<span class="operator">=</span><span class="string">&quot;200&quot;</span> height<span class="operator">=</span><span class="string">&quot;300&quot;</span> align<span class="operator">=</span><span class="string">&quot;bottom&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>效果:</p>
<p><img src="http://p1-ks3.532106.com/33f925f1f92649678221088fdfb531a1.jpg" alt="图片替换文本" width="200" height="300" align="bottom" /></p>
<h4 id="自己处理图片大小-重新生成图片链接"><a href="#自己处理图片大小-重新生成图片链接" class="headerlink" title="自己处理图片大小,重新生成图片链接"></a>自己处理图片大小,重新生成图片链接</h4><p>终极方案,无需考虑各大Markdown编辑器兼容性问题.</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>每家的Markdown编辑器语法会有所不同,因此在一个编辑器下写的Markdown复制到另一家的编辑器下,显示可能会有差异.</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>pod install慢解决</title>
    <url>/2019/11/06/pod%20install%E6%85%A2%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>今天在安装WCDB时,不管是pod install</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">-&gt; Installing WCDB <span class="params">(1.0.6)</span></span><br><span class="line"> &gt; Git download</span><br><span class="line"> &gt; Git download</span><br><span class="line">     $ <span class="string">/usr/local/bin/git</span> clone https:<span class="string">//github.com/Tencent/wcdb.git</span></span><br><span class="line">     <span class="string">/var/folders/5z/1pxqzfcn77s2n7z4gmr63sdr0000gn/T/d20191216-6636-ji8u78</span> <span class="params">--template=</span> <span class="params">--single-branch</span> <span class="params">--depth</span> 1 <span class="params">--branch</span> v1.0.6</span><br><span class="line">     Cloning into &#x27;<span class="string">/var/folders/5z/1pxqzfcn77s2n7z4gmr63sdr0000gn/T/d20191216-6636-ji8u78</span>&#x27;<span class="string">...</span></span><br><span class="line">     error: RPC failed; curl 18 transfer closed with outstanding read data remaining</span><br><span class="line">     fatal: The remote end hung up unexpectedly</span><br><span class="line">     fatal: early EOF</span><br><span class="line">     fatal: index-pack failed</span><br><span class="line"></span><br><span class="line">[!] Error installing WCDB</span><br><span class="line">[!] <span class="string">/usr/local/bin/git</span> clone https:<span class="string">//github.com/Tencent/wcdb.git</span> <span class="string">/var/folders/5z/1pxqzfcn77s2n7z4gmr63sdr0000gn/T/d20191216-6636-ji8u78</span> <span class="params">--template=</span> <span class="params">--single-branch</span> <span class="params">--depth</span> 1 <span class="params">--branch</span> v1.0.6</span><br><span class="line"></span><br><span class="line">Cloning into &#x27;<span class="string">/var/folders/5z/1pxqzfcn77s2n7z4gmr63sdr0000gn/T/d20191216-6636-ji8u78</span>&#x27;<span class="string">...</span></span><br><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data remaining</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>
<p>还是直接git clone,都下载不了.</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="symbol">//github.com/Tencent/wcdb.git</span></span><br><span class="line">Cloning into &#x27;wcdb&#x27;...</span><br><span class="line"><span class="params">remote:</span> Enumerating <span class="params">objects:</span> <span class="number">1704</span>, done.</span><br><span class="line"><span class="params">remote:</span> Counting <span class="params">objects:</span> <span class="number">100</span>% (<span class="number">1704</span><span class="operator">/</span><span class="number">1704</span>), done.</span><br><span class="line"><span class="params">remote:</span> Compressing <span class="params">objects:</span> <span class="number">100</span>% (<span class="number">1192</span><span class="operator">/</span><span class="number">1192</span>), done.</span><br><span class="line"><span class="params">error:</span> RPC failed; curl <span class="number">56</span> LibreSSL <span class="params">SSL_read:</span> SSL_ERROR_SYSCALL, errno <span class="number">54</span></span><br><span class="line"><span class="params">fatal:</span> The remote end hung up unexpectedly</span><br><span class="line"><span class="params">fatal:</span> early EOF</span><br><span class="line"><span class="params">fatal:</span> index-pack failed</span><br></pre></td></tr></table></figure>
<p>从错误原因不难看出是网络的问题，应该是github被墙了。</p>
<p>最后解决办法:</p>
<ol>
<li><p><code>pod repo update</code>更新仓库。</p>
<p>这一步不是必须，除非你的仓库很旧，或者第二步没效果。这一步不翻墙的话同样很慢大概10kb/s的样子，但是比起后面下载源码库尤其是一些必须要翻墙才能下载的（比如libwebp），那简直小巫见大巫了。<code>pod repo update</code>会从github上把最新的仓库更新到本地：<code>~/.cocoapods/repos/master</code>，里面保存了所有第三方库的spec说明书。</p>
</li>
<li><p>从同事那里拷贝源码库(路径为<code>~/Library/Caches/CocoaPods/Pods/Release</code>)和源码库的说明书(路径为<code>~/Library/Caches/CocoaPods/Pods/Specs/Release</code>),也分别放在自己的上述两个目录下.再pod install解决.</p>
</li>
</ol>
<p>从这里可以看出pod install都干了些啥。</p>
<p>参考:<a href="https://www.jianshu.com/p/e2947189c004">无法Pod install第三方库的解决办法</a></p>
<p>ps:<br>pod install下载下来的库的本地存储路径为<br><code>~/Library/Caches/CocoaPods</code>,该目录包含一个搜索索引json文件,以及下载过的库的源代码和对应的Spec.<br>如果Podfile文件中库的版本一致则不会再从github下载,而是直接使用缓存下来的库的源码.因此如果某个库pod install很慢时,可以拷贝别人的版本一致的库到该目录下,减少等待时间.<br>在清理Mac磁盘存储空间时最好不要删除<code>~/Library/Caches/CocoaPods</code>里面的缓存,否则下次pod install会从github上重新下载源码库,这个等待时间你懂得.</p>
<h4 id="让git-clone走代理"><a href="#让git-clone走代理" class="headerlink" title="让git clone走代理"></a>让git clone走代理</h4><p>慢的根本原因:github.global.ssl.fastly.net域名被限制了,导致git clone从上面拉源码库的时候非常慢,呵呵.<br>解决办法:</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">git config <span class="params">--global</span> http.https:<span class="string">//github.com.proxy</span> https:<span class="string">//127.0.0.1</span><span class="function">:xxxxx</span></span><br><span class="line">git config <span class="params">--global</span> https.https:<span class="string">//github.com.proxy</span> https:<span class="string">//127.0.0.1</span><span class="function">:xxxxx</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">git config <span class="params">--global</span> http.https:<span class="string">//github.com.proxy</span> socks5:<span class="string">//127.0.0.1</span><span class="function">:xxxxx</span></span><br><span class="line">git config <span class="params">--global</span> https.https:<span class="string">//github.com.proxy</span> socks5:<span class="string">//127.0.0.1</span><span class="function">:xxxxx</span></span><br></pre></td></tr></table></figure>
<p><code>xxxxx</code>为你的HTTP(S)代理服务器的端口.为什么有两种设置,不知道.反正都试一下.</p>
<p>对应的取消设置为:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git config <span class="attr">--global</span> <span class="attr">--unset</span> http<span class="selector-class">.https</span>:<span class="comment">//github.com.proxy</span></span><br><span class="line">git config <span class="attr">--global</span> <span class="attr">--unset</span> https<span class="selector-class">.https</span>:<span class="comment">//github.com.proxy</span></span><br></pre></td></tr></table></figure>
<p>这个时候git clone可以达到500kb.</p>
<p>ps:</p>
<p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ol>
<li><p>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 —system 选项的 git config 时，它会从此文件读写配置变量。</p>
</li>
<li><p>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 —global 选项让 Git 读写此文件。</p>
</li>
<li><p>当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。</p>
</li>
</ol>
<p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p>
<p>参考:</p>
<p><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE">1.6 起步 - 初次运行 Git 前的配置</a></p>
<p><a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git">8.1 自定义 Git - 配置 Git</a></p>
<h4 id="让Mac终端走代理"><a href="#让Mac终端走代理" class="headerlink" title="让Mac终端走代理"></a>让Mac终端走代理</h4><p><code>vim ~/.zshrc</code>打开<code>.zshrc</code>文件.(我这里用的是zsh)<br>添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&#x27;export all_proxy=socks5://127.0.0.1:xxxxx&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">&#x27;unset all_proxy&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>proxy</code>开启代理.对应的<code>unproxy</code>是关闭.<br>执行<code>curl cip.cc</code>或<code>curl  https://www.dropbox.com</code>检测是否翻墙成功.<br>终端没走代理前git clone都是失败的,走代理后git clone可以工作但只有5kb左右.因此还是需要单独配置上面的git clone.</p>
<p>参考: <a href="https://zhuanlan.zhihu.com/p/47849525">MaxOSX终端走shadowsocks代理</a>.<br>我自己试了一下能用,但晚上11点的速度也不是很快,可能不是独享网络的原因吧.早上6点又试了一下很快. </p>
<p>另:CocoaPods升级到1.8.0+后,版本变化导致的一些问题.<br>参考:<a href="https://zhaoxin.pro/15695124897584.html">脱离CocoaPods 1.8.0的trunk</a><br>在国内还是暂时不要使用trunk,它会让你变得更慢而且还会失败.由于CocoaPods在1.8.0后默认使用trunk,我们可以移除trunk,继续使用master,但此时需要在Podfile文件中指定源<br><code>source &#39;https://github.com/CocoaPods/Specs.git&#39;</code>.</p>
<h4 id="修改计算机网络配置"><a href="#修改计算机网络配置" class="headerlink" title="修改计算机网络配置"></a>修改计算机网络配置</h4><p>如果上述两种办法整了之后还是很慢，可以再结合试一试这个。</p>
<p>由于使用 IPv6 的原因，可能会导致这一问题的出现。可以配置计算机不使用 IPv6，故使用以下命令：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>networksetup -setv6off Wi-Fi</span><br></pre></td></tr></table></figure>
<p>如果有需要，可以再将配置修改回来：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>networksetup -setv6automatic Wi-Fi</span><br></pre></td></tr></table></figure>
<p>ps:公司网络以前配置上面两种后就很快了，不知道从哪天开始突然就不管用了，试了一下这个，又很快了。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.hyperzsb.tech/git-ssl-error/">Git - SSL_ERROR_SYSCALL 问题解决</a></p>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
  </entry>
  <entry>
    <title>关于口罩的几点意见和建议</title>
    <url>/2020/02/02/%E5%85%B3%E4%BA%8E%E5%8F%A3%E7%BD%A9%E7%9A%84%E5%87%A0%E7%82%B9%E6%84%8F%E8%A7%81%E5%92%8C%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="口罩类型"><a href="#口罩类型" class="headerlink" title="口罩类型"></a>口罩类型</h3><p>纸口罩,活性炭口罩,棉布口罩,海绵口罩.这些口罩因材质不够紧密,无法起到防病毒的效果.</p>
<p>能防病毒的有:一次性医用口罩,医用外科口罩,<strong>N95</strong>口罩和<strong>N95</strong>医用防护口罩。</p>
<p>钟南山院士的建议是:并不一定非要戴 N95，因为这些病毒实际上不是单独的存在，它常常存在在飞沫中，一般的口罩、外科口罩等等这些还是能够阻 挡大部分带着飞沫的病毒进入呼吸道。如果是去一般露天公共场所、不与病人接触，可以选择佩戴医用外科口罩，不必过度防护，但如果会接触疑似呼吸道感染的病人，则要佩戴 N95 型口罩。</p>
<h4 id="医用外科口罩"><a href="#医用外科口罩" class="headerlink" title="医用外科口罩"></a>医用外科口罩</h4><p>可阻挡血液、体液穿过口罩,能在一定程度上预防呼吸道感染.<br>购买这一类口罩要注意包装上会有“外科医用口罩”或者是标准为YY-0469-2011.</p>
<blockquote>
<p> 医用外科口罩真假鉴定</p>
</blockquote>
<p>如果没有标注“医用外科口罩”的就别买,<br>在“<a href="http://www.nmpa.gov.cn/WS04/CL2042/">国家药品监督管理局</a>”搜索口罩的械注准字号,该字号下的产品规格、批准日期、有效日期等都能被查到.</p>
<h4 id="N95型口罩"><a href="#N95型口罩" class="headerlink" title="N95型口罩"></a>N95型口罩</h4><p>N95并不是特定的牌子,N95型口罩是NIOSH（美国国家职业安全卫生研究所，National Institute for Occupational Safety and Health）认证的9种颗粒物防护口罩中的一种。“N”表示不耐油（not resistant to oil）。“95”表示暴露在规定数量的专用试验粒子下，口罩内的粒子浓度要比口罩外粒子浓度低95%以上。其中95%这一数值不是平均值，而是最小值。N95不是特定的产品名称，只要符合N95标准，并且通过NIOSH审查的产品就可以称为“N95型口罩”。防护等级为N95级表示在NIOSH标准规定的检测条件下，口罩滤料对非油性颗粒物（如粉尘、酸雾、漆雾、微生物等）的过滤效率达到95%。</p>
<p>NIOSH认证的其他防颗粒物口罩级别还包括：N95、N99、N100、R95、R99、R100、P95、P99、P100，共9种。这些防护级别都能够覆盖N95的防护范围。<br>“N”表示不耐油（not resistant to oil），适合非油性颗粒物。<br>“R”表示耐油（resistant to oil），适合油性或非油性颗粒物，若用于油性颗粒物的防护，使用时间不超过8小时。<br>“P”表示防油（oil proof），适合油性或非油性颗粒物，若用于油性颗粒物，使用时间应遵循制造商的建议。<br>“95”、“99”和“100”是指用0.3微米颗粒进行测试时的过滤效率水平。“95”表示过滤效率在95%以上，“99”表示过滤效率在99%以上，“100”表示过滤效率在99.7%以上。</p>
<blockquote>
<p> N95和KN95的区别</p>
</blockquote>
<p>N95是美国NIOSH制定的标准,而KN95是中国标准和N95几乎是一样的.还有其他的一些标准比如日本DS2、欧洲FFP2标准等都和N95口罩相当.在买不到N95的情况下,KN90也是可以的,只是过滤效率比较低一点但也是有用的.</p>
<blockquote>
<p>N95型口罩真假鉴定</p>
</blockquote>
<p>所有 NIOSH-Approved N95口罩品 牌和型号在 CDC 这个网页 (<a href="https://www.cdc.gov/niosh/npptl/topics/respirators/disp_part/n95list1.html)。大家购买时搜索一下该产品有没有在">https://www.cdc.gov/niosh/npptl/topics/respirators/disp_part/n95list1.html)。大家购买时搜索一下该产品有没有在</a> CDC 的 名单上。</p>
<p>正规厂家的 N95 口罩，每一个口罩上面都应该有如下标识:</p>
<p>NIOSH 认可的制造商名字或注册商标。</p>
<p>大写 NIOSH 字母或 Logo。</p>
<p>NIOSH 测试和认证批准号，例如 TC-84A-XXXX。</p>
<p>NIOSH 过滤器系列和过滤器效率等级，例如 N95，N99，N100，R95， P95，P99，P100。</p>
<p>口罩型号，如 9010、1860。</p>
<h4 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h4><ol>
<li>戴口罩前应洗手，或者在戴口罩过程中避免手接触到口罩内侧面，减少口罩被污染的可能。</li>
<li>分清楚口罩的内外、上下。</li>
<li>不要用手去挤压口罩，N95口罩只能把病毒隔离在口罩表层，如果用手挤压口罩，使得病毒随飞沫湿透口罩，容易造成病毒感染。</li>
<li><strong>要尽量使口罩与面部有良好的密合</strong>。简单的试验方法是：戴上口罩后，用力呼气，空气不能从口罩边缘漏出。</li>
<li>防护口罩必须和使用者脸部紧贴，使用者必须刮净胡须，确保口罩能够与脸部密合，胡须以及垫在口罩密封垫和脸部之间的任何东西都会使口罩出现泄漏。</li>
<li>根据自己的脸型调整好口罩的位置后，应用两手的食指沿着口罩的上缘按压鼻夹，使它与面部紧贴 。</li>
</ol>
<h4 id="更换口罩"><a href="#更换口罩" class="headerlink" title="更换口罩"></a>更换口罩</h4><p>一般的口罩建议每隔2～4小时换一次口罩.</p>
<p>当出现以下情况时，应及时更换口罩：</p>
<ol>
<li>呼吸阻抗明显增加时；</li>
<li>口罩有破损或损坏时；</li>
<li>口罩与面部无法密合时；</li>
<li>口罩受污染（如染有血渍或飞沫等异物时）；</li>
<li>口罩已被污染（曾使用于个例病房或病患接触）；</li>
<li>若为含有活性炭口罩，口罩内有异味时；</li>
<li>口罩使用时长超过建议时长时。</li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>清理你的Xcode</title>
    <url>/2020/02/27/%E6%B8%85%E7%90%86%E4%BD%A0%E7%9A%84Xcode/</url>
    <content><![CDATA[<p>Xcode用久了后会产生很多缓存文件,这些文件会占用很大的磁盘空间.</p>
<p>下面列举的是一些可以删除的文件目录.</p>
<ol>
<li><p><code>~/Library/Developer/Xcode/DerivedData</code>   </p>
<p>一些中间编译信息文件和debug/release 编译生成的 targets.删除后会重新创建.这里清理后腾出了7.81G </p>
</li>
<li><p><code>~/Library/Developer/Xcode/iOS DeviceSupport</code>  </p>
<p>我们每次连上新设备时的『Processing symbol files』就是在向该文件夹写入文件。删除后,再次连上手机时会重新创建.这里清理后腾出了8.68G</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/Xcode清理_DeviceSupport.png" alt="Xcode清理_DeviceSupport"></p>
</li>
<li><p><code>~/Library/Developer/CoreSimulator</code>  </p>
<p>Apps 在模拟器中的存储文档的位置.这里清理后腾出了13.92G</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/Xcode清理_CoreSimulator.png" alt="Xcode清理_CoreSimulator"></p>
</li>
<li><p><code>/Library/Developer/CoreSimulator/Profiles/Runtimes</code></p>
<p>模拟器文件路径.里面是下载的其他版本的模拟器文件.可以删除一些低版本的模拟器.这里清理后腾出了9.6G</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/其他版本模拟器文件路径.png" alt="其他版本模拟器文件路径"></p>
</li>
<li><p><code>~/Library/Developer/Xcode/Archives</code>   </p>
<p>归档项目的存储位置.删除前确保有用的Archive已经备份,因为分析线上崩溃日志需要Archive文件里的一些东西.</p>
</li>
</ol>
<p>其他一些缓存目录：</p>
<p>系统缓存保存在：~/Library/Caches  （按需删除）</p>
<p>系统日志保存在：~/Library/Logs</p>
<p>此外，可以使用命令：“sudo du -sh * ”查看当前文件夹下各个文件和文件夹占用的空间大小，进而一步步找到占用磁盘空间较多的文件。</p>
]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
  </entry>
  <entry>
    <title>iOS图片的缩放</title>
    <url>/2020/02/06/iOS%E5%9B%BE%E7%89%87%E7%9A%84%E7%BC%A9%E6%94%BE/</url>
    <content><![CDATA[<p>在一些情况下需要对图片进行缩放操作.比如使用iPhone6 Plus拍照得到的将是一张2448x3264的图片,这么大分辨率的图片已经远远超过了手机显示屏的分辨率了,如果直接加载到内存会占用很大的空间,这显然是一种浪费.这个时候就需要等比例缩放图片以减小图片分辨率.一般情况下,即时聊天页面用户发送的图片都会经过分辨率压缩和体积压缩后才会上传到服务器.</p>
<p>由于图片的大小和目标大小比例可能不一致,因此等比例缩放图片到目标尺寸有两种填充方式:</p>
<p><strong>1.等比例填满目标大小,图片可能发生裁剪</strong></p>
<p>两种情况:</p>
<p>1.图片与目标大小宽高比一致.</p>
<p>由于与目标大小宽高比一致,图片缩放后会恰好填满整个目标大小,图片不会发生裁剪.</p>
<p>2.图片与目标大小宽高比不一致.</p>
<p>由于与目标大小宽高比不一致,图片缩放后会超出目标大小,因此图片会发生裁剪.</p>
<p>这里又分为两种情况:</p>
<p>prate &lt; drate,图片会在y轴发生裁剪.</p>
<p>prate &gt; drate,图片会在x轴发生裁剪.</p>
<p>如下图所示:</p>
<p><img src="http://m.qpic.cn/psc?/V1266oZg2CElNW/7o.xLwnHK.dZGyBaILrm9x8SHkc6Arj9o6cetKd7mYvokii*NVEUmq*onzjmLHZjLt.n1LKXB7MdsSoPvnlUakgsaGsU5WGJhixm4zx0eCs!/b&bo=ngSqAwAAAAADZ3E!&rf=viewer_4" alt="等比例填满" align="bottom" width="300" height="238" /></p>
<p>108*108</p>
<p>(CGSize) targetSize = (width = 81, height = 162)</p>
<p>(CGRect) rect = (origin = (x = -40.5, y = 0), size = (width = 162, height = 162))</p>
<p><strong>2.等比例适应目标大小,图片可能会有空白部分</strong></p>
<p>两种情况:</p>
<p>1.图片与目标大小宽高比一致.</p>
<p>由于与目标大小宽高比一致,图片缩放后会恰好填满整个目标大小,图片不会有空白部分.</p>
<p>2.图片与目标大小宽高比不一致.</p>
<p>由于与目标大小宽高比不一致,图片缩放后会有空白部分.</p>
<p>这里又分为两种情况:</p>
<p>prate &lt; drate,图片会在x轴产生空白.</p>
<p>prate &gt; drate,图片会在y轴产生空白.</p>
<p>如下图所示:</p>
<p><img src="http://m.qpic.cn/psc?/V1266oZg2CElNW/7o.xLwnHK.dZGyBaILrm9*kU6nfw39PIikWlllQzWPWFD7QaHyossY2yN9.bX3jksmDdE6kab7S7iQvvZ7abYT0LT3D*.8RAu9UTkPERrMo!/b&bo=IARqAwAAAAADB28!&rf=viewer_4" alt="等比例适应" align="bottom" width="300" height="238" /></p>
<p>108*108</p>
<p>(CGSize) targetSize = (width = 81, height = 162)</p>
<p>(CGRect) rect = (origin = (x = 0, y = 40.5), size = (width = 81, height = 81))</p>
<p>实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// MARK: - 缩放图片</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSUInteger, ZAEImageScaleMode) &#123;</span><br><span class="line">    ZAEImageScaleModeFill = 0, //填满</span><br><span class="line">    ZAEImageScaleModeAspectFit = 1, //等比例适应</span><br><span class="line">    ZAEImageScaleModeAspectFill = 2 //等比例填满</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">缩放图片.返回的图片的scale为屏幕scale.</span><br><span class="line"></span><br><span class="line">@param image 原始图片</span><br><span class="line">@param targetSize 目标尺寸</span><br><span class="line">@param scaleMode 缩放模式</span><br><span class="line">@return 缩放后的图片.</span><br><span class="line">*/</span><br><span class="line">+ (UIImage *)za_resizeImage:(UIImage *)image targetSize:(CGSize)targetSize scaleMode:(ZAEImageScaleMode)scaleMode;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">缩放图片.</span><br><span class="line"></span><br><span class="line">@param image 原始图片</span><br><span class="line">@param targetSize 目标尺寸</span><br><span class="line">@param scale 目标scale.[1,屏幕scale]</span><br><span class="line">@param scaleMode 缩放模式</span><br><span class="line">@return 缩放后的图片.</span><br><span class="line">*/</span><br><span class="line">+ (UIImage *)za_resizeImage:(UIImage *)image targetSize:(CGSize)targetSize scale:(CGFloat)scale scaleMode:(ZAEImageScaleMode)scaleMode;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">+ (UIImage *)za_resizeImage:(UIImage *)image targetSize:(CGSize)targetSize scaleMode:(ZAEImageScaleMode)scaleMode</span><br><span class="line">&#123;</span><br><span class="line">    return [UIImage za_resizeImage:image targetSize:targetSize scale:[UIScreen mainScreen].scale scaleMode:scaleMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (UIImage *)za_resizeImage:(UIImage *)image targetSize:(CGSize)targetSize scale:(CGFloat)scale scaleMode:(ZAEImageScaleMode)scaleMode</span><br><span class="line">&#123;</span><br><span class="line">    if (targetSize.width &lt;= 0 || targetSize.height &lt;= 0 || image == nil) return nil;</span><br><span class="line">    </span><br><span class="line">    if (scale &lt; 1) &#123;</span><br><span class="line">        scale = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (scale &gt; [UIScreen mainScreen].scale) &#123;</span><br><span class="line">        scale = [UIScreen mainScreen].scale;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(targetSize, NO, scale);</span><br><span class="line">    CGRect rect = [self CGRectFitWithRect:CGRectMake(0, 0, targetSize.width, targetSize.height) size:image.size scaleMode:scaleMode]; </span><br><span class="line">    [image drawInRect:rect];</span><br><span class="line">    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    if(newImage == nil) &#123;</span><br><span class="line">        NSLog(@&quot;scale image fail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (CGRect)CGRectFitWithRect:(CGRect)rect size:(CGSize)size scaleMode:(ZAEImageScaleMode)scaleMode &#123;</span><br><span class="line">    rect = CGRectStandardize(rect);</span><br><span class="line">    size.width = size.width &lt; 0 ? -size.width : size.width;</span><br><span class="line">    size.height = size.height &lt; 0 ? -size.height : size.height;</span><br><span class="line">    CGPoint center = CGPointMake(CGRectGetMidX(rect), CGRectGetMidY(rect));</span><br><span class="line">    switch (scaleMode) &#123;</span><br><span class="line">        case ZAEImageScaleModeAspectFit:</span><br><span class="line">        case ZAEImageScaleModeAspectFill: &#123;</span><br><span class="line">            if (rect.size.width &lt; 0.01 || rect.size.height &lt; 0.01 ||</span><br><span class="line">                size.width &lt; 0.01 || size.height &lt; 0.01) &#123;</span><br><span class="line">                rect.origin = center;</span><br><span class="line">                rect.size = CGSizeZero;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                CGFloat scale;</span><br><span class="line">                if (scaleMode == ZAEImageScaleModeAspectFit) &#123;</span><br><span class="line">                    if (size.width / size.height &lt; rect.size.width / rect.size.height) &#123; //图片宽不够</span><br><span class="line">                        scale = rect.size.height / size.height; //拉伸高</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        scale = rect.size.width / size.width;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (size.width / size.height &lt; rect.size.width / rect.size.height) &#123; //图片宽不够</span><br><span class="line">                        scale = rect.size.width / size.width; //拉伸宽</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        scale = rect.size.height / size.height;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size.width *= scale;</span><br><span class="line">                size.height *= scale;</span><br><span class="line">                rect.size = size;</span><br><span class="line">                rect.origin = CGPointMake(center.x - size.width * 0.5, center.y - size.height * 0.5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; break;</span><br><span class="line">        case ZAEImageScaleModeFill:</span><br><span class="line">        default: &#123;</span><br><span class="line">            rect = rect;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图片处理</category>
      </categories>
  </entry>
  <entry>
    <title>github pages+hexo+next搭建博客</title>
    <url>/2020/02/29/github%20pages+hexo+next%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ul>
<li>安装环境</li>
<li>初始化项目</li>
<li>部署</li>
<li>配置站点信息</li>
<li>配置主题信息</li>
</ul>
<p>下面是具体的步骤:</p>
<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>安装node.js</p>
<p>安装hexo</p>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>使用 Hexo 的命令行创建一个项目.</p>
<p><code>hexo init &quot;name&quot;</code></p>
<p>调用 Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码.</p>
<p><code>hexo generate</code></p>
<p>利用 Hexo 提供的 server 命令让博客在本地运行起来.</p>
<p><code>hexo server</code></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>安装一个支持 Git 的部署插件，名字叫做 hexo-deployer-git，有了它我们才可以顺利将其部署到 GitHub 上面，如果不安装的话，在执行部署命令时会报错误.</p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p>部署</p>
<p><code>hexo deploy</code></p>
<p>部署成功之后,Hexo会将编译之后的静态页面内容推送到 GitHub 仓库的 master 分支.</p>
<p>需要注意的是里面是没有博客源码的.如果我们换了电脑就需要将以前的博客拷贝回来.这样显然很不方便,因此我们需要将博客源码也托管到 GitHub 上面.</p>
<p><strong>将博客源码托管到 GitHub 上面</strong></p>
<p>可以新建一个source分支,用于博客源码的管理.</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git checkout -<span class="keyword">b </span>source</span><br><span class="line">git <span class="keyword">add </span>-A</span><br><span class="line">git commit -m <span class="string">&quot;init blog&quot;</span></span><br><span class="line">git remote <span class="keyword">add </span><span class="keyword">origin </span><span class="string">&quot;https://github.com/xxx/xxx.github.io.git&quot;</span></span><br><span class="line">git push <span class="keyword">origin </span>source</span><br></pre></td></tr></table></figure>
<h3 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h3><p>站点简介修改</p>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>选择一个主题使用.这里选择next主题.</p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>主题显示效果配置</p>
<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>新增文章</p>
<p><code>hexo new &quot;name&quot;</code></p>
<p>创建的文章会出现在 <code>source/_posts</code> 文件夹下，是 MarkDown 格式。</p>
<p>在文章开头通过如下格式添加必要信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标题</span> <span class="comment"># 自动创建，如 hello-world</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">日期</span> <span class="comment"># 自动创建，如 2020-03-01 13:30:15</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签3</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">分类1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">分类2</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>默认只有title和date,tags字段.可以打开<code>\scaffolds\post.md</code>文件增加一些字段,以后就不要重复写了.</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>增加标签页面</p>
<p><code>hexo new page tags</code></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>增加分类页面</p>
<p><code>hexo new page categories</code></p>
<h3 id="搜索页"><a href="#搜索页" class="headerlink" title="搜索页"></a>搜索页</h3><p>安装搜索插件</p>
<p><code>npm install hexo-generator-searchdb --save</code></p>
<p>在项目的 _config.yml 里面添加搜索设置:</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">  path:</span> search.xml</span><br><span class="line"><span class="symbol">  field:</span> post</span><br><span class="line"><span class="symbol">  format:</span> html</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>在主题的 _config.yml 里面修改如下:</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/wzpan/hexo-generator-search</span></span><br><span class="line"><span class="params">local_search:</span></span><br><span class="line">  <span class="params">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="params">trigger:</span> auto</span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="params">top_n_per_article:</span> <span class="number">5</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="params">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="params">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h3><p>设置自定义的404页面</p>
<p>其他还有很多可以配置的如评论系统,统计系统.</p>
<h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p>官方的推荐:在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断.建议使用 <code>&lt;!-- more --&gt;</code>（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。</p>
<p>不过以前的文章也不可能一一设置,可以使用下面的自动设置.</p>
<p>自动生成摘要的插件:</p>
<p><a href="https://github.com/chekun/hexo-excerpt">Automatic excerpt generator for Hexo</a></p>
<p>安装:<code>npm install hexo-excerpt --save</code></p>
<h3 id="RSS订阅"><a href="#RSS订阅" class="headerlink" title="RSS订阅"></a>RSS订阅</h3><p>安装插件:</p>
<p><code>npm install hexo-generator-feed --save</code></p>
<p>然后在主题配置文件social一栏中新增一行<code>RSS: /atom.xml || rss</code>,就可以让rss显示在侧边栏了.注意不是<code>follow_me:</code>那里(这里开始时没明白,很多文章写的也不是很清楚,浪费了个把小时).</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Social Links</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/xq-120</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="attr">StackOverflow:</span> <span class="string">https://stackoverflow.com/yourname</span> <span class="string">||</span> <span class="string">stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line">  <span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">rss</span></span><br></pre></td></tr></table></figure>
<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>吐槽一点,要想OC代码高亮需要写objc,不能写objective-c,否则不会高亮渲染.我佛了,还以为配置有问题忙活半天.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;```objc&quot;</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> rs = <span class="number">240</span>;</span><br><span class="line"><span class="type">BOOL</span> rs1 = <span class="number">240</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d %d&quot;</span>, rs, rs1);</span><br><span class="line"><span class="string">&quot;```&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>默认npm安装的包在node_modules文件夹里，全局的包安装在 <code>~/.nvm/versions/node/v22.13.0/lib</code> 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cuiqingcai.com/7625.html">利用 GitHub + Hexo + Next 从零搭建一个博客</a></p>
<p><a href="https://blog.csdn.net/u011475210/article/details/79023429">我的个人博客之旅：从jekyll到hexo</a></p>
<p><a href="https://theme-next.iissnan.com/">next配置官方说明</a></p>
<p><a href="https://notes.iissnan.com/">next作者博客</a></p>
<p><a href="https://guanqr.com/tech/website/hexo-theme-next-customization/">Hexo-NexT 主题个性优化</a>:这个很详细.</p>
<p><a href="[https://strivebo.com/2019/02/17/%E7%AF%87%E2%85%A1%EF%BC%9ANexT%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/](https://strivebo.com/2019/02/17/篇Ⅱ：NexT主题的配置和优化指南/">篇Ⅱ：NexT主题的配置和优化指南</a>)</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Swift 数据模型转换框架比较</title>
    <url>/2020/03/08/Swift%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%A1%86%E6%9E%B6%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>Xcode11.3.1,Swift5环境.</p>
<p>在App开发中经常需要将服务端返回的JSON数据转化为模型使用,选择一个好的数据模型转换框架有助于提高开发体验以及减少转换过程中的错误.</p>
<p>我们希望框架支持纯Swift类,结构体,OC类,因此YYModel和MJExtension等一系列优秀的OC数据模型转换框架是不满足要求的,因为它们都需要模型继承自NSObject.</p>
<p>目前使用较多的数据模型转换框架有:</p>
<ol>
<li>系统自带的基于Codable的JSONDecoder/JSONEncoder.</li>
<li>HandyJSON</li>
<li>ObjectMapper</li>
</ol>
<p>下面简单介绍一下各框架的使用,并从框架的使用便捷性和数据容错性上进行一个比较.</p>
<h3 id="JSONDecoder-JSONEncoder"><a href="#JSONDecoder-JSONEncoder" class="headerlink" title="JSONDecoder/JSONEncoder"></a>JSONDecoder/JSONEncoder</h3><p>介绍JSONDecoder之前,先来看下Codable是什么.</p>
<p>Codable是Swift 4.0开始引入的新特性.Codable定义:<code>public typealias Codable = Decodable &amp; Encodable</code>,可以看到Codable是一个类型别名,代表同时遵守Decodable和Encodable协议.</p>
<p>Decodable协议定义了一个解码函数:</p>
<p><code>init(from decoder: Decoder) throws</code></p>
<p>遵从Decodable协议的类型可以使用任何遵守了Decoder协议的对象进行初始化,完成一个解码过程。</p>
<p>Encodable协议定义了一个编码函数:</p>
<p><code>func encode(to encoder: Encoder) throws</code></p>
<p>遵从Encodable协议的类型可以使用任何遵守了Encoder协议的对象进行编码,完成一个编码过程。</p>
<p>可以看到Codable只是规定了编解码的一般规则,并不是为某一个具体的数据格式协议设计的.因此它的扩展性是很强的.系统提供的<code>JSONDecoder,JSONEncoder</code>就是对应于具体的JSON数据格式的编解码类.类似的还有<code>PropertyListEncoder,PropertyListDecoder</code>.当然我们也可以和后端商定一种自定义的数据格式,然后定义两个类分别实现Decoder和Encoder协议用于编解码.</p>
<blockquote>
<p>注意:JSONEncoder自身并没有实现Encoder协议，而是它内部的另一个类_JSONEncoder实现的.JSONEncoder起到一个封装隐藏细节的作用.</p>
</blockquote>
<p>JSONDecoder的解码方法:</p>
<p><code>open func decode&lt;T&gt;(_ type: T.Type, from data: Data) throws -&gt; T where T : Decodable</code></p>
<p>被解码的类型需要遵守Decodable协议.</p>
<p>JSONEncoder的编码方法:</p>
<p><code>open func encode&lt;T&gt;(_ value: T) throws -&gt; Data where T : Encodable</code></p>
<p>被编码的类型需要遵守Encodable协议.</p>
<p>一个模型遵守Codable协议后,通过JSONDecoder,JSONEncoder我们就可以进行JSON的序列化与反序列化.</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小明&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>模型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student1</span>: <span class="title class_ inherited__">Decodable</span>, <span class="title class_ inherited__">Encodable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> grade: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">id</span>: <span class="type">String</span>, <span class="params">name</span>: <span class="type">String</span>, <span class="params">grade</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.id <span class="operator">=</span> id</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.grade <span class="operator">=</span> grade</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> id</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> grade</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container <span class="operator">=</span> encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> container.encode(id, forKey: .id)</span><br><span class="line">        <span class="keyword">try</span> container.encode(name, forKey: .name)</span><br><span class="line">        <span class="keyword">try</span> container.encode(grade, forKey: .grade)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        id <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: <span class="type">CodingKeys</span>.id)</span><br><span class="line">        name <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: <span class="type">CodingKeys</span>.name)</span><br><span class="line">        grade <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: <span class="type">CodingKeys</span>.grade)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够编解码,我们让模型Student1遵守Decodable, Encodable协议,并实现协议.</p>
<p>这样就可以使用JSONEncoder/JSONDecoder编解码了.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">func testBaseCodable() &#123;</span><br><span class="line">    <span class="keyword">let</span> deJsonStr = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;id&quot;: &quot;123456&quot;,</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;小明&quot;,</span></span><br><span class="line"><span class="string">        &quot;grade&quot;: 1</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> deData = deJsonStr.data(<span class="keyword">using</span>: <span class="built_in">String</span>.Encoding.utf8)!</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> decoder = JSONDecoder.init()</span><br><span class="line">        <span class="keyword">let</span> object = <span class="keyword">try</span> decoder.decode(Student1.self, from: deData)</span><br><span class="line">        DLog(object)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error as NSError &#123;</span><br><span class="line">        DLog(<span class="string">&quot;解码失败:\(error.debugDescription)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> student = Student1.init(id: <span class="string">&quot;127182781278&quot;</span>, name: <span class="string">&quot;小红&quot;</span>, grade: <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> jsonData2 = <span class="keyword">try</span> JSONEncoder.init().encode(student)</span><br><span class="line">        <span class="keyword">let</span> jsonString = <span class="built_in">String</span>.init(data: jsonData2, encoding: <span class="built_in">String</span>.Encoding.utf8)</span><br><span class="line">        DLog(jsonString!)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error as NSError &#123;</span><br><span class="line">        DLog(<span class="string">&quot;编码失败:\(error.debugDescription)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中我们为模型实现了Codable协议.在实际使用时并不需要这么麻烦,因为Swift标准库中的类型，比如String，Int，Double和 Foundation 框架中Data，Date，URL都是默认支持Codable协议的，所以如果你的模型使用的都是Swift标准库中的类型,那么只需声明支持协议即可。如下:</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">struct <span class="attribute">Student</span>: <span class="title">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="attribute">id:</span><span class="string"> String</span></span><br><span class="line">    <span class="keyword">var</span> <span class="attribute">name</span>: <span class="built_in">String</span></span><br><span class="line">    <span class="keyword">var</span> <span class="attribute">grade</span>: Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以通过JSONDecoder将json数据转换为模型了.是不是很方便?</p>
<blockquote>
<p>实际上,在编译代码时系统会根据类型的属性，自动生成了一个 <code>CodingKeys</code> 的枚举类型定义，这是一个以 <code>String</code> 类型作为原始值的枚举类型，对应每一个属性的名称。然后再给每一个声明实现 Codable协议的类型自动生成 <code>init(from:)</code> 和 <code>encode(to:)</code> 两个函数的具体实现，最终完成了整个协议的实现。</p>
</blockquote>
<h4 id="嵌套对象，数组和字典"><a href="#嵌套对象，数组和字典" class="headerlink" title="嵌套对象，数组和字典"></a>嵌套对象，数组和字典</h4><p>一般情况下会遇到嵌套的情景.这个时候该如何处理呢?</p>
<p>需要像YYModel那样实现方法<code>+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelContainerPropertyGenericClass;</code>吗?</p>
<p>我们看一下Array和Dictionary的扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> : <span class="title class_ inherited__">Encodable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Element</span> : <span class="title class_ inherited__">Encodable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> : <span class="title class_ inherited__">Decodable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Element</span> : <span class="title class_ inherited__">Decodable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Dictionary</span> : <span class="title class_ inherited__">Decodable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Key</span> : <span class="title class_ inherited__">Decodable</span>, <span class="title class_ inherited__">Value</span> : <span class="title class_ inherited__">Decodable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Dictionary</span> : <span class="title class_ inherited__">Encodable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Key</span> : <span class="title class_ inherited__">Encodable</span>, <span class="title class_ inherited__">Value</span> : <span class="title class_ inherited__">Encodable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数组中每个元素都遵从Codable协议，字典中对应的key和value遵从Codable协议，那么整个容器对象也就遵从Codable协议.</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="variable">struct</span> <span class="title class_">Class</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> className: <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">students</span>: <span class="title class_">Array</span><span class="operator">&lt;</span><span class="title class_">Student</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">teacher</span>: <span class="title class_">Person</span>0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person0</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">name</span>: <span class="title class_">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">age</span>: <span class="title class_">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">motto</span>: <span class="title class_">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">sex</span>: <span class="title class_">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Student遵守Codable协议,因此<code>Array&lt;Student&gt;</code>容器也就遵守Codable协议.这样Class的每个属性都遵守Codable协议.因此如前面所说只需声明Class支持Codable协议即可.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;className&quot;</span><span class="punctuation">:</span><span class="string">&quot;3年A組&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;students&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13321&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小明&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;213&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小王&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;teacher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三丰&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;motto&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nothing is impossible.&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>解码:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let deData = deJsonStr<span class="selector-class">.data</span>(using: String<span class="selector-class">.Encoding</span>.utf8)!</span><br><span class="line">let <span class="selector-tag">object</span> = try! JSONDecoder<span class="selector-class">.init</span>()<span class="selector-class">.decode</span>(Class<span class="selector-class">.self</span>, from: deData)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(object)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="键名和属性名不一致"><a href="#键名和属性名不一致" class="headerlink" title="键名和属性名不一致"></a>键名和属性名不一致</h4><p>一般会遇到和服务器字段名定义不一致的情况.</p>
<p>json如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三丰&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_age&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;motto&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nothing is impossible.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>模型如下:</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">name</span>: <span class="title class_">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">age</span>: <span class="title class_">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">motto</span>: <span class="title class_">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">sex</span>: <span class="title class_">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不做任何处理会报错:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">keyNotFound</span>(<span class="built_in">CodingKeys</span>(<span class="attribute">stringValue</span>: <span class="string">&quot;name&quot;</span>, <span class="attribute">intValue</span>: nil), Swift.DecodingError.<span class="built_in">Context</span>(<span class="attribute">codingPath</span>: [], <span class="attribute">debugDescription</span>: <span class="string">&quot;No value associated with key CodingKeys(stringValue: \&quot;</span>name\<span class="string">&quot;, intValue: nil) (\&quot;</span>name\<span class="string">&quot;).&quot;</span>, <span class="attribute">underlyingError</span>: nil))</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<p>定义一个遵守CodingKey 协议的枚举CodingKeys(名字必须是<strong>CodingKeys</strong>)指定一个明确的映射。Swift 会寻找遵守CodingKey 协议的名为 CodingKeys 的子类型。解码时Swift只解码这里面的属性,其他属性会被忽略.</p>
<p>如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> motto: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name <span class="operator">=</span> <span class="string">&quot;_name&quot;</span></span><br><span class="line">        <span class="keyword">case</span> age <span class="operator">=</span> <span class="string">&quot;_age&quot;</span></span><br><span class="line">        <span class="keyword">case</span> motto <span class="operator">=</span> <span class="string">&quot;motto&quot;</span> </span><br><span class="line">        <span class="keyword">case</span> sex <span class="operator">=</span> <span class="string">&quot;sex&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>坑点</strong>:只要有一个字段名称不匹配,就得定义一个遵守CodingKey 协议的枚举并把其他属性名称全部写进枚举里.</p>
<h4 id="键值对和属性数量不一致"><a href="#键值对和属性数量不一致" class="headerlink" title="键值对和属性数量不一致"></a>键值对和属性数量不一致</h4><ol>
<li>服务器少于客户端字段情况.</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三丰&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">23</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果不做处理会报错:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">keyNotFound</span>(<span class="built_in">CodingKeys</span>(<span class="attribute">stringValue</span>: <span class="string">&quot;motto&quot;</span>, <span class="attribute">intValue</span>: nil), Swift.DecodingError.<span class="built_in">Context</span>(<span class="attribute">codingPath</span>: [], <span class="attribute">debugDescription</span>: <span class="string">&quot;No value associated with key CodingKeys(stringValue: \&quot;</span>motto\<span class="string">&quot;, intValue: nil) (\&quot;</span>motto\<span class="string">&quot;).&quot;</span>, <span class="attribute">underlyingError</span>: nil))</span><br></pre></td></tr></table></figure>
<p>如果是服务器少返回了某个字段,</p>
<p>解决办法:将该字段定义为可选类型.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person21</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> motto: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span>? <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是模型中定义了一些其他字段而服务器没有的,</p>
<p>解决办法:将该字段定义为可选类型或者定义一个遵守CodingKey 协议的枚举,把需要解码的属性写上即可,如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> motto: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>坑点</strong>:有的后台开发者会将没有值的字段省略,所以你根本不知道哪个字段会不返回,不可能把每一个字段都声明为可选值,否则你在使用的过程中简直是噩梦.</p>
<ol>
<li>服务器多于客户端字段情况</li>
</ol>
<p>服务器返回了许多我们不需要的字段,这种情况下,模型只需要定义好该有的属性,无需定义一个遵守CodingKey 协议的枚举,Codable解码时会自动忽略掉多余的键值.</p>
<p>总体上json键值对要包含模型的属性.属于包含单映射关系.</p>
<h4 id="类型不一致"><a href="#类型不一致" class="headerlink" title="类型不一致"></a>类型不一致</h4><p>服务器返回的是String但客户端定义的是Int.</p>
<p>json如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三丰&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;motto&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nothing is impossible.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">175</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>模型如下:</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person3</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">name</span>: <span class="title class_">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">age</span>: <span class="title class_">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">motto</span>: <span class="title class_">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">sex</span>: <span class="title class_">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不做任何处理则报错:类型不匹配.</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">typeMismatch</span>(Swift.Int, Swift.DecodingError.<span class="built_in">Context</span>(<span class="attribute">codingPath</span>: [<span class="built_in">CodingKeys</span>(<span class="attribute">stringValue</span>: <span class="string">&quot;age&quot;</span>, <span class="attribute">intValue</span>: nil)], <span class="attribute">debugDescription</span>: <span class="string">&quot;Expected to decode Int but found a string/data instead.&quot;</span>, <span class="attribute">underlyingError</span>: nil))</span><br></pre></td></tr></table></figure>
<p>解决办法:</p>
<p><a href="https://devkin.cc/2018/04/16/codable 踩坑/">Codable 踩坑</a></p>
<p><strong>Bool值解析</strong></p>
<p>Swift里Bool值只有true和false,如果后端返回的是0,1这样的整型值,Codable会解析出错:类型不匹配.</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">typeMismatch</span>(Swift.Bool, Swift.DecodingError.<span class="built_in">Context</span>(<span class="attribute">codingPath</span>: [<span class="built_in">CodingKeys</span>(<span class="attribute">stringValue</span>: <span class="string">&quot;sex&quot;</span>, <span class="attribute">intValue</span>: nil)], <span class="attribute">debugDescription</span>: <span class="string">&quot;Expected to decode Bool but found a number instead.&quot;</span>, <span class="attribute">underlyingError</span>: nil))</span><br></pre></td></tr></table></figure>
<h4 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h4><ol>
<li><p>服务端使用整型枚举</p>
</li>
<li><p>服务端使用字符串枚举</p>
</li>
</ol>
<p>json如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;feedID&quot;</span><span class="punctuation">:</span><span class="string">&quot;100000&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;video&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>template有:video,pic,link.</p>
<p>gender有:0,1.</p>
<p>模型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeLine</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 服务端使用字符串枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">TimeLineTemplate</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> video <span class="operator">=</span> <span class="string">&quot;video&quot;</span></span><br><span class="line">        <span class="keyword">case</span> pic <span class="operator">=</span> <span class="string">&quot;pic&quot;</span></span><br><span class="line">        <span class="keyword">case</span> link <span class="operator">=</span> <span class="string">&quot;link&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务端使用整型枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Gender</span>: <span class="title class_ inherited__">Int</span>, <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> female <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">case</span> male <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> feedID: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> template: <span class="type">TimeLineTemplate</span></span><br><span class="line">    <span class="keyword">var</span> gender: <span class="type">Gender</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法:让枚举类型支持 Codable 协议.</p>
<p>需要将枚举声明为具有原始值的形式，并且原始值的类型需要支持 Codable 协议.</p>
<ol>
<li>定义一个具有原始值的枚举,指定原始值类型为String或Int.</li>
<li>让枚举遵守Codable协议.</li>
</ol>
<p>需要注意的是:枚举的原始值必须和服务器端商定好保持一致.比如原本只有0,1两个枚举值,但后台却返回3.这就没法对应上了.解码会报错:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dataCorrupted</span>(Swift.DecodingError.<span class="built_in">Context</span>(<span class="attribute">codingPath</span>: [<span class="built_in">CodingKeys</span>(<span class="attribute">stringValue</span>: <span class="string">&quot;template&quot;</span>, <span class="attribute">intValue</span>: nil)], <span class="attribute">debugDescription</span>: <span class="string">&quot;Cannot initialize TimeLineTemplate from invalid String value videos&quot;</span>, <span class="attribute">underlyingError</span>: nil))</span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dataCorrupted</span>(Swift.DecodingError.<span class="built_in">Context</span>(<span class="attribute">codingPath</span>: [<span class="built_in">CodingKeys</span>(<span class="attribute">stringValue</span>: <span class="string">&quot;gender&quot;</span>, <span class="attribute">intValue</span>: nil)], <span class="attribute">debugDescription</span>: <span class="string">&quot;Cannot initialize Gender from invalid Int value 4&quot;</span>, <span class="attribute">underlyingError</span>: nil))</span><br></pre></td></tr></table></figure>
<h4 id="模型中某个属性的类型不支持Codable协议"><a href="#模型中某个属性的类型不支持Codable协议" class="headerlink" title="模型中某个属性的类型不支持Codable协议"></a>模型中某个属性的类型不支持Codable协议</h4><p>比如model使用了一些不属于我们自己的类型，该类型又没有遵守Codable协议.如何让model支持Codable?</p>
<p>比如CLLocationCoordinate2D并没有实现Codable协议.</p>
<p>解决办法有三种:个人感觉无论哪一种都不方便.</p>
<ol>
<li><p>手动让CLLocationCoordinate2D支持Codable协议.</p>
</li>
<li><p>手动让自身支持Codable协议.</p>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person5</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> motto: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> position: <span class="type">CLLocationCoordinate2D</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name <span class="operator">=</span> <span class="string">&quot;_name&quot;</span></span><br><span class="line">        <span class="keyword">case</span> age <span class="operator">=</span> <span class="string">&quot;_age&quot;</span></span><br><span class="line">        <span class="keyword">case</span> motto</span><br><span class="line">        <span class="keyword">case</span> sex</span><br><span class="line">        <span class="keyword">case</span> position <span class="operator">=</span> <span class="string">&quot;position&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自己实现Codable协议.缺点:麻烦,编码,解码都需要实现.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">PositionCodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> latitude</span><br><span class="line">        <span class="keyword">case</span> longitude</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name)</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .age)</span><br><span class="line">        <span class="keyword">self</span>.motto <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .motto)</span><br><span class="line">        <span class="keyword">self</span>.sex <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">Bool</span>.<span class="keyword">self</span>, forKey: .sex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> posContainer <span class="operator">=</span> <span class="keyword">try</span> container.nestedContainer(keyedBy: <span class="type">PositionCodingKeys</span>.<span class="keyword">self</span>, forKey: .position)</span><br><span class="line">        <span class="keyword">self</span>.position <span class="operator">=</span> <span class="type">CLLocationCoordinate2D</span>.<span class="keyword">init</span>(latitude: <span class="keyword">try</span> posContainer.decode(<span class="type">Double</span>.<span class="keyword">self</span>, forKey: .latitude), longitude: <span class="keyword">try</span> posContainer.decode(<span class="type">Double</span>.<span class="keyword">self</span>, forKey: .longitude))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container <span class="operator">=</span> encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> container.encode(name, forKey: .name)</span><br><span class="line">        <span class="keyword">try</span> container.encode(age, forKey: .age)</span><br><span class="line">        <span class="keyword">try</span> container.encode(motto, forKey: .motto)</span><br><span class="line">        <span class="keyword">try</span> container.encode(sex, forKey: .sex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> posContainer <span class="operator">=</span> container.nestedContainer(keyedBy: <span class="type">PositionCodingKeys</span>.<span class="keyword">self</span>, forKey: .position)</span><br><span class="line">        <span class="keyword">try</span> posContainer.encode(position<span class="operator">?</span>.latitude, forKey: .latitude)</span><br><span class="line">        <span class="keyword">try</span> posContainer.encode(position<span class="operator">?</span>.latitude, forKey: .longitude)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>给CLLocationCoordinate2D单独创建一个支持Codable的包装类.</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person4</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> motto: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> position: <span class="type">CLLocationCoordinate2D</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _position <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="literal">nil</span> : <span class="type">CLLocationCoordinate2D</span>.<span class="keyword">init</span>(latitude: _position<span class="operator">!</span>.latitude, longitude: _position<span class="operator">!</span>.longitude)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> newValue <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                _position <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _position <span class="operator">=</span> _CLLocationCoordinate2D.<span class="keyword">init</span>(latitude: newValue<span class="operator">!</span>.latitude, longitude: newValue<span class="operator">!</span>.longitude)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> <span class="title class_">_CLLocationCoordinate2D</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> latitude: <span class="type">CLLocationDegrees</span></span><br><span class="line">        <span class="keyword">var</span> longitude: <span class="type">CLLocationDegrees</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span>(<span class="params">latitude</span>: <span class="type">CLLocationDegrees</span>, <span class="params">longitude</span>: <span class="type">CLLocationDegrees</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.latitude <span class="operator">=</span> latitude</span><br><span class="line">            <span class="keyword">self</span>.longitude <span class="operator">=</span> longitude</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _position: _CLLocationCoordinate2D<span class="operator">?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name <span class="operator">=</span> <span class="string">&quot;_name&quot;</span></span><br><span class="line">        <span class="keyword">case</span> age <span class="operator">=</span> <span class="string">&quot;_age&quot;</span></span><br><span class="line">        <span class="keyword">case</span> motto</span><br><span class="line">        <span class="keyword">case</span> sex</span><br><span class="line">        <span class="keyword">case</span> _position <span class="operator">=</span> <span class="string">&quot;position&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编解码有继承关系的模型"><a href="#编解码有继承关系的模型" class="headerlink" title="编解码有继承关系的模型"></a>编解码有继承关系的模型</h4><p>默认情况下,只有继承来的属性有值,子类自身的属性将不会有值.</p>
<p>模型如下:</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person0</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">name</span>: <span class="title class_">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">age</span>: <span class="title class_">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">motto</span>: <span class="title class_">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">sex</span>: <span class="title class_">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="title class_">Person</span>0 &#123; </span><br><span class="line">    <span class="keyword">var</span> <span class="variable">course</span>: <span class="title class_">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果写为:<code>class Teacher: Person0, Codable</code>,编译会出错:Redundant conformance of ‘Teacher’ to protocol ‘Decodable’.因为Teacher的父类Person0已经遵守Codable了.</p>
<p>测试代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">codablePolymorphismType</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> deJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;张三丰&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 23,</span></span><br><span class="line"><span class="string">        &quot;motto&quot;: &quot;nothing is impossible.&quot;,</span></span><br><span class="line"><span class="string">        &quot;sex&quot;: true</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> deData <span class="operator">=</span> deJsonStr.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> decoder <span class="operator">=</span> <span class="type">JSONDecoder</span>.<span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> object <span class="operator">=</span> <span class="keyword">try</span> decoder.decode(<span class="type">Person0</span>.<span class="keyword">self</span>, from: deData)</span><br><span class="line">        <span class="type">DLog</span>(object)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="type">DLog</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> deTeacherJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;张三丰&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 23,</span></span><br><span class="line"><span class="string">        &quot;motto&quot;: &quot;nothing is impossible.&quot;,</span></span><br><span class="line"><span class="string">        &quot;sex&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;course&quot;: &quot;语文&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> deTeacherData <span class="operator">=</span> deTeacherJsonStr.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> object: <span class="type">Teacher</span>?</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        object <span class="operator">=</span> <span class="keyword">try</span> <span class="type">JSONDecoder</span>.<span class="keyword">init</span>().decode(<span class="type">Teacher</span>.<span class="keyword">self</span>, from: deTeacherData)</span><br><span class="line">        <span class="type">DLog</span>(object<span class="operator">!</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="type">DLog</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> teacher <span class="operator">=</span> object &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try</span> <span class="type">JSONEncoder</span>.<span class="keyword">init</span>().encode(teacher)</span><br><span class="line">            <span class="keyword">let</span> jsonString <span class="operator">=</span> <span class="type">String</span>.<span class="keyword">init</span>(data: data, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">            <span class="type">DLog</span>(jsonString<span class="operator">!</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">            <span class="type">DLog</span>(<span class="string">&quot;编码失败:<span class="subst">\(error.debugDescription)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上解码时,Teacher对象继承的父类的属性有值但自身course属性将是nil.对于这种有继承关系的模型的编解码该怎么办呢?</p>
<p>解决办法:回到最开始的基本使用,自己手动实现Codable协议.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person0</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> motto: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="title class_ inherited__">Person0</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> course: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> course</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        course <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .course)</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">super</span>.<span class="keyword">init</span>(from: decoder)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container <span class="operator">=</span> encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> container.encode(course, forKey: <span class="type">CodingKeys</span>.course)</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">super</span>.encode(to: encoder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>坑点:使用不便.</p>
<h4 id="编码Any"><a href="#编码Any" class="headerlink" title="编码Any"></a>编码Any</h4><h4 id="JSONDecoder-JSONEncoder总结"><a href="#JSONDecoder-JSONEncoder总结" class="headerlink" title="JSONDecoder/JSONEncoder总结"></a>JSONDecoder/JSONEncoder总结</h4><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ol>
<li>系统支持,兼容性问题小.</li>
<li>如果模型中都是基础类型,<code>JSONDecoder/JSONEncoder</code>更方便.</li>
<li>对原生类型支持更好</li>
</ol>
<h5 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h5><ol>
<li>只要有一个属性解析失败则直接抛出异常导致整个解析过程失败。主要体现在:</li>
</ol>
<ul>
<li><p>json中出现null值,空对象,字段缺失,如果不做处理,当解析到该字段时系统会报错.</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">解码失败:<span class="built_in">Error</span> <span class="attribute">Domain</span>=NSCocoaErrorDomain <span class="attribute">Code</span>=4865 <span class="string">&quot;No value associated with key CodingKeys(stringValue: &quot;</span>grade<span class="string">&quot;, intValue: nil) (&quot;</span>grade<span class="string">&quot;).&quot;</span> UserInfo=&#123;<span class="attribute">NSDebugDescription</span>=<span class="literal">No</span> value associated with key CodingKeys(stringValue: <span class="string">&quot;grade&quot;</span>, intValue: <span class="literal">nil</span>) (<span class="string">&quot;grade&quot;</span>)., NSCodingPath=(</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">解码失败:<span class="built_in">Error</span> <span class="attribute">Domain</span>=NSCocoaErrorDomain <span class="attribute">Code</span>=4865 <span class="string">&quot;Expected Int value but found null instead.&quot;</span> UserInfo=&#123;NSCodingPath=(</span><br><span class="line">    <span class="string">&quot;CodingKeys(stringValue: \&quot;grade\&quot;, intValue: nil)&quot;</span></span><br><span class="line">), <span class="attribute">NSDebugDescription</span>=Expected Int value but found <span class="literal">null</span> instead.&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法:将模型中该属性设置为可选值.但正如前文分析的那样,有的后台开发者会将没有值的字段省略,所以你根本不知道哪个字段会不返回,不可能把每一个字段都声明为可选值,否则你在使用的过程中简直是噩梦.</p>
</li>
<li><p>类型不匹配时,如果不做处理,当解析到该字段时系统会报错.</p>
<p>比如服务端定义为String,而你定义为Int.</p>
<p><a href="https://www.jianshu.com/p/1f194f09599a">浅谈 Swift JSON 解析</a>:主流 JSON 解析框架比较,分析了Codable的不足,并提出了解决方案<a href="https://github.com/Pircate/CleanJSON">CleanJSON</a></p>
</li>
</ul>
<ol>
<li>只要有一个字段名称和后台不一致,就得定义一个遵守CodingKey 协议的枚举并把其他属性名称全部写进枚举里,如果一个模型有很多属性,会很繁琐.</li>
<li>编解码有继承关系的模型不方便,需要手动实现Codable协议.</li>
</ol>
<h3 id="HandyJSON"><a href="#HandyJSON" class="headerlink" title="HandyJSON"></a>HandyJSON</h3><p>alibaba开源的一个 json-object 互转的框架.</p>
<h4 id="HandyJSON原理"><a href="#HandyJSON原理" class="headerlink" title="HandyJSON原理"></a>HandyJSON原理</h4><p>主要步骤:</p>
<ol>
<li>通过某种机制(比如Mirror)获取属性名、类型.</li>
<li>根据属性名从JSON串中解析值.</li>
<li>找到实例在内存中的 headPointer, 通过属性的类型计算内存中的偏移值, 确定属性在内存中的位置.</li>
<li>在内存中为属性赋值.(这一步会进行类型的容错处理,比如字符串转数字,数字转字符串等一些简单的转换)</li>
</ol>
<p>由于这个类实例的内存布局可能会变,所以官方文档中有提到”HandyJSON is totally depend on the memory layout rules infered from Swift runtime code. <strong>We are watching it and will follow every bit if it changes.</strong>“.</p>
<p>为啥要分析类实例的内存布局规则呢?</p>
<p>我们知道OC里面可以通过runtime获取一个类所有的属性名和类型,然后通过KVC就可以完成赋值.但是Swift的反射功能很弱,Swift的反射实现类Mirror它只能在运行时获取一个Model实例的所有字段、字段值，但却无法给它赋值,缺少一个类似OC里面KVC的这么一个东西,所以HandyJSON才需要分析类实例的内存布局规则,根据布局规则直接在内存中为属性赋值.</p>
<p>具体可以参考<a href="https://www.jianshu.com/p/eac4a92b44ef">HandyJSON 设计思路简析</a>.</p>
<h4 id="HandyJSON使用"><a href="#HandyJSON使用" class="headerlink" title="HandyJSON使用"></a>HandyJSON使用</h4><p>HandyJSON的使用<a href="https://github.com/alibaba/HandyJSON">官方文档</a>其实已经很全面了.</p>
<p>下面通过一个例子将上面所有的情况也测试一下:</p>
<p>模型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HJPerson</span>: <span class="title class_ inherited__">HandyJSON</span>  &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务端使用整型枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Hobbit</span>: <span class="title class_ inherited__">Int</span>, <span class="title class_ inherited__">HandyJSONEnum</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> none <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> basketball <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">case</span> football <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Music</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">HandyJSONEnum</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> none</span><br><span class="line">        <span class="keyword">case</span> classic</span><br><span class="line">        <span class="keyword">case</span> modern</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> motto: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Float</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> hobbit: <span class="type">Hobbit</span> <span class="operator">=</span> .none</span><br><span class="line">    <span class="keyword">var</span> music: <span class="type">Music</span> <span class="operator">=</span> .none</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//名称不匹配时</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mapping</span>(<span class="params">mapper</span>: <span class="type">HelpingMapper</span>) &#123;</span><br><span class="line">        mapper.specify(property: <span class="operator">&amp;</span>name, name: <span class="string">&quot;_name&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HJTeacher</span>: <span class="title class_ inherited__">HJPerson</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> course: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student2</span>: <span class="title class_ inherited__">HandyJSON</span>  &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        id <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        name <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        grade <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> grade: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">handyJsonStudent</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> deJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;id&quot;: &quot;2323&quot;,</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;小明&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">//        let student = JSONDeserializer&lt;Student2&gt;.deserializeFrom(json: deJsonStr)</span></span><br><span class="line">    <span class="keyword">let</span> student <span class="operator">=</span> <span class="type">Student2</span>.deserialize(from: deJsonStr)</span><br><span class="line">    <span class="type">DLog</span>(student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">handyJsonKeyPropertyTypeNotMatch</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> deJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;_name&quot;: &quot;张三丰&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: &quot;23&quot;,</span></span><br><span class="line"><span class="string">        &quot;motto&quot;: &quot;nothing is impossible.&quot;,</span></span><br><span class="line"><span class="string">        &quot;sex&quot;: 1,</span></span><br><span class="line"><span class="string">        &quot;height&quot;: &quot;172.4&quot;,</span></span><br><span class="line"><span class="string">        &quot;hobbit&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="string">        &quot;music&quot;: &quot;modern&quot;,</span></span><br><span class="line"><span class="string">        &quot;id&quot;: 345345131</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> student <span class="operator">=</span> <span class="type">HJPerson</span>.deserialize(from: deJsonStr)</span><br><span class="line">    <span class="type">DLog</span>(student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handyJsonPolymorphismType</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> deJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;_name&quot;: &quot;张三丰&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 23,</span></span><br><span class="line"><span class="string">        &quot;motto&quot;: &quot;nothing is impossible.&quot;,</span></span><br><span class="line"><span class="string">        &quot;hobbit&quot;: &quot;4&quot;,</span></span><br><span class="line"><span class="string">        &quot;sex&quot;: true</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> person <span class="operator">=</span> <span class="type">HJPerson</span>.deserialize(from: deJsonStr)</span><br><span class="line">    <span class="type">DLog</span>(person)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> deTeacherJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;_name&quot;: &quot;张三丰&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 23,</span></span><br><span class="line"><span class="string">        &quot;motto&quot;: &quot;nothing is impossible.&quot;,</span></span><br><span class="line"><span class="string">        &quot;sex&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;course&quot;: &quot;语文&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> teacher <span class="operator">=</span> <span class="type">HJTeacher</span>.deserialize(from: deTeacherJsonStr)</span><br><span class="line">    <span class="type">DLog</span>(teacher<span class="operator">!</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> string <span class="operator">=</span> teacher<span class="operator">!</span>.toJSONString()</span><br><span class="line">    <span class="type">DLog</span>(string<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当服务端返回的JSON格式不规范时,比如名称不匹配,类型不匹配,缺失字段,字段值为null,Bool值问题等,使用HandyJSON基本上不需要额外的处理,非常方便.</p>
<h4 id="HandyJSON优点"><a href="#HandyJSON优点" class="headerlink" title="HandyJSON优点"></a>HandyJSON优点</h4><ol>
<li>使用非常方便</li>
<li>数据容错性高</li>
</ol>
<h4 id="HandyJSON缺点"><a href="#HandyJSON缺点" class="headerlink" title="HandyJSON缺点"></a>HandyJSON缺点</h4><ol>
<li>依赖于类实例的内存布局规则.</li>
<li>Swift版本兼容性问题.一旦出问题就只能等官方出新版本了.Swift4之前比较坑,不过现在都Swift5了,这个问题会好点.</li>
</ol>
<p>总的来说还是值得入坑的.</p>
<h3 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h3><p>应该是比较早的一批转换框架了,使用上类似 <code>Codable</code>，但是需要额外写 map 方法，重复劳动过多。不是很推荐.</p>
<p>模型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OMPerson</span>: <span class="title class_ inherited__">Mappable</span>   &#123;</span><br><span class="line">    <span class="comment">//服务端使用整型枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Hobbit</span>: <span class="title class_ inherited__">Int</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> none <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> basketball <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">case</span> football <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Music</span>: <span class="title class_ inherited__">String</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> none</span><br><span class="line">        <span class="keyword">case</span> classic</span><br><span class="line">        <span class="keyword">case</span> modern</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> motto: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Float</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> hobbit: <span class="type">Hobbit</span> <span class="operator">=</span> .none</span><br><span class="line">    <span class="keyword">var</span> music: <span class="type">Music</span> <span class="operator">=</span> .none</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init?</span>(<span class="params">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mapping</span>(<span class="params">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        name <span class="operator">&lt;-</span> map[<span class="string">&quot;_name&quot;</span>]</span><br><span class="line">        age <span class="operator">&lt;-</span> map[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">        motto <span class="operator">&lt;-</span> map[<span class="string">&quot;motto&quot;</span>]</span><br><span class="line">        sex <span class="operator">&lt;-</span> map[<span class="string">&quot;sex&quot;</span>]</span><br><span class="line">        height <span class="operator">&lt;-</span> map[<span class="string">&quot;height&quot;</span>]</span><br><span class="line">        id <span class="operator">&lt;-</span> map[<span class="string">&quot;id&quot;</span>]</span><br><span class="line">        hobbit <span class="operator">&lt;-</span> map[<span class="string">&quot;hobbit&quot;</span>]</span><br><span class="line">        music <span class="operator">&lt;-</span> map[<span class="string">&quot;music&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OMTeacher</span>: <span class="title class_ inherited__">OMPerson</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> course: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init?</span>(<span class="params">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(map: map)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">mapping</span>(<span class="params">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.mapping(map: map)</span><br><span class="line">        course <span class="operator">&lt;-</span> map[<span class="string">&quot;course&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要遵守并实现Mappable协议的俩函数,尤其是<code>func mapping(map: Map)</code>函数,比较繁琐.类型不匹配时不会赋值给属性,不像JSONDecoder那样直接报错,但也不像HandyJSON会帮你尝试做一下转换.</p>
<p>测试代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">objectMapperStudent</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> deJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;id&quot;: &quot;2323&quot;,</span></span><br><span class="line"><span class="string">        &quot;_name&quot;: &quot;小明&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> student <span class="operator">=</span> <span class="type">Student3</span>.<span class="keyword">init</span>(JSONString: deJsonStr)</span><br><span class="line">    <span class="type">DLog</span>(student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">objectMapperKeyPropertyTypeNotMatch</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> deJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;_name&quot;: &quot;张三丰&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: &quot;23&quot;,</span></span><br><span class="line"><span class="string">        &quot;motto&quot;: &quot;nothing is impossible.&quot;,</span></span><br><span class="line"><span class="string">        &quot;sex&quot;: 0,</span></span><br><span class="line"><span class="string">        &quot;height&quot;: &quot;172.4&quot;,</span></span><br><span class="line"><span class="string">        &quot;hobbit&quot;: 1,</span></span><br><span class="line"><span class="string">        &quot;music&quot;: &quot;modern&quot;,</span></span><br><span class="line"><span class="string">        &quot;id&quot;: 345345131</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> student <span class="operator">=</span> <span class="type">OMPerson</span>.<span class="keyword">init</span>(JSONString: deJsonStr)</span><br><span class="line">    <span class="type">DLog</span>(student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">objectMapperPolymorphismType</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> deJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;_name&quot;: &quot;张三丰&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 23,</span></span><br><span class="line"><span class="string">        &quot;motto&quot;: &quot;nothing is impossible.&quot;,</span></span><br><span class="line"><span class="string">        &quot;hobbit&quot;: &quot;4&quot;,</span></span><br><span class="line"><span class="string">        &quot;sex&quot;: true</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> person <span class="operator">=</span> <span class="type">OMPerson</span>.<span class="keyword">init</span>(JSONString: deJsonStr)</span><br><span class="line">    <span class="type">DLog</span>(person)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> deTeacherJsonStr <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;_name&quot;: &quot;张三丰&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 23,</span></span><br><span class="line"><span class="string">        &quot;motto&quot;: &quot;nothing is impossible.&quot;,</span></span><br><span class="line"><span class="string">        &quot;sex&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;course&quot;: &quot;语文&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> teacher <span class="operator">=</span> <span class="type">OMTeacher</span>.<span class="keyword">init</span>(JSONString: deTeacherJsonStr)</span><br><span class="line">    <span class="type">DLog</span>(teacher<span class="operator">!</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> string <span class="operator">=</span> <span class="type">Mapper</span>.<span class="keyword">init</span>().toJSONString(teacher<span class="operator">!</span>)</span><br><span class="line">	  <span class="type">DLog</span>(string<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>JSONDecoder/JSONEncoder</th>
<th>HandyJSON</th>
</tr>
</thead>
<tbody>
<tr>
<td>易用性</td>
<td>较好</td>
<td>好</td>
</tr>
<tr>
<td>数据容错性</td>
<td>一般</td>
<td>好</td>
</tr>
<tr>
<td>兼容性</td>
<td>好</td>
<td>一般</td>
</tr>
</tbody>
</table>
</div>
<p>考虑到易用性和数据容错性推荐使用HandyJSON.但是基于Codable的<code>JSONDecoder/JSONEncoder</code>如果能够很好的解决数据容错性方面的问题还是很不错的,毕竟可以少引入一个外部框架.</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Codable</tag>
        <tag>HandyJSON</tag>
        <tag>ObjectMapper</tag>
      </tags>
  </entry>
  <entry>
    <title>IRR内部收益率</title>
    <url>/2020/04/06/IRR%E5%86%85%E9%83%A8%E6%94%B6%E7%9B%8A%E7%8E%87/</url>
    <content><![CDATA[<h4 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a>ROI</h4><p>return on investment，投资回报率。</p>
<p>投资回报率的计算公式：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">投资回报率 <span class="operator">=</span> （收益 - 成本）/ 成本 * <span class="number">100</span>%</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<p>项目A投入本金100，最后可以110，那么ROI = （110 - 100）/ 100 * 100% = 10%</p>
<p>项目B投入本金100，最后可以105，那么ROI = （105 - 100）/ 100 * 100% = 5%</p>
<p>通过计算应该选择项目A。</p>
<p><strong>投资报酬率的优缺点</strong></p>
<p>优点：</p>
<p>计算方便，可以简单粗暴的对不同项目进行横向比较。</p>
<p>缺点：</p>
<p>没有考虑资金时间价值因素，不能正确反映建设期长短及投资方式不同和回收额的有无等条件对项目的影响，分子、分母计算口径的可比性较差，无法直接利用<a href="https://wiki.mbalib.com/wiki/净现金流量">净现金流量</a>信息。一句话就是太粗糙了，无法体现投资期间的一些细节。</p>
<p>为了解决ROI的缺点，需要引入下一个概念NPV。</p>
<h4 id="NPV"><a href="#NPV" class="headerlink" title="NPV"></a>NPV</h4><p><em>Net present value</em> 净现值，指一项投资所产生的未来现金流的折现值与项目投资成本之间的差值。净现值指标是反映项目投资获利能力的指标，净现值&gt;=0表示方案可行，&lt;0表示不可行，净现值越大越好。</p>
<p>简单点讲就是将未来的现金折现为当前的现金再与本金相比较。假设拿100块钱去做投资，可以接受的最低收益率是5%（即折现率），一年后拿回110块则NPV = 110 / (1 + 5%) - 100 = 104.76 - 100 = 4.76。<code>110 / (1 + 5%)</code>表示的就是将未来的现金折现为当前的现金，计算过程跟利息相反（计算利息：100元，假设收益率为5%则一年后可获得100 * （1 + 5%） = 105）。</p>
<p>举个复杂点的例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">本金</th>
<th style="text-align:center">第一年净现金流</th>
<th style="text-align:center">第二年净现金流</th>
<th style="text-align:center">本利和</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">项目A</td>
<td style="text-align:center">100</td>
<td style="text-align:center">80</td>
<td style="text-align:center">30</td>
<td style="text-align:center">110</td>
</tr>
<tr>
<td style="text-align:center">项目B</td>
<td style="text-align:center">100</td>
<td style="text-align:center">4</td>
<td style="text-align:center">106</td>
<td style="text-align:center">110</td>
</tr>
</tbody>
</table>
</div>
<p>如果通过ROI法计算，项目A和项目B得到的结果是完全一致的，总回报率是10%，年均回报率是5%。</p>
<p>那么究竟哪个项目好一点呢？我想大多数人应该都会选择项目A，因为如果我们拿项目第一年的回款进行再投资时项目A明显更多一些。这就是考虑到了现金的时间价值。</p>
<p>我们再来计算一下NPV，假设折现率为5%。</p>
<p>项目A的NPV = 80 / (1 + 5% ) + 30 / (1 + 5%)² - 100 = 103.40 - 100 = 3.40</p>
<p>项目B的NPV = 4 / (1 + 5% ) + 106 / (1 + 5%)² - 100 = 99.95 - 100 = -0.05</p>
<p>在考虑到现金时间价值的情况下，投资A项目实际能多赚3.40元，投资B项目要少赚0.05元。</p>
<h4 id="IRR"><a href="#IRR" class="headerlink" title="IRR"></a>IRR</h4><p>内部收益率（Internal Rate of Return，IRR）就是资金流入现值总额与资金流出现值总额相等，即使得NPV等于0时的那个折现率。</p>
<p>上面计算NPV时我们都假设了一个折现率，但现实应用中通常是已知净现金流和本金计算折现率（最常见的就是商家的分期套路）。</p>
<p>还是上面的例子我们计算一下各项目的IRR。</p>
<p>项目A：</p>
<p>80 / (1 + x ) + 30 / (1 + x)² - 100 = 0</p>
<p>x = 0.07823，即IRR = 7.82%</p>
<p>项目B: </p>
<p>4 / (1 + x ) + 106 / (1 + x)² - 100 = 0</p>
<p>x = 0.04976，即IRR = 4.98%</p>
<p>通过计算得出，项目A的IRR为7.82%，项目B的IRR为4.98%，于是我们发现，按照ROI计算出的5%并不完全靠谱，A项目确实要优于B项目。</p>
<p>由此可以看出IRR考虑了货币时间价值的收益率，是综合考虑了每期的流入流出现金的量和时间，加权出来的结果。</p>
<p>不难看出IRR的计算还是挺复杂的，上述的例子还只是两期的现金流，如果是3期，6期或者12期那么手工计算几乎不太可能，这个时候使用Excel的IRR计算公式就可以轻松搞定。</p>
<h4 id="Numbers的IRR计算器"><a href="#Numbers的IRR计算器" class="headerlink" title="Numbers的IRR计算器"></a>Numbers的IRR计算器</h4><p>我这里是Mac电脑所以使用的是Numbers软件对应的PC电脑就是Excel软件。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/IRR计算.jpg" style="zoom:50%;" /></p>
<p>输入：IRR(C32:C34)，如下：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/IRR计算步骤.jpg" style="zoom:50%;" /></p>
<p>使用到的函数：<strong>IRR</strong>(<em>现金流范围, 估计</em>)</p>
<p>第一个参数为现金流范围：包含现金流值的集合。 现金流范围必须包含数字值。收入（现金流入量）指定为正数，而支出（现金流出量）指定为负数。集合中必须至少包括一个正值和一个负值。现金流量必须按时间顺序指定，且在时间上等距（如每月）。如果某个期间没有现金流量，则该期间使用 0。</p>
<p>-100表示是投入所以是负数。</p>
<p>第二个参数是可选的。所以这里就不填了。</p>
<p>学会了计算IRR，我们就可以计算各个商家给出的分期策略的实际年化收益率了，绝对会让你感叹一句社会，社会！相信你再也不会被商家的分期套路了。</p>
<p><strong>其他</strong></p>
<p>单利：</p>
<p>即利息不作为下一次的投资。</p>
<p><code>到期总收益 = 本金 * (1 + 收益率 * n)</code></p>
<p>复利：</p>
<p>即利息再投资。</p>
<p><code>到期总收益 = 本金 * (1 + 收益率)^n</code></p>
<p>eg:</p>
<p>本金10000，年利率10%，分别计算单利和复利到期后获得的总收益</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>本金</th>
<th>1年</th>
<th>2年</th>
<th>3年</th>
<th>4年</th>
<th>5年</th>
</tr>
</thead>
<tbody>
<tr>
<td>单利</td>
<td>10000</td>
<td>11000</td>
<td>12000</td>
<td>13000</td>
<td>14000</td>
<td>15000</td>
</tr>
<tr>
<td>复利</td>
<td>10000</td>
<td>11000</td>
<td>12100</td>
<td>13310</td>
<td>14641</td>
<td>16105</td>
</tr>
</tbody>
</table>
</div>
<p>感觉5年也差别不是很大，但是20年复利就是67275，单利却只有30000，已经差了2倍多了。单利是线性增长的，但复利却是指数增长的，越往后相差越大。所以不要小看复利的效果。</p>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
  </entry>
  <entry>
    <title>子类同名父类私有属性和方法</title>
    <url>/2020/03/23/%E5%AD%90%E7%B1%BB%E5%90%8C%E5%90%8D%E7%88%B6%E7%B1%BB%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>对于私有属性和方法，子类和父类同名基本上没有什么影响.但是有几点需要注意一下：</p>
<p>如果是属性同名，子类和父类会拥有各自独立的实例变量。</p>
<p>如果是方法同名，按照消息发送的过程，执行的自然是子类中的方法。</p>
<p>举个栗子：</p>
<p>父类：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSInteger</span>)age;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *hobbit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSInteger</span>)age &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;父类方法，%@  %ld %@&quot;</span>, _name, (<span class="type">long</span>)_age, <span class="keyword">self</span>.hobbit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;父类方法run&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)hobbit &#123;</span><br><span class="line">    <span class="keyword">if</span> (_hobbit == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _hobbit = <span class="string">@&quot;unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _hobbit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>子类：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: Animal</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> Person ()</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *hobbit;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> Person</span><br><span class="line"></span><br><span class="line">- (void)hello &#123;</span><br><span class="line">    <span class="selector-attr">[super hello]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">&quot;子类方法，%@ %ld %@&quot;</span>, self.name, (long)self.age, self.hobbit);</span><br><span class="line">    </span><br><span class="line">    <span class="selector-attr">[self performSelector:@selector(run)]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>
<p>属性同名，拥有各自独立的实例变量：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/%E5%90%8C%E5%90%8D%E5%B1%9E%E6%80%A7.jpg" style="zoom:50%;" /></p>
<p>方法同名：</p>
<p>下面代码会打印什么？</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> *p = <span class="comment">[<span class="comment">[Person alloc]</span> initWithName:@&quot;mattt&quot; age:3]</span>;</span><br><span class="line"><span class="comment">[p hello]</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Animal</span> *ani = <span class="comment">[<span class="comment">[Animal alloc]</span> initWithName:@&quot;sun&quot; age:3]</span>;</span><br><span class="line"><span class="comment">[ani hello]</span>;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2020</span>-<span class="number">03</span>-<span class="number">23</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">13</span>.<span class="number">648428</span>+<span class="number">0800</span> 父子类属性同名[<span class="number">47652</span>:<span class="number">6589153</span>] 父类方法，mattt  <span class="number">3</span> (null)</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">03</span>-<span class="number">23</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">13</span>.<span class="number">648780</span>+<span class="number">0800</span> 父子类属性同名[<span class="number">47652</span>:<span class="number">6589153</span>] 子类方法，mattt <span class="number">3</span> (null)</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">03</span>-<span class="number">23</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">13</span>.<span class="number">648815</span>+<span class="number">0800</span> 父子类属性同名[<span class="number">47652</span>:<span class="number">6589153</span>] 父类方法run</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">03</span>-<span class="number">23</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">13</span>.<span class="number">648853</span>+<span class="number">0800</span> 父子类属性同名[<span class="number">47652</span>:<span class="number">6589153</span>] 父类方法，sun  <span class="number">3</span> unknown</span><br></pre></td></tr></table></figure>
<p>可以看到父类的hobbit属性是实现了懒加载的，但子类执行到父类hello方法里的self.hobbit时并没有执行懒加载代码，打印依然为null。这是因为执行self.hobbit时，执行的是子类自己的getter/setter方法。</p>
<p>之所以写这个，是因为在重构的时候发现上面的懒加载代码怎么死活都不执行。</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
  </entry>
  <entry>
    <title>支付宝花呗与借呗背后的利率</title>
    <url>/2020/04/06/%E6%94%AF%E4%BB%98%E5%AE%9D%E8%8A%B1%E5%91%97%E4%B8%8E%E5%80%9F%E5%91%97%E8%83%8C%E5%90%8E%E7%9A%84%E5%88%A9%E7%8E%87/</url>
    <content><![CDATA[<p>本文主要分析支付宝里的花呗，借呗，备用金背后的年化收益率。</p>
<p>在使用支付宝花呗的时候，还款页面除了正常还款外还有一些什么账单分期、最低还款、延期还款之类烂七八糟的东西：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/DBCA822F-CA14-4D45-BA99-5592A7D39D4A.png" style="zoom:50%;" /></p>
<p>似乎是在替用户着想，但真实情况是不是如此呢？下面将仔细分析一下花呗分期的真实年利率。</p>
<h4 id="账单分期"><a href="#账单分期" class="headerlink" title="账单分期"></a>账单分期</h4><p>花呗分期数与手续费率如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>花呗</th>
</tr>
</thead>
<tbody>
<tr>
<td>3期</td>
<td>2.50%</td>
</tr>
<tr>
<td>6期</td>
<td>4.50%</td>
</tr>
<tr>
<td>9期</td>
<td>6.50%</td>
</tr>
<tr>
<td>12期</td>
<td>8.80%</td>
</tr>
</tbody>
</table>
</div>
<p>每期手续费 = 分期金额 / 分期期数 * 手续费率</p>
<p>每期还款数 = 分期金额 / 分期期数 + 每期手续费 = 每期手续费 * (1 + 手续费率 ) / 手续费率</p>
<p>总手续费 = 分期金额 * 手续费率</p>
<p>以12期为例，分期金额1244.55元：</p>
<p>每期手续费 = 1244.55  / 12 * 8.8% = 9.1267 ≈ 9.13</p>
<p>每期还款数 = 1244.55 / 12 + 9.13 = 112.8425 ≈ 112.84</p>
<p>总手续费 = 1244.55 * 8.8% ≈ 109.52</p>
<p>每期本金 = 1244.55 / 12 = 103.7125 ≈ 103.71</p>
<p>花呗的12期分期：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/花呗分期.jpg" style="zoom:50%;" /></p>
<p>发现支付宝第一期居然是112.87，其他期都是112.84，第一期多出的0.03元怎么来的呢</p>
<p>事实就是(112.8425 - 112.84 ) <em> 12 = 0.0025 </em> 12 = 0.03，看来被安排的明明白白。</p>
<p>1244.55元一年总手续费 = 1244.55 * 8.80% = 109.5204 ≈ 109.52。</p>
<p>站在花呗的角度貌似借我1244.55元一年得到利息109.52元，年利率 = 109.52 / 1244.55 = 8.80% = 手续费率。这样看来花呗的年利率8.80%似乎并不太高。</p>
<p>但实际情况并不是这样，因为这1244.55元你并没有真正使用一整年，事实是1244.55元你只占有了一个月，真正占有了一年的是最后一期的103.71元。随着每一期的还款，欠款会越来越少但每期的手续费却还是以最初的分期金额计算的。</p>
<p>因此要想知道花呗分期的真实年利率，就需要计算它的IRR（内部收益率）如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200406154713.png" style="zoom:50%;" /></p>
<p>可以看到花呗分期3期年利率为14.95%，6期年利率为15.26%，9期年利率为15.34%，12期年利率为15.87%，这个收益率估计大多数人都达不到，我自己4%（3.17%）都不到，所以最好不要使用什么分期支付，这只会慢慢侵蚀掉你的财富。</p>
<p>再来看一下延期还款</p>
<h4 id="延期还款"><a href="#延期还款" class="headerlink" title="延期还款"></a>延期还款</h4><p>延期还款就是延期到下个月再还，支付宝收取一定的手续费。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/8BED5EEF-7720-4D2F-A633-CCE525989358.png" style="zoom:50%;" /></p>
<p>可以计算一下它的年化收益率：20 / 1244.55 <em> 12 </em> 100% = 19.28%，虽然看上去只有20元的手续费但对应到年化收益率就是19.28%已经超过分期支付了，你自己拿1244.55去投资一个月基本上不可能得到20元的收益，想一想余额宝里的七日年化才1.89%，1万块钱一个月也只有15.5元的收益，所以不要被表面的数字迷惑。</p>
<h4 id="最低还款"><a href="#最低还款" class="headerlink" title="最低还款"></a>最低还款</h4><p>最低还款说明是这样的：剩余xxx元下期还，日利率0.05%计息，可提前还款。</p>
<p>计算一下它的年化收益率：0.05% <em> 12 </em> 100% = 18.25%，只比延期还款低了一点点。</p>
<p>小记：对于花呗尽量在还款日前一次性还完，这样使用花呗还是不错的。</p>
<h4 id="借呗"><a href="#借呗" class="headerlink" title="借呗"></a>借呗</h4><p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200406163840.png" style="zoom:50%;" /></p>
<p>日利率万3（1千元用1天只需0.3元），其实后面那句“1千元用1天只需0.3元”只是用来迷惑你的，让你觉得一天的利息很低啊，但凡事都得动动脑子。计算一下它的年化收益率：3.65% * 3 = 10.95%，差不多11个点，基本上还算可以。如果你的投资年化收益率能够有20%，那么借呗就是你的商机。</p>
<h4 id="备用金"><a href="#备用金" class="headerlink" title="备用金"></a>备用金</h4><p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200406164954.png" style="zoom:50%;" /></p>
<p>用7天，推广价1.99元（原价2.29元）</p>
<p>计算一下它的年化收益率：</p>
<p>推广价的年化收益率：1.99 / 7 / 500 <em> 365 </em> 100% = 20.75%</p>
<p>原价的年化收益率：2.29 / 7 / 500 <em> 365 </em> 100% = 23.88%</p>
<p>年化收益率23.88%什么概念？</p>
<p>先来看一下法律对于高利贷的定义：</p>
<p><strong>高利贷定义：</strong></p>
<p>借贷双方约定的利率不得超过中国人民银行公布的金融机构同期、同档次贷款利率(不含浮动)的4倍。超过上述标准的，应界定为高利借贷行为。</p>
<p><strong>法律规定：</strong></p>
<p>1、对于年利率在百分之二十四及其以下的民间借贷利息属于“司法保护区”，法院应当予以保护;</p>
<p>2、对于年利率在百分之二十四到百分之三十六之间的部分属于“自然保护区”，如果借款人已经偿还，法院也不会判决他讨回这部分利息;</p>
<p>3、对于年利率超过百分之三十六的民间借贷利息，其超出部分属于“无效区”，法院将对超出部分的约定认定为无效，即便债务人已经偿还亦可请求债权人予以返还，情节严重的，可以处以一定的罚款。</p>
<p>你以为的用7天才2.29元其实已经卡在高利贷的边缘了，所以没事就不要用备用金。除非你实在借不到钱了。</p>
<p>到此为止支付宝里面的各种花招都分析完了，了解一点经济学还是有用的，至少让你明白免费的午餐是没有的，不要被表面的现象迷惑，多动脑分析，可以少走很多套路。</p>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
  </entry>
  <entry>
    <title>iOS设置圆角</title>
    <url>/2020/04/07/iOS%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/</url>
    <content><![CDATA[<p>iOS中设置圆角大致有下面几种办法，每一种都有各自的优缺点，结合场景选择合适的方案才是最佳处理。</p>
<h4 id="1-cornerRadius"><a href="#1-cornerRadius" class="headerlink" title="1.cornerRadius"></a>1.cornerRadius</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Setting <span class="keyword">the</span> radius <span class="keyword">to</span> a value <span class="keyword">greater than</span> <span class="number">0.0</span> causes <span class="keyword">the</span> layer <span class="keyword">to</span> begin drawing rounded corners <span class="keyword">on</span> <span class="keyword">its</span> background. By default, <span class="keyword">the</span> corner radius <span class="keyword">does</span> <span class="keyword">not</span> apply <span class="keyword">to</span> <span class="keyword">the</span> image <span class="keyword">in</span> <span class="keyword">the</span> layer’s <span class="built_in">contents</span> <span class="keyword">property</span>; <span class="keyword">it</span> applies only <span class="keyword">to</span> <span class="keyword">the</span> background color <span class="keyword">and</span> border <span class="keyword">of</span> <span class="keyword">the</span> layer. However, setting <span class="keyword">the</span> masksToBounds <span class="keyword">property</span> <span class="keyword">to</span> YES causes <span class="keyword">the</span> content <span class="keyword">to</span> be clipped <span class="keyword">to</span> <span class="keyword">the</span> rounded corners.</span><br><span class="line">The default value <span class="keyword">of</span> this <span class="keyword">property</span> <span class="keyword">is</span> <span class="number">0.0</span>.</span><br></pre></td></tr></table></figure>
<p>由于cornerRadius只对背景色和边框有效而对layer的contents并不起作用，因此一般都会配合masksToBounds使用。</p>
<p>苹果在iOS9后对cornerRadius+masksToBounds做了优化，当contentMode和backgroundColor为默认值时即：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">imgView.contentMode = <span class="built_in">UIViewContentModeScaleToFill</span>;</span><br><span class="line">imgView.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br></pre></td></tr></table></figure>
<p>不会导致离屏渲染，否则还会离屏渲染，用View Debugging查看UIImageView会有黄色标识。</p>
<p>下面测试下cornerRadius+masksToBounds对FPS的影响。</p>
<p>在iPhone5s,10.3.3上运行一个一屏cell上有36个圆角的Demo，imgView的contentMode和backgroundColor都不使用默认值：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/IMG_0031.PNG" style="zoom:33%;" /></p>
<p>滑动起来依然很顺滑FPS基本在58左右：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/8E0CA66E-8879-4C90-B6D1-5CC0ADC9D9C8.png" style="zoom:50%;" /></p>
<p>可见使用cornerRadius+masksToBounds切圆角对性能的影响并不大。可能在iOS9以前比较影响性能。</p>
<p>该方案最简单，如果页面圆角不多，大可以使用该方案。</p>
<h4 id="2-将原始图片处理为带圆角的图片"><a href="#2-将原始图片处理为带圆角的图片" class="headerlink" title="2.将原始图片处理为带圆角的图片"></a>2.将原始图片处理为带圆角的图片</h4><p>如果说上面是对控件切圆角那么这种办法就是对图片进行切圆角了，该方法不会引起离屏渲染。如果确定是离屏渲染造成性能下降，那么可以使用该方法。</p>
<p>将图片处理为圆角可以在客户端做也可以在服务器端做。</p>
<blockquote>
<p>服务器端处理</p>
</blockquote>
<p>一般在原始图片URL上拼接参数告诉后台要切多大的圆角。</p>
<blockquote>
<p>客户端处理</p>
</blockquote>
<p>如果后台不支持，那只能自己处理了。客户端处理的话一般通过Core Graphics 实现:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)setRoundingCorners:(<span class="built_in">UIRectCorner</span>)corners radius:(<span class="built_in">CGFloat</span>)radius targetSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height);</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:<span class="built_in">CGSizeMake</span>(radius, radius)];</span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</span><br><span class="line">    <span class="built_in">CGContextClip</span>(ctx);</span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    <span class="built_in">CGContextDrawPath</span>(ctx, kCGPathFillStroke);</span><br><span class="line">    <span class="built_in">UIImage</span> *img = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（ps:上述代码虽然给图片加上了圆角，但图片的填充方式是简单填满处理，因此当图片与控件不成比例时会导致图片变形，最好的办法是先等比例缩放原始图片后再调用上述代码添加圆角处理）</p>
<p>这样就将GPU的工作转移给了CPU，因此会对CPU造成一定的负担，可以结合SDWebImage将处理好的图片进行缓存避免每次重复处理。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">           roundingCorners:(<span class="built_in">UIRectCorner</span>)corners</span><br><span class="line">                    radius:(<span class="built_in">CGFloat</span>)radius</span><br><span class="line">                targetSize:(<span class="built_in">CGSize</span>)size</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cachedKey = [<span class="keyword">self</span> getCachedKeyWithURLString:url.absoluteString roundingCorners:corners radius:radius targetSize:size];</span><br><span class="line">    SDImageCacheType cacheType = SDImageCacheTypeNone;</span><br><span class="line">    <span class="built_in">UIImage</span> *cachedImage = [[SDImageCache sharedImageCache] imageFromMemoryCacheForKey:cachedKey];</span><br><span class="line">    <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">        cacheType = SDImageCacheTypeMemory;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cachedImage = [[SDImageCache sharedImageCache] imageFromDiskCacheForKey:cachedKey];</span><br><span class="line">        <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">            cacheType = SDImageCacheTypeDisk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">        <span class="keyword">self</span>.image = cachedImage;</span><br><span class="line">        !completedBlock ?: completedBlock(cachedImage, <span class="literal">nil</span>, cacheType, url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span> sd_setImageWithURL:url placeholderImage:placeholder options:SDWebImageAvoidAutoSetImage context:@&#123;SDWebImageContextStoreCacheType:@(SDImageCacheTypeNone)&#125; progress:<span class="literal">nil</span> completed:^(<span class="built_in">UIImage</span> * _Nullable image, <span class="built_in">NSError</span> * _Nullable error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> * _Nullable imageURL) &#123;</span><br><span class="line">            <span class="built_in">UIImage</span> *transformedImage = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (!error &amp;&amp; image) &#123;</span><br><span class="line">                <span class="built_in">CGSize</span> targetSize = <span class="built_in">CGSizeEqualToSize</span>(size, <span class="built_in">CGSizeZero</span>) ? weakSelf.frame.size : size;</span><br><span class="line">                transformedImage = [image setRoundingCorners:corners radius:radius targetSize:targetSize];</span><br><span class="line">                weakSelf.image = transformedImage;</span><br><span class="line">                [[SDImageCache sharedImageCache] storeImage:transformedImage forKey:cachedKey completion:<span class="literal">nil</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            !completedBlock ?: completedBlock(transformedImage, error, cacheType, imageURL);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)getCachedKeyWithURLString:(<span class="built_in">NSString</span> *)urlString roundingCorners:(<span class="built_in">UIRectCorner</span>)corners radius:(<span class="built_in">CGFloat</span>)radius targetSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cachedKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@?c=%lu&amp;r=%f&amp;w=%f&amp;h=%f&quot;</span>, urlString, (<span class="type">unsigned</span> <span class="type">long</span>)corners, radius, size.width, size.height];</span><br><span class="line">    <span class="keyword">return</span> cachedKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方案较为复杂可以进行一定的封装，如果确定是圆角离屏渲染引起性能问题，可以使用该方案解决。</p>
<h4 id="3-使用特制的圆角切图盖住原始图片"><a href="#3-使用特制的圆角切图盖住原始图片" class="headerlink" title="3.使用特制的圆角切图盖住原始图片"></a>3.使用特制的圆角切图盖住原始图片</h4><p>障眼法，在满足需求和效果的情况下这种方案应该是效率最高的了，既不会产生离屏渲染也不会加重CPU的负担，缺点是应用场景有限。</p>
<h4 id="4-使用一个圆角路径的CAShapeLayer设置mask"><a href="#4-使用一个圆角路径的CAShapeLayer设置mask" class="headerlink" title="4.使用一个圆角路径的CAShapeLayer设置mask"></a>4.使用一个圆角路径的CAShapeLayer设置mask</h4><p>千万不要使用这种方式，会导致离屏渲染而且会明显感觉到卡，性能比cornerRadius+masksToBounds还差：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CAShapeLayer</span> *cornerLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">cornerLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, kImageWH, kImageWH);</span><br><span class="line">cornerLayer.path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, kImageWH, kImageWH) cornerRadius:kImageWH/<span class="number">2.0</span>].CGPath;</span><br><span class="line"><span class="keyword">self</span>.imgView.layer.mask = cornerLayer;</span><br></pre></td></tr></table></figure>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://awhisper.github.io/2016/03/12/滚动圆角卡顿刨根问底/">圆角卡顿刨根问底</a></p>
<p><a href="http://www.cocoachina.com/articles/12873">小心别让圆角成了你列表的帧数杀手</a></p>
<p><a href="https://bestswifter.com/efficient-rounded-corner/">iOS高效添加圆角效果实战讲解</a></p>
<p><a href="https://ronghaopger.github.io/2017/07/iOS优化界面渲染实践中的几点经验/">iOS优化界面渲染实践中的几点经验</a></p>
<p><a href="https://www.kancloud.cn/manual/ios/97828">Instruments使用</a></p>
<p><a href="https://medium.com/@peteliev/diagnose-and-solve-performance-problem-with-xcode-instruments-5c25c27f21d5">Diagnose and solve performance problems with Xcode Instruments</a></p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIImageView</tag>
        <tag>圆角</tag>
      </tags>
  </entry>
  <entry>
    <title>从7日年化收益率到万份收益</title>
    <url>/2019/10/13/%E4%BB%8E7%E6%97%A5%E5%B9%B4%E5%8C%96%E6%94%B6%E7%9B%8A%E7%8E%87%E5%88%B0%E4%B8%87%E4%BB%BD%E6%94%B6%E7%9B%8A/</url>
    <content><![CDATA[<h4 id="一、-7日年化收益率"><a href="#一、-7日年化收益率" class="headerlink" title="一、 7日年化收益率"></a>一、 7日年化收益率</h4><p>今天早上被一条支付宝的通知吵醒,点进去一看发现是有新的花呗账单需要偿还了,还完花呗,刷了一下余额宝,提示昨日收益0.16元,七日年化2.3280%.7日年化?怎么这么熟悉但是细细一想却又不知道到底是什么东西,这让我感到难受.看来有必要了解一下7日年化收益率究竟是什么东西?</p>
<p>不过一上来就讲7日年化收益率略显深奥,还是先来看一下收益率是什么?</p>
<p>大家都知道<code>收益率 = 收益 / 本金</code>.即本金在一段时间后获得的收益除以本金.收益率可以用来衡量一个理财产品的好坏.收益率越高代表到期后获得的收益也越多.</p>
<p>年收益率就是本金在一年以后获得的收益除以本金得到的一个比值.比如银行某个定期理财产品承诺存满一年将获得4%的年收益率.那么你存10000元,到年底的时候取出来将获得10000 x 4%=400元的总收益.</p>
<p>与其对应的是日收益率,即本金在一天后获得的收益除以本金.还是上面的例子,10000元存满一年获得400元收益,那么存一天获得的收益为400 / 365 ≈ 1.0959元.于是R<sub>d</sub> = 1.0959 / 10000 = 0.010959% = 4% / 365.</p>
<p>因此很容易得出日收益率与年收益率存在以下关系:</p>
<p>R<sub>d</sub> x 365 = R<sub>y</sub></p>
<p>R<sub>d</sub> x 365就表示将日收益率进行年化,得到的结果R<sub>y</sub>就是年化收益率.如果你能保证以后的日收益率都是这么多,那R<sub>y</sub>就是年收益率了,但对于基金来说它每天的收益率是在不断变化的,所以只能称为年化收益率.</p>
<p>OK,前戏的部分终于讲完了,现在开始正式进入主题.</p>
<p>7日年化收益率其实是说过去七天货币基金的平均收益率.举个例子,10月11日显示的余额宝七日年化收益率是2.3280%,是指10月4日-10月10日过去这七天的平均年化收益率.即这7天的总收益除以7得到平均每天的收益,也就是平均日收益,那么平均日收益率 = 平均日收益 / 本金.接下来就是把它年化一下,根据上面的公式可得七日年化收益率 = 平均日收益率 x 365 = 7天的总收益 / 7 / 本金 x 365.</p>
<p>让我们再深入一点:</p>
<p>假设m为本金,存n天后获得的总收益为i.那么n日年化收益率计算如下:</p>
<p>先计算日收益率R<sub>d</sub> = i / n / m,</p>
<p>再年化得到年化收益率R<sub>y</sub> = R<sub>d</sub> x 365 = i / n / m x 365.</p>
<p>n为7则R<sub>y</sub>就表示7日年化收益率.<br>n为15则R<sub>y</sub>就表示15日年化收益率.<br>n为30则R<sub>y</sub>就表示30日年化收益率.<br>…<br>n为365则R<sub>y</sub>就表示365日年化收益率.<br>n越大表明该理财产品过去的收益越平稳.值得注意的是不管n为多大它都不能预示未来也会这样平稳,只能说可能性会更高一点.因为它只代表过去是这样,和银行的定期理财承诺4%是不一样的.</p>
<p>一只基金它的7日年化收益率和30日年化收益率可能不相等,大多数情况下也不会相等,如果30日年化收益率大于7日年化收益率说明该基金近期在下跌.反之在上涨.</p>
<p>接下来我们计算一下,一个基金的年化收益率要多少才能”保证”10000元1天能够有1元的收益,这应该才是大伙关注的.</p>
<p>有了上面的公式,这都不叫事.先算日收益率</p>
<p>R<sub>d</sub> = 1 / 10000,</p>
<p>再年化一下</p>
<p>R<sub>y</sub> = R<sub>d</sub> x 365 = 3.65%.</p>
<p>即一个基金的年化收益率要3.65%才能”保证”10000元1天能够有1元的收益.我们再来看一下余额宝借呗,它显示日利率万3也就是借1万元用一天要还3元.我们可以算一下放贷方的年化收益率 = 3 / 10000 x 365 = 3 x 3.65% = 10.95%.差不多11%的年化收益率.试问现在还能找到几个超过4%的<strong>稳健</strong>基金,可见放贷真的是暴利,借贷需谨慎啊!</p>
<h4 id="二、-万份收益"><a href="#二、-万份收益" class="headerlink" title="二、 万份收益"></a>二、 万份收益</h4><p>万份收益是指货币基金1万块钱1天的收益.一般在余额宝看到的万份收益是1万块钱放在余额宝里昨天一天所得的收益,不是今天的收益.</p>
<p>万份收益与7日年化收益率有什么关系呢?</p>
<p>先说结论:根据7日年化收益率计算出的万份收益其实是期望万份收益并不等于(实际)万份收益.</p>
<blockquote>
<p>声明:以下的万份收益和7日年化收益率都是指昨日的,因为今日的万份收益与7日年化收益率在没收市之前是无法知道的,今天可能涨,跌也可能持平.</p>
</blockquote>
<p>举个例子:</p>
<p>10月11日余额宝显示的七日年化收益率是2.3280%(即10月10日的7日年化收益率为2.3280%),我们可以算一下在这个收益率下10000元1天只能得到2.3280% / 365 * 10000 = 0.6378元.如果你还记得10000元1天能够有1元的收益,年化收益率为3.65%的话,你可以以这个为基准快速计算上面的结果2.3280% / 3.65% = 0.6378元,即为10月10日的”万份收益”.不过我们会发现余额宝实际显示的10月10日万份收益为0.6266元,相差0.0112元.</p>
<p>为什么会相差0.0112呢?</p>
<p>除了计算精度影响外,还有没有其他原因呢?我们可以算一下10月10日的1日年化收益率= 0.6266 x 3.65% = 2.2871% &lt; 2.3280%,说明前六天的比10月10日的要高,平均下来后计算出10月10日的七日年化收益率比当天的年化收益率要高,这说明余额宝对应的基金其实是在下跌.因此另一个原因就是10月10日的日收益率低于前几天的日收益率,基金在下跌.</p>
<p>这说明了根据7日年化收益率计算出的万份收益其实是期望万份收益并不等于(实际)万份收益.</p>
<p>引申一下可以得出以下结论:</p>
<ol>
<li>昨日的年化收益率可以大于、等于、小于昨日的7日年化收益率.大于说明基金昨日涨了,反之说明跌了.</li>
<li>昨日的万份收益可以大于、等于、小于以昨日的7日年化收益率计算出的万份收益(个人把它叫做期望万份收益,反正我就这么叫了).</li>
<li>基金的年化收益率只表明过去的收益情况,并不保证未来的收益.因此基金才有各种风险等级,风险越低的基金说明它很稳你基本上可以确定根据7日年化收益率计算出的收益就是明天的收益.反之风险越高,那它的7日年化收益率就真的只能参考了.所以不能盲目看年化收益率也要看一下风险等级.</li>
</ol>
<p>写到这里终于结束了,不经意间一缕阳光悄悄的穿过树叶的缝隙洒落在书桌上,心里也不再难受,但看着余额宝昨日的收益,似乎感觉到前面的路依然充满荆棘.</p>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
  </entry>
  <entry>
    <title>买基实践总结</title>
    <url>/2020/05/01/%E4%B9%B0%E5%9F%BA%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>之前买了个基金：天添金稳健型，刚开始觉得还挺不错的。但几天过后才发现并不是那么划算，今天就来分析一下：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/IMG_2655.jpg" style="zoom:50%;" /></p>
<p>成立以来年化4.53%，购买费率0，赎回费率:持有<360日则0.1%，>=360日则0.05%。即使减去0.1%的赎回费率，也有4.43%，看起来挺不错的。</p>
<p>实际上4.53%是成立以来年化，它的近三年的累计收益率为13.38%，平均每年为4.46%小于成立以来的4.53%，说明该基金没以前那么好了，走势有下降的趋势。再看一下近1年累计收益率只有3.8%，减去手续费0.05%，就只有3.75%了。也就是你放一年只有3.75%的收益率，这个收益率其实还稍稍低于其他的定期基金。虽然写着随时申赎但是如果没满一年的话是很亏的。</p>
<p>比如只持有1个月那么你的月收益率为3.8% / 12 = 0.3167%，再扣除0.1%的赎回费率那么就只有0.2167%。年化一下就是2.6%，已经非常低了。如果你只持有10天，那么收益刚好抵消手续费，你被白嫖。如果小于10天那就是在亏钱了。</p>
<p>所以这里的随时申赎其实就是一个诱饵，如果不加分析很容易上钩。当然也不是说该基金在骗人，而是不划算。想要达到它说的4.53%，以R2较低风险来看，基本上要长期持有3年左右。说是随时申赎实际上是不能“随时申赎”的。</p>
<p>上述的分析告诉了我们：</p>
<p>1.买基金不能只看成立以来的年化，要看走势图里的1月，3月，1年，3年。</p>
<p>2.有手续费的基金如果收益率不高的话就不要买了。就像上面的基金满一年扣除手续费后还不如定期的基金了。</p>
<p>个人将年化3.65%作为一个参考值，也就是1万元1天收益1元。</p>
<p>则月收益率为：3.65% / 12 = 0.3% </p>
<p>日收益率为：3.65% / 365 = 0.01%，日收益率平均需要0.01%，年化才有3.65%。</p>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>买基总结</tag>
      </tags>
  </entry>
  <entry>
    <title>基金常见概念</title>
    <url>/2020/05/01/%E5%9F%BA%E9%87%91%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p><strong>基金的一些概念</strong></p>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/5C9E117C940FCD96FFFDB344982570E9.png" style="zoom:25%;" /></p>
<p><strong>日涨幅</strong></p>
<p>（当日净值 - 昨日净值）/ 昨日净值 x 100%</p>
<p>比如要计算4.30的日涨幅，那么当日净值需要取4.30的净值，昨日净值取的就是4.29的净值。</p>
<p>eg:</p>
<p>4月29日的单位净值为1.8470，4月30日的单位净值为1.8450，这样4月30日的日涨幅就是：</p>
<p>（1.8450 - 1.8470）/ 1.8470 x 100% = -0.108284% ≈ -0.11%，负数说明亏了。</p>
<p><strong>昨日收益</strong></p>
<p>特别注意，今天看到的收益其实是昨日的收益。今天都没结束所以你是没办法看到今天的收益的。仔细品一下这里面的代词。比如这里5月1日看到的就是4月30日的收益。</p>
<p>昨日收益 =（当日净值 - 昨日净值）x 份额。这里的昨日净值相对的是当日净值，平时生活里我们说昨日默认相对的是今天。</p>
<p>这样4月30日的收益 =（4.30的净值 - 4.29的净值）x 份额 =（1.8450 - 1.8470）x 544.67 = -1.089。</p>
<p>根据日涨幅和当日净值的关系也可以得出昨日收益的另一种计算：</p>
<p>昨日收益  = 昨日净值  x 日涨幅 x 份额 </p>
<p>这样4月30日的收益 =  4.29的净值 x 4.30的日涨幅 x 份额 = 1.8470  x -0.11% x 544.67 = -1.1066，与-1.089有出入是因为日涨幅的精度问题。</p>
<p><strong>持仓成本价</strong></p>
<p>即购买当天的单位净值。</p>
<p><strong>份额</strong></p>
<p>购买基金的本金 / 购买当天的单位净值。</p>
<p>这里涉及到基金交易的时间点，每日的15:00前买入/卖出的则单位净值为当日的单位净值。否则为下一日的单位净值。所以在买入卖出时要注意一下。</p>
<p><strong>持仓收益</strong></p>
<p>（最新净值 - 持仓成本价）x 份额</p>
<p><strong>基金的历史收益率</strong></p>
<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/RPReplay_Final1588308124.gif" alt=""></p>
<p>有近1个月，近3个月，近1年，成立以来。</p>
<p>这个历史收益率（余额宝中称为业绩走势，其实都是同一个东西）是每日收益率累加的结果。</p>
<p>近1个月，近3个月，近1年，成立以来这些都指的是累计多久，比如近1个月的历史收益率，这里就是3.30-4.30这一段时间，那么就以3.30为基准0%开始累加。3.30-4.30这一段时间的每日收益率累加之后就是近1个月的历史收益率。这就是为什么某几天都在亏钱，但业绩走势显示的本基金还是+1.07%。如果你查看业绩走势中的每个点，就会发现亏钱的那天的值是比它之前的值要小的。</p>
<p>看那个历史收益率，这个基金要是能长期持有收益率还是挺不错的，14年累计398.91%的收益率，平均每年为28.5%还是挺可观的。虽然跟股票没法比，但是股票的风险就太大了。</p>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>基金概念</tag>
      </tags>
  </entry>
  <entry>
    <title>制作CocoaPods私有库</title>
    <url>/2020/04/15/%E5%88%B6%E4%BD%9CCocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/</url>
    <content><![CDATA[<p><strong>1. 创建私有pod spec仓库</strong></p>
<p>因为制作的是私有库所以就不能把pod sepc文件存放到cocoapods的公开仓库中了，因此需要在GitHub上新建一个repository <code>XQSpecs</code>用于保存所有的私有pod spec。</p>
<p>如果已经有自己的私有pod spec仓库，则这一步可跳过。</p>
<p><strong>2. 创建私有pod库</strong></p>
<p>主要包含pod源码和pod sepc文件、许可证等。</p>
<p>创建pod库,可以使用命令：<code>pod lib create xxx</code>，创建好模板pod，然后基于模板修改。也可以全部自己手动创建。</p>
<p>进入本地目的目录，使用命令：<code>pod lib create xxx</code>，然后基于模板修改。</p>
<p><strong>3. 验证pod库</strong></p>
<p>pod源码和pod sepc文件都准备好后，别着急发布，先验证pod库的可用性:</p>
<p><code>pod lib lint xxx.podspec</code>或者使用：<code>pod lib lint AlgorithmUtils.podspec --allow-warnings</code>，忽略警告。</p>
<p><strong>4. 提交pod到GitHub，并打tag</strong></p>
<p>在GitHub上新建一个repository用于保存pod.</p>
<p>创建完成后，回到本地pod目录执行：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> remote <span class="keyword">add</span> origin https:<span class="comment">//github.com/xq-120/AlgorithmUtils.git</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push</span> -u origin master</span><br></pre></td></tr></table></figure>
<p>将已存在的本地git目录关联到远程地址。</p>
<p>提交代码到远程：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git commit -a -m <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>
<p>打tag并推送到远程:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> tag <span class="number">0</span>.<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">git</span> push origin <span class="number">0</span>.<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>5. 发布</strong></p>
<p>如果本地还没有刚创建的pod spec私有仓库，那么需要执行：</p>
<p><code>pod repo add XQSpecs https://github.com/xq-120/XQSpecs.git</code></p>
<p>在本地生成XQSpecs目录。</p>
<p>发布pod:</p>
<p><code>pod repo push XQSpecs xxx.podspec</code></p>
<p>将.podspec文件推送到pod spec仓库中，成功之后就可以在其他项目里使用该pod了。</p>
<p><strong>6. 使用</strong></p>
<p>在其他项目使用：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/xq-120/XQSpecs.git&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">platform</span> :ios,<span class="string">&#x27;10.0&#x27;</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;adsad&#x27;</span> <span class="keyword">do</span></span><br><span class="line">   pod <span class="string">&#x27;AlgorithmUtils&#x27;</span>, <span class="string">&#x27;~&gt; 0.1.0&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>7. 升级</strong><br>如果新增了功能或修复了某个bug，这个时候就需要升级pod版本并发布。这个过程基本上是重复上述步骤。</p>
<ul>
<li>pod新增功能源码变动，更改pod sepc里的pod版本</li>
<li>最好再验证一下pod库</li>
<li>提交pod到GitHub，并打tag</li>
<li>发布。<code>pod repo push XQSpecs xxx.podspec</code></li>
</ul>
<p>如果pod修改频繁，就需要频繁升级版本，这无疑非常麻烦，因此可以直接指定git路径和branch，这样就可以避免每次修改后都需要升级版本了：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/xq-120/XQSpecs.git&#x27;</span></span><br><span class="line"></span><br><span class="line">platform :ios,<span class="string">&#x27;10.0&#x27;</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;adsad&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">   pod <span class="string">&#x27;AlgorithmUtils&#x27;</span>, :<span class="function"><span class="params">git</span> =&gt;</span> <span class="string">&#x27;https://github.com/xq-120/AlgorithmUtils.git&#x27;</span>, :<span class="function"><span class="params">branch</span> =&gt;</span> <span class="string">&#x27;master&#x27;</span></span><br><span class="line">     </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>还有一种操作：</p>
<ul>
<li><p>修改源码提交后，删除原来tag</p>
</li>
<li><p>在新的提交记录上打tag（tag名称和之前一样）</p>
</li>
<li><p>进入本地<code>~/Library/Caches/CocoaPods/Pods/Release</code>找到之前下载缓存的pod源码删除</p>
</li>
<li>进入Xcode工程编辑Podfile文件注释掉pod，执行pod install，再放开注释pod，执行pod install（即重新安装pod）</li>
</ul>
<p>相关阅读：<a href="https://xq-120.github.io/2020/04/16/%E5%88%B6%E4%BD%9CCocoaPods%E5%85%AC%E5%BC%80%E5%BA%93/#more">制作CocoaPods公开库</a></p>
<p>参考：<a href="https://juejin.im/post/5accdbc86fb9a028ca534f2e">如何制作一个CocoaPods私有库</a></p>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>私有库</tag>
      </tags>
  </entry>
  <entry>
    <title>UITableView性能优化总结</title>
    <url>/2020/04/16/UITableView%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>计算机最宝贵的资源就是CPU和内存，因此所谓的优化其实就是在”空间”和”时间”之间权衡。以空间换取更短的时间响应，表现在可能会增加额外的内存开销如：cell的重用、高度的缓存甚至布局的缓存等。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="1-cell的重用"><a href="#1-cell的重用" class="headerlink" title="1.cell的重用"></a>1.cell的重用</h4><p>注意重用可能导致的数据错乱问题。</p>
<p>参考：<a href="https://xq-120.github.io/2016/04/24/UITableViewCell%E9%87%8D%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%9B%BE%E7%89%87%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98/">UITableViewCell重用导致的图片错乱问题</a></p>
<h4 id="2-提前计算好cell的高度并且缓存起来"><a href="#2-提前计算好cell的高度并且缓存起来" class="headerlink" title="2.提前计算好cell的高度并且缓存起来"></a>2.提前计算好cell的高度并且缓存起来</h4><p>UITableView代理方法的执行顺序：<br>系统会先调用numberOfRowsInSection来获取cell的行数,然后再多次(和numberOfRow正相关)调用heightForRow来确定contentSize及cell的位置,最后才会调用cellForRow显示当前屏幕的cell. </p>
<p>由于heightForRow会频繁的调用,因此该方法里一定不要进行大量重复的计算.所以cell的高度需要进行缓存,然后在heightForRow方法中直接返回.可采用的策略:网络请求完成后就计算好每个cell的高度,并缓存到对应的model中.更有甚者会在此时连cell的子视图布局都计算好.</p>
<p>cell的高度计算与缓存时效问题？</p>
<h4 id="3-避免阻塞主线程"><a href="#3-避免阻塞主线程" class="headerlink" title="3.避免阻塞主线程"></a>3.避免阻塞主线程</h4><p>比如图片的下载，图片的处理等其他耗时操作应该放在子线程执行，如果可以应该缓存起来。</p>
<h4 id="4-按需加载"><a href="#4-按需加载" class="headerlink" title="4.按需加载"></a>4.按需加载</h4><p>比如还在滚动时,不去加载显示图片.当滚动停止时才加载显示图片.这种方式在滚动时会看不到图片,因此需要结合实际需求使用.</p>
<h4 id="5-不要动态的add或remove子控件"><a href="#5-不要动态的add或remove子控件" class="headerlink" title="5.不要动态的add或remove子控件"></a>5.不要动态的add或remove子控件</h4><p>子控件最好在初始化时就添加完成,可采用hidden来控制是否显示。复杂的cell可以采用<a href="https://github.com/Instagram/IGListKit">IGListKit</a>，而不是各种remake约束。</p>
<h4 id="6-尽可能重用创建时开销比较大的对象"><a href="#6-尽可能重用创建时开销比较大的对象" class="headerlink" title="6.尽可能重用创建时开销比较大的对象"></a>6.尽可能重用创建时开销比较大的对象</h4><p>比如NSDateFormatter和NSCalendar等对象.这些对象初始化非常的慢,我们可以把它们加入到类的属性当中,或者创建单例来使用.</p>
<h4 id="7-注意避免离屏渲染"><a href="#7-注意避免离屏渲染" class="headerlink" title="7.注意避免离屏渲染"></a>7.注意避免离屏渲染</h4><p><strong>什么是离屏渲染</strong></p>
<p>GPU渲染机制：</p>
<p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据传递给显示器显示。</p>
<p>GPU屏幕渲染有以下两种方式：</p>
<p>On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>
<p>Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>
<p><strong>为什么会出现离屏渲染</strong></p>
<p>因为有些效果不能直接在当前屏幕渲染，所以需要有离屏渲染。貌似是废话。为什么圆角，阴影，遮罩等效果不能直接在当前屏幕渲染？</p>
<p><strong>离屏渲染代价</strong></p>
<p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>
<ul>
<li>创建新缓冲区</li>
</ul>
<p>要想进行离屏渲染，首先要创建一个新的缓冲区。</p>
<ul>
<li>上下文切换</li>
</ul>
<p>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p>
<p><strong>引起离屏渲染的因素</strong></p>
<ol>
<li><p>使用了Core Graphics里的方法.(任何CG开头的类)</p>
</li>
<li><p>重写了- drawRect方法，即使是空实现。</p>
</li>
<li><p>设置CALayers的以下属性：</p>
<p>光栅化</p>
<p><code>@property BOOL shouldRasterize;</code> //shouldRasterize属性设置为YES.</p>
<p>遮罩</p>
<p><code>@property(nullable, strong) CALayer *mask;</code> //遮罩相关</p>
<p>阴影(shadow)</p>
<p><code>@property(nullable) CGColorRef shadowColor;</code>等</p>
<p>抗锯齿</p>
<p><code>@property CAEdgeAntialiasingMask edgeAntialiasingMask;</code> //边缘抗锯齿遮罩 </p>
<p>组不透明（Group opacity）<br><code>@property BOOL allowsGroupOpacity;</code></p>
</li>
<li><p>cornerRadius和maskToBounds=YES结合使用实现圆角.<br>注：layer.cornerRadius，layer.borderWidth，layer.borderColor并不会发生Offscreen Render，因为这些不需要加入Mask。设置圆角只需要设置cornerRadius的值,但是由于cornerRadius只对背景颜色和layer的border起作用,而不会对layer里的内容起作用,所以一般才需要和masksToBounds配合使用.它们独立作用的时候不会引起离屏渲染。</p>
</li>
</ol>
<p>为了避免离屏渲染，对于圆角效果，我们可以将图片裁剪为圆形再显示。</p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/aa8dc1a61c91">为什么产生离屏渲染</a></p>
<p><a href="https://juejin.im/post/5d732ea96fb9a06b2d77f76a">OpenGL 图片从文件渲染到屏幕的过程</a></p>
<p><a href="http://imgtec.eetrend.com/d6-imgtec/blog/2018-08/17019.html">GPU屏幕渲染——离屏渲染</a></p>
<p><a href="https://xq-120.github.io/2020/04/07/iOS%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/">iOS设置圆角</a></p>
<h4 id="8-注意避免图层混合"><a href="#8-注意避免图层混合" class="headerlink" title="8.注意避免图层混合"></a>8.注意避免图层混合</h4><p><strong>什么是图层混合</strong></p>
<p>如果屏幕的一块区域上有多个图层（layer），每个图层都会有一定的透明度，那么最后这块区域的显示效果就是这些图层共同作用的结果，这种结果需要cpu对每个图层的颜色进行计算，需要消耗更多的cpu资源。如果我们把最上层的layer设定为不透明，那么cpu就不需要计算底层的layer的色值，这样就可以节约cpu的计算量，节约资源。</p>
<p><strong>应对措施</strong></p>
<ol>
<li>确保控件的opaque属性设置为true，确保backgroundColor不透明.关于backgroundColor说明:The default value is nil, which results in a transparent background color.  常见的就是把UILabel的背景色设置为白色（颜色根据场景需要）。</li>
<li>如无特殊需要，不要设置低于1的alpha值.  </li>
<li>确保UIImage没有alpha通道.  </li>
</ol>
<p>参考：<a href="https://www.jianshu.com/p/b8ee7a40e219">ios性能优化—label上汉字图层混合问题</a></p>
<h4 id="9-异步绘制"><a href="#9-异步绘制" class="headerlink" title="9.异步绘制"></a>9.异步绘制</h4><p>适合纯代码的开发.使用AsyncDisplayKit等异步绘制框架。极限优化可以尝试一下。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/facebookarchive/AsyncDisplayKit">AsyncDisplayKit</a></p>
<p><a href="https://github.com/ibireme/YYText">YYText</a></p>
<p><a href="https://medium.com/jike-engineering/asyncdisplaykit%E4%BB%8B%E7%BB%8D-%E4%B8%80-6b871d29e005">AsyncDisplayKit介绍（一）原理和思路</a></p>
]]></content>
      <categories>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title>OC反射+多态调用类方法</title>
    <url>/2020/03/06/OC%E5%8F%8D%E5%B0%84+%E5%A4%9A%E6%80%81%E8%B0%83%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态指的是允许父类的指针指向子类的对象,当指针指向不同的子类对象时,给它发送同一个消息就会有不同的响应.</p>
<p>如下定义一个父类Animal和二个子类Dog,Cat.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)bark;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)canClimb:(<span class="type">void</span>(^)(<span class="type">BOOL</span> can))blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ run&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)bark &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ bark&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)canClimb:(<span class="type">void</span> (^)(<span class="type">BOOL</span>))blk &#123;</span><br><span class="line">    !blk ?: blk(<span class="literal">NO</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ run&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)bark &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ bark&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)canClimb:(<span class="type">void</span> (^)(<span class="type">BOOL</span>))blk &#123;</span><br><span class="line">    !blk ?: blk(<span class="literal">NO</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Cat</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ run&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)bark &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ bark&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)canClimb:(<span class="type">void</span> (^)(<span class="type">BOOL</span>))blk &#123;</span><br><span class="line">    !blk ?: blk(<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>接下来我们来个反射+多态:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *clsArr = @[<span class="string">@&quot;Animal&quot;</span>, <span class="string">@&quot;Dog&quot;</span>, <span class="string">@&quot;Cat&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *clsStr <span class="keyword">in</span> clsArr) &#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(clsStr);</span><br><span class="line">    <span class="type">id</span> obj = [cls new];</span><br><span class="line">    [obj run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *clsStr <span class="keyword">in</span> clsArr) &#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(clsStr);</span><br><span class="line">    [cls performSelector:<span class="keyword">@selector</span>(bark)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动写全</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *clsStr <span class="keyword">in</span> clsArr) &#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(clsStr);</span><br><span class="line">    [cls canClimb:^(<span class="type">BOOL</span> can)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ can climb:%d&quot;</span>,cls, can);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用performSelector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *clsStr <span class="keyword">in</span> clsArr) &#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(clsStr);</span><br><span class="line">    [cls performSelector:<span class="keyword">@selector</span>(canClimb:) withObject:^(<span class="type">BOOL</span> can)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ can climb:%d&quot;</span>,cls, can);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上需要注意的是:</p>
<p>Xcode对于id类型调用实例方法,实例方法会有补全提示.对于Class类型调用类方法,类方法就没有补全提示,但你写全后也不会报错.</p>
<p>对于类方法的动态调用可以使用<code>performSelector</code>,也可以手动写全,这里Xcode不会自动补全不知道为什么.</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
  </entry>
  <entry>
    <title>制作CocoaPods公开库</title>
    <url>/2020/04/16/%E5%88%B6%E4%BD%9CCocoaPods%E5%85%AC%E5%BC%80%E5%BA%93/</url>
    <content><![CDATA[<p><strong>1. 创建要公开的pod库</strong></p>
<p>主要包含pod源码和pod sepc文件、许可证等。</p>
<p>这个过程可以先在本地创建好，再到GitHub创建对应的仓库，然后将本地pod添加到远程仓库。</p>
<p>也可以先在GitHub创建好仓库，再clone到本地，然后在clone的目录下创建pod。</p>
<p>pod sepc文件的说明可以参考：</p>
<p><a href="https://www.jianshu.com/p/75e19c92df50">CocoaPods 系列之三 Podspec 语法说明</a></p>
<p><a href="https://cocoapods.org/">cocoapods官网文档</a> </p>
<p><a href="https://guides.cocoapods.org/syntax/podspec.html">Podspec Syntax Reference</a></p>
<p>创建sepc文件：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">pod <span class="keyword">spec</span> create 库名</span><br></pre></td></tr></table></figure>
<p>示例sepc文件如下:</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Be sure to run `pod spec lint Peanut.podspec&#x27; to ensure this is a</span></span><br><span class="line"><span class="comment">#  valid spec and to remove all comments including this before submitting the spec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  To learn more about Podspec attributes see https://guides.cocoapods.org/syntax/podspec.html</span></span><br><span class="line"><span class="comment">#  To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">Pod::Spec</span>.new do |spec|</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  These will help people to find your library, and whilst it</span></span><br><span class="line">  <span class="comment">#  can feel like a chore to fill in it&#x27;s definitely to your advantage. The</span></span><br><span class="line">  <span class="comment">#  summary should be tweet-length, and the description more in depth.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  spec.<span class="keyword">name</span>         = <span class="string">&quot;Peanut&quot;</span></span><br><span class="line">  spec.version      = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line">  spec.summary      = <span class="string">&quot;A short description of Peanut.&quot;</span></span><br><span class="line">  spec.homepage     = <span class="string">&quot;http://EXAMPLE/Peanut&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Licensing your code is important. See https://choosealicense.com for more info.</span></span><br><span class="line">  <span class="comment">#  CocoaPods will detect a license file if there is a named LICENSE*</span></span><br><span class="line">  <span class="comment">#  Popular ones are &#x27;MIT&#x27;, &#x27;BSD&#x27; and &#x27;Apache License, Version 2.0&#x27;.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  spec.<span class="literal">license</span>      = &#123; :type =&gt; <span class="string">&quot;MIT&quot;</span>, :<span class="keyword">file</span> =&gt; <span class="string">&quot;LICENSE&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Specify the authors of the library, with email addresses. Email addresses</span></span><br><span class="line">  <span class="comment">#  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also</span></span><br><span class="line">  <span class="comment">#  accepts just a name if you&#x27;d rather not provide an email address.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Specify a social_media_url where others can refer to, for example a twitter</span></span><br><span class="line">  <span class="comment">#  profile URL.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  spec.author             = &#123; <span class="string">&quot;mt&quot;</span> =&gt; <span class="string">&quot;邮箱&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  If this Pod runs only on iOS or OS X, then specify the platform and</span></span><br><span class="line">  <span class="comment">#  the deployment target. You can optionally include the target after the platform.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  spec.platform     = :ios, <span class="string">&quot;10.0&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Specify the location from where the source should be retrieved.</span></span><br><span class="line">  <span class="comment">#  Supports git, hg, bzr, svn and HTTP.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  spec.source       = &#123; :git =&gt; <span class="string">&quot;http://EXAMPLE/Peanut.git&quot;</span>, :tag =&gt; <span class="string">&quot;#&#123;spec.version&#125;&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  CocoaPods is smart about how it includes source code. For source files</span></span><br><span class="line">  <span class="comment">#  giving a folder will include any swift, h, m, mm, c &amp; cpp files.</span></span><br><span class="line">  <span class="comment">#  For header files it will include any header in the folder.</span></span><br><span class="line">  <span class="comment">#  Not including the public_header_files will make all headers public.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  spec.source_files  = <span class="string">&quot;Peanut/Classes/**/*&quot;</span></span><br><span class="line">  <span class="comment"># spec.exclude_files = &quot;Classes/Exclude&quot;</span></span><br><span class="line">  <span class="comment"># spec.public_header_files = &quot;Classes/**/*.h&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  A list of resources included with the Pod. These are copied into the</span></span><br><span class="line">  <span class="comment">#  target bundle with a build phase script. Anything else will be cleaned.</span></span><br><span class="line">  <span class="comment">#  You can preserve files from being cleaned, please don&#x27;t preserve</span></span><br><span class="line">  <span class="comment">#  non-essential files like tests, examples and documentation.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  spec.resources = <span class="string">&quot;Resources/*&quot;</span></span><br><span class="line">  <span class="comment"># spec.preserve_paths = &quot;FilesToSave&quot;, &quot;MoreFilesToSave&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Link your library with frameworks, or libraries. Libraries do not include</span></span><br><span class="line">  <span class="comment">#  the lib prefix of their name.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  spec.frameworks = <span class="string">&quot;Foundation&quot;</span>, <span class="string">&quot;UIKit&quot;</span></span><br><span class="line">  <span class="comment"># spec.libraries = &quot;iconv&quot;, &quot;xml2&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  If your library depends on compiler flags you can set them in the xcconfig hash</span></span><br><span class="line">  <span class="comment">#  where they will only apply to your library. If you depend on other Podspecs</span></span><br><span class="line">  <span class="comment">#  you can include multiple dependencies to ensure it works.</span></span><br><span class="line"></span><br><span class="line">  spec.requires_arc = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># spec.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125;</span></span><br><span class="line">  <span class="comment"># spec.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>看上面的注释很容易看懂。</p>
<p><strong>2. 验证pod库</strong></p>
<p>pod源码和pod sepc文件都准备好后，别着急发布，先验证pod库的可用性:</p>
<p><code>pod spec lint xxx.podsepc</code></p>
<p>验证库坑:</p>
<p><code>pod spec lint name.podsepc</code></p>
<p>一直提示:CDN: trunk URL couldn’t be downloaded</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">-&gt; XQSheet (<span class="number">2.0</span>.<span class="number">0</span>)</span><br><span class="line">   - <span class="literal">ERROR</span> | [iOS] unknown: Encountered an unknown <span class="literal">error</span> (CDN: trunk URL couldn<span class="symbol">&#x27;t</span> be downloaded: https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/<span class="number">4</span>/<span class="number">2</span>/<span class="number">1</span>/JKPresentationController/<span class="number">1.0</span>.<span class="number">0</span>/JKPresentationController.podspec.json, <span class="literal">error</span>: Failed <span class="keyword">to</span> <span class="keyword">open</span> TCP connection <span class="keyword">to</span> raw.githubusercontent.com:<span class="number">443</span> (Connection refused - connect(<span class="number">2</span>) <span class="keyword">for</span> <span class="string">&quot;raw.githubusercontent.com&quot;</span> <span class="keyword">port</span> <span class="number">443</span>)) during validation.</span><br></pre></td></tr></table></figure>
<p>解决办法：指定source。</p>
<p><code>pod spec lint name.podsepc --sources=&#39;https://github.com/CocoaPods/Specs.git&#39;</code></p>
<p>允许警告可以添加：—allow-warnings</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">pod spec lint GSDMediaCache<span class="selector-class">.podspec</span> <span class="attr">--allow-warnings</span></span><br></pre></td></tr></table></figure>
<p>如果使用pod还依赖了第三方库则还需要添加—use-libraries：表示使用静态库或者是framework，这里主要是解决当我们依赖一些framework库后校验提示找不到库的时候用到。</p>
<p>eg:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">pod spec lint GSDMediaCache<span class="selector-class">.podspec</span> <span class="attr">--allow-warnings</span> <span class="attr">--use-libraries</span></span><br></pre></td></tr></table></figure>
<p><strong>3.提交pod到GitHub，并打tag</strong></p>
<p>这个就是平时开发提交代码，打tag。</p>
<p>前面这几步和制作私有库是一样的都是准备工作。</p>
<p><strong>4. 发布</strong></p>
<p>要想发布一个公开库，需要先注册一个 CocoaPods 账号。</p>
<p>查看有没有注册过：</p>
<p><code>pod trunk me</code></p>
<p>如果没有那么先注册：</p>
<p><code>pod trunk register EMAIL [NAME]</code></p>
<p>eg:</p>
<p><code>pod trunk register orta@cocoapods.org &#39;Orta Therox&#39; --description=&#39;macbook air&#39;</code></p>
<p>注册好后，开始发布，使用命令：</p>
<p><code>pod trunk push xxx.podspec</code></p>
<p>将pod spec文件推送到cocoapods的官方仓库，这样别人才能找得到。</p>
<p>注意：pod trunk push也会验证库，所以上面预验证的参数还得加：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">pod trunk push GSDMediaCache<span class="selector-class">.podspec</span> <span class="attr">--allow-warnings</span> <span class="attr">--use-libraries</span></span><br></pre></td></tr></table></figure>
<p>推送库坑:</p>
<p><code>pod trunk push XQSheet.podspec</code></p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">Updating spec repo `trunk`</span><br><span class="line"></span><br><span class="line">CocoaPods <span class="number">1.9</span>.<span class="number">1</span> <span class="keyword">is</span> available.</span><br><span class="line"><span class="keyword">To</span> update <span class="keyword">use</span>: `sudo gem install cocoapods`</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information, see https://blog.cocoapods.org <span class="keyword">and</span> the CHANGELOG <span class="keyword">for</span> this version at https://github.com/CocoaPods/CocoaPods/releases/tag/<span class="number">1.9</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Validating podspec</span><br><span class="line"> -&gt; XQSheet (<span class="number">2.0</span>.<span class="number">0</span>)</span><br><span class="line">    - <span class="literal">ERROR</span> | [iOS] unknown: Encountered an unknown <span class="literal">error</span> (CDN: trunk URL couldn<span class="symbol">&#x27;t</span> be downloaded: https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/<span class="number">4</span>/<span class="number">2</span>/<span class="number">1</span>/JKPresentationController/<span class="number">1.0</span>.<span class="number">0</span>/JKPresentationController.podspec.json, <span class="literal">error</span>: Failed <span class="keyword">to</span> <span class="keyword">open</span> TCP connection <span class="keyword">to</span> raw.githubusercontent.com:<span class="number">443</span> (Connection refused - connect(<span class="number">2</span>) <span class="keyword">for</span> <span class="string">&quot;raw.githubusercontent.com&quot;</span> <span class="keyword">port</span> <span class="number">443</span>)) during validation.</span><br><span class="line"></span><br><span class="line">[!] The spec did <span class="keyword">not</span> pass validation, due <span class="keyword">to</span> <span class="number">1</span> <span class="literal">error</span>.</span><br></pre></td></tr></table></figure>
<p>一直卡在这里,最后让终端翻墙后好了.</p>
<p><strong>5. 验证结果</strong></p>
<p>推送到CocoaPods成功后，我们可以搜索刚才制作的pod。此时一般是搜不到的，因为你本地的搜索索引文件，pod spec仓库都是旧的。</p>
<p>发布成功后搜索不到解决办法:</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新spec仓库。更新后尝试搜索，如果还搜不到就继续后面一步。</span></span><br><span class="line">pod repo <span class="keyword">update</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除本地索引</span></span><br><span class="line"><span class="keyword">rm</span> ~/Library/Caches/CocoaPods/search_index.json</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索</span></span><br><span class="line">pod <span class="keyword">search</span> [库名]</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong></p>
<p>上述步骤每次操作也都挺繁琐的，可以考虑自动化，参考：<a href="https://ripperhe.com/2017/03/30/fastlane-pod/">一行命令发布 Pod 框架</a></p>
<p><strong>其他</strong></p>
<p>上述pod是托管到某个平台上的，如果不想上传到服务器，也可以托管在本地玩玩。</p>
<p>安装本地pod</p>
<p>假设已经有了一个本地pod。<code>JKPresentationController.podspec</code>如下:</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">spec.source       = &#123; :<span class="function"><span class="params">git</span> =&gt;</span> <span class="string">&quot;./JKPresentationController/&quot;</span>, :<span class="function"><span class="params">tag</span> =&gt;</span> <span class="string">&quot;#&#123;spec.version&#125;&quot;</span> &#125;</span><br><span class="line">spec.source_files  = <span class="string">&quot;JKPresentationController/*.swift&quot;</span></span><br></pre></td></tr></table></figure>
<p>git后面是源码本地路径.</p>
<p>Podfile文件:</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;10.0&#x27;</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;JKPresentationControllerDemo&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;JKPresentationController&#x27;</span>, <span class="symbol">:path</span> =&gt; <span class="string">&#x27;../&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;SnapKit&#x27;</span>, <span class="string">&#x27;~&gt; 5.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>path后面是<code>JKPresentationController.podspec</code>所在的路径.</p>
<p>执行pod install后,Pods工程下会出现一个<code>Development Pods</code>目录.该目录中包含你的源码文件夹.</p>
<p>相关阅读：<a href="https://xq-120.github.io/2020/04/15/%E5%88%B6%E4%BD%9CCocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/#more">制作CocoaPods私有库</a></p>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>公开库</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift数组截取</title>
    <url>/2020/05/03/Swift%E6%95%B0%E7%BB%84%E6%88%AA%E5%8F%96/</url>
    <content><![CDATA[<p>数组截取的一些方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//startIndex:0, endIndex:5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;startIndex:<span class="subst">\(arr.startIndex)</span>, endIndex:<span class="subst">\(arr.endIndex)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice1 <span class="operator">=</span> arr.dropFirst(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//startIndex:2, endIndex:5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;startIndex:<span class="subst">\(slice1.startIndex)</span>, endIndex:<span class="subst">\(slice1.endIndex)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice2 <span class="operator">=</span> arr.dropFirst().dropLast()</span><br><span class="line"><span class="comment">//startIndex:1, endIndex:4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;startIndex:<span class="subst">\(slice2.startIndex)</span>, endIndex:<span class="subst">\(slice2.endIndex)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs <span class="operator">=</span> arr.dropFirst().prefix(upTo: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(rs) <span class="comment">//[2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs1 <span class="operator">=</span> arr.dropFirst().prefix(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(rs1) <span class="comment">//[2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fib <span class="operator">=</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>]</span><br><span class="line"><span class="keyword">let</span> slfib <span class="operator">=</span> fib[<span class="number">1</span><span class="operator">...</span><span class="number">5</span>]</span><br><span class="line"><span class="comment">//startIndex:1, endIndex:6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;startIndex:<span class="subst">\(slfib.startIndex)</span>, endIndex:<span class="subst">\(slfib.endIndex)</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(slfib) <span class="comment">//[1, 2, 3, 5, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> prefix(upTo end: Int)</span></span><br><span class="line"><span class="comment"> 表示从集合的索引startIndex开始截取到索引n之间的元素，不包含索引n元素。n取值范围：[startIndex, endIndex]，传startIndex则返回空数组，传endIndex则返回整个数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> prefixArr0 <span class="operator">=</span> arr.prefix(upTo: arr.startIndex)</span><br><span class="line"><span class="built_in">print</span>(prefixArr0) <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prefixArr <span class="operator">=</span> arr.prefix(upTo: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(prefixArr) <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prefixArr1 <span class="operator">=</span> arr.prefix(upTo: arr.endIndex)</span><br><span class="line"><span class="built_in">print</span>(prefixArr1) <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prefixArr2 <span class="operator">=</span> slfib.prefix(upTo: <span class="number">3</span>) <span class="comment">//根据上面说明这里只能取[1, 6],取0会崩溃</span></span><br><span class="line"><span class="built_in">print</span>(prefixArr2) <span class="comment">//[1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prefix(_ maxLength: Int)，表示截取集合前n个元素，n取值范围：n&gt;=0，当n = 0时，返回空数组；当n&gt;数组个数时，则返回全部。</span></span><br><span class="line"><span class="keyword">let</span> preArr2 <span class="operator">=</span> arr.prefix(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(preArr2) <span class="comment">//[1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> prefix(through position: Int)</span></span><br><span class="line"><span class="comment"> 表示从集合的索引startIndex开始截取到索引n之间的元素，包含索引n元素。n取值范围：[startIndex, endIndex)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> preArr3 <span class="operator">=</span> arr.prefix(through: <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(preArr3) <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//suffix(from start: Int)：从集合的索引n元素开始截取到末尾，包含索引n元素，n取值范围：[startIndex, endIndex]，当n为endIndex时，结果为空数组。</span></span><br><span class="line"><span class="keyword">let</span> suffixArr0 <span class="operator">=</span> arr.suffix(from: arr.startIndex)</span><br><span class="line"><span class="built_in">print</span>(suffixArr0) <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> suffixArr00 <span class="operator">=</span> arr.suffix(from: arr.endIndex)</span><br><span class="line"><span class="built_in">print</span>(suffixArr00) <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> suffixArr <span class="operator">=</span> arr.suffix(from: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(suffixArr) <span class="comment">//[4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> suffixArr2 <span class="operator">=</span> slfib.suffix(from: <span class="number">3</span>) <span class="comment">//这里参数也不能取0，因为startIndex==1。</span></span><br><span class="line"><span class="built_in">print</span>(suffixArr2) <span class="comment">//[3, 5, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//suffix(_ maxLength: Int)：截取集合的最后n个元素，n取值范围：n&gt;=0，当n = 0时，返回空数组；当n&gt;数组元素个数时，则返回全部。</span></span><br><span class="line"><span class="keyword">let</span> suffixArr1 <span class="operator">=</span> arr.suffix(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(suffixArr1) <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用range时，参数取值范围为[0, 数组个数]，且start&lt;=end。当start 或 end 等于count时，右边只能用&quot;&lt;&quot;或省略end了。不能等于，否则越界了。</span></span><br><span class="line"><span class="keyword">let</span> rangeArr <span class="operator">=</span> arr[<span class="number">3</span><span class="operator">...</span><span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(rangeArr) <span class="comment">//[4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rangeArr1 <span class="operator">=</span> arr[<span class="number">2</span><span class="operator">..&lt;</span><span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(rangeArr1) <span class="comment">//[3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rangeArr2 <span class="operator">=</span> arr[<span class="number">2</span><span class="operator">...</span>]</span><br><span class="line"><span class="built_in">print</span>(rangeArr2) <span class="comment">//[3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rangeArr3 <span class="operator">=</span> arr[<span class="operator">..&lt;</span><span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(rangeArr3) <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rangeArr4 <span class="operator">=</span> arr[<span class="number">5</span><span class="operator">..&lt;</span><span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(rangeArr4) <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rangeArr5 <span class="operator">=</span> arr[<span class="number">5</span><span class="operator">...</span>]</span><br><span class="line"><span class="built_in">print</span>(rangeArr5) <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从头部开始删除n个元素，当n&gt;数组元素个数时表示删除全部，结果返回空数组。</span></span><br><span class="line"><span class="keyword">let</span> dropFirstArr <span class="operator">=</span> arr.dropFirst(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(dropFirstArr) <span class="comment">//[4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从尾部开始删除n个元素，当n&gt;数组元素个数时表示删除全部，结果返回空数组。</span></span><br><span class="line"><span class="keyword">let</span> dropLastArr <span class="operator">=</span> arr.dropLast(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(dropLastArr) <span class="comment">//[1, 2]</span></span><br></pre></td></tr></table></figure>
<p>上述操作之后得到的都是数组切片类型，而不是数组类型。这里简单介绍一下<code>ArraySlice</code> 类型，因为上面有些方法是跟索引相关的，比如方法<code>prefix(upTo end: Int)</code>，而<code>ArraySlice</code> 类型的startIndex并不总是从0开始，所以得到的结果可能出乎你的预料。</p>
<p><code>ArraySlice</code> 类型官方文档：</p>
<p>The <code>ArraySlice</code> type makes it fast and efficient for you to perform operations on sections of a larger array. Instead of copying over the elements of a slice to new storage, an <code>ArraySlice</code>instance presents a view onto the storage of a larger array. And because <code>ArraySlice</code> presents the same interface as <code>Array</code>, you can generally perform the same operations on a slice as you could on the original array.</p>
<p>Unlike <code>Array</code> and <code>ContiguousArray</code>, the starting index for an <code>ArraySlice</code> instance isn’t always zero. Slices maintain the same indices of the larger array for the same elements, so the starting index of a slice depends on how it was created, letting you perform index-based operations on either a full array or a slice.</p>
<p><code>ArraySlice</code>是<code>Array</code>, <code>ContiguousArray</code>, or <code>ArraySlice</code> 实例的一个切片。但是它并不会将切片中的元素拷贝到一个新的存储空间，而是依然指向原始数组。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/ArraySlice1.jpg" style="zoom:50%;" /></p>
<p>注意：endIndex始终指向集合最后一个元素的后一个位置。系统的很多方法涉及到索引时都会跟startIndex和endIndex相关。而不是0和数组个数。</p>
<p><strong><code>ArraySlice</code>的startIndex并不总是从0开始</strong>，而是取决于它的创建方式。下面的例子中可以看到slice1的startIndex是2而不是0。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//startIndex:0, endIndex:5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;startIndex:<span class="subst">\(arr.startIndex)</span>, endIndex:<span class="subst">\(arr.endIndex)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice1 <span class="operator">=</span> arr.dropFirst(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//startIndex:2, endIndex:5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;startIndex:<span class="subst">\(slice1.startIndex)</span>, endIndex:<span class="subst">\(slice1.endIndex)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice2 <span class="operator">=</span> arr.dropFirst().dropLast()</span><br><span class="line"><span class="comment">//startIndex:1, endIndex:4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;startIndex:<span class="subst">\(slice2.startIndex)</span>, endIndex:<span class="subst">\(slice2.endIndex)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs <span class="operator">=</span> arr.dropFirst().prefix(upTo: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(rs) <span class="comment">//[2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs1 <span class="operator">=</span> arr.dropFirst().prefix(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(rs1) <span class="comment">//[2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>接下来解释一下<code>arr.dropFirst().prefix(upTo: 3)</code>的结果为什么是[2, 3]，而不是[2, 3, 4]。</p>
<p>首先<code>arr.dropFirst()</code>将得到一个切片[2, 3, 4, 5]，它的startIndex为1，endIndex为5。<code>prefix(upTo: 3)</code>表示从startIndex开始取到索引为3的元素（不包括），而切片的startIndex为1，所以这里只会取索引为1，2的元素，所以结果为[2, 3]。而<code>prefix(3)</code>表示取前3个，所以结果为[2, 3, 4]。</p>
<p>参考</p>
<p><a href="https://developer.apple.com/documentation/swift/arrayslice">ArraySlice</a></p>
<p><a href="https://juejin.im/post/5b20197cf265da6e083bf070">WWDC 2018：在Swift中如何高效地使用集合</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>数组操作</tag>
        <tag>数组截取</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义Xcode模板</title>
    <url>/2020/05/04/%E8%87%AA%E5%AE%9A%E4%B9%89Xcode%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>很多时候我们需要一个较复杂场景的Demo工程来验证点东西或者研究某个技术，直接在公司项目工程中实验运行又太慢，并且还可能受到其他代码的影响。而Xcode自身提供的工程模板又太过简单，导致每次都要浪费很多时间编写重复的代码来搭建环境。为了提高效率，我们可以自定义工程模板和文件模板。</p>
<p>如下图，系统提供的默认模板其实都在<code>Xcode.app</code>中，自定义工程模板和文件模板最好的办法就是参考系统的模板。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E5%B1%95%E7%A4%BA%E6%95%88%E6%9E%9C.png" style="zoom:50%;" /></p>
<p>系统的工程模板位置:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/Xcode/</span>Templates<span class="regexp">/Project Templates/i</span>OS</span><br></pre></td></tr></table></figure>
<p>系统的文件模板位置:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/Xcode/</span>Templates/<span class="keyword">File</span> Templates</span><br></pre></td></tr></table></figure>
<p>以上是系统默认的模板存储路径，对于自定义的模板则需要存放在其他路径：</p>
<p>自定义工程模板的路径需要存放在:<code>~/Library/Developer/Xcode/Templates/Project Templates/Application/</code>.</p>
<p>自定义文件模板的路径需要存放在:<code>~/Library/Developer/Xcode/Templates/File Templates/</code>.</p>
<p>当做好自己的模板后只需要存放在上述位置，重启Xcode就能看到我们自己的工程模板了。</p>
<p>注：如果上述路径不存在则需要自己创建好。</p>
<h4 id="了解系统的工程模板"><a href="#了解系统的工程模板" class="headerlink" title="了解系统的工程模板"></a>了解系统的工程模板</h4><p>在制作自己的工程模板之前，先来了解一下系统的工程模板都有些啥，以最简单的Single View App模板为例：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/Single%20View%20App.png" style="zoom:50%;" /></p>
<p>每个模板文件夹中都会包含一个模板信息的plist文件里面是一些关于模板的配置。我们要做的也就是修改TemplateInfo.plist文件。</p>
<p>简单介绍一下TemplateInfo.plist文件：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/TemplateInfo_plist.png" alt=""></p>
<p><strong>Kind</strong></p>
<p>分为工程模板和文件模板，这个不用修改使用默认的就好。</p>
<p>工程模板：<code>Xcode.Xcode3.ProjectTemplateUnitKind</code></p>
<p>文件模板：<code>Xcode.IDEFoundation.TextSubstitutionFileTemplateKind</code></p>
<p><strong>Identifier</strong></p>
<p>模板ID，用于唯一标识一个模板。类似于类名。</p>
<p><strong>Ancestors</strong></p>
<p>模板系统允许模板继承和重写其他模板，Ancestors里面包含的就是当前模板继承的其他模板的ID（就是上面那个Identifier）。</p>
<p>Single View App模板的Ancestors包含两个父模板：</p>
<p><code>com.apple.dt.unit.coreDataCocoaTouchApplication</code>：如果你在创建工程时勾线了CoreData，这个模板就会让Xcode在AppDelegate中添加CoreData的样板文件。</p>
<p><code>com.apple.dt.unit.sceneLifecycleApplication</code>：这个是iOS13出的，会让Xcode创建SceneDelegate.h/m。</p>
<p>上面两个模板又都继承自Cocoa Touch Application Base模板，</p>
<p><code>com.apple.dt.unit.cocoaTouchApplicationBase</code>：这个模板主要是在AppDelegate中添加一些样板代码和Info.plist的一些设置。</p>
<p>允许模板的继承和重写就可以让各个模板功能清晰，代码复用，达到类似于类的继承的效果。</p>
<p><strong>Concrete</strong></p>
<p>必须设置为YES才能在Xcode面板中显示出来。</p>
<p><strong>Description</strong></p>
<p>模板的描述。</p>
<p><strong>SortOrder</strong></p>
<p>模板在Xcode面板中的显示位置。值越大显示在越后面。</p>
<p><strong>Options</strong></p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/option_item.png" style="zoom:50%;" /></p>
<p>这个就是模板的主要内容了，里面包括要创建的类文件，存根方法的实现等。Nodes里定义了一些key，它的值就是Definitions里的东西。参照系统的写法我们就可以依葫芦画瓢制作自己的模板了。</p>
<h4 id="制作自己的工程模板"><a href="#制作自己的工程模板" class="headerlink" title="制作自己的工程模板"></a>制作自己的工程模板</h4><p>接下来制作自己的工程模板，使用该模板创建的Demo工程将自动包含一个tabBar控制器,及三个子navigation控制器。其中的MATHomeViewController上添加了一个tableView,MATMessageViewController上添加了一个按钮。支持OC和Swift。</p>
<p>首先拷贝一份系统的Single View App模板，我们主要基于Single View App模板进行修改。</p>
<p>修改文件名为<code>Demo App.xctemplate</code>，文件夹下的模板图标可以换一下。接下来就是对TemplateInfo.plist文件的修改了。</p>
<p><strong>Identifier</strong></p>
<p>随便取个名称，<code>com.apple.dt.unit.MATDemoApplication</code>。</p>
<p><strong>Ancestors</strong></p>
<p>由于不想要Storyboard，所以用<code>com.apple.dt.unit.cocoaTouchApplicationBase</code>替换掉<code>com.apple.dt.unit.sceneLifecycleApplication</code>模板。</p>
<p><strong>SortOrder</strong></p>
<p>取值100。让它排在系统的后面。</p>
<p>接下来就是大头Options。</p>
<p><strong>Options</strong></p>
<blockquote>
<p>更改AppDelegate</p>
</blockquote>
<p>在Nodes里添加一个item <code>AppDelegate.m:imports:importHeader:MATTabBarController.h</code>：表示在AppDelegate.m里面导入MATTabBarController.h头文件，这样Xcode在创建工程时就会自动在AppDelegate.m里添加<code>#import&quot;MATTabBarController.h&quot;</code>。</p>
<p>在Nodes里添加一个item <code>AppDelegate.m:implementation:methods:applicationdidFinishLaunchingWithOptions:body</code></p>
<p>并在Definitions里添加对应的值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.window <span class="operator">=</span> [[<span class="type">UIWindow</span> alloc] initWithFrame:<span class="type">UIScreen</span>.mainScreen.bounds];</span><br><span class="line"><span class="keyword">self</span>.window.backgroundColor <span class="operator">=</span> [<span class="type">UIColor</span> whiteColor];</span><br><span class="line"><span class="type">MATTabBarController</span> <span class="operator">*</span>tabController <span class="operator">=</span> [[<span class="type">MATTabBarController</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="keyword">self</span>.window.rootViewController <span class="operator">=</span> tabController;</span><br><span class="line">[<span class="keyword">self</span>.window makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
<p>这样Xcode就会自动在AppDelegate.m里didFinishLaunchingWithOptions方法里面添加上述代码。</p>
<p>如图：</p>
<p>Nodes:</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/appDelegate_1.png" alt=""></p>
<p>Definitions:</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/appDelegate_2.png" alt=""></p>
<blockquote>
<p>添加已有的类文件</p>
</blockquote>
<p>MATTabBarController.h/m是我们自己提供的类文件，为了让Xcode在创建工程时能够找到这些类，我们需要在模板文件中指明。</p>
<p>在Nodes里添加两个item：<code>MATTabBarController.h</code>和<code>MATTabBarController.m</code></p>
<p>并在Definitions里添加对应的值：</p>
<p>key:<code>MATTabBarController.h</code>，value类型选择字典。字典中添加key:<code>Path</code>，value为文件的路径。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6.png" alt=""></p>
<blockquote>
<p>动态创建类</p>
</blockquote>
<p>这个参照系统的就可以了：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB.png" alt=""></p>
<p>红色划线处替换为你自己的类名即可。</p>
<blockquote>
<p>添加方法</p>
</blockquote>
<p>让Xcode在创建的类中自动添加一个方法。</p>
<p>在Nodes里添加两个item:</p>
<p><code>MATMessageViewController.m:implementation:methods:btnDidClicked(- (void\)btnDidClicked:(UIButton *\)sender)</code> 和</p>
<p><code>MATMessageViewController.m:implementation:methods:btnDidClicked:body</code></p>
<p>即方法声明和方法实现。</p>
<p>在Definitions里添加<code>MATMessageViewController.m:implementation:methods:btnDidClicked:body</code>的值，这里就是btnDidClicked方法的实现：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">NSLog(@<span class="string">&quot;btnDidClicked&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>添加属性及懒加载实现</p>
</blockquote>
<p>让Xcode在创建的类中自动添加一个属性及属性的懒加载实现。</p>
<p>在Nodes里添加三个item</p>
<p><code>MATMessageViewController.m:extension:btn</code></p>
<p><code>MATMessageViewController.m:implementation:methods:btn(- (UIButton *\)btn)</code></p>
<p><code>MATMessageViewController.m:implementation:methods:btn:return</code></p>
<p>在Definitions添加对应的值：</p>
<p><code>MATMessageViewController.m:extension:btn</code>的值：</p>
<p><code>@property (strong, nonatomic) UIButton *btn;</code></p>
<p><code>MATMessageViewController.m:implementation:methods:btn:return</code>的值：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_btn == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    btn.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">44</span>);</span><br><span class="line">    btn.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [btn setTitle:<span class="string">@&quot;button&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnDidClicked:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    _btn = btn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _btn;</span><br></pre></td></tr></table></figure>
<p>到此为止工程模板就差不多了，将其拷贝到<code>~/Library/Developer/Xcode/Templates/Project Templates/Application/</code>目录下，重启Xcode就可以看到我们自己的模板了。</p>
<h4 id="制作自己的文件模板"><a href="#制作自己的文件模板" class="headerlink" title="制作自己的文件模板"></a>制作自己的文件模板</h4><p>制作文件模板最好也是参照系统的文件模板。</p>
<p>新建一个文件夹命名为<code>ZACustom</code>,然后从目录：</p>
<p><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File Templates/Source</code></p>
<p>拷贝一份<code>Cocoa Touch Class.xctemplate</code>，到该目录下。</p>
<p>一般新建UIViewController和NSObject较多，所以可以只保留这两个类，其他的类文件夹可以删掉。</p>
<p>文件模板的TemplateInfo.plist文件基本不需要修改，只需要修改各类文件夹下的<code>___FILEBASENAME___.m</code>文件。</p>
<p>修改<code>UIViewControllerObjective-C</code>文件夹下的<code>___FILEBASENAME___.m</code>，新增代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//___FILEHEADER___</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;___FILEBASENAME___.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">___FILEBASENAMEASIDENTIFIER___</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">___FILEBASENAMEASIDENTIFIER___</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK:  life cycle</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidAppear:animated];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewWillDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillDisappear:animated];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidDisappear:animated];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: system protocol</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: custom protocol</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: notification</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: event response</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: public method</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: private method</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: setter &amp; getter</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样创建的UIViewController子类就自带这些注释和实现的方法。</p>
<p>可以修改<code>NSObjectObjective-C</code>文件夹下的<code>___FILEBASENAME___.h</code>，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//___FILEHEADER___</span></span><br><span class="line"></span><br><span class="line">___IMPORTHEADER_cocoaTouchSubclass___</span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">___FILEBASENAMEASIDENTIFIER___</span> : <span class="title">___VARIABLE_cocoaTouchSubclass___</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *&lt;#property1#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *&lt;#property2#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *&lt;#property3#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *&lt;#property4#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *&lt;#property5#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> &lt;#property6#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">float</span> &lt;#property7#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样创建的模型，自动就有7个占位属性了。</p>
<p>最后将文件夹<code>ZACustom</code>拷贝到<code>~/Library/Developer/Xcode/Templates/File Templates/</code>目录下，重启Xcode就可以看到我们自己定义的文件模板了。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF%E5%B1%95%E7%A4%BA%E6%95%88%E6%9E%9C.png" style="zoom:50%;" /></p>
<p>有需要的朋友可以点击下方链接下载使用：</p>
<p><a href="https://github.com/xq-120/FireDemoAppTemplate">FireDemoAppTemplate</a></p>
]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>Xcode模板</tag>
      </tags>
  </entry>
  <entry>
    <title>OC类型自省函数</title>
    <url>/2020/05/05/OC%E7%B1%BB%E5%9E%8B%E8%87%AA%E7%9C%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>先上测试代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ZAEImageView *img = [ZAEImageView new];</span><br><span class="line"><span class="type">BOOL</span> isMember1 = [img isMemberOfClass:ZAEImageView.class];</span><br><span class="line"><span class="type">BOOL</span> isMember2 = [img isMemberOfClass:<span class="built_in">UIImageView</span>.class];</span><br><span class="line"><span class="type">BOOL</span> isMember3 = [ZAEImageView isMemberOfClass:ZAEImageView.class];</span><br><span class="line"><span class="type">BOOL</span> isMember4 = [ZAEImageView isMemberOfClass:<span class="built_in">UIImageView</span>.class];</span><br><span class="line"><span class="type">BOOL</span> isMember5 = [ZAEImageView isMemberOfClass:object_getClass(ZAEImageView.class)];</span><br><span class="line"><span class="type">BOOL</span> isMember6 = [ZAEImageView isMemberOfClass:object_getClass(<span class="built_in">UIImageView</span>.class)];</span><br><span class="line"><span class="type">BOOL</span> isKind1 = [img isKindOfClass:ZAEImageView.class];</span><br><span class="line"><span class="type">BOOL</span> isKind2 = [img isKindOfClass:<span class="built_in">UIImageView</span>.class];</span><br><span class="line"><span class="type">BOOL</span> isKind3 = [ZAEImageView isKindOfClass:ZAEImageView.class];</span><br><span class="line"><span class="type">BOOL</span> isKind4 = [ZAEImageView isKindOfClass:<span class="built_in">UIImageView</span>.class];</span><br><span class="line"><span class="type">BOOL</span> isKind5 = [ZAEImageView isKindOfClass:object_getClass(ZAEImageView.class)];</span><br><span class="line"><span class="type">BOOL</span> isKind6 = [ZAEImageView isKindOfClass:object_getClass(<span class="built_in">UIImageView</span>.class)];</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/OC%E7%B1%BB%E5%9E%8B%E8%87%AA%E7%9C%81_%E7%BB%93%E6%9E%9C.jpg" alt="结果"></p>
<p>OC类型自省的函数如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)isKindOfClass:(Class)aClass;</span><br><span class="line">- (<span class="type">BOOL</span>)isMemberOfClass:(Class)aClass;</span><br></pre></td></tr></table></figure>
<p>它们声明在<code>@protocol NSObject</code>中,NSObject类实现了NSObject协议<code>@interface NSObject &lt;NSObject&gt;</code>.</p>
<p>可以看到它们都是实例方法,但是为什么可以发送给类对象?和元类有关.</p>
<p><code>- (BOOL)isMemberOfClass:(Class)aClass;</code></p>
<p>Returns a Boolean value that indicates whether the receiver is an instance of a given class.</p>
<p>用于检测消息接收者是否是某个类的实例.</p>
<p><code>- (BOOL)isKindOfClass:(Class)aClass;</code></p>
<p>Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class.</p>
<p>用于检测消息接收者是否是某个类的实例或者是其子类的实例.注意与<code>isMemberOfClass</code>的区别.</p>
<h4 id="对实例对象进行自省"><a href="#对实例对象进行自省" class="headerlink" title="对实例对象进行自省"></a>对实例对象进行自省</h4><p>示例:<code>[img isKindOfClass:UIImageView.class];</code>这个很好理解,不是今天的重点.</p>
<h4 id="对类对象进行自省"><a href="#对类对象进行自省" class="headerlink" title="对类对象进行自省"></a>对类对象进行自省</h4><p>示例:<code>[ZAEImageView isKindOfClass:object_getClass(UIImageView.class)];</code></p>
<p>对类对象进行自省时isKindOfClass的参数为啥是<code>object_getClass(UIImageView.class)</code>而不能是<code>UIImageView.class</code>?</p>
<p>其实也很简单:实例对象的类型是类对象,类对象的类型是元类对象.因此对类对象进行自省时,isKindOfClass的参数就需要传入类对象的类型,那如何获取类对象的类型呢?答案就是<code>object_getClass()</code>.</p>
<p><code>OBJC_EXPORT Class _Nullable object_getClass(id _Nullable obj);</code></p>
<p>Returns the class of an object.</p>
<p>返回一个对象的类型.注意这里的参数是id.因此可以是任何OC对象—实例对象,类对象,元类对象.</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/// An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">/// Represents an<span class="built_in"> instance </span>of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAI<span class="class">LABILITY;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an<span class="built_in"> instance </span>of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAI<span class="class">LABILITY;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAI<span class="class">LABLE;</span></span><br><span class="line">   <span class="built_in"> const </span>char * _Nonnull name                               OBJC2_UNAVAI<span class="class">LABLE;</span></span><br><span class="line">   <span class="built_in"> long </span>version                                             OBJC2_UNAVAI<span class="class">LABLE;</span></span><br><span class="line">   <span class="built_in"> long </span>info                                                OBJC2_UNAVAI<span class="class">LABLE;</span></span><br><span class="line">   <span class="built_in"> long </span>instance_size                                       OBJC2_UNAVAI<span class="class">LABLE;</span></span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAI<span class="class">LABLE;</span></span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable method<span class="class">Lists                    OBJC2_UNAVAILABLE;</span></span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAI<span class="class">LABLE;</span></span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAI<span class="class">LABLE;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAI<span class="class">LABLE;</span></span><br></pre></td></tr></table></figure>
<p>至于为什么id可以指向任意OC对象,简单点讲就是因为所有OC对象都有一个<code>Class isa</code>指针.因此都可以赋值给id变量.具体可以参考:<a href="https://juejin.im/post/5ce9541bf265da1b6b1cb2c1">iOS OC id类型为什么能指向任意类</a></p>
<p>测试:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">id cls1 <span class="operator">=</span> img.class<span class="comment">;</span></span><br><span class="line">id cls2 <span class="operator">=</span> object_getClass(img)<span class="comment">;</span></span><br><span class="line">id cls3 <span class="operator">=</span> ZAEImageView.class<span class="comment">;</span></span><br><span class="line">id cls4 <span class="operator">=</span> object_getClass(ZAEImageView.class)<span class="comment">;</span></span><br><span class="line">id cls5 <span class="operator">=</span> objc_getMetaClass(<span class="string">&quot;ZAEImageView&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures//OC%E7%B1%BB%E5%9E%8B%E8%87%AA%E7%9C%81_%E7%BB%93%E6%9E%9C2.jpg" alt="结果"></p>
<p>可以看到当传入的是实例对象时,object_getClass()返回的是实例对象的类型—类对象,如果传入的是类对象,则object_getClass()返回的是类对象的类型—元类对象.所以cls4指向的地址和前面几个不同.</p>
<p><strong>object_getClass()实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_getClass(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> Class _object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">OBJC_IS_TAGGED_PTR</span>(obj)) &#123;</span><br><span class="line">      <span class="type">uint8_t</span> slotNumber = ((<span class="type">uint8_t</span>) (<span class="type">uint64_t</span>) obj) &amp; <span class="number">0x0F</span>;</span><br><span class="line">      Class isa = _objc_tagged_isa_table[slotNumber];</span><br><span class="line">      <span class="keyword">return</span> isa;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;isa;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到object_getClass()就是返回对象的isa指针.</p>
<p>另外<code>+ (Class)class,- (Class)class</code>的实现分别如下:</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">//声明于NSObject类中,类方法.返回自身指针</span><br><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> //声明于NSObject协议中,实例方法.调用object_getClass，返回isa指针</span><br><span class="line">- (Class)<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道了实现就不难理解cls1=cls2=cls3=类对象不等于cls4=cls5=元类对象了.</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC类型自省</tag>
      </tags>
  </entry>
  <entry>
    <title>NSMutableArray实现原理</title>
    <url>/2020/05/17/NSMutableArray%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>本文基于<a href="https://ciechanow.ski/exposing-nsmutablearray/">Exposing NSMutableArray</a> 理解和扩展。</p>
<p>C语言中的数组可以说是最基本的数据结构了，其他一些数据结构比如队列，循环队列等都可以基于普通C数组的进一步封装来实现。</p>
<h2 id="普通C数组"><a href="#普通C数组" class="headerlink" title="普通C数组"></a>普通C数组</h2><p>数组占据的是一段连续的内存空间，并根据顺序存储数据。</p>
<p>优点：时间效率很高</p>
<p>由于数组中的内存是连续的，因此可以根据下标读写任何元素，时间复杂度为O(1)。</p>
<p>缺点：空间效率较低</p>
<p>创建数组时需要先指定数组的容量大小，然后根据大小分配内存。即使只在数组中存储一个元素也需要为所有的数据预先分配内存。因此它的空间效率不是很高，经常会有空闲区域没有被使用。</p>
<p>另一个明显的缺点是：在下标 0 处插入或删除一个元素时，需要移动其它所有的元素。当数据量很大时，性能就变得很差。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>如何避免这个问题呢？答案就是循环队列。循环队列在进行入队和出队操作时，其他元素是不需要移动的。因此可以借鉴这个思想。理解了循环队列基本上就理解了NSMutableArray的底层数据结构。</p>
<p>循环队列里一个很重要的操作就是取模。</p>
<p>例如，对于任何一个自然数，模上5，得到的结果都会在[0,4]之间。</p>
<p>0%5  = 0，1%5  = 1，2%5  = 2，3%5  = 3，4%5  = 4，5%5  = 0，6%5  = 1，7%5  = 2， ……。看到没有，结果已经开始循环了。</p>
<p>循环队列的声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularQueue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> size: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> count: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> head: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> tail: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> items: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般都会有head和tail两个指针，head总是指向第一个元素，tail总是指向下一个存储的元素的位置。也可以不使用tail，而使用head和count，因为tail = head + count。</p>
<p>初始化时head==tail。另外head可以等于0也可以不等于0这个不重要，因为是循环的，所以无论从哪个点开始都是一样的。</p>
<p>这里初始化：head==tail=0。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/618F53DD5E0AC45A98E4192354D0F63E.jpg" style="zoom:50%;" /></p>
<p>入队1</p>
<p>每次入队时，tail往后移动一个位置。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/488D507C0EC5B5CDA656D769F25C9281.jpg" style="zoom:50%;" /></p>
<p>入4</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200517115455.png" style="zoom:50%;" /></p>
<p>入5</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/8C560E41A5516F18BAE25E17928B9A3C.jpg" style="zoom:50%;" /></p>
<p>入队5时，队列就满了，tail的位置又回到了原点。此时就不再允许入队了因为已经满了。</p>
<p>因此每次入队时，tail往后移动一个位置，对应的代码为：</p>
<p>tail = (tail + 1) % size。模size意味着超出size时回到原来的位置。开始循环。这就是取模的魅力。</p>
<p>再来看出队：</p>
<p>这里连续出队1，2，3。每次出队后，head就往后移动一个位置，指向新的第一个元素的位置，对应的代码为：</p>
<p>head = (head + 1) % size。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/6C548BF9E45EA310CDBF27701E5131E7.jpg" style="zoom:50%;" /></p>
<p>再入队3：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/667D39026317F4D61F674BB94052BA4F.jpg" style="zoom:50%;" /></p>
<p>这样head和tail就不断的循环，充分利用了空间，并且每次操作时其他元素是不动的。</p>
<p>上面的数组的内容为[4,5,3]。如果我们想用下标来直接取出一个元素该怎么操作呢。比如a[2] = 3。</p>
<p>利用head就可以轻松计算出实际的下标：realIndex = (head + index) % size 。</p>
<p>即realIndex = (3 + 2) % 5 = 0，原数组下标0即为要取的元素。</p>
<p>利用循环队列结合取模操作，我们既做到了插入或删除一个元素时，不移动其它元素。又可以通过下标来取出元素。</p>
<p>有兴趣的可以刷一下LeetCode的<a href="https://leetcode-cn.com/problems/design-circular-queue/">622. 设计循环队列</a>，加深理解。</p>
<h2 id="循环双端队列"><a href="#循环双端队列" class="headerlink" title="循环双端队列"></a>循环双端队列</h2><p>上面的循环队列依然遵守队头出，队尾入的规则。有时候就不太灵活，于是就有循环双端队列这一变种，它可以在两端进行插入和删除操作，但不能在中间操作。</p>
<p>可以刷一下<a href="https://leetcode-cn.com/problems/design-circular-deque/">641. 设计循环双端队列</a>，由于和循环队列差别不大，这里就不做介绍了。</p>
<p>循环双端队列和NSMutableArray的底层数据结构就更接近了。</p>
<p>在头部插入：head = (head-1+size)%size</p>
<p>在头部移除：head = (head+1)%size</p>
<p>在尾部插入：tail = (tail+1)%size</p>
<p>在尾部移除：tail = (tail-1+size)%size</p>
<p>访问元素：realIndex = (head + index) % size 。</p>
<h2 id="NSMutableArray底层数据结构"><a href="#NSMutableArray底层数据结构" class="headerlink" title="NSMutableArray底层数据结构"></a>NSMutableArray底层数据结构</h2><p>NSMutableArray借鉴了循环双端队列数据结构的思想，只不过NSMutableArray还允许在中间进行插入删除。</p>
<p>NSMutableArray是一个类簇，实际的类型是__NSArrayM。</p>
<p>__NSArrayM的实例布局：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">__NSArrayM</span> : <span class="title">NSMutableArray</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _used;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _doHardRetain:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _doWeakAccess:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _size:<span class="number">62</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _hasObjects:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _hasStrongReferences:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _offset:<span class="number">62</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> _mutations;</span><br><span class="line">    <span class="type">id</span> *_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较重要的几个属性：</p>
<p>_used：当前已使用的内存空间个数，即当前数组中元素的个数。</p>
<p>_size：数组的大小</p>
<p>_offset：数组的第一个元素索引，始终指向数组的第一个元素。相当于上面的head</p>
<p>_list：缓冲区指针，指向分配的那一段连续的内存空间，即元素存储的地方。相当于上面的Array。</p>
<p>_offset + _used就相当于上面的tail。</p>
<p>下标查找时realIndex = (_offset + index) % size 。</p>
<p><strong>在两端操作，其他元素不需要移动</strong></p>
<p>在头部进行插入和删除操作及在尾部进行插入和删除操作，同循环双端队列，其他元素是不需要移动的，这就提高了性能。</p>
<p><strong>在中间操作</strong></p>
<p>delete at middle或insert at middle</p>
<p>原则：移动较少的一端的元素。</p>
<p>在中间插入或删除时不可避免需要移动元素否则就无法通过下标定位元素了，这里采用移动较少的一端的元素来提高性能。</p>
<p><strong>扩容</strong></p>
<p>普通C数组在初始化时容量就已经确定了，所谓的插入和删除操作其实都是在这个确定的容量里进行，并且插入和删除操作并不会对这个确定的容量有什么影响，只有在插入时容量不足了，才需要扩容。</p>
<p>容量不够时，NSMutableArray会扩大到原来的1.625倍，并不是2倍，这个都是有讲究的。扩大后即使元素全部移除也不会再缩减空间。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ciechanow.ski/exposing-nsmutablearray/">Exposing NSMutableArray</a> 译文：<a href="http://blog.joyingx.me/2015/05/03/NSMutableArray%20%E5%8E%9F%E7%90%86%E6%8F%AD%E9%9C%B2/">NSMutableArray原理揭露</a></p>
<p><a href="https://blog.csdn.net/Deft_MKJing/article/details/82732833">NSDictionary和NSMutableArray</a></p>
<p><a href="https://www.jianshu.com/p/9ba8a65464dd">数据结构 第7讲 循环队列</a></p>
<p><a href="https://juejin.im/post/5d5fb74fe51d45620346b8d0">看完这篇你还不知道这些队列，我这些图白作了</a> 讲解了各种队列。</p>
<p><a href="https://zhuanlan.zhihu.com/p/72007079">堆、栈和队列如何理解与应用？</a> 主要讲数据结构中的堆和栈。</p>
<p><a href="https://zhuanlan.zhihu.com/p/66922957">怎样深入理解堆和栈</a> 主要讲操作系统中<strong>内存分配方式</strong>的堆和栈。</p>
<p><a href="https://juejin.im/entry/58330cbfa0bb9f005a0fed62">常见数据结构 (一)- 栈, 队列, 堆, 哈希表</a></p>
<p><strong>iOS逆向</strong></p>
<p>知识储备</p>
<p><a href="https://chinafishnews.github.io/2018/05/29/class-dump%E5%92%8CMachO%E6%96%87%E4%BB%B6/">class-dump和MachO文件</a></p>
<p><a href="https://www.jianshu.com/p/6b6691d52e8a">iOS逆向工具之class-dump(MacOS)介绍</a> 本文作者对iOS逆向有较深入研究。</p>
<p>class-dump安装目录：<code>/usr/local/bin</code></p>
<p><code>class-dump -H /System/Library/Frameworks/CoreFoundation.framework -o 目的文件夹</code></p>
<p>Xcode11不能使用下面的CoreFoundation路径。（网上的教程都是下面的路径，但实验证明不行）</p>
<p><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreFoundation.framework</code></p>
<p>库的路径整了一天，看来是路径变了。</p>
<p>别人整好的：关于iOS SDK的所有头文件，早有专人建立了一个在线网站去分析，点击跳转：<a href="http://developer.limneos.net/">iOS Runtime Headers</a></p>
<p><a href="https://github.com/w0lfschild/macOS_headers">macOS_headers</a> macOS上的Frameworks class-dump。</p>
<p>另一款工具：<a href="https://derekselander.github.io/dsdump/">dsdump</a>：An improved nm + Objective-C &amp; Swift class-dump</p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>NSMutableArray</tag>
      </tags>
  </entry>
  <entry>
    <title>OC内存管理之自动释放池实现原理</title>
    <url>/2020/05/22/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>整了8个小时，基本上算整明白了。</p>
<p>环境：</p>
<p><a href="https://opensource.apple.com/source/objc4/objc4-781/runtime/NSObject.mm.auto.html">NSObject.mm源码</a> 版本为objc4-781。</p>
<p>对代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">clang -<span class="built_in">rewrite</span>-objc main.m</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> </span><br><span class="line">    &#123; </span><br><span class="line">    __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_46_lys08y0137d41lbysrxxd0h80000gn_T_main_8ccfab_mi_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="type">void</span> * <span class="title function_">objc_autoreleasePoolPush</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="type">void</span> <span class="title function_">objc_autoreleasePoolPop</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="type">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>里面有一个构造函数<code>__AtAutoreleasePool()</code>和一个析构函数<code>~__AtAutoreleasePool()</code>。</p>
<p>上述代码等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do whatever you want</span></span><br><span class="line"></span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.获取当前自动释放池的哨兵对象的指针 2.把当前自动释放池里的自动释放对象清空直到哨兵对象为止。</p>
<p>即你每次写@autoreleasepool </p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就等价于:一对花括号，上花括号紧接着的是objc_autoreleasePoolPush操作，下括号上面紧接着的是objc_autoreleasePoolPop操作。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    void * atautoreleasepoolobj <span class="operator">=</span> objc_autoreleasePoolPush()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    // do whatever you want</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住这一点很重要。</p>
<p>上述两个函数的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">objc_autoreleasePoolPush</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NEVER_INLINE</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">objc_autoreleasePoolPop</span><span class="params">(<span class="type">void</span> *ctxt)</span></span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AutoreleasePoolPage结构"><a href="#AutoreleasePoolPage结构" class="headerlink" title="AutoreleasePoolPage结构"></a>AutoreleasePoolPage结构</h3><p>AutoreleasePoolPage的实现注解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">   Autorelease pool implementation</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   A thread&#x27;s autorelease pool is a stack of pointers. </span></span><br><span class="line"><span class="comment">   Each pointer is either an object to release, or POOL_BOUNDARY which is </span></span><br><span class="line"><span class="comment">     an autorelease pool boundary.</span></span><br><span class="line"><span class="comment">   A pool token is a pointer to the POOL_BOUNDARY for that pool. When </span></span><br><span class="line"><span class="comment">     the pool is popped, every object hotter than the sentinel is released.</span></span><br><span class="line"><span class="comment">   The stack is divided into a doubly-linked list of pages. Pages are added </span></span><br><span class="line"><span class="comment">     and deleted as necessary. </span></span><br><span class="line"><span class="comment">   Thread-local storage points to the hot page, where newly autoreleased </span></span><br><span class="line"><span class="comment">     objects are stored. </span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoreleasePoolPage</span> : <span class="keyword">private</span> AutoreleasePoolPageData </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">thread_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> SIZE =</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">		PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		PAGE_MIN_SIZE;  <span class="comment">// size and alignment, power of 2 //4KB</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">pthread_key_t</span> <span class="type">const</span> key = AUTORELEASE_POOL_KEY; <span class="comment">//AUTORELEASE_POOL_KEY：43</span></span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> <span class="type">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">	<span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> COUNT = SIZE / <span class="built_in">sizeof</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span></span><br><span class="line">    <span class="comment">// pushed and it has never contained any objects. This saves memory </span></span><br><span class="line">    <span class="comment">// when the top level (i.e. libdispatch) pushes and pops pools but </span></span><br><span class="line">    <span class="comment">// never uses them.</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1) <span class="comment">//占位池，起到优化作用。因为很可能创建了自动释放池但实际没有使用到自动释放对象，使用占位池就可以避免这种损耗。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> POOL_BOUNDARY nil <span class="comment">//哨兵对象，清空本次自动释放池里的对象的截止位置。</span></span></span><br><span class="line">		...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">id * <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="type">uint8_t</span> *)<span class="keyword">this</span>+<span class="built_in">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id * <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="type">uint8_t</span> *)<span class="keyword">this</span>+SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next == <span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> next == <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lessThanHalfFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (next - <span class="built_in">begin</span>() &lt; (<span class="built_in">end</span>() - <span class="built_in">begin</span>()) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(!<span class="built_in">full</span>());</span><br><span class="line">        <span class="built_in">unprotect</span>();</span><br><span class="line">        id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">        *next++ = obj;</span><br><span class="line">        <span class="built_in">protect</span>();</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">//返回一个地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoreleasePoolPage</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AutoreleasePoolPageData</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">magic_t</span> <span class="type">const</span> magic;</span><br><span class="line">	__unsafe_unretained id *next;</span><br><span class="line">	<span class="type">pthread_t</span> <span class="type">const</span> thread;</span><br><span class="line">	AutoreleasePoolPage * <span class="type">const</span> parent;</span><br><span class="line">	AutoreleasePoolPage *child;</span><br><span class="line">	<span class="type">uint32_t</span> <span class="type">const</span> depth;</span><br><span class="line">	<span class="type">uint32_t</span> hiwat;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AutoreleasePoolPageData</span>(__unsafe_unretained id* _next, <span class="type">pthread_t</span> _thread, AutoreleasePoolPage* _parent, <span class="type">uint32_t</span> _depth, <span class="type">uint32_t</span> _hiwat)</span><br><span class="line">		: <span class="built_in">magic</span>(), <span class="built_in">next</span>(_next), <span class="built_in">thread</span>(_thread),</span><br><span class="line">		  <span class="built_in">parent</span>(_parent), <span class="built_in">child</span>(nil),</span><br><span class="line">		  <span class="built_in">depth</span>(_depth), <span class="built_in">hiwat</span>(_hiwat)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个线程的自动释放池登记了一堆指针，每个指针指向的要么是一个待释放的对象，要么是一个POOL_BOUNDARY（也称为哨兵对象），POOL_BOUNDARY是一个自动释放池的界限，这表明自动释放池可以嵌套。每个自动释放池都有一个token指针指向POOL_BOUNDARY。当池子被pop时，比哨兵对象后登记的对象都将被释放。自动释放池的底层由一个双链表 <code>AutoreleasePoolPage</code> 实现。每一个AutoreleasePoolPage对象占用4KB（也就是每一页最多注册128*4=512个对象）。page按需添加或删除。Thread-local storage（TLS，即线程局部存储）指向 hot page，hot page 是指最新添加的 autorelease 对象所在的那个 page。</p>
<p>magic：用于对当前 <code>AutoreleasePoolPage</code> <strong>完整性</strong>的校验</p>
<p>next：指针变量，可以指向任意类型，指针变量自然它的值就是地址。它指向的是下一次添加对象时的存储位置。</p>
<p>thread：当前自动释放池所在的线程</p>
<p>parent：父AutoreleasePoolPage，第一个结点的 <code>parent</code> 值为 <code>nil</code>;</p>
<p>child：子AutoreleasePoolPage，最后一个结点的 <code>child</code> 值为 <code>nil</code>;</p>
<p>depth：双链表的深度</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200916214437.png" style="zoom:50%;" /></p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(DebugPoolAllocation)) &#123;</span><br><span class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">        dest = <span class="built_in">autoreleaseNewPage</span>(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest = <span class="built_in">autoreleaseFast</span>(POOL_BOUNDARY); <span class="comment">//注意这里的参数是POOL_BOUNDARY</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT</span>(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest; <span class="comment">//返回的是page上的一个地址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>push操作就是调用autoreleaseFast添加一个POOL_BOUNDARY哨兵对象并返回哨兵对象所在的内存地址或者一个EMPTY_POOL_PLACEHOLDER占位地址。所谓的哨兵对象就是一个nil对象，因此page的这一栏的内容其实是空的。</p>
<p>第一次执行push的时候返回的其实是一个占位地址EMPTY_POOL_PLACEHOLDER，其他时候才是page上某一栏的内存地址了。这里的EMPTY_POOL_PLACEHOLDER是一个性能优化，因为有可能我们虽然写了 <code>@autoreleasepool&#123;&#125;</code> 但里面不一定会使用到自动释放对象，这个时候就没必要创建一个page，即page是懒加载的，真正往里面注册时才会创建page。懒加载后，系统也是先添加一个哨兵对象再添加传入的对象。</p>
<p>与push操作相对的是pop操作，pop操作会一直release对象直到POOL_BOUNDARY哨兵对象（该对象就是push操作时返回的）。</p>
<p>完成添加操作的函数autoreleaseFast：</p>
<h3 id="autoreleaseFast"><a href="#autoreleaseFast" class="headerlink" title="autoreleaseFast"></a>autoreleaseFast</h3><p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;<span class="built_in">full</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseFullPage</span>(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseNoPage</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>autoreleaseFast函数返回的就是对象被添加到page上时的内存地址。</p>
<p>整个逻辑分为三个部分：</p>
<ol>
<li>首先查找是否存在hotPage</li>
<li>hotPage存在且没有满，则直接添加到page上</li>
<li>hotPage存在但已经满了，则调用autoreleaseFullPage，创建新的一页page，然后将obj添加到新的page上</li>
<li>hotPage不存在，表明当前还没有page，则调用autoreleaseNoPage，创建第一个page，将obj添加到page上</li>
</ol>
<p>接下来具体看一下各子函数：</p>
<h3 id="hotPage"><a href="#hotPage" class="headerlink" title="hotPage"></a>hotPage</h3><p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title function_">hotPage</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    <span class="keyword">if</span> ((id *)result == EMPTY_POOL_PLACEHOLDER) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (result) result-&gt;fastcheck();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> <span class="type">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">define <span class="title function_">AUTORELEASE_POOL_KEY</span>  <span class="params">((<span class="type">tls_key_t</span>)__PTK_FRAMEWORK_OBJC_KEY3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PTK_FRAMEWORK_OBJC_KEY3	43</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span></span><br><span class="line"><span class="comment">// pushed and it has never contained any objects. This saves memory </span></span><br><span class="line"><span class="comment">// when the top level (i.e. libdispatch) pushes and pops pools but </span></span><br><span class="line"><span class="comment">// never uses them.</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)</span></span><br></pre></td></tr></table></figure>
<p>大致流程：</p>
<ol>
<li>从线程的TLS读取AUTORELEASE_POOL_KEY的值，如果等于EMPTY_POOL_PLACEHOLDER，表明当前没有page，因此返回nil。</li>
<li>如果不是EMPTY_POOL_PLACEHOLDER，则表明当前线程有正在使用的未满的page，返回它。正在使用的未满的page也叫做hotPage。hotPage不一定是双链表的最后一页，因为pop的时候可能会保留一页空的page。只能说hotPage跟双链表的最后一页很近。</li>
</ol>
<p>这里是get hotPage，我们可以看下是如何set hotPage的：</p>
<h3 id="setHotPage"><a href="#setHotPage" class="headerlink" title="setHotPage"></a>setHotPage</h3><p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">setHotPage</span><span class="params">(AutoreleasePoolPage *page)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (page) page-&gt;fastcheck();</span><br><span class="line">    tls_set_direct(key, (<span class="type">void</span> *)page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单就是把page的地址存储到线程的TLS。</p>
<p>与hotPage对应的是codePage</p>
<h3 id="codePage"><a href="#codePage" class="headerlink" title="codePage"></a>codePage</h3><p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title function_">coldPage</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *result = hotPage();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">while</span> (result-&gt;parent) &#123;</span><br><span class="line">            result = result-&gt;parent;</span><br><span class="line">            result-&gt;fastcheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是找到双链表的第一个page。即双链表的第一个page也叫coldPage。</p>
<p>接着未完成的分析，autoreleaseFullPage</p>
<h3 id="autoreleaseFullPage"><a href="#autoreleaseFullPage" class="headerlink" title="autoreleaseFullPage"></a>autoreleaseFullPage</h3><p>自动释放池页满了的处理。</p>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __attribute__((noinline))</span><br><span class="line">id *<span class="title function_">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The hot page is full. </span></span><br><span class="line">    <span class="comment">// Step to the next non-full page, adding a new page if necessary.</span></span><br><span class="line">    <span class="comment">// Then add the object to that page.</span></span><br><span class="line">    ASSERT(page == hotPage());</span><br><span class="line">    ASSERT(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致逻辑：</p>
<ol>
<li><p>从当前page开始沿着双链表往后查找，直到查找到一个未满的page。如果查找到末尾也没有则新创建一个page。</p>
</li>
<li><p>设置page为hotPage。</p>
</li>
<li>将obj添加到page上。</li>
</ol>
<p>由此可以看到如果注册的对象特别多，那么一个自动释放池可以横跨很多个page。</p>
<p>接着分析autoreleaseNoPage：</p>
<h3 id="autoreleaseNoPage"><a href="#autoreleaseNoPage" class="headerlink" title="autoreleaseNoPage"></a>autoreleaseNoPage</h3><p>没有自动释放池页的处理，需要加载一个。</p>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __attribute__((noinline))</span><br><span class="line">id *<span class="title function_">autoreleaseNoPage</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// &quot;No page&quot; could mean no pool has been pushed</span></span><br><span class="line">    <span class="comment">// or an empty placeholder pool has been pushed and has no contents yet</span></span><br><span class="line">    ASSERT(!hotPage());</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> pushExtraBoundary = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        <span class="comment">// We are pushing a second pool over the empty placeholder pool</span></span><br><span class="line">        <span class="comment">// or pushing the first object into the empty placeholder pool.</span></span><br><span class="line">        <span class="comment">// Before doing that, push a pool boundary on behalf of the pool </span></span><br><span class="line">        <span class="comment">// that is currently represented by the empty placeholder.</span></span><br><span class="line">        pushExtraBoundary = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        <span class="comment">// We are pushing an object with no pool in place, </span></span><br><span class="line">        <span class="comment">// and no-pool debugging was requested by environment.</span></span><br><span class="line">        _objc_inform(<span class="string">&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span></span><br><span class="line">                     <span class="string">&quot;autoreleased with no pool in place - &quot;</span></span><br><span class="line">                     <span class="string">&quot;just leaking - break on &quot;</span></span><br><span class="line">                     <span class="string">&quot;objc_autoreleaseNoPool() to debug&quot;</span>, </span><br><span class="line">                     objc_thread_self(), (<span class="type">void</span>*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</span><br><span class="line">        <span class="comment">// We are pushing a pool with no pool in place,</span></span><br><span class="line">        <span class="comment">// and alloc-per-pool debugging was not requested.</span></span><br><span class="line">        <span class="comment">// Install and return the empty pool placeholder.</span></span><br><span class="line">        <span class="keyword">return</span> setEmptyPoolPlaceholder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are pushing an object or a non-placeholder&#x27;d pool.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the first page.</span></span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span></span><br><span class="line">    <span class="keyword">if</span> (pushExtraBoundary) &#123;</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push the requested object or pool.</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">haveEmptyPoolPlaceholder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    id *tls = (id *)tls_get_direct(key);</span><br><span class="line">    <span class="keyword">return</span> (tls == EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> id* <span class="title function_">setEmptyPoolPlaceholder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(tls_get_direct(key) == nil);</span><br><span class="line">    tls_set_direct(key, (<span class="type">void</span> *)EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">return</span> EMPTY_POOL_PLACEHOLDER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑也很简单：</p>
<ol>
<li>调用haveEmptyPoolPlaceholder，先判断TLS中存储的是否等于EMPTY_POOL_PLACEHOLDER。</li>
<li>如果等于EMPTY_POOL_PLACEHOLDER，说明可以创建第一个page了。</li>
<li>创建一个page，并设置为hotPage。</li>
<li>如果是第一个page则还需要添加POOL_BOUNDARY用于pop的停止标志。</li>
<li>添加obj到page上</li>
<li>接第一步如果不等于EMPTY_POOL_PLACEHOLDER，说明当前双链表为空没有page。如果obj等于POOL_BOUNDARY，则走 <code>else if (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation)</code> 分支，调用setEmptyPoolPlaceholder往TLS上写入占位符EMPTY_POOL_PLACEHOLDER并返回EMPTY_POOL_PLACEHOLDER，第一次push的时候走的就是这里。接下来是比较特殊的一种情况，如果obj不等于POOL_BOUNDARY 生产环境下代码并不会走 <code>else if (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools)</code> 分支，因此会创建一个page，并将对象添加到page上，只不过这种情况下不会有哨兵对象。没有哨兵对象会不会出问题呢？从后续的pop方法可以看到不会有问题。</li>
</ol>
<h4 id="setEmptyPoolPlaceholder"><a href="#setEmptyPoolPlaceholder" class="headerlink" title="setEmptyPoolPlaceholder"></a>setEmptyPoolPlaceholder</h4><p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">haveEmptyPoolPlaceholder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    id *tls = (id *)tls_get_direct(key);</span><br><span class="line">    <span class="keyword">return</span> (tls == EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> id* <span class="title function_">setEmptyPoolPlaceholder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(tls_get_direct(key) == nil);</span><br><span class="line">    tls_set_direct(key, (<span class="type">void</span> *)EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">return</span> EMPTY_POOL_PLACEHOLDER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="autorelease—给对象发送一条autorelease消息"><a href="#autorelease—给对象发送一条autorelease消息" class="headerlink" title="autorelease—给对象发送一条autorelease消息"></a>autorelease—给对象发送一条autorelease消息</h3><p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> id <span class="title">autorelease</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(obj);</span><br><span class="line">    <span class="built_in">ASSERT</span>(!obj-&gt;<span class="built_in">isTaggedPointer</span>());</span><br><span class="line">    id *dest __unused = <span class="built_in">autoreleaseFast</span>(obj);</span><br><span class="line">    <span class="built_in">ASSERT</span>(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们给对象发送autorelease消息时，就是调用autoreleaseFast(obj)将对象添加到双链表上。注意没有retain操作。</p>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">pop</span><span class="params">(<span class="type">void</span> *token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="type">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">        page = <span class="built_in">hotPage</span>();</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setHotPage</span>(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">        <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">        page = <span class="built_in">coldPage</span>();</span><br><span class="line">        token = page-&gt;<span class="built_in">begin</span>(); <span class="comment">//coldPage是双链表的第一页，这里将token设置为begin位置。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        page = <span class="built_in">pageForPointer</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stop == page-&gt;<span class="built_in">begin</span>()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">            <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">            <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">            <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">badPop</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">popPageDebug</span>(token, page, stop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">popPage</span>&lt;<span class="literal">false</span>&gt;(token, page, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到整个过程如下：</p>
<ol>
<li>判断传入的token是否等于EMPTY_POOL_PLACEHOLDER，第一次push的时候就是EMPTY_POOL_PLACEHOLDER。</li>
<li>如果等于EMPTY_POOL_PLACEHOLDER，则获取hotPage，如果hotPag等于nil，则表明 <code>@autoreleasepool&#123;&#125;</code> 内没有使用到自动释放对象，优化成功。将TLS对应key置为nil退出。如果hotPag不等于nil，说明有使用到自动释放对象。则获取coldPage，及token。</li>
<li>接第一步如果传入的token不等于EMPTY_POOL_PLACEHOLDER（这种情况一般是嵌套了自动释放池，上面已经提及只有第一次push的时候才会返回EMPTY_POOL_PLACEHOLDER，后面再push的时候返回的将是page上的一个地址），则根据token找到它的那一个page。</li>
<li>判断token是否指向哨兵对象，一般情况下都会指向哨兵对象，但是也有一些特殊情况下不会指向哨兵对象。其中 <code>if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent)</code> 即token指向第一个对象并且page是第一页则可以正常popPage（比如没有先push操作就开始注册对象），其他情况就是badPop。</li>
<li>调用popPage开始释放。</li>
</ol>
<p>pop的主要逻辑其实是根据传入的token，找到token所在的那一个page。这个page+token就是本次释放的结束地点。</p>
<h4 id="Q：如何根据传入的token，找到token所在的那一个page？"><a href="#Q：如何根据传入的token，找到token所在的那一个page？" class="headerlink" title="Q：如何根据传入的token，找到token所在的那一个page？"></a>Q：如何根据传入的token，找到token所在的那一个page？</h4><p>这里稍微看一下如何根据token查找出token所在的page：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据token查找出token所在的page</span></span><br><span class="line"><span class="function"><span class="type">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pageForPointer</span>((<span class="type">uintptr_t</span>)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="type">uintptr_t</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *result;</span><br><span class="line">    <span class="type">uintptr_t</span> offset = p % SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT</span>(offset &gt;= <span class="built_in">sizeof</span>(AutoreleasePoolPage));</span><br><span class="line"></span><br><span class="line">    result = (AutoreleasePoolPage *)(p - offset);</span><br><span class="line">    result-&gt;<span class="built_in">fastcheck</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>result = p - (p % SIZE)；这就是token所在的page的地址。为什么可以这么计算？主要还是得益于内存对齐，page的起始地址肯定是SIZE的整数倍。这里不可谓不妙。</p>
<p>举个简单的例子验证一下：</p>
<p>假设第一页的地址为100，一页可以登记10个对象，问token为132所在的page的地址是多少？</p>
<p>因为第一页是100，那么第二页就是110，第三页就是120，第四页就是130，于是第四页的第二个位置就是132。因此132所在的page的地址就是130。</p>
<p>根据上面的算法 132 % 10 = 2，132-2 = 130。也可以得到130。</p>
<h4 id="Q：为啥要去查找token所在的page"><a href="#Q：为啥要去查找token所在的page" class="headerlink" title="Q：为啥要去查找token所在的page?"></a>Q：为啥要去查找token所在的page?</h4><p>这里不是很理解，我获取到hotPage后就开始清除，然后根据双链表一直往上清除，最终肯定会到达token所在的page的。感觉根本不需要先去查找token所在的page啊？</p>
<p>因为后续调用的releaseUntil是定义在AutoreleasePoolPage里的方法，而releaseUntil里的while条件是this-&gt;next != stop.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (this-&gt;next != stop) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this指代的是当前page，所以方法的对象只能是token所在的page，如果是其他的page那么停止的位置就不对了。</p>
<h3 id="popPage"><a href="#popPage" class="headerlink" title="popPage"></a>popPage</h3><p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="type">bool</span> allowDebug&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">popPage</span><span class="params">(<span class="type">void</span> *token, AutoreleasePoolPage *page, id *stop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (allowDebug &amp;&amp; PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="keyword">if</span> (allowDebug &amp;&amp; DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowDebug &amp;&amp; DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top)</span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123; <span class="comment">//前面的分支是debug用的，所以主要看这里</span></span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要是调用releaseUntil进行释放，释放之后当前page后面的page肯定是空的了，因此需要把后面的空page删除，直至剩一个空的page。</p>
<h3 id="releaseUntil"><a href="#releaseUntil" class="headerlink" title="releaseUntil"></a>releaseUntil</h3><p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">releaseUntil</span><span class="params">(id *stop)</span> </span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 注释很清楚：不使用递归是怕把栈给搞爆了，所以使用了循环。</span></span><br><span class="line">    <span class="comment">// Not recursive: we don&#x27;t want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">		</span><br><span class="line">    <span class="keyword">while</span> (this-&gt;next != stop) &#123; <span class="comment">//一直释放到stop的位置。</span></span><br><span class="line">        <span class="comment">// Restart from hotPage() every time, in case -release </span></span><br><span class="line">        <span class="comment">// autoreleased more objects</span></span><br><span class="line">        AutoreleasePoolPage *page = hotPage(); <span class="comment">//先获取hotPage.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme I think this `while` can be `if`, but I can&#x27;t prove it</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123; <span class="comment">//如果是空的，说明这一页已经清空，则继续往上找，最终page会等于this。随着释放this-&gt;next最终会等于stop.</span></span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        id obj = *--page-&gt;next; <span class="comment">//因为next指向的是下一个空的位置，所以这里要先--，移动到有注册对象的位置。</span></span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next)); <span class="comment">//将这一栏填充SCRIBBLE==0xA3</span></span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123; <span class="comment">//这里很妙，如果obj不是nil也会释放掉。因为有可能page里就没有POOL_BOUNDARY对象。不过这种情况一般不会出现，因为系统在新开线程的时候会帮你执行push操作所以基本上都会存在POOL_BOUNDARY对象。</span></span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setHotPage(this);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// we expect any children to be completely empty</span></span><br><span class="line">    <span class="keyword">for</span> (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123;</span><br><span class="line">        ASSERT(page-&gt;empty());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致逻辑：</p>
<ol>
<li>获取hotPage</li>
<li>然后从hotPage处开始一直释放注册到page上的对象，直到哨兵对象处结束。本次自动释放池的作用域结束。</li>
<li>设置当前page为hotPage。</li>
</ol>
<h3 id="autoreleasepool嵌套情况"><a href="#autoreleasepool嵌套情况" class="headerlink" title="autoreleasepool嵌套情况"></a>autoreleasepool嵌套情况</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@&quot;Hello, World!&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(@&quot;Hello, World!&quot;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(@&quot;Hello, World!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">void * atautoreleasepoolobj1 <span class="operator">=</span> objc_autoreleasePoolPush()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">void * atautoreleasepoolobj2 <span class="operator">=</span> objc_autoreleasePoolPush()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">void * atautoreleasepoolobj3 <span class="operator">=</span> objc_autoreleasePoolPush()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj3)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj2)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj1)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>pop atautoreleasepoolobj3时，就是从hotPage到POOL_BOUNDARY3截止，</p>
<p>pop atautoreleasepoolobj2时，就是从hotPage到POOL_BOUNDARY2截止，</p>
<p>pop atautoreleasepoolobj1时，就是从hotPage到POOL_BOUNDARY1截止。</p>
<p>应用程序启动时，主线程在进入runloop前会执行push操作创建好自动释放池，当退出runloop时就会执行pop操作销毁自动释放池。这里可以参考runloop原理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>稍微总结一下：</p>
<p>自动释放池底层是由一个双链表数据结构实现的，双链表的每一个元素被称为AutoreleasePoolPage，每个page可以注册一定数量的对象。在MRC时代我们可以给对象发送一条autorelease消息将其注册到自动释放池里，而在ARC时代我们可以将一个对象赋值给一个 <code>__autoreleasing</code> 修饰符的指针变量： <code>id __autoreleasing obj1 = obj;</code> 将其注册到自动释放池里。</p>
<p>而 <code>@autoreleasepool&#123;&#125;</code> 其实是push-pop对的语法糖：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do whatever you want</span></span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>push函数除第一次调用返回的是占位符外，后续调用返回的是page上的一个位置地址。第一次push时，系统并不会马上创建自动释放池，而是等到真正注册自动释放的对象时才创建。</p>
<p>pop函数就是将hotpage到哨兵对象之间的所有注册的对象清除并发送release消息释放对象。</p>
<p>在子线程中，系统会在创建线程时调用push，在线程销毁时调用pop，因此如果你没有显示创建自动释放池，那么在这期间产生的自动释放对象需要等到线程销毁时才会被释放，而这可能会造成内存峰值压力。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="Q0：MRC下给对象发送-autorelease消息会发生什么？"><a href="#Q0：MRC下给对象发送-autorelease消息会发生什么？" class="headerlink" title="Q0：MRC下给对象发送-autorelease消息会发生什么？"></a>Q0：MRC下给对象发送-autorelease消息会发生什么？</h4><p>调用栈：最终就是被注册到自动释放池里。注意这里并没有retain操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (id)autorelease &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAutorelease(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id </span><br><span class="line"><span class="title function_">objc_object::rootAutorelease2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> id *<span class="title function_">autoreleaseFast</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_mrc_autorelease &#123;</span><br><span class="line">    XQUser *user = [[XQUser alloc] initWithName:<span class="string">@&quot;李白&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%ld&quot;</span>, (<span class="type">long</span>)<span class="built_in">CFGetRetainCount</span>(user)); <span class="comment">//1</span></span><br><span class="line">    </span><br><span class="line">    [user autorelease];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%ld&quot;</span>, (<span class="type">long</span>)<span class="built_in">CFGetRetainCount</span>(user)); <span class="comment">//1</span></span><br><span class="line">    </span><br><span class="line">    [user autorelease];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%ld&quot;</span>, (<span class="type">long</span>)<span class="built_in">CFGetRetainCount</span>(user)); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终崩溃，因为过度释放。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在ARC中<code>__autoreleasing修饰符</code>,如果是创建一个对象并赋值给__autoreleasing 的指针变量，则仅仅是将对象注册到自动释放池。其他情况则会retain对象再注册到自动释放池中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">  id obj = [NSObject new];</span><br><span class="line">  &#123;</span><br><span class="line">    id __autoreleasing obj1 = obj; <span class="comment">//2</span></span><br><span class="line">    NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">id obj = msg_Send(NSObject, <span class="string">&quot;new&quot;</span>);</span><br><span class="line">id obj1 = objc_retainAutorelease(obj); <span class="comment">//retain对象+注册对象到自动释放池</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">objc_storeStrong(&amp;obj, nil);</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line"><span class="title function_">objc_retainAutorelease</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_autorelease(objc_retain(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Q1：如何获取创建的自动释放池？"><a href="#Q1：如何获取创建的自动释放池？" class="headerlink" title="Q1：如何获取创建的自动释放池？"></a>Q1：如何获取创建的自动释放池？</h4><p>自动释放池都是new出来的，获取的时候怎么找到这个自动释放池呢？从上面的代码可以看到new了一个自动释放池页后，会调用setHotPage(page);这个函数就是往线程的TLS上写入key（key=43）—page地址。这样下次我们只需要读取TLS上的key就可以得到当前正在使用的自动释放池页。系统内部会一直更新key的值，确保key始终指向当前正在使用的自动释放池页。有了hotPage的地址，再加上双链表就可以找到第一页coldPage的地址。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">static inline void <span class="built_in">setHotPage</span>(AutoreleasePoolPage *page) </span><br><span class="line">&#123;</span><br><span class="line">    if (page) <span class="attribute">page</span>-&gt;<span class="built_in">fastcheck</span>();</span><br><span class="line">    <span class="built_in">tls_set_direct</span>(key, (void *)<span class="attribute">page</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意一个线程只会有一个双链表自动释放池。push的作用：</p>
<p>1.懒加载page，如果此时还没有page或者page满了则会创建一个新的page链接在之前的双链表上，而不是创建另一个双链表。</p>
<p>2.返回一个token地址。</p>
<p>@autoreleasepool嵌套，只是返回不同的token地址。没有创建很多个自动释放池。</p>
<h4 id="Q2：在子线程中没有显示写-autoreleasepool-然后创建了自动释放对象，会造成内存泄漏吗？"><a href="#Q2：在子线程中没有显示写-autoreleasepool-然后创建了自动释放对象，会造成内存泄漏吗？" class="headerlink" title="Q2：在子线程中没有显示写 @autoreleasepool{} 然后创建了自动释放对象，会造成内存泄漏吗？"></a>Q2：在子线程中没有显示写 <code>@autoreleasepool&#123;&#125;</code> 然后创建了自动释放对象，会造成内存泄漏吗？</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)doSome &#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(test_child_thread_autorelease_obj_dealloc) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test_child_thread_autorelease_obj_dealloc &#123;</span><br><span class="line">    __autoreleasing Animal *ani = [[Animal alloc] init];</span><br><span class="line">    [ani eat];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用NSThread创建的线程或者使用gcd，使用pthread等里都不会。基本上使用苹果的框架都不会。</p>
<p>NSAutoreleasePool的说明：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Each thread (including <span class="keyword">the</span> main thread) maintains its own stack <span class="keyword">of</span> NSAutoreleasePool objects (see Threads). As <span class="built_in">new</span> pools are created, they <span class="built_in">get</span> added <span class="built_in">to</span> <span class="keyword">the</span> top <span class="keyword">of</span> <span class="keyword">the</span> stack. When pools are deallocated, they are removed <span class="built_in">from</span> <span class="keyword">the</span> stack. Autoreleased objects are placed <span class="keyword">into</span> <span class="keyword">the</span> top autorelease pool <span class="keyword">for</span> <span class="keyword">the</span> current thread. When <span class="keyword">a</span> thread terminates, <span class="keyword">it</span> automatically drains all <span class="keyword">of</span> <span class="keyword">the</span> autorelease pools associated <span class="keyword">with</span> itself.</span><br></pre></td></tr></table></figure>
<p>在runtime加载时会调用AutoreleasePoolPage的静态方法init进行初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">arr_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::init();</span><br><span class="line">    SideTablesMap.init();</span><br><span class="line">    _objc_associations_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动释放池的init：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="comment">//静态方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r __unused = pthread_key_init_np(AutoreleasePoolPage::key, </span><br><span class="line">                                         AutoreleasePoolPage::tls_dealloc);</span><br><span class="line">    ASSERT(r == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !VARIANT_DYLD</span></span><br><span class="line"><span class="comment">// <span class="doctag">XXX:</span> key should be pthread_key_t</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pthread_key_init_np</span><span class="params">(<span class="type">int</span> key, <span class="type">void</span> (*destructor)(<span class="type">void</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = EINVAL; <span class="comment">// Returns EINVAL if key is out of range.</span></span><br><span class="line">	<span class="keyword">if</span> (key &gt;= __pthread_tsd_first &amp;&amp; key &lt; __pthread_tsd_start) &#123;</span><br><span class="line">		_PTHREAD_LOCK(__pthread_tsd_lock);</span><br><span class="line">		_pthread_key_set_destructor(key, destructor);</span><br><span class="line">		<span class="keyword">if</span> (key &gt; __pthread_tsd_max) &#123;</span><br><span class="line">			__pthread_tsd_max = key;</span><br><span class="line">		&#125;</span><br><span class="line">		_PTHREAD_UNLOCK(__pthread_tsd_lock);</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !VARIANT_DYLD</span></span></span><br></pre></td></tr></table></figure>
<p>绑定了一个key—tls_dealloc，线程退出时会执行tls_dealloc。</p>
<p>线程退出时会进行一些清理工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PTHREAD_NORETURN</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_pthread_exit(<span class="type">pthread_t</span> self, <span class="type">void</span> *exit_value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">darwin_pthread_handler_rec</span> *<span class="title">handler</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable signal delivery while we clean up</span></span><br><span class="line">	__disable_threadsignal(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set cancel state to disable and type to deferred</span></span><br><span class="line">	_pthread_setcancelstate_exit(self, exit_value);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((handler = self-&gt;__cleanup_stack) != <span class="number">0</span>) &#123;</span><br><span class="line">		(handler-&gt;__routine)(handler-&gt;__arg);</span><br><span class="line">		self-&gt;__cleanup_stack = handler-&gt;__next;</span><br><span class="line">	&#125;</span><br><span class="line">	_pthread_tsd_cleanup(self); <span class="comment">//清除tsd</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear per-thread semaphore cache</span></span><br><span class="line">	os_put_cached_semaphore(SEMAPHORE_NULL);</span><br><span class="line"></span><br><span class="line">	_pthread_terminate_invoke(self, exit_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中一个就是_pthread_tsd_cleanup：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_pthread_tsd_cleanup(<span class="type">pthread_t</span> self)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !VARIANT_DYLD</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// unless __pthread_key_legacy_behaviour == 1, use the new pthread key</span></span><br><span class="line">	<span class="comment">// destructor order: (dynamic -&gt; static) x5 -&gt; (GC x5)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__pthread_key_legacy_behaviour == <span class="number">0</span>) &#123;</span><br><span class="line">		_pthread_tsd_cleanup_new(self);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_pthread_tsd_cleanup_legacy(self);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !VARIANT_DYLD</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_pthread_tsd_cleanup_new(<span class="type">pthread_t</span> self)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clean up all keys</span></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; PTHREAD_DESTRUCTOR_ITERATIONS; j++) &#123;</span><br><span class="line">		<span class="type">pthread_key_t</span> k;</span><br><span class="line">		<span class="keyword">for</span> (k = __pthread_tsd_start; k &lt;= self-&gt;max_tsd_key; k++) &#123;</span><br><span class="line">			_pthread_tsd_cleanup_key(self, k);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (k = __pthread_tsd_first; k &lt;= __pthread_tsd_max; k++) &#123;</span><br><span class="line">			_pthread_tsd_cleanup_key(self, k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self-&gt;max_tsd_key = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_pthread_tsd_cleanup_key(<span class="type">pthread_t</span> self, <span class="type">pthread_key_t</span> key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> (*destructor)(<span class="type">void</span> *);</span><br><span class="line">	<span class="keyword">if</span> (_pthread_key_get_destructor(key, &amp;destructor)) &#123;</span><br><span class="line">		<span class="type">void</span> **ptr = &amp;self-&gt;tsd[key];</span><br><span class="line">		<span class="type">void</span> *value = *ptr;</span><br><span class="line">		<span class="keyword">if</span> (value) &#123;</span><br><span class="line">			*ptr = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (destructor) &#123; <span class="comment">//其中一个就是tls_dealloc</span></span><br><span class="line">				destructor(value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会调用自动释放池的tls_dealloc：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tls_dealloc</span><span class="params">(<span class="type">void</span> *p)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == (<span class="type">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">// No objects or pool pages to clean up here.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reinstate TLS value while we work</span></span><br><span class="line">    setHotPage((AutoreleasePoolPage *)p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AutoreleasePoolPage *page = coldPage()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!page-&gt;empty()) objc_autoreleasePoolPop(page-&gt;begin());  <span class="comment">// pop all of the pools</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(DebugMissingPools || DebugPoolAllocation)) &#123;</span><br><span class="line">            <span class="comment">// pop() killed the pages already</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            page-&gt;kill();  <span class="comment">// free all of the pages</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear TLS value so TLS destruction doesn&#x27;t loop</span></span><br><span class="line">    setHotPage(nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用objc_autoreleasePoolPop将其中的对象释放掉。</p>
<p>这里还有一个关键点，与objc_autoreleasePoolPop相对应的objc_autoreleasePoolPush是什么时候调用的？</p>
<p>我们可以打断点查看一下：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200917095746.png" style="zoom:50%;" /></p>
<p>可以看到在子线程启动的时候系统内部会执行objc_autoreleasePoolPush，帮你创建好一个自动释放池。所以即使在子线程里不显式使用 <code>@autorelease&#123;&#125;</code> ，创建的自动释放对象最终也会销毁，但是需要等到线程退出时才会进行。所以最好还是创建自己的自动释放池。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1、C++中结构体可以继承类，而类也可以继承结构体（多少有点震惊），这时的访问权限取决于子类或子结构体而非父类或父结构体。</p>
<p>例如：</p>
<p>struct A {};</p>
<p>struct B : A {}; //public继承</p>
<p>class C : A {}; //private继承</p>
<p>2、C++对象的创建：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">   	&#123;</span><br><span class="line">    	 <span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">        <span class="built_in">MyStruct</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;初始化\n&quot;</span>;&#125;</span><br><span class="line">        ~<span class="built_in">MyStruct</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;销毁\n&quot;</span>;&#125;</span><br><span class="line">    	 &#125;;</span><br><span class="line">    	 <span class="keyword">struct</span> <span class="title class_">MyStruct</span> sd; <span class="comment">//这里就已经分配栈内存了。初始化方法也会调用(多少有点震惊)。类似于int a;</span></span><br><span class="line">   	&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">Hello, World!</span><br><span class="line">初始化</span><br><span class="line">销毁</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://aevit.xyz/2017/03/12/iOS-autorelease/">iOS 自动释放池原理探究</a></p>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>
<p><a href="https://draveness.me/autoreleasepool#">自动释放池的前世今生 —— 深入解析 autoreleasepool</a></p>
<p><a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=occ">NSAutoreleasePool</a></p>
<p><a href="https://www.jianshu.com/p/7bd2f85f03dc">iOS内存管理-深入解析自动释放池</a>  挺不错的</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>OC atomic修饰符</title>
    <url>/2020/06/06/OC-atomic%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>源码版本：objc4-781，<code>objc-accessors.mm</code>文件中。</p>
<p>原子操作是指操作是不可分割的，要么发生，要么不发生。事物只会处于原始状态和成功状态两种中的一种，不会处于一种半完成状态。</p>
<h3 id="OC-中的atomic修饰符"><a href="#OC-中的atomic修饰符" class="headerlink" title="OC 中的atomic修饰符"></a>OC 中的atomic修饰符</h3><p>源码实现：</p>
<p>getter 方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getProperty</span><span class="params">(id self, SEL _cmd, <span class="type">ptrdiff_t</span> offset, BOOL atomic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object_getClass</span>(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    id *slot = (id*) ((<span class="type">char</span>*)self + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    <span class="type">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.<span class="built_in">lock</span>();</span><br><span class="line">    id value = <span class="built_in">objc_retain</span>(*slot); <span class="comment">//+1</span></span><br><span class="line">    slotlock.<span class="built_in">unlock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">objc_autoreleaseReturnValue</span>(value); <span class="comment">//注册到自动释放池中，延迟-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于none atomic属性，getter方法只是简单的返回对象地址。<br>对于atomic属性，getter方法会加锁进行retain操作，并返回一个注册到自动释放池里的对象地址。这样就可以防止getter的对象不会因为其他线程的setter操作导致销毁。</p>
<p>setter 方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">reallySetProperty</span><span class="params">(id self, SEL _cmd, id newValue, <span class="type">ptrdiff_t</span> offset, <span class="type">bool</span> atomic, <span class="type">bool</span> copy, <span class="type">bool</span> mutableCopy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">object_setClass</span>(self, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((<span class="type">char</span>*)self + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = <span class="built_in">objc_retain</span>(newValue); <span class="comment">//retain新值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot; <span class="comment">//获取旧值</span></span><br><span class="line">        *slot = newValue; <span class="comment">//赋予新值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.<span class="built_in">lock</span>();  </span><br><span class="line">        oldValue = *slot; <span class="comment">//</span></span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">objc_release</span>(oldValue); <span class="comment">//release 旧值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_setProperty_atomic</span><span class="params">(id self, SEL _cmd, id newValue, <span class="type">ptrdiff_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reallySetProperty</span>(self, _cmd, newValue, offset, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_setProperty_nonatomic</span><span class="params">(id self, SEL _cmd, id newValue, <span class="type">ptrdiff_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reallySetProperty</span>(self, _cmd, newValue, offset, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_setProperty_atomic_copy</span><span class="params">(id self, SEL _cmd, id newValue, <span class="type">ptrdiff_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reallySetProperty</span>(self, _cmd, newValue, offset, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_setProperty_nonatomic_copy</span><span class="params">(id self, SEL _cmd, id newValue, <span class="type">ptrdiff_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reallySetProperty</span>(self, _cmd, newValue, offset, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述锁从何而来：从objc-accessors.mm中定义的全局PropertyLocks哈希表中获取。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">StripedMap&lt;spinlock_t&gt; PropertyLocks<span class="comment">;</span></span><br><span class="line">StripedMap&lt;spinlock_t&gt; StructLocks<span class="comment">;</span></span><br><span class="line">StripedMap&lt;spinlock_t&gt; CppObjectLocks<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看到使用atomic修饰的属性，编译器在合成getter/setter方法时，相比于nonatomic的属性会有额外的处理：</p>
<ol>
<li>加锁（自旋锁），保证原子性。其他线程需要等待。</li>
<li>getter方法获取到对象后会先retain再注册到自动释放池里最后返回给调用者，确保调用者获取到的对象生命周期不受后续setter影响。</li>
</ol>
<p><strong>atomic保证了赋值/取值的整个过程的完整性，并且不受其他线程的干扰</strong>。比如线程A在setter时，线程B如果想setter那么就需要等待，线程C想getter也需要等待。</p>
<p>再来看一下使用nonatomic在多线程环境下，下面的场景会出现什么问题：</p>
<p>1、A，B线程同时调用setter方法会怎样。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line"><span class="number">1</span>    oldValue = *slot; <span class="comment">//获取旧值</span></span><br><span class="line"><span class="number">2</span>    *slot = newValue; <span class="comment">//赋予新值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.<span class="built_in">lock</span>();  </span><br><span class="line">    oldValue = *slot; <span class="comment">//</span></span><br><span class="line">    *slot = newValue;        </span><br><span class="line">    slotlock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="built_in">objc_release</span>(oldValue); <span class="comment">//release 旧值</span></span><br></pre></td></tr></table></figure>
<p>A，B同时执行1，因此获得了同一个旧值对象，然后各自执行2因此属性的值是不确定的（这里倒没有什么致命关系），最后执行3，于是一个对象被释放了两次，这有可能会导致野指针崩溃。而atomic有加锁保护所以不会有问题。</p>
<p>2、线程A调用getter方法获得对象地址，在对象使用期间，线程B调用setter方法，会怎样？</p>
<p>getter方法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id <span class="title function_">objc_getProperty</span><span class="params">(id self, SEL _cmd, <span class="type">ptrdiff_t</span> offset, BOOL atomic)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    id *slot = (id*) ((<span class="type">char</span>*)self + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    <span class="type">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    id value = objc_retain(*slot); <span class="comment">//+1</span></span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于nonatomic，getter方法获取到旧值后只是简单返回。上述情况nonatomic可能会因为线程B调用setter方法释放旧值而造成线程A潜在的野指针访问崩溃风险。而atomic会先retain再注册到自动释放池里最后返回给调用者，因此不会存在这种风险。</p>
<p>iOS12.5.4 iPhone6plus</p>
<p>例1：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/image-20210930112832606.png" alt=""></p>
<p>例2：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20210930112345.png" alt=""></p>
<p>这些都是野指针崩溃，访问了已经销毁的对象。</p>
<p>因此如果属性存在多线程访问的情况，应该使用atomic并使用存取器访问实例变量，如果有需要还应该配合锁使用。</p>
<p>注意：atomic无法保证对象自身的线程安全。</p>
<p>官方文档对atomic无法保证对象的线程安全举的例子：</p>
<p>考虑XYZPerson，拥有firstName和lastName两个atomic属性。如果一个线程A正在修改这两个属性，与此同时另一个线程B正在读取这两个属性，那么线程B得到的firstName和lastName的值将会发生数据不匹配的情况。这虽然不会导致崩溃问题，但结果是不符合预期的。</p>
<p>eg：</p>
<p>初始时, firstName = @”李”;  lastName = @”四”;</p>
<p>线程A想修改为：firstName = @”张”;  lastName = @”三”;</p>
<p>与此同时线程B在读取这两个属性，那么线程B有可能得到：</p>
<p>张四，李三。</p>
<p>要想解决的话就应该把<code>firstName = @&quot;张&quot;;  lastName = @&quot;三&quot;;</code>这一段代码也加锁。</p>
<p>另外一个例子：经典的i++问题。</p>
<p>i++对应的汇编：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x100368d83</span> &lt;<span class="number">+19</span>&gt;: movl   <span class="number">-0</span><span class="keyword">x</span><span class="number">14</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%eax</span></span><br><span class="line"><span class="number">0x100368d86</span> &lt;<span class="number">+22</span>&gt;: addl   $<span class="number">0x1</span><span class="punctuation">,</span> <span class="variable">%eax</span></span><br><span class="line"><span class="number">0x100368d89</span> &lt;<span class="number">+25</span>&gt;: movl   <span class="variable">%eax</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">14</span>(<span class="variable">%rbp</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，完成一次<code>i++</code>总共分为三步：</p>
<ul>
<li>从内存中取出<code>i</code>的值存放到寄存器上</li>
<li>对寄存器的值<code>+1</code></li>
<li>将寄存器中的值存放回<code>i</code>的内存</li>
</ul>
<p>由于需要三条指令，因此在多线程中是不安全的。比如线程A在执行第二步时，线程B刚好在执行第一步，此时线程 B 获取到的将是旧的值，最终i的值将只加了一次。</p>
<p>再来看一下OC 中<code>self.i++;</code>的汇编，i 为 atomic 属性。</p>
<p>源码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_atomic_xiushi &#123;</span><br><span class="line">    <span class="keyword">self</span>.i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multithreadDemo`-[XQLockViewController test_atomic_xiushi]:</span><br><span class="line">    0x101c90d60 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x101c90d61 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x101c90d64 &lt;+4&gt;:  subq   $0x20, %rsp</span><br><span class="line">    0x101c90d68 &lt;+8&gt;:  movq   %rdi, -0x8(%rbp)</span><br><span class="line">    0x101c90d6c &lt;+12&gt;: movq   %rsi, -0x10(%rbp)</span><br><span class="line">    0x101c90d70 &lt;+16&gt;: movq   -0x8(%rbp), %rax</span><br><span class="line">    0x101c90d74 &lt;+20&gt;: movq   0x155f5(%rip), %rsi       ; &quot;&#x27;i&#x27;&quot;</span><br><span class="line">    0x101c90d7b &lt;+27&gt;: movq   %rax, %rcx</span><br><span class="line">    0x101c90d7e &lt;+30&gt;: movq   %rcx, %rdi</span><br><span class="line">    0x101c90d81 &lt;+33&gt;: movq   %rax, -0x18(%rbp)</span><br><span class="line">    0x101c90d85 &lt;+37&gt;: callq  *0xe2b5(%rip)             ; (void *)0x00000001025ec940: objc_msgSend   #调用objc_msgSend(self, &quot;i&quot;）</span><br><span class="line">    0x101c90d8b &lt;+43&gt;: addq   $0x1, %rax	#将寄存器中的值加 1</span><br><span class="line">    0x101c90d91 &lt;+49&gt;: movq   0x156c8(%rip), %rsi       ; &quot;setI:&quot;</span><br><span class="line">    0x101c90d98 &lt;+56&gt;: movq   -0x18(%rbp), %rcx</span><br><span class="line">    0x101c90d9c &lt;+60&gt;: movq   %rcx, %rdi</span><br><span class="line">    0x101c90d9f &lt;+63&gt;: movq   %rax, %rdx</span><br><span class="line">-&gt;  0x101c90da2 &lt;+66&gt;: callq  *0xe298(%rip)             ; (void *)0x00000001025ec940: objc_msgSend  #调用objc_msgSend(self, &quot;setI:&quot;, %rdx)</span><br><span class="line">    0x101c90da8 &lt;+72&gt;: addq   $0x20, %rsp</span><br><span class="line">    0x101c90dac &lt;+76&gt;: popq   %rbp</span><br><span class="line">    0x101c90dad &lt;+77&gt;: retq </span><br></pre></td></tr></table></figure>
<p>步骤：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.调用objc_msgSend(<span class="variable language_">self</span>, <span class="string">&quot;i&quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.执行addq   <span class="variable">$0x1</span>, %rax	<span class="comment">#将寄存器中的值加 1</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.调用objc_msgSend(<span class="variable language_">self</span>, <span class="string">&quot;setI:&quot;</span>, %rdx);</span><br></pre></td></tr></table></figure>
<p>跟上面的普通 i++其实是一样的，只不过这里 1，3 执行到 getter/setter 时都会加锁，但问题还是出在第 2 步。当线程 A 正在执行第2步还没来得及执行第 3 步将值写入内存时，线程 B 是可以执行第 1 步的，此时线程 B 将获取到旧的值。于是最终只加了一次。要想线程安全必须将 1，2，3都包在锁内 。</p>
<p>即：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">加锁</span></span><br><span class="line"><span class="comment">self</span><span class="string">.</span><span class="comment">i</span><span class="literal">++</span><span class="comment">;</span></span><br><span class="line"><span class="comment">解锁</span></span><br></pre></td></tr></table></figure>
<p>因此即使是atomic的属性也是不能保证上述代码是线程安全的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>atomic只是保证了设值/取值的过程是完整的，不受其他线程的干扰。它无法保证其他使用逻辑是线程安全的</strong>。</p>
<p>比如上面的i++操作。</p>
<p>场景： 使用<code>atomic</code>修饰属性，如果有A、B和C三个线程。其中A和B线程同时对一个属性进行赋值操作，C线程进行取值操作，那么可以保证C线程一定可以取到一个完整的值，但是这个值的内容可能是A线程赋的值，也可能是B线程赋的值，也可能是原始值，虽然取得了完整的值，但是这个值不一定是程序员想要的，所以说<code>atomic</code>并不是线程安全的，它只是保证了属性的setter和getter方法内部是线程安全的。如果你想要真正保证线程安全，那么需要在赋值操作的前后进行加锁和解锁操作，还有注意使用同一把锁。</p>
<p>有没有仅使用atomic就能够满足要求的场景？我想象不到，如果你只需要属性存取线程安全，或许仅使用atomic就可以了。比如上面使用atomic就可以避免多线程下的野指针问题。因此atomic的使用场景有限。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://sindrilin.com/2017/09/09/thread_safe.html">多线程-线程安全</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW37">Properties Are Atomic by Default</a>  官方文档</p>
<p><a href="https://juejin.cn/post/6844904072475049992">OC 基础之atomic和nonatomic关键字</a></p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>atomic</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 信号量使用篇</title>
    <url>/2020/06/06/iOS-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<h3 id="信号量使用篇"><a href="#信号量使用篇" class="headerlink" title="信号量使用篇"></a>信号量使用篇</h3><h4 id="操作GCD信号量的函数"><a href="#操作GCD信号量的函数" class="headerlink" title="操作GCD信号量的函数"></a>操作GCD信号量的函数</h4><p>在iOS中有三个函数可以操作GCD信号量：</p>
<p><code>dispatch_semaphore_t dispatch_semaphore_create(long value);</code> 创建一个信号量。</p>
<p><code>long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</code> 发送一个信号.</p>
<p><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</code> 等待一个信号。</p>
<h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h4><ol>
<li><p><code>dispatch_semaphore_t semaphoreTask1 = dispatch_semaphore_create(0);</code><br>创建一个信号量，并赋予初始值(必须传一个&gt;=0的值)。eg：传入2则表示同时最多两个线程可以访问临界区。</p>
</li>
<li><p><code>long signalRs = dispatch_semaphore_signal(semaphoreTask1);</code><br>发出一个信号，将信号量加1。如果之前的信号量小于0，说明有等待dispatch semaphore的计数值增加的线程，那么该函数在返回前将唤醒最先处于等待状态的线程。</p>
<p>返回值：This function returns non-zero if a thread is woken. Otherwise, zero is returned。如果有线程被唤醒则返回一个非0值，否则返回0。</p>
</li>
<li><p><code>long waitRs = dispatch_semaphore_wait(semaphoreTask1, DISPATCH_TIME_FOREVER);</code><br>将信号量-1。减去1后如果得到的值<0，则该函数在返回前将一直等待信号的发出，线程会被阻塞。减去1后如果得到的值>=0，则正常返回0，不阻塞线程。</p>
<p> timeout：指定等待的时间。如果线程要被阻塞该值表明将阻塞该线程多久。传DISPATCH_TIME_FOREVER意味着该线程永久等待一个信号的发出。 传一个其他值如：dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC))，表明将阻塞该线程2s，2s后函数将返回，线程继续执行（不一定就是执行临界区的代码，可以判断如果返回的是非0表明是等待超时了可以做其他处理）。</p>
<p>返回值：Returns zero on success, or non-zero if the timeout occurred。</p>
</li>
</ol>
<p>eg:使用信号量控制多线程添加数组元素。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)testSemaphoreLock &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arr = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.semaphoreLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程：%@ 执行  i = %d&quot;</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">            <span class="type">long</span> waitRs = dispatch_semaphore_wait(<span class="keyword">self</span>.semaphoreLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程：%@，dispatch_semaphore_wait:%ld&quot;</span>, [<span class="built_in">NSThread</span> currentThread], waitRs);</span><br><span class="line">            <span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:i];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程：%@，将要添加：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread], number);</span><br><span class="line">            [arr addObject:number];</span><br><span class="line">            <span class="type">long</span> signalRs = dispatch_semaphore_signal(<span class="keyword">self</span>.semaphoreLock);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程：%@，dispatch_semaphore_signal:%ld&quot;</span>, [<span class="built_in">NSThread</span> currentThread], signalRs);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;count:%ld, %@&quot;</span>,arr.count, arr);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.043402</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993600</span>] 线程：&lt;NSThread: <span class="number">0</span>x6<span class="number">04000468580</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 执行  i = <span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.043669</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993602</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400046df80&gt;&#123;number = <span class="number">4</span>, name = (null)&#125; 执行  i = <span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.043674</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993599</span>] 线程：&lt;NSThread: <span class="number">0</span>x<span class="number">604000861180</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125; 执行  i = <span class="number">2</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.043764</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993601</span>] 线程：&lt;NSThread: <span class="number">0</span>x60<span class="number">40008688c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125; 执行  i = <span class="number">3</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.043824</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993710</span>] 线程：&lt;NSThread: <span class="number">0</span>x6<span class="number">00000476f80</span>&gt;&#123;number = <span class="number">7</span>, name = (null)&#125; 执行  i = <span class="number">4</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.043892</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993711</span>] 线程：&lt;NSThread: <span class="number">0</span>x60<span class="number">00004771c0</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125; 执行  i = <span class="number">5</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.043892</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993712</span>] 线程：&lt;NSThread: <span class="number">0</span>x604<span class="number">00086a3c0</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125; 执行  i = <span class="number">6</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26:02.044138</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993600</span>] 线程：&lt;NSThread: <span class="number">0</span>x6<span class="number">04000468580</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.044284</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993713</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aa00&gt;&#123;number = <span class="number">10</span>, name = (null)&#125; 执行  i = <span class="number">7</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.044389</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993715</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aa40&gt;&#123;number = <span class="number">12</span>, name = (null)&#125; 执行  i = <span class="number">9</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.044352</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993714</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aac0&gt;&#123;number = <span class="number">11</span>, name = (null)&#125; 执行  i = <span class="number">8</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.045823</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993600</span>] 线程：&lt;NSThread: <span class="number">0</span>x6<span class="number">04000468580</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;，将要添加：<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.047405</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993600</span>] 线程：&lt;NSThread: <span class="number">0</span>x6<span class="number">04000468580</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.047405</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993602</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400046df80&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.049837</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993602</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400046df80&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;，将要添加：<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.050684</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993602</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400046df80&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.050684</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993599</span>] 线程：&lt;NSThread: <span class="number">0</span>x<span class="number">604000861180</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26:02.051183</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993599</span>] 线程：&lt;NSThread: <span class="number">0</span>x<span class="number">604000861180</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;，将要添加：<span class="number">2</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.055352</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993599</span>] 线程：&lt;NSThread: <span class="number">0</span>x<span class="number">604000861180</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.055352</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993601</span>] 线程：&lt;NSThread: <span class="number">0</span>x60<span class="number">40008688c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.055915</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993601</span>] 线程：&lt;NSThread: <span class="number">0</span>x60<span class="number">40008688c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;，将要添加：<span class="number">3</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.056057</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993601</span>] 线程：&lt;NSThread: <span class="number">0</span>x60<span class="number">40008688c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.056091</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993710</span>] 线程：&lt;NSThread: <span class="number">0</span>x6<span class="number">00000476f80</span>&gt;&#123;number = <span class="number">7</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.056829</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993710</span>] 线程：&lt;NSThread: <span class="number">0</span>x6<span class="number">00000476f80</span>&gt;&#123;number = <span class="number">7</span>, name = (null)&#125;，将要添加：<span class="number">4</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.057543</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993710</span>] 线程：&lt;NSThread: <span class="number">0</span>x6<span class="number">00000476f80</span>&gt;&#123;number = <span class="number">7</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.057543</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993711</span>] 线程：&lt;NSThread: <span class="number">0</span>x60<span class="number">00004771c0</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.058272</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993711</span>] 线程：&lt;NSThread: <span class="number">0</span>x60<span class="number">00004771c0</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;，将要添加：<span class="number">5</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.058587</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993712</span>] 线程：&lt;NSThread: <span class="number">0</span>x604<span class="number">00086a3c0</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.058612</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993711</span>] 线程：&lt;NSThread: <span class="number">0</span>x60<span class="number">00004771c0</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.058969</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993712</span>] 线程：&lt;NSThread: <span class="number">0</span>x604<span class="number">00086a3c0</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;，将要添加：<span class="number">6</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.059605</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993712</span>] 线程：&lt;NSThread: <span class="number">0</span>x604<span class="number">00086a3c0</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.059675</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993713</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aa00&gt;&#123;number = <span class="number">10</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.060750</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993713</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aa00&gt;&#123;number = <span class="number">10</span>, name = (null)&#125;，将要添加：<span class="number">7</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.061001</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993713</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aa00&gt;&#123;number = <span class="number">10</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.061034</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993714</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aac0&gt;&#123;number = <span class="number">11</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.061310</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993714</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aac0&gt;&#123;number = <span class="number">11</span>, name = (null)&#125;，将要添加：<span class="number">8</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.061667</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993714</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aac0&gt;&#123;number = <span class="number">11</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">1</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.061686</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993715</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aa40&gt;&#123;number = <span class="number">12</span>, name = (null)&#125;，dispatch_semaphore_wait:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26:02.062198</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993715</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aa40&gt;&#123;number = <span class="number">12</span>, name = (null)&#125;，将要添加：<span class="number">9</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02.062506</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993715</span>] 线程：&lt;NSThread: <span class="number">0</span>x60400086aa40&gt;&#123;number = <span class="number">12</span>, name = (null)&#125;，dispatch_semaphore_signal:<span class="number">0</span></span><br><span class="line"><span class="number">2020-06-04</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">07.043709</span>+<span class="number">0800</span> multithreadDemo[<span class="number">71599</span>:<span class="number">7993539</span>] count:<span class="number">10</span>, (</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>,</span><br><span class="line">    <span class="number">5</span>,</span><br><span class="line">    <span class="number">6</span>,</span><br><span class="line">    <span class="number">7</span>,</span><br><span class="line">    <span class="number">8</span>,</span><br><span class="line">    <span class="number">9</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>从打印可以看到dispatch_semaphore_create(1)保证了同一时刻仅有一个线程可以访问临界区。不过上述数组中添加的元素顺序不是依次的。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>进行线程同步、控制线程的并发数量。</p>
<p>eg：控制网络请求的执行顺序。</p>
<blockquote>
<p>Q：想让请求1完成之后，再进行网络请求2，然后进行网络请求N，要求不能阻塞主线程。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)testSemaphoreLock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;currentThread:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> requestSomethingWithN:<span class="number">40</span> completion:^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;40 rs = %ld&quot;</span>, (<span class="type">long</span>)result);</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;===1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//阻塞住子线程</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;===2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> requestSomethingWithN:<span class="number">41</span> completion:^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;41 rs = %ld&quot;</span>, (<span class="type">long</span>)result);</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;===3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;===4&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> requestSomethingWithN:<span class="number">42</span> completion:^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;42 rs = %ld&quot;</span>, (<span class="type">long</span>)result);</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过上面的情景也可以直接在请求完成block里再发起请求，信号量都不需要了。可以看一个稍微复杂点的：</p>
<blockquote>
<p>Q：请求A和请求B同时发起，但需要二者都完成后再发起请求C。要求不能阻塞主线程，仅使用信号量完成。</p>
</blockquote>
<p>这个如果使用dispatch_group_notify再配合<code>dispatch_group_enter/leave</code>就很简单，但如果仅使用信号量该怎么实现呢？</p>
<p>只需要在请求C发起前，wait两次阻塞住子线程，请求AB完成后发出信号即可。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)testSemaphoreLock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;currentThread:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        __block <span class="built_in">NSInteger</span> rs1 = <span class="number">0</span>;</span><br><span class="line">        [<span class="keyword">self</span> requestSomethingWithN:<span class="number">40</span> completion:^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">            rs1 = result;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;40 rs = %ld&quot;</span>, (<span class="type">long</span>)result);</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        __block <span class="built_in">NSInteger</span> rs2 = <span class="number">0</span>;</span><br><span class="line">        [<span class="keyword">self</span> requestSomethingWithN:<span class="number">41</span> completion:^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">            rs2 = result;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;41 rs = %ld&quot;</span>, (<span class="type">long</span>)result);</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;===1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;===2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;===3&quot;</span>);</span><br><span class="line">        [<span class="keyword">self</span> requestSomethingWithN:<span class="number">42</span> completion:^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;42 rs = %ld&quot;</span>, (<span class="type">long</span>)result);</span><br><span class="line">            <span class="built_in">NSInteger</span> total = rs1 + rs2 + result;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;total：%ld&quot;</span>, (<span class="type">long</span>)total);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>dispatch_semaphore_signal() 与 dispatch_semaphore_wait() 必须配对使用，否则在信号量销毁时容易导致<code>EXC_BAD_INSTRUCTION</code>崩溃。</li>
</ul>
<h4 id="释疑"><a href="#释疑" class="headerlink" title="释疑"></a>释疑</h4><p><strong>1. 信号量会减为负数吗？会减为-2，-3…吗？</strong></p>
<p>结论：会，如果很多线程调用wait的话，信号量的值会一直减。但对于wait超时返回的情况，系统会进行+1操作。</p>
<p>以前一直以为信号量减到0就不会再减了，其实不然。</p>
<p>通过po可以查看信号量的值：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">(lldb) po self.semaphoreLock</span><br><span class="line"><span class="tag">&lt;<span class="name">OS_dispatch_semaphore:</span> <span class="attr">semaphore</span>[<span class="attr">0x6000024960d0</span>] = <span class="string">&#123;</span> <span class="attr">xref</span> = <span class="string">4,</span> <span class="attr">ref</span> = <span class="string">1,</span> <span class="attr">port</span> = <span class="string">0x2403,</span> <span class="attr">value</span> = <span class="string">-3,</span> <span class="attr">orig</span> = <span class="string">1</span> &#125;&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以设计一个测试代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.semaphoreLock = dispatch_semaphore_create(<span class="number">1</span>); </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;---&quot;</span>);    <span class="comment">//这里po时，value = 1</span></span><br><span class="line">dispatch_semaphore_wait(<span class="keyword">self</span>.semaphoreLock, DISPATCH_TIME_FOREVER); </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;---&quot;</span>);    <span class="comment">//这里po时，value = 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * i * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">        dispatch_semaphore_wait(<span class="keyword">self</span>.semaphoreLock, time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;---&quot;</span>); <span class="comment">//这里po时，value = -3，因为上面减了三次。</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">12</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;---&quot;</span>); <span class="comment">//这里po时，由于上面三次wait超时，系统自动+1三次，所以最终value = 0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>理解了信号的实现原理，上述代码就很容易理解。</p>
<p><strong>2. dispatch_semaphore_signal() 与 dispatch_semaphore_wait() 不配对会导致什么问题？</strong></p>
<p>从底层实现来看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal时的判断</span><br><span class="line"><span class="keyword">if</span> (unlikely(value == LONG_MIN)) &#123;</span><br><span class="line">  DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">      <span class="string">&quot;Unbalanced call to dispatch_semaphore_signal()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">销毁时的判断</span><br><span class="line"><span class="keyword">if</span> (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) &#123;</span><br><span class="line">  DISPATCH_CLIENT_CRASH(dsema-&gt;dsema_orig - dsema-&gt;dsema_value,</span><br><span class="line">      <span class="string">&quot;Semaphore object deallocated while in use&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.不能过度wait，导致计数值变成LONG_MIN，这个一般不会出现。</p>
<p>2.保证signal的次数要&gt;=wait的次数，否则信号量在销毁时会产生崩溃。</p>
<p>为了避免上述崩溃，应该让signal和wait保持配对。这里多signal貌似也没啥问题。</p>
<p><strong>3. 多线程调用dispatch_semaphore_signal/wait为啥不会导致线程安全问题？</strong></p>
<p>因为dispatch_semaphore_signal/wait里面操作信号量计数值时是原子操作的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> value = <span class="built_in">os_atomic_inc2o</span>(dsema, dsema_value, release); <span class="comment">//signal</span></span><br><span class="line"><span class="type">long</span> value = <span class="built_in">os_atomic_dec2o</span>(dsema, dsema_value, acquire); <span class="comment">//wait</span></span><br></pre></td></tr></table></figure>
<p><strong>4. 信号量变为-3 后，另一个线程发送信号还能唤醒一个等待的线程吗？</strong></p>
<p>可以。dispatch_semaphore_signal的作用就是将信号量+1，如果加1后信号量还是&lt;=0，说明有wait的线程，那就唤醒最先等待的线程。</p>
<p><strong>5.信号量与互斥锁的区别</strong></p>
<ol>
<li>互斥锁的加锁和解锁<strong>必须由同一线程</strong>分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li>
<li>互斥量值只能为0/1，信号量值可以为非负整数。<strong>锁是服务于共享资源的；而semaphore是服务于多个线程间的执行的逻辑顺序的。</strong>semaphore的本质就是<strong>调度线程</strong>。</li>
</ol>
<p>一个最典型的使用semaphore的场景： a源自一个线程，b源自另一个线程，计算c = a + b也是一个线程。（即一共三个线程）</p>
<p>显然，第三个线程必须等第一、二个线程执行完毕它才能执行。 在这个时候，我们就需要<strong>调度线程</strong>了：让第一、二个线程执行完毕后，再执行第三个线程。 此时，就需要用semaphore了。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a, b, c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geta</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    a = calculatea();</span><br><span class="line">    semaphore_increase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getb</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    b = calculateb();</span><br><span class="line">    semaphore_increase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getc</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    semaphore_decrease(); <span class="comment">//线程3在这里可能会停住等待</span></span><br><span class="line">    semaphore_decrease(); <span class="comment">//线程3在这里可能会停住等待</span></span><br><span class="line">    c = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t1 = thread_create(geta);</span><br><span class="line">t2 = thread_create(getb);</span><br><span class="line">t3 = thread_create(getc);</span><br><span class="line">thread_join(t3);</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.cnblogs.com/zzdbullet/p/9822242.html">信号量与互斥锁的区别</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 信号量原理篇</title>
    <url>/2020/06/06/iOS-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    <content><![CDATA[<h3 id="信号量原理篇"><a href="#信号量原理篇" class="headerlink" title="信号量原理篇"></a>信号量原理篇</h3><p>源码版本：libdispatch-1173.40.5</p>
<p>信号量的实现主要是创建，销毁，wait和signal，四个方法。</p>
<p>信号量结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DISPATCH_CLASS_DECL(semaphore, OBJECT);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> &#123;</span></span><br><span class="line">	DISPATCH_OBJECT_HEADER(semaphore);</span><br><span class="line">	<span class="type">long</span> <span class="keyword">volatile</span> dsema_value;</span><br><span class="line">	<span class="type">long</span> dsema_orig;</span><br><span class="line">	<span class="type">_dispatch_sema4_t</span> dsema_sema;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">semaphore_t</span> <span class="type">_dispatch_sema4_t</span>;</span><br></pre></td></tr></table></figure>
<h4 id="信号量的创建—dispatch-semaphore-create"><a href="#信号量的创建—dispatch-semaphore-create" class="headerlink" title="信号量的创建—dispatch_semaphore_create"></a>信号量的创建—dispatch_semaphore_create</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">dispatch_semaphore_t</span></span><br><span class="line"><span class="title function_">dispatch_semaphore_create</span><span class="params">(<span class="type">long</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">dispatch_semaphore_t</span> dsema;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the internal value is negative, then the absolute of the value is</span></span><br><span class="line">	<span class="comment">// equal to the number of waiting threads. Therefore it is bogus to</span></span><br><span class="line">	<span class="comment">// initialize the semaphore with a negative value.</span></span><br><span class="line">	<span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dsema = _dispatch_object_alloc(DISPATCH_VTABLE(semaphore),</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_semaphore_s));</span><br><span class="line">	dsema-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dsema-&gt;do_targetq = _dispatch_get_default_queue(<span class="literal">false</span>);</span><br><span class="line">	dsema-&gt;dsema_value = value;</span><br><span class="line">	_dispatch_sema4_init(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	dsema-&gt;dsema_orig = value;</span><br><span class="line">	<span class="keyword">return</span> dsema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到不能传入一个小于0的值。信号量有几个重要的属性：</p>
<p>dsema_value：记录当前计数值，后续的wait和signal函数会改变该值。</p>
<p>dsema_sema：信号量 (真正干事情的)</p>
<p>dsema_orig：记录创建时传入的初始计数值。在信号量销毁时有用到。</p>
<h4 id="信号量wait操作—dispatch-semaphore-wait"><a href="#信号量wait操作—dispatch-semaphore-wait" class="headerlink" title="信号量wait操作—dispatch_semaphore_wait"></a>信号量wait操作—dispatch_semaphore_wait</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span></span><br><span class="line"><span class="title function_">dispatch_semaphore_wait</span><span class="params">(<span class="type">dispatch_semaphore_t</span> dsema, <span class="type">dispatch_time_t</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> value = os_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>os_atomic_dec2o是一个宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_dec2o(p, f, m) \</span></span><br><span class="line"><span class="meta">		os_atomic_sub2o(p, f, 1, m)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_sub2o(p, f, v, m) \</span></span><br><span class="line"><span class="meta">		os_atomic_sub(&amp;(p)-&gt;f, (v), m)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_sub(p, v, m) \</span></span><br><span class="line"><span class="meta">		_os_atomic_c11_op((p), (v), m, sub, -)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _os_atomic_c11_op(p, v, m, o, op) \</span></span><br><span class="line"><span class="meta">		(&#123; _os_atomic_basetypeof(p) _v = (v), _r = \</span></span><br><span class="line"><span class="meta">		atomic_fetch_##o##_explicit(_os_atomic_c11_atomic(p), _v, \</span></span><br><span class="line"><span class="meta">		memory_order_##m); (__typeof__(_r))(_r op _v); &#125;)</span></span><br><span class="line">		</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _os_atomic_basetypeof(p) \</span></span><br><span class="line"><span class="meta">		__typeof__(atomic_load_explicit(_os_atomic_c11_atomic(p), memory_order_relaxed))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _os_atomic_c11_atomic(p) \</span></span><br><span class="line"><span class="meta">		((__typeof__(*(p)) _Atomic *)(p))</span></span><br></pre></td></tr></table></figure>
<p>展开后如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> value = (&#123; __typeof__(atomic_load_explicit(((__typeof__(*((&amp;(dsema)-&gt;dsema_value))) <span class="keyword">_Atomic</span> *)((&amp;(dsema)-&gt;dsema_value))), memory_order_relaxed)) _v = (((<span class="number">1</span>))), _r = atomic_fetch_sub_explicit(((__typeof__(*((&amp;(dsema)-&gt;dsema_value))) <span class="keyword">_Atomic</span> *)((&amp;(dsema)-&gt;dsema_value))), _v, memory_order_acquire); (__typeof__(_r))(_r - _v); &#125;);</span><br></pre></td></tr></table></figure>
<p>简化下就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> value = (</span><br><span class="line">  &#123;</span><br><span class="line">    _v = <span class="number">1</span>, </span><br><span class="line">    _r = atomic_fetch_sub_explicit(*((&amp;(dsema)-&gt;dsema_value)), <span class="number">1</span>, memory_order_acquire);</span><br><span class="line">    _r - _v;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>类似于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> value = (&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">3</span>; <span class="type">int</span> b = <span class="number">1</span>; a - b;</span><br><span class="line">&#125;); <span class="comment">//value的值就等于a-b = 2;  源码里好多这样的宏</span></span><br></pre></td></tr></table></figure>
<p>而atomic_fetch_sub_explicit函数表示dsema_value -= 1，并返回dsema_value原来的值。</p>
<p>因此<code>long value = os_atomic_dec2o(dsema, dsema_value, acquire);</code></p>
<p>这句代码的意思就是：</p>
<p>原子操作，将信号量自减1，并将结果赋值给value。</p>
<p>由于是原子操作，因此同一时刻只会有一个线程对dsema_value进行减1。多线程下不会出问题。</p>
<p>如果value&gt;=0，则返回0，这种情况不会阻塞线程。</p>
<p>否则调用_dispatch_semaphore_wait_slow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line">_dispatch_semaphore_wait_slow(<span class="type">dispatch_semaphore_t</span> dsema,</span><br><span class="line">		<span class="type">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> orig;</span><br><span class="line"></span><br><span class="line">	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	<span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dsema-&gt;dsema_sema, timeout)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Fall through and try to undo what the fast path did to</span></span><br><span class="line">		<span class="comment">// dsema-&gt;dsema_value</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">		orig = dsema-&gt;dsema_value;</span><br><span class="line">		<span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (os_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">					&amp;orig, relaxed)) &#123; <span class="comment">//超时的系统才会自动+1</span></span><br><span class="line">				<span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Another thread called semaphore_signal().</span></span><br><span class="line">		<span class="comment">// Fall through and drain the wakeup.</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">		_dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会根据传入的dispatch_time_t进行区分：</p>
<p>其他等待时间：比如传入dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC))，即2s。</p>
<p>该case里主要就是_dispatch_sema4_timedwait：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line">_dispatch_sema4_timedwait(<span class="type">_dispatch_sema4_t</span> *sema, <span class="type">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mach_timespec_t</span> _timeout;</span><br><span class="line">	<span class="type">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="type">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">		_timeout.tv_sec = (__typeof__(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">		_timeout.tv_nsec = (__typeof__(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">		kr = semaphore_timedwait(*sema, _timeout);</span><br><span class="line">	&#125; <span class="keyword">while</span> (unlikely(kr == KERN_ABORTED));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算剩余时间，调用mach内核的等待函数semaphore_timedwait()进行等待，线程进入休眠状态。如果在指定时间内没有得到通知，则会一直阻塞住，监听dsema_port等待其通知。</p>
<p>如果kr == KERN_OPERATION_TIMED_OUT，代表等待超时，则返回true。其他情况返回false。</p>
<p>当_dispatch_sema4_timedwait返回true时，case会掉入到DISPATCH_TIME_NOW处理。</p>
<p>当_dispatch_sema4_timedwait返回false时，代表在等待期间收到了一个信号，线程被唤醒。case会break；dispatch_semaphore_wait也就返回0。</p>
<p>DISPATCH_TIME_NOW：也就是不等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">os_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">					&amp;orig, relaxed)</span><br></pre></td></tr></table></figure>
<p>该宏由以下宏组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_cmpxchgvw2o(p, f, e, v, g, m) \</span></span><br><span class="line"><span class="meta">		os_atomic_cmpxchgvw(&amp;(p)-&gt;f, (e), (v), (g), m)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_cmpxchgvw(p, e, v, g, m) \</span></span><br><span class="line"><span class="meta">		(&#123; _os_atomic_basetypeof(p) _r = (e); _Bool _b = \</span></span><br><span class="line"><span class="meta">		atomic_compare_exchange_weak_explicit(_os_atomic_c11_atomic(p), \</span></span><br><span class="line"><span class="meta">		&amp;_r, v, memory_order_##m, memory_order_relaxed); *(g) = _r;  _b; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _os_atomic_basetypeof(p) \</span></span><br><span class="line"><span class="meta">__typeof__(atomic_load_explicit(_os_atomic_c11_atomic(p), memory_order_relaxed))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _os_atomic_c11_atomic(p) \</span></span><br><span class="line"><span class="meta">		((__typeof__(*(p)) _Atomic *)(p))</span></span><br></pre></td></tr></table></figure>
<p>将宏展开：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(&#123; </span><br><span class="line">  __typeof__(atomic_load_explicit(((__typeof__(*(&amp;(dsema)-&gt;dsema_value)) <span class="keyword">_Atomic</span> *)(&amp;(dsema)-&gt;dsema_value)), memory_order_relaxed)) _r = ((orig)); </span><br><span class="line">  <span class="type">_Bool</span> _b = atomic_compare_exchange_weak_explicit(((__typeof__(*(&amp;(dsema)-&gt;dsema_value)) <span class="keyword">_Atomic</span> *)(&amp;(dsema)-&gt;dsema_value)), &amp;_r, (orig + <span class="number">1</span>), memory_order_relaxed, memory_order_relaxed); </span><br><span class="line">  *((&amp;orig)) = _r; </span><br><span class="line">  _b; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>主要是atomic_compare_exchange_weak_explicit函数的意思了：</p>
<p><code>_Bool atomic_compare_exchange_weak_explicit（volatile A * obj，C * expected，C desired，memory_order succ，memory_order fail）;</code></p>
<p>比较并交换被封装的值(weak)与参数 expected 所指定的值是否相等，如果：<br>相等，则用 desired 替换原子对象的旧值。<br>不相等，则用原子对象的旧值替换 expected ，因此调用该函数之后，如果被该原子对象封装的值与参数 expected 所指定的值不相等，expected 中的内容就是原子对象的旧值。<br>该函数通常会读取原子对象封装的值，如果比较为 true(即原子对象的值等于 expected)，则替换原子对象的旧值，但整个操作是原子的，在某个线程读取和修改该原子对象时，另外的线程不能读取和修改该原子对象。</p>
<p>比较的结果：<code>true</code>如果<code>*obj</code>等于<code>*exp</code>，否则<code>false</code>。</p>
<p>在这里，orig肯定&lt;0，所以会进入while循环，</p>
<p>如果orig和dsema_value相等（在这里orig是等于dsema_value的），则dsema_value加1，os_atomic_cmpxchgvw2o返回true，最终<code>return _DSEMA4_TIMEOUT();</code></p>
<p>因此DISPATCH_TIME_NOW的作用：将信号量自加1（抵消掉了前面的自减1。注意即使这里自加1，dsema_value的值也不一定就是0），然后返回<code>_DSEMA4_TIMEOUT()</code>一个非0数。</p>
<p>DISPATCH_TIME_FOREVER：永久等待一个信号的发送。</p>
<p>这里主要就是_dispatch_sema4_wait的作用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_sema4_wait(<span class="type">_dispatch_sema4_t</span> *sema)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">kern_return_t</span> kr;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		kr = semaphore_wait(*sema);</span><br><span class="line">	&#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">	DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用mach内核的等待函数semaphore_wait()进行等待。直到收到一个信号被唤醒。</p>
<h4 id="信号量signal操作—dispatch-semaphore-signal"><a href="#信号量signal操作—dispatch-semaphore-signal" class="headerlink" title="信号量signal操作—dispatch_semaphore_signal"></a>信号量signal操作—dispatch_semaphore_signal</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span></span><br><span class="line"><span class="title function_">dispatch_semaphore_signal</span><span class="params">(<span class="type">dispatch_semaphore_t</span> dsema)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> value = os_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(value == LONG_MIN)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">				<span class="string">&quot;Unbalanced call to dispatch_semaphore_signal()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="type">long</span></span><br><span class="line">_dispatch_semaphore_signal_slow(<span class="type">dispatch_semaphore_t</span> dsema)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	_dispatch_sema4_signal(&amp;dsema-&gt;dsema_sema, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_sema4_signal(<span class="type">_dispatch_sema4_t</span> *sema, <span class="type">long</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="type">kern_return_t</span> kr = semaphore_signal(*sema);</span><br><span class="line">		DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是宏os_atomic_inc2o，这个看字面意思很容易猜到是原子操作将dsema_value自加1，并将结果赋值给value。</p>
<p>如果value &gt; 0,表示信号量足够，直接返回0。</p>
<p>如果value == LONG_MIN，则崩溃。应该是过度wait了。</p>
<p>否则调用_dispatch_semaphore_signal_slow函数，最终会调用内核函数<code>semaphore_signal(*sema);</code>发出一个信号唤醒一个wait的线程，返回1。</p>
<p>因此dispatch_semaphore_signal的作用就是将信号量+1，如果加1后信号量还是&lt;=0，说明有wait的线程，那就唤醒最先等待的线程。</p>
<h4 id="信号量的销毁—-dispatch-semaphore-dispose"><a href="#信号量的销毁—-dispatch-semaphore-dispose" class="headerlink" title="信号量的销毁—_dispatch_semaphore_dispose"></a>信号量的销毁—_dispatch_semaphore_dispose</h4><p>信号量对象遵守ARC内存管理，当信号量对象引用计数为0时，比如将self.semaphore = nil，或者self.semaphore = 新信号量对象，那么之前的信号量对象将销毁。所以当还有wait中的线程时千万不要把信号量对象给整销毁了。</p>
<p>销毁时系统会调用_dispatch_semaphore_dispose函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_semaphore_dispose(<span class="type">dispatch_object_t</span> dou,</span><br><span class="line">		DISPATCH_UNUSED <span class="type">bool</span> *allow_free)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">dispatch_semaphore_t</span> dsema = dou._dsema;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(dsema-&gt;dsema_orig - dsema-&gt;dsema_value,</span><br><span class="line">				<span class="string">&quot;Semaphore object deallocated while in use&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_sema4_dispose(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_sema4_dispose(<span class="type">_dispatch_sema4_t</span> *sema, <span class="type">int</span> policy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_sema4_is_created(sema)) &#123;</span><br><span class="line">		_dispatch_sema4_dispose_slow(sema, policy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_sema4_dispose_slow(<span class="type">_dispatch_sema4_t</span> *sema, <span class="type">int</span> policy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">semaphore_t</span> sema_port = *sema;</span><br><span class="line">	*sema = MACH_PORT_DEAD;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_OS_SEMAPHORE_CACHE</span></span><br><span class="line">	<span class="keyword">if</span> (policy == _DSEMA4_POLICY_FIFO) &#123;</span><br><span class="line">		<span class="keyword">return</span> os_put_cached_semaphore((<span class="type">os_semaphore_t</span>)sema_port);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kern_return_t</span> kr = semaphore_destroy(mach_task_self(), sema_port);</span><br><span class="line">	DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果dsema_value &lt; dsema_orig，程序会崩溃并提示Semaphore object deallocated while in use。提示这个并不一定说明还有线程阻塞和等待signal，这是系统的一种过于保守的保护措施，目的就是要让业务层平衡使用signal和wait。所以函数说明才提醒我们wait和signal要配对使用。</p>
<p>换句话，只有当signal次数&gt;=wait的次数，dsema_value才会&gt;=dsema_orig。从实现来看，我们要保证signal次数&gt;=wait的次数。</p>
<p>然后就是调用_dispatch_sema4_dispose进行销毁操作。</p>
<p>eg：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_semaphore_do_task_after_all_work1 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     错误实现，没有理解dispatch_semaphore_signal的作用。</span></span><br><span class="line"><span class="comment">     signal函数的作用：1.将信号量加1。2.如果之前有线程被阻塞，则按优先级唤醒一个线程。</span></span><br><span class="line"><span class="comment">     下面的实现不仅达不到要求，并且还会崩溃.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;current1:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">2</span>); <span class="comment">//初始化时信号量是2.</span></span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        __block <span class="built_in">NSInteger</span> rs1 = <span class="number">0</span>;</span><br><span class="line">        [<span class="keyword">self</span> requestSomethingWithN:<span class="number">40</span> completion:^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">            rs1 = result;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;40 rs = %ld&quot;</span>, (<span class="type">long</span>)result);</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        __block <span class="built_in">NSInteger</span> rs2 = <span class="number">0</span>;</span><br><span class="line">        [<span class="keyword">self</span> requestSomethingWithN:<span class="number">41</span> completion:^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">            rs2 = result;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;41 rs = %ld&quot;</span>, (<span class="type">long</span>)result);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             这里semaphore是等到block执行完成后才释放的。还以为block没强引用semaphore呢。</span></span><br><span class="line"><span class="comment">             崩溃：</span></span><br><span class="line"><span class="comment">             &quot;BUG IN CLIENT OF LIBDISPATCH: Semaphore object deallocated while in use (current value &lt; original value)&quot;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dispatch_semaphore_signal(semaphore); <span class="comment">//销毁时，信号量是1，小于初始值2，因此崩溃。</span></span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="built_in">NSInteger</span> rs = rs1 + rs2;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;==rs=%ld&quot;</span>, rs);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思考</strong></p>
<p>Q1：使用互斥锁和条件变量实现一个信号量？</p>
<p>在实现时特别要注意条件的判断。不能使用信号量计数值作为条件的判断条件，否则很容易导致循环等待。必须要额外定义一个变量专门用于条件的判断。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XQCustomSemaphore</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) pthread_mutex_t mutex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) pthread_cond_t cond;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> value; <span class="comment">//信号量的值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> wakeups; <span class="comment">//记录唤醒次数，这个变量非常重要，条件判断时应该使用该变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XQCustomSemaphore</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSemaphore:(<span class="built_in">NSInteger</span>)semaphore &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        pthread_mutex_init(&amp;_mutex, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_cond_init(&amp;_cond, <span class="literal">NULL</span>);</span><br><span class="line">        _value = semaphore;</span><br><span class="line">        _wakeups = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)signal &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    _value++;</span><br><span class="line">    <span class="keyword">if</span> (_value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _wakeups++;</span><br><span class="line">        pthread_cond_signal(&amp;_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)wait &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    _value--;</span><br><span class="line">    <span class="keyword">if</span> (_value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">        &#125; <span class="keyword">while</span> (_wakeups &lt; <span class="number">1</span>); <span class="comment">//如果因为其他原因被唤醒，_wakeups的值必定小于 1，于是又等待。</span></span><br><span class="line">        _wakeups--;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误实现</span></span><br><span class="line">- (<span class="type">void</span>)signal &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    _value++;</span><br><span class="line">    <span class="keyword">if</span> (_value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_cond_signal(&amp;_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)wait &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    _value--;</span><br><span class="line">    <span class="keyword">while</span> (_value &lt; <span class="number">0</span>) &#123; <span class="comment">//wait--wait--signal.signal之后value=-1，还是小于0.所以必须定义一个wakeups变量用于条件判断。</span></span><br><span class="line">        pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://segmentfault.com/a/1190000005934154">操作系统思考 第十一章 C语言中的信号量</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://xiaozhuanlan.com/topic/4365017982">深入浅出 GCD 之 dispatch_semaphore</a>  介绍信号量源码实现的，不过版本较低</p>
<p><a href="https://www.shangmayuan.com/a/32031a7be207483dbf4c870c.html">写给本身看的源码系列: GCD的信号量semaphore</a>   新版本的</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>信号量</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理命令之宏定义</title>
    <url>/2020/07/03/%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>这里不谈宏的使用。只是突然想知道定义一个宏之后，这个宏的作用域有多大。</p>
<h3 id="宏定义作用域"><a href="#宏定义作用域" class="headerlink" title="宏定义作用域"></a>宏定义作用域</h3><p>C语言标准中宏定义的作用域是：如果是在块作用域内，则从定义位置开始，到块作用域结束，否则到其当前文件结尾，其他文件如果没有通过#include包含这个文件，则使用该宏是无效的。</p>
<p>比如我在a.m里面定义了一个宏<code>#define kCondTrue 1</code>，在b.m里面有如下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)btnDidClicked:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;btnDidClicked&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> kCondTrue			<span class="comment">//不会有编译错误</span></span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;111&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于kCondTrue宏对b.m是不可见的，所以这里不会打印111。</p>
<p>通常编译器会有一些预定义宏，预定义的宏大多会遵守命名规则：<code>__xxx_yyy__</code>，以双下划线开始和结束。比如<code>__OBJC2__</code>就是一个预定义的宏。</p>
<p>宏定义很强大，组合起来可以实现一个很复杂的功能。but 这样的宏可读性是很差的，你可以想象一下一个由十几个宏共同组合完成的宏有多么可怕，OC开源源码里面原子操作相关的宏是真滴恐怖。感觉如果一个宏过于复杂最好还是用方法代替。</p>
<p>完了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/jiuyi/archive/2018/12/20/10149625.html">C 和 Objective-C中的 #ifdef #ifndef</a></p>
<p><a href="https://onevcat.com/2014/01/black-magic-in-macro/">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>预处理命令</tag>
      </tags>
  </entry>
  <entry>
    <title>内存对齐</title>
    <url>/2020/07/20/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h3 id="为什么要进行内存对齐"><a href="#为什么要进行内存对齐" class="headerlink" title="为什么要进行内存对齐"></a>为什么要进行内存对齐</h3><p>主要有两个原因：1.内存对齐后可以减少内存的读取次数，提高内存的访问效率。2.提高程序的可移植性，因为有的平台对寻址的起始地址有要求。</p>
<p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对数据在内存中存放的位置是有限制的，它们会要求这些数据的内存首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。<br>注：某个数是4的倍数，不一定就是8的倍数，比如4、12、20、28、36。但反过来是8的倍数则必定是4的倍数。</p>
<p>内存对齐主要是为了提高内存的访问效率，CPU访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如32位的CPU，字长为4字节，那么CPU访问内存的单位也是4字节，即一次读取4个字节的内存。又比如intel 32位cpu，每个总线周期都是从偶数地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据，因此需要在内存中存放数据时进行对齐。</p>
<p>总之一句话，只有当数据的首地址为某个数k（通常它为4或8）的倍数时（偶数地址），CPU需要进行数据剔除的情况才会越少发生。当剔除操作无法避免时，剔除次数越少越好，如果数据的首地址是奇数，那么CPU需要剔除前后的数据。而如果是偶数则最好情况下只需要剔除前面或后面的数据。char类型的变量因为只占1个字节就随便了。</p>
<p>假如没有内存对齐机制，数据可以在任意内存地址处开始存放：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200925224735.png" alt=""></p>
<p>现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p>
<p>如果int变量存放在从地址4开始的连续四个字节地址中，就可以一次读取完数据。</p>
<p>所以int变量的内存首地址通常在4的倍数的地址处开始，比如上面的编号为4或8的地址处，而不可能是2或5这样的地址处。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(char):%lu, sizeof(int):%lu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch:%p\n&quot;</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch1 = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch1:%p\n&quot;</span>, &amp;ch1);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> integer = <span class="number">34</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer:%p\n&quot;</span>, &amp;integer);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> integer1 = <span class="number">34332321</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer1:%p\n&quot;</span>, &amp;integer1);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> integer2 = <span class="number">3433</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer2:%p\n&quot;</span>, &amp;integer2);</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sizeof</span>(char):<span class="number">1</span>, sizeof(int):<span class="number">4</span></span><br><span class="line"><span class="attribute">ch</span>:<span class="number">0</span>x7ffeefbff34f 	//<span class="number">140732920755023</span></span><br><span class="line"><span class="attribute">ch1</span>:<span class="number">0</span>x7ffeefbff34e	//<span class="number">140732920755022</span></span><br><span class="line"><span class="attribute">integer</span>:<span class="number">0</span>x7ffeefbff348  //<span class="number">140732920755016</span></span><br><span class="line"><span class="attribute">integer1</span>:<span class="number">0</span>x7ffeefbff344 //<span class="number">140732920755012</span></span><br><span class="line"><span class="attribute">integer2</span>:<span class="number">0</span>x7ffeefbff340 //<span class="number">140732920755008</span></span><br></pre></td></tr></table></figure>
<p>会发现：</p>
<ol>
<li>栈是往下增长的，由高地址到低地址。</li>
<li>char占1个字节所以放哪里都是一样的，int占4个字节为了提高CPU存取效率所以进行了内存对齐，首地址选择了4的倍数的地址。</li>
</ol>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p><strong>sizeof</strong> 是一个关键字，用于判断变量或数据类型的字节大小。它并不是一个函数而是一个<strong>编译时</strong>运算符。字节数的计算在程序编译时进行，而不是在程序执行的过程中才计算出来。</p>
<p>sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。</p>
<h3 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h3><p>对齐系数:</p>
<p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。Xcode默认的对齐系数是8（不确定是否跟CPU的位数有关，32位的就是4，64位的就是8）。</p>
<p>对齐单位:</p>
<p>给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。即min(pack, 结构体中最长数据类型的长度)。如果是嵌套结构体那么计算对齐单位时需要不要考虑这个嵌套的结构体里的成员？实验了一下，貌似不需要考虑嵌套的结构体。</p>
<p>内存对齐规则：</p>
<p> (1) 元素对齐。结构体第一个成员的偏移量（offset）为0。下一个数据成员为基本数据类型的，则offset=整数倍的min(d, sizeof(member))。数据成员为结构体的，则offset=整数倍的min(pack, ss中最长数据类型的长度)。</p>
<p> (2) 总体对齐。结构体的总大小为对齐单位的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</p>
<p>上面的文字用公式表达就是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>已知对齐系数为p。</span><br><span class="line"><span class="number">2.</span>计算对齐单位d<span class="operator">=</span><span class="built_in">min</span>(p, <span class="built_in">max</span>(s.member))。</span><br><span class="line"><span class="number">3.</span>元素对齐：第一个<span class="keyword">member</span>的<span class="keyword">offset</span>为<span class="number">0</span>，其他<span class="keyword">member</span>的<span class="keyword">offset</span><span class="operator">=</span>整数倍的<span class="built_in">min</span>(d, sizeof(<span class="keyword">member</span>))，<span class="keyword">member</span>为基础类型。</span><br><span class="line">																									<span class="operator">=</span>整数倍的<span class="built_in">min</span>(pack, ss中最长数据类型的长度)，<span class="keyword">member</span>为结构体,ss代表该结构体。</span><br><span class="line"><span class="number">4.</span>总体对齐：整数倍的d。</span><br></pre></td></tr></table></figure>
<p>可以使用offsetof(type, member)查看结构体某个成员存储的位置偏移结构体首地址多少个字节。</p>
<p>基本数据类型需要对齐，结构体可以看成是一些基本数据类型的集合，因此结构体不仅需要整体对齐，其内部各变量的首地址也需要对齐。</p>
<p>Q：对齐规则为什么是这样的？不知道。为什么要定义一个对齐单位？</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_memory_align &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4) <span class="comment">//对齐系数默认是4,可以通过该宏修改</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char: %lu byte\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int: %lu byte\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//4</span></span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//对齐系数p=4</span></span><br><span class="line">  	<span class="comment">//对齐单位d=min(p, max(s.member))=4。</span></span><br><span class="line">    <span class="comment">//元素对齐：第一个member的offset为0，其他member的offset等于整数倍的min(d, sizeof(member))。</span></span><br><span class="line">  	<span class="comment">//总体对齐：整数倍的d。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s1</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i; <span class="comment">//offset:0</span></span><br><span class="line">        <span class="type">char</span> c1; <span class="comment">//offset:4</span></span><br><span class="line">        <span class="type">char</span> c2; <span class="comment">//offset:5,总体长度5+sizeof(char)=5+1=6。--&gt;整体对齐得到8</span></span><br><span class="line">    &#125;x1;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s2</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c1; <span class="comment">//offset:0</span></span><br><span class="line">        <span class="type">int</span> i; <span class="comment">//offset:4</span></span><br><span class="line">        <span class="type">char</span> c2; <span class="comment">//offset:8,总体长度8+sizeof(char)=8+1=9。--&gt;整体对齐得到12</span></span><br><span class="line">    &#125;x2;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c1;  <span class="comment">//offset:0</span></span><br><span class="line">        <span class="type">char</span> c2; <span class="comment">//offset:1</span></span><br><span class="line">        <span class="type">int</span> i;  <span class="comment">//offset:4,总体长度4+sizeof(int)=4+4=8。已经整体对齐</span></span><br><span class="line">    &#125;x3;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//假设对齐系数是8，则对齐单位=min(8,16)=8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s4</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c1;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">short</span> a; <span class="comment">//offset:8. </span></span><br><span class="line">        <span class="type">double</span> b; <span class="comment">//offset:16. </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s2</span> <span class="title">c</span>;</span> <span class="comment">//offset:24. 24+16=40</span></span><br><span class="line">    &#125;x4; <span class="comment">//pack = 4。sizeof=32 //pack = 8。sizeof=40</span></span><br><span class="line">  </span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">s5</span> &#123;</span></span><br><span class="line">      	<span class="type">double</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">s6</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">      	<span class="class"><span class="keyword">struct</span> <span class="title">s5</span> <span class="title">b</span>;</span></span><br><span class="line">    &#125;x6;</span><br><span class="line">  </span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">s5</span> &#123;</span>  <span class="comment">//8</span></span><br><span class="line">        <span class="type">double</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s51</span> &#123;</span>  <span class="comment">//12</span></span><br><span class="line">        <span class="type">short</span> a;</span><br><span class="line">        <span class="type">double</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s52</span> &#123;</span>  <span class="comment">//12</span></span><br><span class="line">        <span class="type">char</span> a;</span><br><span class="line">        <span class="type">double</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s6</span> &#123;</span> <span class="comment">//12</span></span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s5</span> <span class="title">b</span>;</span> <span class="comment">//offset=4而不是8.offset只需要是min(4,8)的倍数就行了。</span></span><br><span class="line">    &#125;x6;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s61</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> a; <span class="comment">//offset-0</span></span><br><span class="line">        <span class="type">short</span> b;<span class="comment">//offset-4</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s52</span> <span class="title">c</span>;</span> <span class="comment">//offset并不是6而是8，并不是网上说的直接把s52简单平铺。</span></span><br><span class="line">    &#125;x61;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s7</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> a;  <span class="comment">//offset-0</span></span><br><span class="line">        <span class="type">short</span> b; <span class="comment">//offset-4</span></span><br><span class="line">        <span class="type">char</span> c;  <span class="comment">//offset-6</span></span><br><span class="line">        <span class="type">double</span> d; <span class="comment">//offset-8</span></span><br><span class="line">    &#125;x7;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1-c1:%lu\n&quot;</span>, offsetof(<span class="keyword">struct</span> s1, c1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s3-c1:%lu\n&quot;</span>, offsetof(<span class="keyword">struct</span> s3, c1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s3-c2:%lu\n&quot;</span>, offsetof(<span class="keyword">struct</span> s3, c2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s3-i:%lu\n&quot;</span>, offsetof(<span class="keyword">struct</span> s3, i));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(x1));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(x2));  <span class="comment">// 输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(x3));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(x4));  <span class="comment">// 输出32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/u012611878/article/details/52455576">32位与64位系统基本数据类型的字节数</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解</a></p>
<p><a href="https://www.pengrl.com/p/20020/">为什么要内存对齐</a></p>
<p>拓展阅读</p>
<p><a href="https://embeddedartistry.com/blog/2017/02/22/generating-aligned-memory/">Generating Aligned Memory</a>   有空看一下。</p>
<p><a href="http://lanhin.xyz/2015/03/29/c-%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0/">C 语言内存分配函数</a></p>
<p><a href="https://blog.csdn.net/weixin_43679037/article/details/121853460">memalign和posix_memalign的区别</a></p>
<p><a href="https://www.cnblogs.com/sigma0/p/10837760.html">malloc分配内存进行对齐的操作</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>内存对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>OC内存管理之weak修饰符实现原理</title>
    <url>/2020/06/15/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8Bweak%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>源码版本：<a href="https://opensource.apple.com/tarballs/objc4/objc4-781.tar.gz">objc4-781</a></p>
<h3 id="0-weak-修饰符的作用"><a href="#0-weak-修饰符的作用" class="headerlink" title="0.weak 修饰符的作用"></a>0.weak 修饰符的作用</h3><p>之前的文章提到过 <code>__weak</code> 修饰符作用：</p>
<p>1.当我们将一个对象赋值给一个 <code>__weak</code> 修饰符的指针变量时，编译器会插入 <code>objc_initWeak</code> 或 <code>objc_storeWeak</code> 函数将该弱指针变量从旧对象的weak表剔除（如果之前有指向对象的话）并注册到新对象的weak表里，然后将弱指针指向新对象。</p>
<p>2.当使用附有 <code>__weak</code> 修饰符的变量时，编译器会在使用前插入 <code>objc_loadWeakRetained</code> 函数将对象引用计数+1，保证对象在后面的使用过程中不被释放。并在使用后插入 <code>objc_release(tmp1);</code> 释放对象。</p>
<p>3.当弱引用指针变量超出作用域被废弃时，编译器会插入 <code>objc_destroyWeak</code> 将该指针变量从weak表里移除。</p>
<p>4.当对象销毁时，weak表中对象的所有弱引用指针变量会被赋值为nil，避免了野指针崩溃。比如对nil对象发送消息不会有任何反应，需要注意的是如果是对nil进行解引用还是会崩溃的。</p>
<p>这些功能是assign所不具备的，assign唯一与weak相同的地方就是不会导致对象的引用计数+1。</p>
<p>note：weak 只能用于修饰对象类型。并且只能用于iOS5及以上，在iOS4可以使用 <code>__unsafe_unretained</code> 代替.另外weak在MRC下也是有效果的，不过需要设置 <code>Weak References in Manual Retain Release</code> 为 YES。</p>
<p>今天就来看一下weak的上述功能是如何实现的，在看源码之前，可以带着一些问题，比如：</p>
<p>1.使用weak后为啥对象就不会被retain？</p>
<p>2.为了实现对象销毁时所有指向它的弱引用指针变量将被赋值为nil。你是不是得登记保存一下这些弱引用指针变量的地址？源码又是定义了哪些数据结构完成的。</p>
<p>3.一个 <code>__weak</code> 指针变量如果之前指向了A，后面改为指向B，你是不是得把之前登记的给删除（不删除的话会有什么问题），然后登记到新的对象下，这里就涉及到查找，源码为了提高查找效率又是如何优化的。</p>
<h3 id="1-objc-initWeak"><a href="#1-objc-initWeak" class="headerlink" title="1.objc_initWeak"></a>1.objc_initWeak</h3><p>对如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    XQPerson *p = [XQPerson new];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> XQPerson *wp = p;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;hello:%@&quot;</span>, wp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>__weak XQPerson *wp = p;</code>这一行打好断点。</p>
<p>运行后如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/weak%E6%96%AD%E7%82%B9.jpg" style="zoom:50%;" /></p>
<p>给指针变量添加__weak修饰符后，系统会调用一个objc_initWeak的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="title function_">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数接受两个参数：</p>
<p>location：双重指针变量，对象指针的指针。</p>
<p>newObj：指针变量，指向一个对象，它的值是对象的地址。</p>
<p>当传入的newObj等于nil时，将对象指针变量置为nil。在上述示例代码中<code>*location = nil;</code>就相当于<code>wp = nil;</code>。</p>
<p>接下来可以看下如果是将p赋值给一个__strong类型的指针变量会发生什么：</p>
<p>代码如下：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="keyword">void</span>)<span class="keyword">viewDidLoad</span> &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    XQModel <span class="operator">*</span>model <span class="operator">=</span> [XQModel <span class="keyword">new</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">id</span> tmp <span class="operator">=</span> model;</span><br><span class="line">    </span><br><span class="line">    NSLog(<span class="string">@&quot;tmp:%@&quot;</span>, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打好断点后运行，会看到如下汇编代码：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/strong%E6%B1%87%E7%BC%96.png" style="zoom:50%;" /></p>
<p>可以看到如果是将model赋值给一个 <code>__strong</code> 类型的指针变量，系统会调用到<code>objc_retain</code>函数，对象的引用计数就会加1。</p>
<p>稍微总结一下：</p>
<p>使用 <code>__weak</code> 修饰符时，系统会调用objc_initWeak函数而没有调用类似<code>objc_retain</code>这样的函数，因此对象的引用计数不会发生改变。</p>
<p>使用 <code>__strong</code> 修饰符时，系统会调用<code>objc_retain</code>函数，对象的引用计数会加1。</p>
<p>在继续 weak 的实现原理之前，需要区分<strong>指向对象的指针变量</strong>和<strong>对象</strong>之间的关系：</p>
<p>指向对象的指针变量是一个变量，它的值是一个地址，这个地址指向某一段内存空间。在上述代码中指针变量 wp 是分配在栈上的，而 wp指向的对象是分配在堆上的。</p>
<p>对象：分配在堆上的一段内存空间，我们需要一个指针变量来引用它，才可以找到并访问这个对象。</p>
<p>它们之间的关系类似于人和人名之间的关系，你可以通过人名找到这个人，但人名不等于人。</p>
<p>后续实现 weak 的数据结构里面要保存的几个关键信息中就包含指针变量的值（即对象的地址）和指针变量的地址。在示例代码中就是保存 wp 的值和 wp自身的地址。</p>
<p>为什么需要保存指针变量的地址呢？因为 weak 修饰符的功能之一就是当对象销毁时将所有指向它的弱引用指针变量赋值为nil。当保存了这些指针变量的地址我们就可以很方便的将这些指针变量赋值为 nil ，而在这个语境下不太可能通过指针变量名来将其置为 nil。</p>
<p>为了实现weak 修饰符的功能，源码中定义了一系列的数据结构。只有充分理解了要干嘛，在看源码时才更有体会。</p>
<h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h3><p>在介绍 weak 的实现前，有一些相关的数据结构需要说明一下：</p>
<h4 id="StripedMap"><a href="#StripedMap" class="headerlink" title="StripedMap"></a>StripedMap</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StripedMap&lt;T&gt; is a map of void* -&gt; T, sized appropriately </span></span><br><span class="line"><span class="comment">// for cache-friendly lock striping. </span></span><br><span class="line"><span class="comment">// For example, this may be used as StripedMap&lt;spinlock_t&gt;</span></span><br><span class="line"><span class="comment">// or as StripedMap&lt;SomeStruct&gt; where SomeStruct stores a spin lock.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StripedMap</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PaddedT</span> &#123;</span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) &#123; </span><br><span class="line">        <span class="keyword">return</span> array[<span class="built_in">indexForPointer</span>(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shortcuts for StripedMaps of locks.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lockAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            array[i].value.<span class="built_in">lock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlockAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            array[i].value.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">forceResetAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            array[i].value.forceReset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">defineLockOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            <span class="built_in">lockdebug_lock_precedes_lock</span>(&amp;array[i<span class="number">-1</span>].value, &amp;array[i].value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">precedeLock</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *newlock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assumes defineLockOrder is also called</span></span><br><span class="line">        <span class="built_in">lockdebug_lock_precedes_lock</span>(&amp;array[StripeCount<span class="number">-1</span>].value, newlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">succeedLock</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *oldlock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assumes defineLockOrder is also called</span></span><br><span class="line">        <span class="built_in">lockdebug_lock_precedes_lock</span>(oldlock, &amp;array[<span class="number">0</span>].value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">void</span> *<span class="title">getLock</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; StripeCount) <span class="keyword">return</span> &amp;array[i].value;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">StripedMap</span>() &#123;</span><br><span class="line">        <span class="comment">// Verify alignment expectations.</span></span><br><span class="line">        <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">0</span>].value;</span><br><span class="line">        <span class="type">uintptr_t</span> delta = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">1</span>].value - base;</span><br><span class="line">        <span class="built_in">ASSERT</span>(delta % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">ASSERT</span>(base % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">StripedMap</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>StripedMap 字面意思是条纹map，是一个哈希表模板类，key 是对象地址，value 是 T 类型实例，T 里面需要有一把自旋锁。StripedMap里面定义了一个长度为 8或者64的数组，数组元素是T 类型实例。</p>
<p>主要的一个函数：将一个地址映射为数组的下标。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> addr = reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SideTablesMap"><a href="#SideTablesMap" class="headerlink" title="SideTablesMap"></a>SideTablesMap</h4><p>边表map</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</span><br><span class="line"><span class="function"><span class="type">static</span> StripedMap&lt;SideTable&gt;&amp; <span class="title">SideTables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SideTablesMap.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitInit</span> &#123;</span><br><span class="line">    <span class="built_in">alignas</span>(Type) <span class="type">uint8_t</span> _storage[<span class="built_in">sizeof</span>(Type)]; <span class="comment">//ExplicitInit里有一个数组,数组的长度是sizeof(Type)，而sizeof(StripedMap&lt;SideTable&gt;)在iOS上等于512（8*64），mac上为4096（64*64）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(Ts &amp;&amp;... Args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (_storage) <span class="built_in">Type</span>(std::forward&lt;Ts&gt;(Args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type &amp;<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;Type *&gt;(_storage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SideTablesMap是一个静态全局变量，它是在arr_init函数中初始化的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">arr_init</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage::<span class="built_in">init</span>();</span><br><span class="line">    SideTablesMap.<span class="built_in">init</span>();</span><br><span class="line">    _objc_associations_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而arr_init函数是在map_images_nolock中被调用的，map_images_nolock又是在map_images中被调用的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">map_images_nolock</span><span class="params">(<span class="type">unsigned</span> mhCount, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">map_images</span><span class="params">(<span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> paths[],</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span>;</span><br></pre></td></tr></table></figure>
<p>简而言之，在 runtime 启动时会初始化一个自动释放池AutoreleasePoolPage，一个静态全局变量SideTablesMap，一个关联对象管理器AssociationsManager（保存类别中关联的实例变量）。</p>
<p>SideTablesMap的类型为 <code>ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt;</code> ，C++的类也没怎么看懂，大致可以把SideTablesMap理解为一个全局的hash数组，数组长度为8（iPhone ）或64（Mac），里面存储的是SideTable，因此SideTable不止一个。</p>
<p>源码里一般通过 <code>&amp;SideTables()</code> 获取一个SideTable</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">static StripedMap&lt;SideTable&gt;&amp; <span class="built_in">SideTables</span>() &#123;</span><br><span class="line">    return SideTablesMap<span class="selector-class">.get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如：<code>SideTable *newTable = &amp;SideTables()[newObj];</code></p>
<p>通过将传入的对象地址映射为数组index，然后从数组中取出对应的SideTable。</p>
<h4 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h4><p>边表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SideTable</span> &#123;</span><br><span class="line">    <span class="type">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="type">weak_table_t</span> weak_table;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SideTable</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;weak_table, <span class="number">0</span>, <span class="built_in">sizeof</span>(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SideTable</span>() &#123;</span><br><span class="line">        _objc_fatal(<span class="string">&quot;Do not delete SideTable.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; slock.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; slock.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">forceReset</span><span class="params">()</span> </span>&#123; slock.forceReset(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Address-ordered lock discipline for a pair of side tables.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;HaveOld, HaveNew&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">lockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;HaveOld, HaveNew&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">unlockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>slock：自旋锁</p>
<p>refcnts：引用计数表。<strong>哈希表</strong></p>
<p>weak_table：弱引用表。里面有一个成员变量指向一个哈希表</p>
<p>RefcountMap是一个类型别名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RefcountMap disguises its pointers because we </span></span><br><span class="line"><span class="comment">// don&#x27;t want the table to act as a root for `leaks`.</span></span><br><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="type">size_t</span>,RefcountMapValuePurgeable&gt; RefcountMap;</span><br></pre></td></tr></table></figure>
<h4 id="DisguisedPtr"><a href="#DisguisedPtr" class="headerlink" title="DisguisedPtr"></a>DisguisedPtr</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DisguisedPtr&lt;T&gt; acts like pointer type T*, except the </span></span><br><span class="line"><span class="comment">// stored value is disguised to hide it from tools like `leaks`.</span></span><br><span class="line"><span class="comment">// nil is disguised as itself so zero-filled memory works as expected, </span></span><br><span class="line"><span class="comment">// which means 0x80..00 is also disguised as itself but we don&#x27;t care.</span></span><br><span class="line"><span class="comment">// Note that weak_entry_t knows about this encoding.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisguisedPtr</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title">disguise</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(<span class="type">uintptr_t</span>)ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">undisguise</span><span class="params">(<span class="type">uintptr_t</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*)-val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisguisedPtr</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">DisguisedPtr</span>(T* ptr) </span><br><span class="line">        : <span class="built_in">value</span>(<span class="built_in">disguise</span>(ptr)) &#123; &#125;</span><br><span class="line">    <span class="built_in">DisguisedPtr</span>(<span class="type">const</span> DisguisedPtr&lt;T&gt;&amp; ptr) </span><br><span class="line">        : <span class="built_in">value</span>(ptr.value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; <span class="keyword">operator</span> = (T* rhs) &#123;</span><br><span class="line">        value = <span class="built_in">disguise</span>(rhs);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> DisguisedPtr&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> T* () <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">undisguise</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt; () <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">undisguise</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> * () <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">undisguise</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> [] (<span class="type">size_t</span> i) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">undisguise</span>(value)[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pointer arithmetic operators omitted </span></span><br><span class="line">    <span class="comment">// because we don&#x27;t currently use them anywhere</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指针伪装模板类，<code>DisguisedPtr&lt;T&gt;</code>的作用类似于<code>T *</code>，但不是真正的<code>T *</code>，它里面只有一个无符号整型属性value，并没有一个真的指针成员<code>T *</code>。理论上 value 的值保存被引用对象的地址就可以了，有了对象的地址又有对象的类型，DisguisedPtr的功能已经类似于一个指针变量<code>T *</code>了。</p>
<p>但是DisguisedPtr并没有直接保存被引用对象的地址，而是将其取负后再强转为无符号整数。这么做的目的就是让类似于leaks这样的工具检测不到有这么个东西也保存了对象的地址。</p>
<p>DisguisedPtr中的两个重要方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪装对象的地址</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title">disguise</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(<span class="type">uintptr_t</span>)ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解伪装对象的地址</span></span><br><span class="line"><span class="function"><span class="type">static</span> T* <span class="title">undisguise</span><span class="params">(<span class="type">uintptr_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T*)-val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The address of a __weak variable.</span></span><br><span class="line"><span class="comment">// These pointers are stored disguised so memory analysis tools</span></span><br><span class="line"><span class="comment">// don&#x27;t see lots of interior pointers from the weak table into objects.</span></span><br><span class="line"><span class="keyword">typedef</span> DisguisedPtr&lt;objc_object *&gt; <span class="type">weak_referrer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_MINUS_2 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_MINUS_2 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal structure stored in the weak references table. </span></span><br><span class="line"><span class="comment"> * It maintains and stores</span></span><br><span class="line"><span class="comment"> * a hash set of weak references pointing to an object.</span></span><br><span class="line"><span class="comment"> * If out_of_line_ness != REFERRERS_OUT_OF_LINE then the set</span></span><br><span class="line"><span class="comment"> * is instead a small inline array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEAK_INLINE_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].</span></span><br><span class="line"><span class="comment">// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.</span></span><br><span class="line"><span class="comment">// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00</span></span><br><span class="line"><span class="comment">// (disguised nil or 0x80..00) or 0b11 (any other address).</span></span><br><span class="line"><span class="comment">// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_entry_t</span> &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">weak_referrer_t</span> *referrers; <span class="comment">//哈希表，动态数组</span></span><br><span class="line">            <span class="type">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>; </span><br><span class="line">            <span class="type">uintptr_t</span>        num_refs : PTR_MINUS_2;</span><br><span class="line">            <span class="type">uintptr_t</span>        mask;</span><br><span class="line">            <span class="type">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            <span class="type">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT]; <span class="comment">//普通数组，可以存储4个元素，弱引用&lt;=4时保存在这里。起到优化作用。</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">weak_entry_t</span>&amp; other) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="built_in">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : <span class="built_in">referent</span>(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>weak_entry_t 主要保存了被引用对象自身以及指向它的所有弱引用指针变量的地址。weak entry实体自身被保存在weak表中。</p>
<p>referent：用于保存对象的地址，DisguisedPtr<objc_object>类型，效果类似于objc_object <em>但并不是真正的objc_object </em>类型。</p>
<p>接下来是一个联合，主要用于保存该对象的所有弱引用指针变量的地址。使用联合主要是为了优化存储。</p>
<p>如果弱引用个数&lt;=4，则使用inline_referrers固定数组保存。 </p>
<p>如果弱引用个数&gt;4，则使用动态数组weak_referrer_t *referrers。referrers其实是一个哈希表，存储在里面的弱引用指针变量的地址并不是按顺序依次排列的，而是将弱引用指针变量的地址映射为一个 index，然后存储在 index 上，这样做的好处就是可以快速查找出它在referrers中的位置，否则只能遍历整个数组。这里就是源码为了提高查找效率做的优化。</p>
<p>out_of_line_ness：是否使用动态hash数组标记位</p>
<p>num_refs：hash数组referrers中的元素个数</p>
<p>mask：hash数组长度-1。（注意，这里是hash数组的长度，而不是元素个数。比如，数组长度可能是64，而元素个数仅存了2个）。</p>
<p>max_hash_displacement：可能会发生的hash冲突的最大次数，用于判断是否出现了逻辑错误（hash表中的冲突次数绝不会超过该值）</p>
<h4 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global weak references table. Stores object ids as keys,</span></span><br><span class="line"><span class="comment"> * and weak_entry_t structs as their values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_table_t</span> &#123;</span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries; <span class="comment">//哈希表，容量不够了会扩容</span></span><br><span class="line">    <span class="type">size_t</span>    num_entries;</span><br><span class="line">    <span class="type">uintptr_t</span> mask;</span><br><span class="line">    <span class="type">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>weak_table_t weak表，是一个全局的弱引用表，也是一个哈希表。被引用的对象的地址作为key，weak_entry_t结构体作为值。</p>
<p>weak_entries： 指针变量，指向一个hash数组，数组里存储弱引用对象的相关信息weak_entry_t。初始时为NULL，第一次插入时才会创建一个长度为64的数组并用weak_entries指向该数组，相当于懒加载。如果事先分配一个长度为64的数组，显然是不必要的，因为有可能没有地方使用到weak指针。</p>
<p>num_entries： hash数组中的元素个数</p>
<p>mask：hash数组长度-1（注意，这里是hash数组的长度，而不是元素个数。比如，数组长度可能是64，而元素个数仅存了2个）    </p>
<p>max_hash_displacement：可能会发生的hash冲突的最大次数，用于判断是否出现了逻辑错误（hash表中的冲突次数绝不会超过该值）</p>
<p>ps：在C++里面weak_entry_t就相当于struct weak_entry_t可以省略struct，在C中肯定是没有这样的语法的，我说怎么看起来这么奇怪。</p>
<h3 id="3-weak的实现"><a href="#3-weak的实现" class="headerlink" title="3.weak的实现"></a>3.weak的实现</h3><h4 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h4><p>前面已经知道，使用__weak修饰符时，系统其实是调用了objc_initWeak函数，本节就分析一下objc_initWeak的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">id</span></span><br><span class="line"><span class="function"><span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>location的值就是对象指针变量的地址，<code>*location</code> 指向旧对象，newObj指向新对象。后面的大部分操作都和这三个值有关。</p>
<h4 id="storeweak"><a href="#storeweak" class="headerlink" title="storeweak"></a>storeweak</h4><p>objc_initWeak主要调用了storeweak函数，它的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> id </span></span><br><span class="line"><span class="function"><span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) <span class="built_in">ASSERT</span>(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire locks for old and new values.</span></span><br><span class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></span><br><span class="line">    <span class="comment">// Retry if the old value changes underneath us.</span></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;<span class="built_in">SideTables</span>()[oldObj]; <span class="comment">//从SideTablesMap哈希表中获取旧对象的SideTable</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;<span class="built_in">SideTables</span>()[newObj]; <span class="comment">//从SideTablesMap哈希表中获取新对象的SideTable</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::<span class="built_in">lockTwo</span>&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::<span class="built_in">unlockTwo</span>&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a deadlock between the weak reference machinery</span></span><br><span class="line">    <span class="comment">// and the +initialize machinery by ensuring that no </span></span><br><span class="line">    <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;<span class="built_in">isInitialized</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::<span class="built_in">unlockTwo</span>&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            <span class="built_in">class_initialize</span>(cls, (id)newObj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this class is finished with +initialize then we&#x27;re good.</span></span><br><span class="line">            <span class="comment">// If this class is still running +initialize on this thread </span></span><br><span class="line">            <span class="comment">// (i.e. +initialize called storeWeak on an instance of itself)</span></span><br><span class="line">            <span class="comment">// then we may proceed but it will appear initializing and </span></span><br><span class="line">            <span class="comment">// not yet initialized to the check above.</span></span><br><span class="line">            <span class="comment">// Instead set previouslyInitializedClass to recognize it on retry.</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        <span class="built_in">weak_unregister_no_lock</span>(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            <span class="built_in">weak_register_no_lock</span>(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;<span class="built_in">isTaggedPointer</span>()) &#123;</span><br><span class="line">            newObj-&gt;<span class="built_in">setWeaklyReferenced_nolock</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::<span class="built_in">unlockTwo</span>&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> StripedMap&lt;SideTable&gt;&amp; <span class="title">SideTables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SideTablesMap.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>storeWeak的作用大致如下：</p>
<ol>
<li>根据旧对象的地址从SideTablesMap中找到旧SideTable，根据新对象的地址从SideTablesMap中找到新SideTable</li>
<li>加锁，锁上新旧SideTable。因为后面要操作表里面的东西了，保证同一时刻只能由一个线程操作该表。</li>
<li>unregister，从旧的表中移除当前指针变量地址。</li>
<li>register，在新的表中登记当前指针变量地址。</li>
<li>将对象的<code>weakly_referenced</code>标志位置为 true，说明该对象是有弱引用指针的，销毁时需要将它们置为 nil 并移除。完成后将指针变量的值指向新对象。</li>
<li>解锁SideTable</li>
</ol>
<p>另外，unregister或register时可能会进行weak表的减容或扩容。</p>
<p>这里面主要的两个函数就是weak_unregister_no_lock和weak_register_no_lock了。</p>
<h4 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h4><p>先来看weak_register_no_lock:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Registers a new (object, weak pointer) pair. Creates a new weak</span></span><br><span class="line"><span class="comment"> * object entry if it does not exist.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object pointed to by the weak reference.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak pointer address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">id</span> </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="type">id</span> referent_id, </span><br><span class="line">                      <span class="type">id</span> *referrer_id, <span class="type">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">    <span class="type">bool</span> deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (<span class="type">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((<span class="type">id</span>)referent, </span><br><span class="line">                                           <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Cannot form weak reference to instance (%p) of &quot;</span></span><br><span class="line">                        <span class="string">&quot;class %s. It is possible that this object was &quot;</span></span><br><span class="line">                        <span class="string">&quot;over-released, or is in the process of deallocation.&quot;</span>,</span><br><span class="line">                        (<span class="type">void</span>*)referent, object_getClassName((<span class="type">id</span>)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概过程：</p>
<ol>
<li>根据对象的地址从weak_table中找到weak_entry_t，把指针变量的地址保存到weak_entry_t里的数组中。</li>
<li>如果在weak_table没有找到该对象的weak_entry_t，则新创建一个weak_entry_t并把指针变量的地址保存到weak_entry_t里的数组中，扩容weak_table（if needed）,将新创建的weak_entry_t插入到weak_table中</li>
</ol>
<p>正常保存之前会有一些判断，会判断当前对象是否正在销毁，如果正在销毁则根据crashIfDeallocating决定是崩溃还是返回 nil，如果是返回 nil，则指针变量就被赋值为nil 了。对于 objc_initWeak 和 objc_storeWeak函数来说传入的都是DoCrashIfDeallocating，因此<strong>不要在对象的 dealloc 方法里再去弱引用它</strong>。比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="type">id</span> __<span class="keyword">weak</span> obj = <span class="keyword">self</span>; <span class="comment">//实际代码当然不会这么明显，比较隐蔽的一种情况是懒加载的view设置delegate为self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>崩溃：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">objc[70479]: Cannot form weak reference to<span class="built_in"> instance </span>(0x600001778540) of class ARCPerson. It is possible that this object was over-released,<span class="built_in"> or </span>is in the process of deallocation.</span><br></pre></td></tr></table></figure>
<p>weak_register_no_lock里面调用了很多函数，不过都是哈希表的操作，一个个看。</p>
<h5 id="weak-entry-for-referent"><a href="#weak-entry-for-referent" class="headerlink" title="weak_entry_for_referent"></a>weak_entry_for_referent</h5><p>weak_entry_for_referent：根据对象的地址从weak_table中找到weak_entry_t</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Return the weak reference table entry for the given referent. </span></span><br><span class="line"><span class="comment"> * If there is no entry for referent, return NULL. </span></span><br><span class="line"><span class="comment"> * Performs a lookup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object. Must not be nil.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The table of weak referrers to this object. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(referent);</span><br><span class="line"></span><br><span class="line">    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>首先判断weak_table_t的成员变量weak_entries是否为NULL，如果为NULL说明需要创建哈希数组。</li>
<li>将对象地址hash 化并按位与weak_table-&gt;mask确保不会数组越界，这样就得到一个起始 index。</li>
<li>hash冲突解决，如果 index 处已经有元素但并不等于当前对象，表明存在 hash冲突，则和 index 的下一个位置进行比较。期间如果又找到开始的位置则调用bad_weak_table函数抛出异常。如果超过了最大哈希冲突max_hash_displacement则停止查找也返回 nil，表明哈希表冲突太多了需要扩容了。</li>
</ol>
<p>这里可以看一下对象地址的hash 化：hash_pointer(referent)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title function_">hash_pointer</span><span class="params">(objc_object *key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_hash((<span class="type">uintptr_t</span>)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pointer hash function.</span></span><br><span class="line"><span class="comment">// This is not a terrific hash, but it is fast </span></span><br><span class="line"><span class="comment">// and not outrageously flawed for our purposes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Based on principles from http://locklessinc.com/articles/fast_hash/</span></span><br><span class="line"><span class="comment">// and evaluation ideas from http://floodyberry.com/noncryptohashzoo/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">ptr_hash</span><span class="params">(<span class="type">uint64_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    key *= <span class="number">0x8a970be7488fda55</span>;</span><br><span class="line">    key ^= __builtin_bswap64(key);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">ptr_hash</span><span class="params">(<span class="type">uint32_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    key *= <span class="number">0x5052acdb</span>;</span><br><span class="line">    key ^= __builtin_bswap32(key);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Higher-quality hash function. This is measurably slower in some workloads.</span></span><br><span class="line"><span class="comment">#if __LP64__</span></span><br><span class="line"><span class="comment"> uint32_t ptr_hash(uint64_t key)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    key -= __builtin_bswap64(key);</span></span><br><span class="line"><span class="comment">    key *= 0x8a970be7488fda55;</span></span><br><span class="line"><span class="comment">    key ^= __builtin_bswap64(key);</span></span><br><span class="line"><span class="comment">    key *= 0x8a970be7488fda55;</span></span><br><span class="line"><span class="comment">    key ^= __builtin_bswap64(key);</span></span><br><span class="line"><span class="comment">    return (uint32_t)key;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">static uint32_t ptr_hash(uint32_t key)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    key -= __builtin_bswap32(key);</span></span><br><span class="line"><span class="comment">    key *= 0x5052acdb;</span></span><br><span class="line"><span class="comment">    key ^= __builtin_bswap32(key);</span></span><br><span class="line"><span class="comment">    key *= 0x5052acdb;</span></span><br><span class="line"><span class="comment">    key ^= __builtin_bswap32(key);</span></span><br><span class="line"><span class="comment">    return key;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>系统采用了一个不是很棒但是速度很快的哈希函数，不是很棒表明该哈希函数可能会导致一些哈希冲突，散列的不是很均匀。同时注释里列举了一个高质量的哈希函数，但是在某些情况下速度比较慢的哈希函数。可以看到系统对散列均匀程度与速度之间的权衡。</p>
<h5 id="weak-entry-insert"><a href="#weak-entry-insert" class="headerlink" title="weak_entry_insert"></a>weak_entry_insert</h5><p>weak_entry_insert：往weak表中插入一个元素weak_entry_t</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_entry_insert</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">weak_entry_t</span> *new_entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    ASSERT(weak_entries != nil);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_entries[index].referent != nil) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_entries); <span class="comment">//bad_weak_table就是抛出异常。一般不会到这里</span></span><br><span class="line">        hash_displacement++; <span class="comment">//记录冲突的次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entries[index] = *new_entry;</span><br><span class="line">    weak_table-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">        weak_table-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样先得到一个起始 index，再进行 hash 冲突解决并记录冲突的次数，然后插入到空位置。最后更新哈希表的最大哈希冲突值max_hash_displacement。</p>
<h5 id="weak-grow-maybe"><a href="#weak-grow-maybe" class="headerlink" title="weak_grow_maybe"></a>weak_grow_maybe</h5><p>weak_grow_maybe：扩容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Grow the given zone&#x27;s table of weak references if it is full.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_grow_maybe</span><span class="params">(<span class="type">weak_table_t</span> *weak_table)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grow if at least 3/4 full.</span></span><br><span class="line">    <span class="keyword">if</span> (weak_table-&gt;num_entries &gt;= old_size * <span class="number">3</span> / <span class="number">4</span>) &#123;</span><br><span class="line">        weak_resize(weak_table, old_size ? old_size*<span class="number">2</span> : <span class="number">64</span>); <span class="comment">//old_size为0时，则默认设置为64个槽。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>达到最大空间的3/4时进行扩容。扩容时机：插入元素前，会先判断是否需要扩容。</p>
<h5 id="append-referrer"><a href="#append-referrer" class="headerlink" title="append_referrer"></a>append_referrer</h5><p>append_referrer：将指针变量地址添加到weak_entry_t的哈希表里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Add the given referrer to set of weak pointers in this entry.</span></span><br><span class="line"><span class="comment"> * Does not perform duplicate checking (b/c weak pointers are never</span></span><br><span class="line"><span class="comment"> * added to a set twice). </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the set of weak pointers. </span></span><br><span class="line"><span class="comment"> * @param new_referrer The new weak pointer to be added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">append_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **new_referrer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Couldn&#x27;t insert inline. Allocate out of line.</span></span><br><span class="line">        <span class="type">weak_referrer_t</span> *new_referrers = (<span class="type">weak_referrer_t</span> *)</span><br><span class="line">            <span class="built_in">calloc</span>(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(<span class="type">weak_referrer_t</span>));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(entry-&gt;out_of_line());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Grow the entry&#x27;s hash table of referrers. Rehashes each</span></span><br><span class="line"><span class="comment"> * of the referrers.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param entry Weak pointer hash set for a particular object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__attribute__((noinline, used))</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">grow_refs_and_insert</span><span class="params">(<span class="type">weak_entry_t</span> *entry, </span></span><br><span class="line"><span class="params">                                 objc_object **new_referrer)</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(entry-&gt;out_of_line());</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(entry);</span><br><span class="line">    <span class="type">size_t</span> new_size = old_size ? old_size * <span class="number">2</span> : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> num_refs = entry-&gt;num_refs;</span><br><span class="line">    <span class="type">weak_referrer_t</span> *old_refs = entry-&gt;referrers;</span><br><span class="line">    entry-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    entry-&gt;referrers = (<span class="type">weak_referrer_t</span> *)</span><br><span class="line">        <span class="built_in">calloc</span>(TABLE_SIZE(entry), <span class="keyword">sizeof</span>(<span class="type">weak_referrer_t</span>));</span><br><span class="line">    entry-&gt;num_refs = <span class="number">0</span>;</span><br><span class="line">    entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; old_size &amp;&amp; num_refs &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (old_refs[i] != nil) &#123;</span><br><span class="line">            append_referrer(entry, old_refs[i]);</span><br><span class="line">            num_refs--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Insert</span></span><br><span class="line">    append_referrer(entry, new_referrer);</span><br><span class="line">    <span class="keyword">if</span> (old_refs) <span class="built_in">free</span>(old_refs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的参数是 <code>new_referrer</code> ，即我们将要把对象指针变量的地址插入到entry的哈希表里。</p>
<p>这里会先判断有没有超出 <code>out_of_line</code> ，如果没有则插入到一个普通数组，否则插入到一个哈希数组里。</p>
<p>上面是 <code>weak_register_no_lock</code> 的整个逻辑。下面看一下 <code>weak_unregister_no_lock</code> 。</p>
<h4 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><p>weak_unregister_no_lock：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">weak_unregister_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id, </span></span><br><span class="line"><span class="params">                        id *referrer_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="type">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>找到weak_entry</li>
<li>调用remove_referrer移除指针变量地址</li>
<li>判断weak_entry是否为空，为空则从weak_table中将weak_entry也移除。weak_table减容如果可能。</li>
</ol>
<p>这里主要是remove_referrer和weak_entry_remove的调用。</p>
<h5 id="remove-referrer"><a href="#remove-referrer" class="headerlink" title="remove_referrer"></a>remove_referrer</h5><p>remove_referrer：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Remove old_referrer from set of referrers, if it&#x27;s present.</span></span><br><span class="line"><span class="comment"> * Does not remove duplicates, because duplicates should not exist. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @todo this is slow if old_referrer is not present. Is this ever the case? </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the referrers.</span></span><br><span class="line"><span class="comment"> * @param old_referrer The referrer to remove. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **old_referrer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                     <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                     <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                     <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                         <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                         <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                         <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很多，但逻辑很简单，就是找到old_referrer这个元素的位置，然后将这个位置的内容置为 nil。注意这里并没有将弱引用指针置位nil。</p>
<h5 id="weak-entry-remove"><a href="#weak-entry-remove" class="headerlink" title="weak_entry_remove"></a>weak_entry_remove</h5><p>weak_entry_remove：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove entry from the zone&#x27;s table of weak references.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_entry_remove</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">weak_entry_t</span> *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// remove entry</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) <span class="built_in">free</span>(entry-&gt;referrers);</span><br><span class="line">    bzero(entry, <span class="keyword">sizeof</span>(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line"></span><br><span class="line">    weak_compact_maybe(weak_table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shrink the table if it is mostly empty.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_compact_maybe</span><span class="params">(<span class="type">weak_table_t</span> *weak_table)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shrink if larger than 1024 buckets and at most 1/16 full.</span></span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= <span class="number">1024</span>  &amp;&amp; old_size / <span class="number">16</span> &gt;= weak_table-&gt;num_entries) &#123;</span><br><span class="line">        weak_resize(weak_table, old_size / <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// leaves new table no more than 1/2 full</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>如果weak_entry_t使用的是哈希数组则释放哈希数组内存</li>
<li>将weak_entry_t自身的内存清零，这样weak_table_t中就腾出来一个可用的位置</li>
<li>将num_entries减 1，即weak_table_t元素个数减 1</li>
<li>如果weak表里面元素个数小于某个值时，则将weak_table_t进行减容</li>
</ol>
<p>减容和扩容都会调用weak_resize：</p>
<h4 id="weak-resize"><a href="#weak-resize" class="headerlink" title="weak_resize"></a>weak_resize</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_resize</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">size_t</span> new_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *old_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    <span class="type">weak_entry_t</span> *new_entries = (<span class="type">weak_entry_t</span> *)</span><br><span class="line">        <span class="built_in">calloc</span>(new_size, <span class="keyword">sizeof</span>(<span class="type">weak_entry_t</span>));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">    weak_table-&gt;weak_entries = new_entries;</span><br><span class="line">    weak_table-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (old_entries) &#123;</span><br><span class="line">        <span class="type">weak_entry_t</span> *entry;</span><br><span class="line">        <span class="type">weak_entry_t</span> *end = old_entries + old_size;</span><br><span class="line">        <span class="keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;referent) &#123;</span><br><span class="line">                weak_entry_insert(weak_table, entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(old_entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>开辟一个新的长度为new_size的内存空间</li>
<li>将旧的哈希表old_entries里的weak_entry_t重新插入（其实就是重新散列）到新的new_entries里，插入前判断entry-&gt;referent是否有值。这样已经清零的内存就不会插入。</li>
</ol>
<p>到此为止objc_initWeak的作用就分析完了。</p>
<p>接下来就是查看当对象销毁时，如何将所有指向它的弱引用指针变量赋值为nil。</p>
<h4 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h4><p>一个对象销毁时会调用dealloc方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123; <span class="comment">//NSObject的dealloc，所以在子类中需要调用super才会执行如weak表的清除，关联对象的释放等。</span></span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;<span class="built_in">rootDealloc</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootDealloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">sidetable_present</span>());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_dispose</span></span><br><span class="line"><span class="comment">* fixme</span></span><br><span class="line"><span class="comment">* Locking: none</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">id </span></span><br><span class="line"><span class="function"><span class="title">object_dispose</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">objc_destructInstance</span>(obj);    </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">        <span class="type">bool</span> assoc = obj-&gt;<span class="built_in">hasAssociatedObjects</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="built_in">object_cxxDestruct</span>(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;<span class="built_in">clearDeallocating</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::clearDeallocating</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        <span class="built_in">sidetable_clearDeallocating</span>(); <span class="comment">//这里面也是清除weak，清除引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">slowpath</span>(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        <span class="built_in">clearDeallocating_slow</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">sidetable_present</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_destructInstance函数作用：</p>
<p>如果有自定义的C++析构方法，则调用C++析构函数。如果有关联对象，则移除关联对象并将其自身从<code>Association Manager</code>的map中移除。调用<code>clearDeallocating</code>方法清除对象的相关引用。</p>
<p>最终会调用clearDeallocating_slow：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Slow path of clearDeallocating() </span></span><br><span class="line"><span class="comment">// for objects with nonpointer isa</span></span><br><span class="line"><span class="comment">// that were ever weakly referenced </span></span><br><span class="line"><span class="comment">// or whose retain count ever overflowed to the side table.</span></span><br><span class="line"><span class="function">NEVER_INLINE <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::clearDeallocating_slow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line">    table.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        <span class="built_in">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.<span class="built_in">erase</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clearDeallocating_slow在获取到SideTable后会加锁，完成清除操作后，SideTable又会释放锁。</p>
<h5 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h5><p>核心函数weak_clear_no_lock：将所有弱引用该对象的指针变量的值置为 nil，并将该 object 的weak_entry_t从 weak 表中移除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Called by dealloc; nils out all weak pointers that point to the </span></span><br><span class="line"><span class="comment"> * provided object so that they can no longer be used.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object being deallocated. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">weak_clear_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    <span class="type">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = <span class="built_in">TABLE_SIZE</span>(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil; <span class="comment">//弱引用指针的值被置位nil.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                             <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                             <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                             <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                             referrer, (<span class="type">void</span>*)*referrer, (<span class="type">void</span>*)referent);</span><br><span class="line">                <span class="built_in">objc_weak_error</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">weak_entry_remove</span>(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>SideTable示意图</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/E011FE656F40C3CA194795B0CA107AA9.png" alt=""></p>
<p>让我们再来看一下下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">XQPerson *p = XQPerson.new;</span><br><span class="line">__<span class="keyword">weak</span> XQPerson *wp = p;</span><br></pre></td></tr></table></figure>
<p>对于上面简单的一句 <code>__weak XQPerson *wp = p;</code> 背后执行的逻辑可不少。</p>
<p>首先会根据新旧对象的地址分别从SideTablesMap中获取到新旧对象的SideTable，</p>
<p>然后再根据旧对象的地址从旧对象的SideTable的weak 表中获取到weak entry，然后从weak entry的referrers哈希表中把指针变量移除，</p>
<p>最后再根据新对象的地址从新对象的SideTable的weak 表中获取到weak entry，然后将弱引用指针变量登记到weak entry的referrers哈希表中。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wangwangok.github.io/2018/05/18/source_code_objc_weak_t/">细看objc-weak源码</a></p>
<p><a href="https://juejin.im/post/5e7a322f6fb9a07ca24f79bb">iOS底层原理：weak的实现原理</a></p>
<p><a href="https://blog.csdn.net/u013378438/article/details/82790332">Objective-C runtime机制(7)——SideTables, SideTable, weak_table, weak_entry_t</a></p>
<p>哈希算法相关</p>
<p><a href="https://blog.codinghorror.com/speed-hashing/">Speed Hashing</a></p>
<p><a href="http://blog.itpub.net/31557372/viewspace-2222260/">扫盲，那些让人蛋疼的Hash概念</a></p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>Q1：OC对象的引用计数是保存在哪的？（已完成）</p>
<p>分析了好几天的 weak 实现，突然想知道OC对象的引用计数到底是保存在哪的，于是便有了这个疑问。这个问题比较大，可能需要一整篇文章才能回答。</p>
<p>简单点讲就是存储在SideTable的RefcountMap（也是一个哈希表）里，不过大多数情况下是存储在对象的isa里。</p>
<p>参考：</p>
<p><a href="https://juejin.im/post/5b4c59a55188251ac9767872">苹果iOS系统源码思考：对象的引用计数存储在哪里？—从runtime源码得到的启示</a></p>
<p><a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/">Objective-C 引用计数原理</a></p>
<p><a href="https://juejin.im/post/5ce2b7386fb9a07eff005b4c">理解 ARC 实现原理</a></p>
<p>Q2：为什么 weak 是线程不安全的？（待解决）</p>
<p>源码里好些weak 相关的函数都注释着该函数是线程不安全的，如：objc_initWeak，objc_destroyWeak。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Destroys the relationship between a weak pointer</span></span><br><span class="line"><span class="comment"> * and the object it is referencing in the internal weak</span></span><br><span class="line"><span class="comment"> * table. If the weak pointer is not referencing anything, </span></span><br><span class="line"><span class="comment"> * there is no need to edit the weak table. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param location The weak pointer address. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">objc_destroyWeak</span><span class="params">(id *location)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但本人没遇到过因为 weak 导致的崩溃，也没试出来，看源码发现该加锁的地方也都加锁了，实在看不出来到底是哪个地方会导致线程不安全。</p>
<p>参考</p>
<p><a href="https://suhou.github.io/2019/05/14/%E4%BB%8E%E4%B8%80%E4%B8%AAcrash%E7%90%86%E8%A7%A3weak%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE/">从一个crash理解weak的延迟释放</a>   作者其他文章也还不错</p>
<p><a href="https://blog.csdn.net/rhythmkay/article/details/86539617">不安全的weak变量</a>  不安全的一个例子，没怎么看懂</p>
<p><a href="https://debugly.cn/2017/07/17-weakself-in-dealloc-cause-crash.html">在 dealloc 里使用 weak self 引起崩溃？</a></p>
<p><a href="https://bugs.swift.org/browse/SR-192">Weak properties are not thread safe when reading</a>  不过系统已经解决了。</p>
<p><a href="https://github.com/apple/swift/pull/1454">[runtime] Thread safety for weak references #1454</a></p>
<p>查遍了Google都是说因为objc_loadWeakRetained的问题导致的多线程下过度释放，但从资料上显示objc_loadWeakRetained函数已经修复了该问题。所以不太清楚到底还有哪些原因导致weak多线程不安全。</p>
<p>Q3：dealloc 的时候增加引用计数，会防止对象销毁吗？</p>
<p>不能。在dealloc 的时候调用retain，引用计数确实会增加，但不会阻止对象销毁。因为dealloc最终会调用super-dealloc，而super-dealloc从上面的实现可以看到最终会调用free释放内存。可以说dealloc是一个不可逆的行为。</p>
<p>retain只在对象还没销毁的时候才有用。</p>
<p>MRC：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">//在[super dealloc];前写没有问题，虽然此时引用计数会增加，但对象已经在销毁了，super dealloc里最终会调用free。</span></span><br><span class="line"><span class="comment">//    [self retain]; //引用计数会变为2.但没用。</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;retainCount:%lu&quot;, (unsigned long)[self retainCount]); </span></span><br><span class="line">    </span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在[super dealloc];后写会崩溃，因为对象的内存已经free了，这里会野指针崩溃。</span></span><br><span class="line">    [<span class="keyword">self</span> <span class="keyword">retain</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;retainCount:%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)[<span class="keyword">self</span> retainCount]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARC：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    ARCPerson *obj = <span class="keyword">self</span>; <span class="comment">//这里没事，引用计数会变为2.</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;obj:%@&quot;</span>, obj);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;retain count = %ld\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge  <span class="built_in">CFTypeRef</span>)(<span class="keyword">self</span>)));</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> ARCPerson *wObj = <span class="keyword">self</span>; <span class="comment">//这里会崩溃。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;wObj:%@&quot;</span>, wObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q4：weak是否适用于MRC？</p>
<p>适用。weak在MRC下也是有效果的。只不过weak只能在&gt;=iOS5上才能使用。</p>
<p>示例：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)hello &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MRCCat *cat = [MRCCat new];</span><br><span class="line">        <span class="keyword">self</span>.weakCat = cat;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 1&quot;</span>, <span class="keyword">self</span>.weakCat);</span><br><span class="line">        [cat release];</span><br><span class="line">    &#125; <span class="comment">//weak在MRC下也是有效果的。只不过weak只能在&gt;=iOS5上才能使用。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 2&quot;</span>, <span class="keyword">self</span>.weakCat); <span class="comment">//这里打印为：(null) 2。说明weakCat被置为nil了。</span></span><br><span class="line">    [<span class="keyword">self</span>.weakCat hello];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ hello&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>复习 C 语言里的指针和数组的一些语法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *intPtr = &amp;i; <span class="comment">//可以指向一个int变量，也可以指向一个元素为int的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> intArr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">intArr[<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *intPtrArr[<span class="number">10</span>] = &#123;&amp;i&#125;;</span><br><span class="line">*intPtrArr[<span class="number">0</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *intPtrArr = intArr;</span><br><span class="line">*(intPtrArr+<span class="number">1</span>) = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">intPtr = intArr; <span class="comment">//这里intPtr就指向了一个数组</span></span><br><span class="line">*(intPtr + <span class="number">2</span>) = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **ptrD = &amp;intPtr; <span class="comment">//ptrD指针的指针</span></span><br><span class="line"><span class="type">int</span> **arr[<span class="number">10</span>] = &#123;<span class="literal">NULL</span>&#125;; <span class="comment">//arr是一个数组，元素是指针的指针</span></span><br><span class="line"><span class="type">int</span> ***ptrArr = arr; <span class="comment">//ptrArr是一个指针，指向一个数组，数组的元素是指针的指针</span></span><br><span class="line">arr[<span class="number">0</span>] = ptrD;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = *intPtr;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>一种可行的边下边播方案for AVPlayer</title>
    <url>/2020/07/18/%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A1%8C%E7%9A%84%E8%BE%B9%E4%B8%8B%E8%BE%B9%E6%92%AD%E6%96%B9%E6%A1%88for%20AVPlayer/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么是边下边播？</p>
<p>个人理解边下边播指的是从服务器获取到的数据一边供给播放器播放一边缓存到本地，即使用一遍的流量完成播放和缓存。下次播放时有缓存的地方则播放缓存数据，没有缓存的地方则从服务器获取再播放。</p>
<h3 id="0-边下边播方案"><a href="#0-边下边播方案" class="headerlink" title="0.边下边播方案"></a>0.边下边播方案</h3><p>目前的边下边播实现方案大致有两种：一种是使用本地代理服务器，一种是使用系统的AVAssetResourceLoaderDelegate。</p>
<h4 id="使用本地代理服务器"><a href="#使用本地代理服务器" class="headerlink" title="使用本地代理服务器"></a>使用本地代理服务器</h4><p>该方案是在播放器与视频源服务器之间加一层代理服务器，拦截视频播放器发送的请求，根据拦截的请求，向网络服务器请求数据，然后写到本地。本地代理服务器从文件中读取数据并发送给播放器进行播放。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/E26B3DA6-54DC-499A-B2E1-937E65C93A8F.png" style="zoom:50%;" /></p>
<p>对于 iOS 端代理服务器的实现，可以参考和使用 CocoaHTTPServer。对于 iOS 端的视频缓存管理，可以参考和使用 KTVHTTPCache。这种方案难度较高，但自主可控性更高。</p>
<h4 id="使用系统原生API—AVAssetResourceLoaderDelegate"><a href="#使用系统原生API—AVAssetResourceLoaderDelegate" class="headerlink" title="使用系统原生API—AVAssetResourceLoaderDelegate"></a>使用系统原生API—AVAssetResourceLoaderDelegate</h4><p>方案三跟方案二原理基本一致，但是不需要我们自己开启本地服务器，实现相对简单，只需要遵守相关协议，提供播放的数据即可。默认情况下使用AVPlayer播放音视频，系统是不会把数据缓存到本地的。但是我们可以通过设置AVAssetResourceLoader的delegate来代理系统的请求。代理系统请求后我们就可以对数据进行缓存。</p>
<p>本文采用原生API来实现边下边播。具体实现参考我的开源库：<a href="https://xxx">GSDMediaCache</a></p>
<h3 id="1-边下边播的难点—空洞"><a href="#1-边下边播的难点—空洞" class="headerlink" title="1.边下边播的难点—空洞"></a>1.边下边播的难点—空洞</h3><p>一个视频在播放的时候，用户难免会快进或快退，频繁的快进或快退会造成大量的空洞，这给缓存带来了巨大的麻烦。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20210405172404.png" style="zoom:50%;" /></p>
<p>绿色的代表已缓存，红色的代表未缓存。</p>
<p>这里给出的解决方案是稀疏文件+区间记录表。</p>
<p>稀疏文件（Sparse File）其实就是一个普通文件，用于保存音视频数据，当接收到数据时，按区间填充该文件。</p>
<p>区间记录表用于记录哪些区间是已经缓存好的。区间记录表里可能有多个区间，但当视频完全缓存时区间记录表里就只剩一个区间：[0, n-1]。</p>
<p>这样整个工作流程就变为：</p>
<p>1.根据系统的请求范围，查找区间记录表，将系统请求拆分为一个请求列表。</p>
<p>如：[本地请求，远程请求，本地请求…]。</p>
<p>2.依次执行请求列表中的每个请求，并将请求到的数据供给播放器。</p>
<p>在得到请求列表后，我们就需要执行这些请求。对于本地请求则直接从本地音视频缓存文件中查找该区间的数据并返回。对于远程请求则发起HTTP range请求，接收到数据后提供给播放器播放并缓存到本地。</p>
<p>3.对于远程请求接收到数据后缓存到音视频文件，并<strong>合并式更新区间记录表</strong>。</p>
<p>远程请求会发起HTTP range请求，接收到数据后需要写入到音视频缓存文件，与此同时需要合并式更新区间记录表。所谓合并式更新：<br>比如区间记录表里有：[0, 99]、[200, 299]。如果下一次写入的是[100, 199]，则需要融合区间变为[0, 299]。</p>
<p>这里的主要难点就是系统请求的拆分与区间记录表的维护了。当然实际开发中还会遇到各种各样的小问题，比如读写问题，内存问题，甚至是系统的坑。</p>
<h3 id="2-GSDMediaCache"><a href="#2-GSDMediaCache" class="headerlink" title="2.GSDMediaCache"></a>2.GSDMediaCache</h3><p>一个基于AVPlayer的边下边播缓存框架。具有如下特点：</p>
<ol>
<li>支持边下边播，一遍的流量完成播放和缓存。</li>
<li>极致的缓存利用，只有未缓存的区间才会从服务器获取。</li>
<li>线程安全。</li>
<li>高性能，低内存、低CPU消耗。</li>
<li>最低支持iOS10。</li>
</ol>
<h4 id="2-1框架示意图"><a href="#2-1框架示意图" class="headerlink" title="2.1框架示意图"></a>2.1框架示意图</h4><p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20210404163913.png" style="zoom:50%;" /></p>
<h4 id="2-2类图"><a href="#2-2类图" class="headerlink" title="2.2类图"></a>2.2类图</h4><p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20220113113013.png" alt=""></p>
<p>说明：</p>
<p>一个resource URL对应一个loader，一个loader管理多个loadingRequest，每个loadingRequest对应一个fetchOperation用于获取数据。fetchOperation内部根据区间记录表将range请求拆分为一个请求序列，如：[RemoteRangeTask, LocalRangeTask, RemoteRangeTask, LocalRangeTask, …]。然后依次执行RangeTask并将获取到的数据提供给播放器播放。</p>
<p>这里需要注意的是在iOS10上最好限制一个loader管理的loadingRequest数量，必要时手动取消一些loadingRequest，一般保持在3个左右。否则在频繁seek的时候容易出现一些奇奇怪怪的问题。</p>
<p>由于本SDK使用系统的API来实现，那么自然需要对AVAssetResourceLoaderDelegate进行一番介绍。</p>
<h3 id="3-AVAssetResourceLoaderDelegate"><a href="#3-AVAssetResourceLoaderDelegate" class="headerlink" title="3. AVAssetResourceLoaderDelegate"></a>3. AVAssetResourceLoaderDelegate</h3><h4 id="3-1-代理系统的请求"><a href="#3-1-代理系统的请求" class="headerlink" title="3.1 代理系统的请求"></a>3.1 代理系统的请求</h4><p>在代理系统的请求前，可以通过抓包，大致了解下AVPlayer播放一个URL时的请求机制：<br>AVPlayer会先请求0-1的数据段，成功后再请求一大段数据，但只接收一小段数据就cancel掉请求。播放一小段后又请求一大段数据，但接收一小段数据后又cancel掉请求，循环这个操作直到接收所有数据。而当用户seek时会取消之前的请求，然后从seek处发起一个新请求。在整个过程中AVPlayer会不断的发起新请求，取消旧的请求，当然有的请求可能不会被取消因而可以正常完成。发起与取消是AVPlayer的内部行为，外部只能得到通知而不能主动发起一个AVAssetResourceLoadingRequest。</p>
<p>了解这一过程对后面的实现非常有帮助，下面正式代理系统的请求。</p>
<p>代理系统的请求非常简单，只需要将我们的对象设置为 <code>AVAssetResourceLoader</code> 的代理，并实现 <code>AVAssetResourceLoaderDelegate</code> 协议。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.将正常的scheme替换为自定义的scheme，并将self设置为resourceLoader的代理</span></span><br><span class="line">- (<span class="built_in">AVURLAsset</span> *)customSchemeAssetWithURL:(<span class="built_in">NSURL</span> *)URL options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="type">id</span>&gt; *)options &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *customURL = [URL gsd_customSchemeURLByAppendingSuffix:kCustomSchemeSuffix];</span><br><span class="line">    <span class="built_in">AVURLAsset</span> *urlAsset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:customURL options:options];</span><br><span class="line">    [urlAsset.resourceLoader setDelegate:<span class="keyword">self</span> queue:<span class="keyword">self</span>.assetDelegateQueue];</span><br><span class="line">    <span class="keyword">return</span> urlAsset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.实现`AVAssetResourceLoaderDelegate`协议中的如下两个，如果有其他的需求可以实现其他几个协议。</span></span><br><span class="line"><span class="comment">//接收到一个新的loadingRequest。该方法仅在系统不知道如何处理URLAsset资源时才会回调，所以我们需要自定义scheme。如果scheme是我们自定义的则返回YES表示我们将接管资源的请求，否则返回NO。</span></span><br><span class="line">- (<span class="type">BOOL</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *resourceURL = loadingRequest.request.URL;</span><br><span class="line">    <span class="keyword">if</span> ([resourceURL gsd_isCustomSchemeURLByContainningSuffix:kCustomSchemeSuffix]) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *originalURL = [resourceURL gsd_recoverCustomSchemeURLByRemovingSuffix:kCustomSchemeSuffix];</span><br><span class="line">        os_unfair_lock_lock(&amp;_loaderLock);</span><br><span class="line">        GSDResourceLoader *loader = <span class="keyword">self</span>.loaderDict[originalURL];</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="literal">nil</span>) &#123;</span><br><span class="line">            loader = [[GSDResourceLoader alloc] initWithResourceURL:originalURL inSession:<span class="keyword">self</span>.session];</span><br><span class="line">            <span class="keyword">self</span>.loaderDict[originalURL] = loader;</span><br><span class="line">        &#125;</span><br><span class="line">        os_unfair_lock_unlock(&amp;_loaderLock);</span><br><span class="line">        [loader addLoadingRequest:loadingRequest];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//系统取消加载资源后回调。在该方法里我们需要取消掉我们之前发的请求。</span></span><br><span class="line">- (<span class="type">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *originalURL = [loadingRequest.request.URL gsd_recoverCustomSchemeURLByRemovingSuffix:kCustomSchemeSuffix];</span><br><span class="line">    os_unfair_lock_lock(&amp;_loaderLock);</span><br><span class="line">    GSDResourceLoader *loader = <span class="keyword">self</span>.loaderDict[originalURL];</span><br><span class="line">    os_unfair_lock_unlock(&amp;_loaderLock);</span><br><span class="line">    [loader cancelLoadingRequest:loadingRequest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是 URL 必须是自定义的 URLScheme，我们需要把原始 URL 的 <code>http://</code> 或 <code>https://</code> 替换成 <code>xxx://</code>，协议方法才会生效。这里我们在原scheme后面拼接“-mine”作为自定义的scheme。选择在原scheme后面拼接的好处就是当我们自己去服务器请求的时候能够很方便的解析出原scheme。到此为止我们就成功拦截了播放器的请求，拦截请求之后我们就需要获取数据并提供给播放器。数据可以从本地缓存获取也可以从服务器获取，这是我们后面要做的事。</p>
<p>然而非常坑人的事情来了，经过测试发现在iOS10.3.3中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest API_AVAILABLE(macos(<span class="number">10.9</span>), ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br></pre></td></tr></table></figure>
<p>didCancelLoadingRequest:方法除了手机重启后的第一次运行APP会被调用，其他时候都不会被调用，非常诡异。而在iOS14上则正常，AVAssetResourceLoader会时不时调用didCancelLoadingRequest:让你有机会cancel掉之前的请求，从而不会出现同时进行的请求数过多的情况。为了适配iOS10，我们需要自己设计一种规则适时的取消掉一些loadingRequest，这里可谓是一个天坑。</p>
<p>参考：<a href="https://developer.apple.com/forums/thread/29039">AVAssetResourceLoaderDelegate -resourceLoader: didCancelLoadingRequest: naver called (in the Device only)</a></p>
<h4 id="3-2-发起请求"><a href="#3-2-发起请求" class="headerlink" title="3.2 发起请求"></a>3.2 发起请求</h4><p>在协议</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest;</span><br></pre></td></tr></table></figure>
<p>中根据loadingRequest参数获取本次的range请求范围，然后向本地缓存或服务器发起请求获取数据。</p>
<p>代理系统的请求后，我们需要根据请求去获取相应的数据，而在shouldWaitForLoadingOfRequestedResource代理方法里，系统给我们提供了一个AVAssetResourceLoadingRequest对象，因此我们需要根据AVAssetResourceLoadingRequest相关的API来获取本次range请求的范围。</p>
<p>AVAssetResourceLoadingRequest：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetResourceLoadingRequest</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">	<span class="built_in">AVAssetResourceLoadingRequestInternal</span> *_loadingRequest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">AV_INIT_UNAVAILABLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVAssetResourceLoadingContentInformationRequest</span> *contentInformationRequest API_AVAILABLE(macos(<span class="number">10.9</span>), ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest API_AVAILABLE(macos(<span class="number">10.9</span>), ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)finishLoading API_AVAILABLE(macos(<span class="number">10.9</span>), ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos); <span class="comment">//本次LoadingRequest请求完成时调用finishLoading通知系统。</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)finishLoadingWithError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error; <span class="comment">//本次LoadingRequest请求出错时调用finishLoadingWithError:通知系统。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>contentInformationRequest：视频元数据信息。如果没设置过则为nil，否则是设置的值。因此需要在接收到0-1的range请求时设置该值告诉AVPlayer视频的相关信息。</p>
<p>dataRequest：数据请求，里面包含本次range请求的范围。</p>
<p>AVAssetResourceLoadingContentInformationRequest：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetResourceLoadingContentInformationRequest</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">	<span class="built_in">AVAssetResourceLoadingContentInformationRequestInternal</span> *_contentInformationRequest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">AV_INIT_UNAVAILABLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *contentType; <span class="comment">//响应头的content-type，但要转为UTI才能赋值给contentType</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">long</span> <span class="type">long</span> contentLength; <span class="comment">//视频长度（byte）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isByteRangeAccessSupported) <span class="type">BOOL</span> byteRangeAccessSupported; <span class="comment">//是否支持range请求。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>AVAssetResourceLoadingDataRequest：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetResourceLoadingDataRequest</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">	<span class="built_in">AVAssetResourceLoadingDataRequestInternal</span> *_dataRequest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">AV_INIT_UNAVAILABLE</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">long</span> <span class="type">long</span> requestedOffset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> requestedLength;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> requestsAllDataToEndOfResource API_AVAILABLE(macos(<span class="number">10.11</span>), ios(<span class="number">9.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">long</span> <span class="type">long</span> currentOffset;</span><br><span class="line">- (<span class="type">void</span>)respondWithData:(<span class="built_in">NSData</span> *)data; <span class="comment">//将请求到的数据塞给播放器。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>requestedOffset：本次range请求的起始字节位置。</p>
<p>requestedLength：本次range请求的长度。</p>
<p>currentOffset：当前已下载的数据的偏移量。requestedOffset + data.length = currentOffset。每次调用respondWithData:方法后，currentOffset会改变。</p>
<p>示意图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20210404163714.png" alt=""></p>
<h4 id="3-3-塞数据给播放器播放"><a href="#3-3-塞数据给播放器播放" class="headerlink" title="3.3 塞数据给播放器播放"></a>3.3 塞数据给播放器播放</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetResourceLoadingDataRequest</span> : <span class="title">NSObject</span> </span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)respondWithData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>调用AVAssetResourceLoadingDataRequest的respondWithData方法将下载的数据提供给播放器播放。</p>
<h4 id="3-4-取消请求"><a href="#3-4-取消请求" class="headerlink" title="3.4 取消请求"></a>3.4 取消请求</h4><p>系统内部会不断的发起请求与取消请求，当我们收到取消请求的通知时，我们需要取消掉对应的数据请求，数据的来源可能是本地缓存也有可能是服务器，因此取消请求分为两种：本地请求取消与远程请求取消。请求的取消至关重要比如系统发起一个0-300M的range请求，恰好本地缓存有这个范围的数据，但系统接收了20M就发起了取消，此时如果你的本地请求不能取消的话APP很快就会耗尽手机的内存直至OOM崩溃。</p>
<p>在协议</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest;</span><br></pre></td></tr></table></figure>
<p>中取消正在进行的请求。但在iOS10上该方法不会被回调，因此对于iOS10可以在发起请求的时机中取消掉之前的一些loadingRequest，这里不能不取消也不能全取消保留2~3个loadingRequest目前来看效果比较好。</p>
<h4 id="3-5-完成请求"><a href="#3-5-完成请求" class="headerlink" title="3.5 完成请求"></a>3.5 完成请求</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetResourceLoadingRequest</span> : <span class="title">NSObject</span> </span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)finishLoading API_AVAILABLE(macos(<span class="number">10.9</span>), ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos); <span class="comment">//本次LoadingRequest请求完成时调用finishLoading通知系统。</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)finishLoadingWithError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error; <span class="comment">//本次LoadingRequest请求出错时调用finishLoadingWithError:通知系统。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>本次LoadingRequest请求成功完成时调用 <code>finishLoading</code> 通知系统，如果失败则调用 <code>finishLoadingWithError:</code> 通知系统。</p>
<h3 id="4-缓存数据，并建立区间记录表"><a href="#4-缓存数据，并建立区间记录表" class="headerlink" title="4.缓存数据，并建立区间记录表"></a>4.缓存数据，并建立区间记录表</h3><p>数据的缓存主要涉及音频元数据的保存，音频文件的保存，区间记录表的保存。</p>
<p>在第一次播放的时候，是没有任何缓存的，区间记录表也没有创建，当远程请求发起HTTP range请求接收到数据后如何保存呢？这就需要用到 <code>NSFileHandle</code> 。</p>
<p>可以调用 <code>NSFileHandle</code> 的 <code>truncateFileAtOffset:</code> ：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)truncateFileAtOffset:(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)offset;</span><br><span class="line">- (<span class="type">void</span>)seekToFileOffset:(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)offset;</span><br><span class="line">- (<span class="type">void</span>)writeData:(<span class="built_in">NSData</span> *)data;</span><br></pre></td></tr></table></figure>
<p>创建一个与音视频大小相等的”稀疏文件”，然后往里填充数据即可。写入完成后，同步更新区间记录表，记录本次写入的数据区间，比如[0, 99]这100个字节。往后写入的时候需要<strong>合并式更新</strong>区间记录表。</p>
<p>比如区间记录表里有：[0, 99]、[200, 299]。如果下一次写入的是[100, 199]，则需要融合区间变为[0, 299]。</p>
<p>注意：区间记录表需要正确维护否则依据区间记录表从缓存文件里读取相应的数据给播放器时会出现各种画面问题或声音问题。</p>
<h3 id="5-缓存清除策略"><a href="#5-缓存清除策略" class="headerlink" title="5.缓存清除策略"></a>5.缓存清除策略</h3><p>缓存清除可以按照最大时间和最大空间两个维度来进行清除。进入后台后优先删除较旧的缓存，如果检测超出最大空间则进一步删除旧缓存直至小于最大空间的0.5倍。当然也可以实现LFU策略。</p>
<p>注意：在删除缓存时要确保音视频数据文件和区间记录表同时删除。如果音视频数据文件删除了但却遗留下了区间记录表显然会有问题。</p>
<h4 id="5-1-计算文件大小"><a href="#5-1-计算文件大小" class="headerlink" title="5.1 计算文件大小"></a>5.1 计算文件大小</h4><p>在实现的过程中发现文件的大小计算跟想象中的还不太一样。</p>
<p>系统提供了一些key用于获取文件信息</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Resource keys applicable only to regular files</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSURLResourceKey</span> <span class="keyword">const</span> <span class="built_in">NSURLFileSizeKey</span>                    API_AVAILABLE(macos(<span class="number">10.6</span>), ios(<span class="number">4.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)); <span class="comment">// Total file size in bytes (Read-only, value type NSNumber)</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSURLResourceKey</span> <span class="keyword">const</span> <span class="built_in">NSURLFileAllocatedSizeKey</span>           API_AVAILABLE(macos(<span class="number">10.6</span>), ios(<span class="number">4.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)); <span class="comment">// Total size allocated on disk for the file in bytes (number of blocks times block size) (Read-only, value type NSNumber)</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSURLResourceKey</span> <span class="keyword">const</span> <span class="built_in">NSURLTotalFileSizeKey</span>               API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)); <span class="comment">// Total displayable size of the file in bytes (this may include space used by metadata), or nil if not available. (Read-only, value type NSNumber)</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSURLResourceKey</span> <span class="keyword">const</span> <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>      API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)); <span class="comment">// Total allocated size of the file in bytes (this may include space used by metadata), or nil if not available. This can be less than the value returned by NSURLTotalFileSizeKey if the resource is compressed. (Read-only, value type NSNumber)</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSURLResourceKey</span> <span class="keyword">const</span> <span class="built_in">NSURLIsAliasFileKey</span>                 API_AVAILABLE(macos(<span class="number">10.6</span>), ios(<span class="number">4.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)); <span class="comment">// true if the resource is a Finder alias file or a symlink, false otherwise ( Read-only, value type boolean NSNumber)</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSURLResourceKey</span> <span class="keyword">const</span> <span class="built_in">NSURLFileProtectionKey</span>              API_AVAILABLE(macos(<span class="number">10.11</span>), ios(<span class="number">9.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)); <span class="comment">// The protection level for this file</span></span><br></pre></td></tr></table></figure>
<p>注意NSURLTotalFileAllocatedSizeKey的说明：This can be less than the value returned by NSURLTotalFileSizeKey if the resource is compressed. 也就是说文件大小和文件实际占用的磁盘大小有可能不一致，这得益于APFS文件系统。</p>
<p>eg: 一个553M的视频，在缓存时会先初始化一个553M的占位文件，然后边下载边往里面填充实际数据。如果没有缓存完就停止缓存，此时用NSURLFileSizeKey 和 NSURLTotalFileAllocatedSizeKey去获取文件大小就会发现二者的值不一样。</p>
<p>NSURLFileSizeKey 返回的是文件自身的大小。而NSURLTotalFileAllocatedSizeKey 返回的是该文件占用的磁盘大小，因为实际只缓存了一点点数据，系统会对他进行压缩。所以该值会小于NSURLFileSizeKey 返回的值。当完全缓存时，该值就会约等于NSURLFileSizeKey 返回的值（实际会稍大于，因为NSURLTotalFileAllocatedSizeKey 还会计算元数据占用的空间）。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">01</span>:<span class="number">24.590838</span>+<span class="number">0800</span> AudioDemo[<span class="number">6292</span>:<span class="number">586528</span>] attrs:&#123;</span><br><span class="line">    <span class="built_in">NSFileCreationDate</span> = <span class="string">&quot;2021-01-25 09:31:02 +0000&quot;</span>;</span><br><span class="line">    <span class="built_in">NSFileExtensionHidden</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSFileGroupOwnerAccountID</span> = <span class="number">501</span>;</span><br><span class="line">    <span class="built_in">NSFileGroupOwnerAccountName</span> = mobile;</span><br><span class="line">    <span class="built_in">NSFileModificationDate</span> = <span class="string">&quot;2021-01-26 02:43:28 +0000&quot;</span>;</span><br><span class="line">    <span class="built_in">NSFileOwnerAccountID</span> = <span class="number">501</span>;</span><br><span class="line">    <span class="built_in">NSFileOwnerAccountName</span> = mobile;</span><br><span class="line">    <span class="built_in">NSFilePosixPermissions</span> = <span class="number">420</span>;</span><br><span class="line">    <span class="built_in">NSFileProtectionKey</span> = <span class="built_in">NSFileProtectionCompleteUntilFirstUserAuthentication</span>;</span><br><span class="line">    <span class="built_in">NSFileReferenceCount</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSFileSize</span> = <span class="number">553363384</span>;</span><br><span class="line">    <span class="built_in">NSFileSystemFileNumber</span> = <span class="number">4470737601</span>;</span><br><span class="line">    <span class="built_in">NSFileSystemNumber</span> = <span class="number">16777223</span>;</span><br><span class="line">    <span class="built_in">NSFileType</span> = <span class="built_in">NSFileTypeRegular</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">29.875546</span>+<span class="number">0800</span> AudioDemo[<span class="number">6292</span>:<span class="number">586700</span>] 文件：file:<span class="comment">///private/var/mobile/Containers/Data/Application/407F45FC-F6D8-411F-89FA-F014ADC5F4EA/Library/Caches/com.xq.GSDMediaCache/data/ddcada74ee08d06dda5cd13b4117ad30.mp4，totalAllocatedSize：553365504</span></span><br></pre></td></tr></table></figure>
<p>iOS 14.3上“ iPhone存储空间”里的App“文稿与数据”只显示App沙盒Documents目录下文件占用的空间，并且展示的是文件实际占用的磁盘大小即NSURLTotalFileAllocatedSizeKey的值，而Cache目录下的文件并不会计算在内。可能是因为Cache目录下的文件在磁盘空间紧张时系统会自动清理。</p>
<p>iOS 10.3.3上“ iPhone存储空间”里的App“文稿与数据”显示的是所有沙盒目录下的文件占用的空间。</p>
<p><strong>文件系统</strong></p>
<p>发展过程：分层文件系统（Hierarchical File System，HFS）—&gt; HFS Plus —&gt; APFS （Apple File System）</p>
<p>APFS :</p>
<p>Apple File System replaces HFS Plus as the default file system for iOS 10.3 and later, and for macOS High Sierra and later. Apple File System offers improved file system fundamentals as well as several new features, including cloning, snapshots, space sharing, fast directory sizing, atomic safe-save, and sparse files.</p>
<p>里面提到了sparse file（稀疏文件），正是由于APFS文件系统支持稀疏文件，所以一个稀疏文件如果不往里填充数据那么它实际不会占用那么大的磁盘空间。</p>
<p>参考：</p>
<p><a href="https://developer.apple.com/documentation/foundation/file_system/about_apple_file_system?language=objc">About Apple File System</a></p>
<p><a href="https://stackoverflow.com/questions/43126760/what-is-a-sparse-file-and-why-do-we-need-it">What is a sparse file and why do we need it?</a></p>
<p><a href="https://stackoverflow.com/questions/2188469/how-can-i-calculate-the-size-of-a-folder/28660040#28660040">How can I calculate the size of a folder?</a></p>
<p><a href="https://blog.csdn.net/duyusean/article/details/78643475">“文件大小”和“占用空间”的区别</a></p>
<h3 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h3><p>如果这个库有帮助到你，欢迎点赞，收藏，转发。当然支持一下也是可以的。最后转载请注明出处。</p>
<h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h3><p><a href="https://www.codeproject.com/Articles/875105/Audio-streaming-and-caching-in-iOS-using">Audio streaming and caching in iOS using AVAssetResourceLoader and AVPlayer</a></p>
<p><a href="http://sky-weihao.github.io/2015/10/06/Video-streaming-and-caching-in-iOS/">iOS音视频实现边下载边播放</a></p>
<p><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/690067/">AVPlayer支持的视频格式</a>  原出处： <a href="https://www.jianshu.com/p/7373f07f1cbf">AVPlayer支持的视频格式</a></p>
<p><a href="https://www.jianshu.com/p/def926938398">音视频封装格式、编码格式</a>  </p>
<p><a href="http://chuquan.me/2019/12/03/ios-avplayer-support-cache/">iOS AVPlayer 视频缓存的设计与实现</a></p>
<p><a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA">可能是目前最好的 AVPlayer 音视频缓存方案</a></p>
<p><a href="https://mochangxing.github.io/2018/08/11/AVPlayer%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0/">AVPlayer 视频缓存</a>  </p>
<p><a href="https://blog.csdn.net/szk972092933/article/details/82771631">iOS音视频开发——-流媒体</a>  </p>
<p><a href="https://blog.csdn.net/kevinpake/article/details/25626587">iOS 获取视频的任意一帧</a></p>
<p><a href="https://juejin.cn/post/6844904115416334343">IOS音视频（四十五）HTTPS 自签名证书 实现边下边播</a> </p>
<p><a href="https://zltunes.github.io/2019/04/23/avplayer-best-practice/">AVPlayer 边下边播与最佳实践</a></p>
<p><a href="https://caisanze.com/post/swift-avplayer/">基于AVPlayer实现音视频播放和缓存，支持视频画面的同步输出</a></p>
<p><a href="https://github.com/vitoziv/VIMediaCache/issues/19">如果视频拖动快进这时候会有声音但画面卡住了</a>  </p>
<p><a href="https://www.mdeditor.tw/pl/ptm8">iOS性能优化实践：头条抖音如何实现OOM崩溃率下降50%+</a>  </p>
<p><a href="http://www.samirchen.com/video-playback-bandwidth-cost/">点播中的流量成本优化</a> </p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650997049&amp;idx=1&amp;sn=079d954687944e74778df58f31078bd3&amp;chksm=bdbef96a8ac9707cd094f3737f6a32ce849066f50857b0b260fc2804e2eda22d3f6452b3cbfa&amp;scene=27#wechat_redirect">腾讯研发总监王辉：十亿级视频播放技术优化揭秘</a>   </p>
<p><a href="https://cocoapods.org/pods/NicooM3u8Downloader">NicooM3u8Downloader</a>  </p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>边下边播</tag>
        <tag>AVPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title>从汇编角度看ARC中的所有权修饰符</title>
    <url>/2020/06/21/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E7%9C%8BARC%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>环境：Xcode11</p>
<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p>在MRC时代 <code>id obj1 = obj;</code> 这一行代码仅仅是赋值，不会引起obj对象引用计数的任何变化。而在ARC时代这一行代码会导致对象的引用计数+1。这背后究竟发生了什么？接下来让我们研究一下。</p>
<p>ARC：自动引用计数。不再需要手动调用 retain 、release、autorelease 等方法，而是由编译器在合适的地方自动添加。那么编译器又是怎么知道是添加retain还是添加autorelease或者weak的呢？这就需要所有权修饰符了。通过不同类型的所有权修饰符，编译器就知道该添加什么语句了。</p>
<p>ARC 有效时，<strong>id 类型和对象类型</strong>必须附加所有权修饰符，有如下几种：</p>
<ul>
<li>__strong 修饰符</li>
<li>__weak 修饰符</li>
<li>__unsafe_unretained 修饰符</li>
<li>__autoreleasing 修饰符</li>
</ul>
<p>其中 <code>__strong</code> 修饰符是OC对象类型的默认修饰符。</p>
<p>接下来从汇编角度看，当一个指针变量使用这些修饰符后，编译器会作何处理。</p>
<h3 id="strong-修饰符"><a href="#strong-修饰符" class="headerlink" title="__strong 修饰符"></a>__strong 修饰符</h3><p>对于下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">       id obj = [NSObject new];</span><br><span class="line">       &#123;</span><br><span class="line">         id __strong obj1 = obj; <span class="comment">//引用计数为2</span></span><br><span class="line">         NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">     .loc    1 12 22 prologue_end    ## WeakDemo/main.m:12:22</span><br><span class="line">     callq    _objc_autoreleasePoolPush</span><br><span class="line"> Ltmp1:</span><br><span class="line">     .loc    1 13 18                 ## WeakDemo/main.m:13:18</span><br><span class="line">     movq    _OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">     movq    _OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">     movq    %rcx, %rdi</span><br><span class="line">     movq    %rax, -40(%rbp)         ## 8-byte Spill</span><br><span class="line">     callq    *_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">     .loc    1 13 12 is_stmt 0       ## WeakDemo/main.m:13:12</span><br><span class="line">     movq    %rax, -24(%rbp)</span><br><span class="line"> Ltmp2:</span><br><span class="line">     .loc    1 15 23 is_stmt 1       ## WeakDemo/main.m:15:23</span><br><span class="line">     movq    -24(%rbp), %rdi</span><br><span class="line">     callq    *_objc_retain@GOTPCREL(%rip)</span><br><span class="line">     leaq    L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">     movq    %rax, -32(%rbp)</span><br><span class="line">     .loc    1 16 29                 ## WeakDemo/main.m:16:29</span><br><span class="line">     movq    -32(%rbp), %rsi</span><br><span class="line">     .loc    1 16 11 is_stmt 0       ## WeakDemo/main.m:16:11</span><br><span class="line">     movq    %rcx, %rdi</span><br><span class="line">     movb    $0, %al</span><br><span class="line">     callq    _NSLog</span><br><span class="line">     xorl    %edx, %edx</span><br><span class="line">     movl    %edx, %esi</span><br><span class="line"> Ltmp3:</span><br><span class="line">     .loc    1 17 9 is_stmt 1        ## WeakDemo/main.m:17:9</span><br><span class="line">     leaq    -32(%rbp), %rdi</span><br><span class="line">     callq    _objc_storeStrong</span><br><span class="line">     xorl    %edx, %edx</span><br><span class="line">     movl    %edx, %esi</span><br><span class="line">     .loc    1 18 5                  ## WeakDemo/main.m:18:5</span><br><span class="line">     leaq    -24(%rbp), %rdi</span><br><span class="line">     callq    _objc_storeStrong</span><br><span class="line">     movq    -40(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">     callq    _objc_autoreleasePoolPop</span><br><span class="line">     xorl    %eax, %eax</span><br></pre></td></tr></table></figure>
<p>上述汇编对应的编译器的模拟源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id obj = objc_msgSend(NSObject, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">id obj1 = objc_retain(obj);  <span class="comment">//插入objc_retain</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">objc_storeStrong(&amp;obj1, nil); <span class="comment">//obj1作用域结束，释放对象，并将obj1置为nil。</span></span><br><span class="line"></span><br><span class="line">objc_storeStrong(&amp;obj, nil);</span><br></pre></td></tr></table></figure>
<p><code>id __strong obj1 = obj;</code> 这句代码实际上被编译器转换为：<code>id obj1 = objc_retain(obj);</code> 。 </p>
<p>看一下函数objc_retain的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__attribute__((<span class="built_in">aligned</span>(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="function">id </span></span><br><span class="line"><span class="function"><span class="title">objc_retain</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">retain</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to calling [this retain], with shortcuts if there is no override</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> id </span></span><br><span class="line"><span class="function"><span class="title">objc_object::retain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">isTaggedPointer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rootRetain</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, @<span class="built_in">selector</span>(retain));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛开那些判断，objc_retain函数最终调用了 retain 方法。对象的引用计数加 1 。这也就是我们常说的在 ARC 下将一个对象赋值给一个强引用的指针变量时，编译器会自动插入一条 retain 方法。</p>
<p>接着往下看，当obj1作用域结束后会执行一句<code>objc_storeStrong(&amp;obj1, nil);</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_storeStrong</span><span class="params">(id *location, id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id prev = *location;</span><br><span class="line">    <span class="keyword">if</span> (obj == prev) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">objc_retain</span>(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    <span class="built_in">objc_release</span>(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//objc_release的实现，基本上等价于调用 release方法。</span></span><br><span class="line">__attribute__((<span class="built_in">aligned</span>(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_release</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to calling [this release], with shortcuts if there is no override</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">isTaggedPointer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>())) &#123;</span><br><span class="line">        <span class="built_in">rootRelease</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="built_in">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, @<span class="built_in">selector</span>(release));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_storeStrong函数的作用：</p>
<p>retain新对象，将指针变量指向新对象，release旧对象。特别的，如果 obj 等于 nil ，上述逻辑代表着将指针变量赋值为 nil，并且 release之前指向的对象。因此 <code>objc_storeStrong(&amp;obj1, nil);</code> 代表着 release obj1 指向的对象，并将obj1置为nil。</p>
<p>这也就是我们常说的在 ARC 下一个强引用的指针变量超出作用域被废弃时，编译器会自动插入一条 release 方法，另外其实还把强引用的指针变量置为nil了。</p>
<p>例子2:</p>
<p>将一个使用new方法创建的对象赋值给一个 <code>__strong</code> 修饰的指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          id __strong obj1 = [NSObject new]; <span class="comment">//引用计数为1而不是2</span></span><br><span class="line">          NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp1:</span><br><span class="line">	.loc	1 32 30                 ## WeakDemo/main.m:32:30</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, -32(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">	.loc	1 32 23 is_stmt 0       ## WeakDemo/main.m:32:23</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">	.loc	1 33 29 is_stmt 1       ## WeakDemo/main.m:33:29</span><br><span class="line">	movq	-24(%rbp), %rsi</span><br><span class="line">	.loc	1 33 11 is_stmt 0       ## WeakDemo/main.m:33:11</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_NSLog</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">	movl	%edx, %esi</span><br><span class="line">Ltmp2:</span><br><span class="line">	.loc	1 34 9 is_stmt 1        ## WeakDemo/main.m:34:9</span><br><span class="line">	leaq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_storeStrong</span><br><span class="line">	movq	-32(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	.loc	1 35 5                  ## WeakDemo/main.m:35:5</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id obj1 = objc_msgSend(NSObject, <span class="string">&quot;new&quot;</span>);</span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">objc_storeStrong(&amp;obj1, nil);</span><br></pre></td></tr></table></figure>
<p>编译器发现obj1可以持有对象，又是创建对象，于是不再 retain。</p>
<p>例子 3：</p>
<p>将一个使用myPerson方法创建的对象赋值给一个 <code>__strong</code> 修饰的指针变量</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">id</span> __<span class="keyword">strong</span> obj1 = [ARCPerson myPerson];</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)myPerson &#123;</span><br><span class="line">    ARCPerson *p = [ARCPerson new];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/20220210154059.png" alt=""></p>
<p>上述汇编对应的编译器的模拟源代码：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id obj1<span class="comment">;</span></span><br><span class="line">id tmp = objc_msgSend(<span class="name">ARCPerson</span>, <span class="string">&quot;myPerson&quot;</span>)<span class="comment">; </span></span><br><span class="line">tmp = objc_autoreleaseReturnValue(<span class="name">tmp</span>)<span class="comment">; //走了优化路径，对象并没有注册到自动释放池</span></span><br><span class="line">obj1 = objc_retainAutoreleasedReturnValue(<span class="name">tmp</span>)<span class="comment">; //和上面不同，这里插入的是objc_retainAutoreleasedReturnValue，而不是objc_retain。由于上面生成的对象没有注册到自动释放池，所以这里也是走的优化路径并没有再retain对象</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1)<span class="comment">;</span></span><br><span class="line">objc_storeStrong(<span class="name">&amp;obj1</span>, <span class="literal">nil</span>)<span class="comment">; //释放对象，起到优化作用，这样就不需要等到runloop结束才释放</span></span><br></pre></td></tr></table></figure>
<p>objc_autoreleaseReturnValue实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prepare a value at +1 for return through a +0 autoreleasing convention.</span></span><br><span class="line">id </span><br><span class="line"><span class="title function_">objc_autoreleaseReturnValue</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	prepareOptimizedReturn(ReturnAtPlus1)的作用就是</span></span><br><span class="line"><span class="comment">  	检测紧接着调用的是不是objc_retainAutoreleasedReturnValue或objc_unsafeClaimAutoreleasedReturnValue</span></span><br><span class="line"><span class="comment">  	是的话就往线程的TLS上写入ReturnAtPlus1即1.这样后面两个函数获取TLS上的值如果发现是1就知道走了优化路径了。</span></span><br><span class="line"><span class="comment">  	这种优化方式有点特别，平时我们可能用个全局变量标记一下，但这里使用的是线程的TLS区域，另外检测后续调用的函数名称也是吊到不行。</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> obj; <span class="comment">//优化路径，不将对象注册到自动释放池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc_autorelease(obj); <span class="comment">//正常路径，注册到自动释放池中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to prepare for optimized return with the given disposition (+0 or +1).</span></span><br><span class="line"><span class="comment">// Returns true if the optimized path is successful.</span></span><br><span class="line"><span class="comment">// Otherwise the return value must be retained and/or autoreleased as usual.</span></span><br><span class="line"><span class="type">static</span> ALWAYS_INLINE <span class="type">bool</span> </span><br><span class="line"><span class="title function_">prepareOptimizedReturn</span><span class="params">(ReturnDisposition disposition)</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(getReturnDisposition() == ReturnAtPlus0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callerAcceptsOptimizedReturn(__builtin_return_address(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (disposition) setReturnDisposition(disposition);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to accept an optimized return.</span></span><br><span class="line"><span class="comment">// Returns the disposition of the returned object (+0 or +1).</span></span><br><span class="line"><span class="comment">// An un-optimized return is +0.</span></span><br><span class="line"><span class="type">static</span> ALWAYS_INLINE ReturnDisposition </span><br><span class="line"><span class="title function_">acceptOptimizedReturn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ReturnDisposition disposition = getReturnDisposition();</span><br><span class="line">    setReturnDisposition(ReturnAtPlus0);  <span class="comment">// reset to the unoptimized state</span></span><br><span class="line">    <span class="keyword">return</span> disposition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取TLS上RETURN_DISPOSITION_KEY的值</span></span><br><span class="line"><span class="type">static</span> ALWAYS_INLINE ReturnDisposition </span><br><span class="line"><span class="title function_">getReturnDisposition</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (ReturnDisposition)(<span class="type">uintptr_t</span>)tls_get_direct(RETURN_DISPOSITION_KEY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往TLS上写数据RETURN_DISPOSITION_KEY--disposition</span></span><br><span class="line"><span class="type">static</span> ALWAYS_INLINE <span class="type">void</span> </span><br><span class="line"><span class="title function_">setReturnDisposition</span><span class="params">(ReturnDisposition disposition)</span></span><br><span class="line">&#123;</span><br><span class="line">    tls_set_direct(RETURN_DISPOSITION_KEY, (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)disposition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_retainAutoreleasedReturnValue实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="title function_">objc_retainAutoreleasedReturnValue</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (acceptOptimizedReturn() == ReturnAtPlus1) <span class="keyword">return</span> obj; <span class="comment">//优化路径，不 retain而是直接返回对象。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc_retain(obj); <span class="comment">//正常路径，retain,引用计数+1后，才返回对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_autoreleaseReturnValue会做一个优化，如果检测到后续紧接着调用了objc_retainAutoreleasedReturnValue，则往 TLS 写ReturnAtPlus1标识，表明返回的对象的内存管理有优化。此时objc_autoreleaseReturnValue不会再将生成的对象真的注册到自动释放池中而是直接返回。当执行objc_retainAutoreleasedReturnValue时，会先从TLS中取值检测是否等于ReturnAtPlus1，相等说明走的是优化路径则不 retain，避免重复retain。</p>
<p>因此以其他单词命名开头的方法创建并返回的对象，该对象本应该注册到自动释放池，但如果创建后马上就赋值给一个 <code>__strong</code> 修饰符的指针变量，此时系统会做一个优化，该对象将不再注册到自动释放池中，因此能够及时释放对象，起到优化作用。<br>note：使用系统的对象 <code>id __strong obj1 = [NSArray array];</code>可能看不到这种优化。</p>
<p>总结：将一个对象赋值给一个 <code>__strong</code> 修饰符的指针变量，编译器会视情况插入<code>objc_retain</code> 或<code>objc_retainAutoreleasedReturnValue</code> 函数的调用。而当指针变量超出作用域后被销毁时，会插入<code>objc_storeStrong(&amp;obj, nil);</code> 释放对象，并置为nil。</p>
<p>objc_autoreleaseReturnValue 和 objc_retainAutoreleasedReturnValue是一对优化。</p>
<p>objc_retainAutoreleaseReturnValue 和 objc_unsafeClaimAutoreleasedReturnValue 是另一对优化。</p>
<p>如果优化成功，他们都避免了多余的注册到自动释放池的过程，加快了对象的释放。</p>
<h3 id="weak-修饰符"><a href="#weak-修饰符" class="headerlink" title="__weak 修饰符"></a>__weak 修饰符</h3><p>对于下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">     @autoreleasepool &#123;</span><br><span class="line">         id obj = [NSObject new];</span><br><span class="line">         &#123;</span><br><span class="line">           id __weak obj1 = obj;</span><br><span class="line">           NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ltmp3:</span><br><span class="line">     .loc    1 12 22 prologue_end    ## WeakDemo/main.m:12:22</span><br><span class="line">     callq    _objc_autoreleasePoolPush</span><br><span class="line"> Ltmp4:</span><br><span class="line">     .loc    1 13 18                 ## WeakDemo/main.m:13:18</span><br><span class="line">     movq    _OBJC_CLASSLIST_REFERENCES_$_(%rip), %rdi</span><br><span class="line">     movq    _OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">     movq    _objc_msgSend@GOTPCREL(%rip), %rcx</span><br><span class="line">     movq    %rax, -56(%rbp)         ## 8-byte Spill</span><br><span class="line">     callq    *%rcx</span><br><span class="line">     .loc    1 13 12 is_stmt 0       ## WeakDemo/main.m:13:12</span><br><span class="line">     movq    %rax, -24(%rbp)</span><br><span class="line"> Ltmp5:</span><br><span class="line">     .loc    1 15 28 is_stmt 1       ## WeakDemo/main.m:15:28</span><br><span class="line">     movq    -24(%rbp), %rsi</span><br><span class="line">     leaq    -32(%rbp), %rax</span><br><span class="line">     .loc    1 15 21 is_stmt 0       ## WeakDemo/main.m:15:21</span><br><span class="line">     movq    %rax, %rdi</span><br><span class="line">     movq    %rax, -64(%rbp)         ## 8-byte Spill</span><br><span class="line">     callq    _objc_initWeak</span><br><span class="line">     movq    -64(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">     movq    %rax, -72(%rbp)         ## 8-byte Spill</span><br><span class="line">     .loc    1 16 29 is_stmt 1       ## WeakDemo/main.m:16:29</span><br><span class="line">     callq    _objc_loadWeakRetained</span><br><span class="line">     movq    %rax, %rcx</span><br><span class="line"> Ltmp0:</span><br><span class="line">     .loc    1 16 11 is_stmt 0       ## WeakDemo/main.m:16:11</span><br><span class="line">     leaq    L__unnamed_cfstring_(%rip), %rdi</span><br><span class="line">     xorl    %edx, %edx</span><br><span class="line">                                         ## kill: def $dl killed $dl killed $edx</span><br><span class="line">     movq    %rax, %rsi</span><br><span class="line">     movb    %dl, %al</span><br><span class="line">     movq    %rcx, -80(%rbp)         ## 8-byte Spill</span><br><span class="line">     callq    _NSLog</span><br><span class="line"> Ltmp1:</span><br><span class="line">     jmp    LBB0_1</span><br><span class="line"> LBB0_1:</span><br><span class="line">     .loc    1 0 11                  ## WeakDemo/main.m:0:11</span><br><span class="line">     movq    -80(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">     .loc    1 16 11                 ## WeakDemo/main.m:16:11</span><br><span class="line">     callq    *_objc_release@GOTPCREL(%rip)</span><br><span class="line"> Ltmp6:</span><br><span class="line">     .loc    1 17 9 is_stmt 1        ## WeakDemo/main.m:17:9</span><br><span class="line">     leaq    -32(%rbp), %rdi</span><br><span class="line">     callq    _objc_destroyWeak</span><br><span class="line">     xorl    %eax, %eax</span><br><span class="line">     movl    %eax, %esi</span><br><span class="line">     .loc    1 18 5                  ## WeakDemo/main.m:18:5</span><br><span class="line">     leaq    -24(%rbp), %rdi</span><br><span class="line">     callq    _objc_storeStrong</span><br><span class="line">     movq    -56(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">     callq    _objc_autoreleasePoolPop</span><br><span class="line">     xorl    %eax, %eax</span><br></pre></td></tr></table></figure>
<p>上述汇编对应的编译器的模拟源代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> obj1 = objc_initWeak(&amp;obj1, obj);</span><br><span class="line"><span class="type">id</span> tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;obj1:%@&quot;</span>, tmp);</span><br><span class="line">objc_release(tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br><span class="line"></span><br><span class="line">objc_storeStrong(&amp;obj, <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>id __weak obj1 = obj;</code>，这句代码实际上被编译器转换为：<code>id obj1 = objc_initWeak(&amp;obj1, obj);</code>。没有调用什么 retain 方法，这就是使用__weak修饰符不会导致对象引用计数加 1 的原因。</p>
<p>but，objc_initWeak函数又是干什么的，这里不做详述，有兴趣的可以查看 weak 的实现原理。这里简单说下objc_initWeak的作用就是将一个指针变量的地址登记到对象的 weak 表中。它的实现是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="title function_">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着往下看，会发现 <code>NSLog(@&quot;obj1:%@&quot;, obj1);</code>代码变成了三句：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">id tmp <span class="punctuation">=</span> objc_loadWeakRetained<span class="punctuation">(</span><span class="meta">&amp;obj1);  <span class="comment">//将对象引用计数加 1</span></span></span><br><span class="line">NSLog<span class="punctuation">(</span>@<span class="string">&quot;obj1:%@&quot;</span><span class="punctuation">,</span> tmp<span class="punctuation">)</span><span class="punctuation">;</span></span><br><span class="line">objc_release<span class="punctuation">(</span>tmp<span class="punctuation">)</span><span class="punctuation">;</span>  <span class="comment">//将对象引用计数减 1</span></span><br></pre></td></tr></table></figure>
<p>如果对象还可用时执行了<code>id tmp = objc_loadWeakRetained(&amp;obj1);</code>，那么即使对象在其他线程被释放了，对象此刻也不会被销毁，能够保证<code>NSLog(@&quot;obj1:%@&quot;, obj1);</code>方法在执行完前对象都是可用的。</p>
<p>以前这里是将对象注册到自动释放池的，可以参考：<a href="https://stackoverflow.com/questions/40993809/why-weak-object-will-be-added-to-autorelease-pool">Why __weak object will be added to autorelease pool?</a> 。经过测试发现在MRC中还是将对象注册到自动释放池的。这时代码等价于：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">id tmp <span class="punctuation">=</span> objc_loadWeakRetained<span class="punctuation">(</span><span class="meta">&amp;obj1);  <span class="comment">//将对象引用计数加 1</span></span></span><br><span class="line">objc_autorelease<span class="punctuation">(</span>tmp<span class="punctuation">)</span><span class="punctuation">;</span> <span class="comment">//注册到自动释放池.注册到自动释放池仅仅是注册到自动释放池，不会对对象的引用计数产生影响。</span></span><br><span class="line">NSLog<span class="punctuation">(</span>@<span class="string">&quot;obj1:%@&quot;</span><span class="punctuation">,</span> tmp<span class="punctuation">)</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)hello &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        MRCCat *cat = [MRCCat new];</span><br><span class="line">        <span class="keyword">self</span>.cat = cat;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 1&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">        [cat release];</span><br><span class="line">    &#125; <span class="comment">//使用weak，cat居然还没有被销毁。因为被注册到自动释放池里去了</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 2&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">    [<span class="keyword">self</span>.cat hello];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ hello&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会发现在调用 <code>[cat release];</code> 后，cat对象并没有马上销毁。</p>
<p>我们可以在<code>NSLog(@&quot;%@ 1&quot;, self.cat);</code> 这一行打上断点，并执行 <code>po _objc_autoreleasePoolPrint()</code> :</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848230]</span>    0x7fcd6ef0a5c0  UIWindow</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848238]</span>    0x60000032c6c0  __NSArrayM</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848240]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848248]</span>    0x7fcd6ef0a5c0  UIWindow</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848250]</span>    0x60000032c8a0  __NSArrayM</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848258]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848260]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: ##############</span><br></pre></td></tr></table></figure>
<p>此时AUTORELEASE POOLS里还没有MRCCat对象，接着在 <code>[cat release];</code> 打上断点，再次执行 <code>po _objc_autoreleasePoolPrint()</code> ：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848248</span>]    <span class="number">0x7fcd6ef0a5c0</span>  UIWindow</span><br><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848250</span>]    <span class="number">0x60000032c8a0</span>  __NSArrayM</span><br><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848258</span>]    <span class="number">0x7fcd6ef09f20</span>  ViewController</span><br><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848260</span>]    <span class="number">0x7fcd6ef09f20</span>  ViewController</span><br><span class="line">objc[<span class="number">3377</span>]: [<span class="number">0x7fcd70848268</span>]    <span class="number">0x600000f747b0</span>  MRCCat</span><br><span class="line">objc[<span class="number">3377</span>]: ##############</span><br></pre></td></tr></table></figure>
<p>可以看到MRCCat被注册到自动释放池里去了。所以后面即使调用 <code>[cat release];</code> cat对象也不会马上销毁。如果你在<code>[self.cat hello];</code> 打上断点，再次执行 <code>po _objc_autoreleasePoolPrint()</code> ：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848240]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848248]</span>    0x7fcd6ef0a5c0  UIWindow</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848250]</span>    0x60000032c8a0  __NSArrayM</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848258]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848260]</span>    0x7fcd6ef09f20  ViewController</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848268]</span>    0x600000f747b0  MRCCat</span><br><span class="line">objc<span class="comment">[3377]</span>: <span class="comment">[0x7fcd70848270]</span>    0x600000f747b0  MRCCat</span><br><span class="line">objc<span class="comment">[3377]</span>: ##############</span><br></pre></td></tr></table></figure>
<p>你会发现cat对象被注册了两次。</p>
<p>因此使用附有 <code>__weak</code> 修饰符的变量，等价于使用retain并注册到autoreleasepool中的对象。如果你某段代码需要多次使用该weak变量，最好先retain后赋值给一个变量然后使用该变量。要不然每次都会retain+注册到自动释放池。所幸的是现在几乎接触不到MRC的代码，并且在ARC中使用附有 <code>__weak</code> 修饰符的变量，系统也不会retain后再将其注册到autoreleasepool中了，而是在使用前调用retain，使用后调用release马上释放。</p>
<p>另外我们对上述代码稍作改动，添加一个@autoreleasepool：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)hello &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MRCCat *cat = [MRCCat new];</span><br><span class="line">        <span class="keyword">self</span>.cat = cat;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 1&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">        [cat release];</span><br><span class="line">    &#125; <span class="comment">//这里cat就会被销毁了</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 2&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">    [<span class="keyword">self</span>.cat hello];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ hello&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会发现cat对象在autoreleasepool块执行完成后马上就被销毁了。</p>
<p>继续，当作用域结束时，obj1 变量被废弃，因此编译器插入了一条objc_destroyWeak函数的调用。该方法会将 obj1弱引用指针变量从对象的 weak 表中移除（这里obj1变量先于obj对象废弃，因此obj1不会被置为nil）。</p>
<p>objc_destroyWeak 源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">objc_destroyWeak</span><span class="params">(id *location)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, nil); <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> id </span><br><span class="line"><span class="title function_">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">  <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">      weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Unregister an already-registered weak reference.</span></span><br><span class="line"><span class="comment"> * This is used when referrer&#x27;s storage is about to go away, but referent</span></span><br><span class="line"><span class="comment"> * isn&#x27;t dead yet. (Otherwise, zeroing referrer later would be a</span></span><br><span class="line"><span class="comment"> * bad memory access.)</span></span><br><span class="line"><span class="comment"> * Does nothing if referent/referrer is not a currently active weak reference.</span></span><br><span class="line"><span class="comment"> * Does not zero referrer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * FIXME currently requires old referent value to be passed in (lame)</span></span><br><span class="line"><span class="comment"> * FIXME unregistration should be automatic if referrer is collected</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">weak_unregister_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id, </span></span><br><span class="line"><span class="params">                        id *referrer_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        remove_referrer(entry, referrer); <span class="comment">//将referrer从entry中移除。</span></span><br><span class="line">        <span class="type">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **old_referrer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                     <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                     <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                     <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                         <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                         <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                         <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>weak_unregister_no_lock</code> 的作用：将弱引用指针变量从对象的weak表里移除。如果weak表中对象的weak_entry为空，则将entry也移除。</p>
<p>上述就是使用 <code>__weak</code> 修饰符修饰指针变量时，ARC 对其的处理。</p>
<p>再来看一个例子：</p>
<p>将new方法刚创建的对象赋值给一个__weak指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          id __weak obj1 = [NSObject new];</span><br><span class="line">          NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能知道打印的结果为 null，但它对应的汇编又是怎样的呢？</p>
<p>对应的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ltmp3:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp4:</span><br><span class="line">	.loc	1 32 28                 ## WeakDemo/main.m:32:28</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rdi</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	_objc_msgSend@GOTPCREL(%rip), %rcx</span><br><span class="line">	movq	%rax, -48(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*%rcx</span><br><span class="line">	leaq	-24(%rbp), %rcx</span><br><span class="line">	.loc	1 32 21 is_stmt 0       ## WeakDemo/main.m:32:21</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, %rsi</span><br><span class="line">	movq	%rax, -56(%rbp)         ## 8-byte Spill</span><br><span class="line">	movq	%rcx, -64(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	_objc_initWeak</span><br><span class="line">	movq	_objc_release@GOTPCREL(%rip), %rcx</span><br><span class="line">	movq	-56(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	movq	%rax, -72(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*%rcx</span><br><span class="line">	movq	-64(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	.loc	1 33 29 is_stmt 1       ## WeakDemo/main.m:33:29</span><br><span class="line">	callq	_objc_loadWeakRetained</span><br><span class="line">	movq	%rax, %rcx</span><br><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 33 11 is_stmt 0       ## WeakDemo/main.m:33:11</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rdi</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">                                        ## kill: def $dl killed $dl killed $edx</span><br><span class="line">	movq	%rax, %rsi</span><br><span class="line">	movb	%dl, %al</span><br><span class="line">	movq	%rcx, -80(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	_NSLog</span><br><span class="line">Ltmp1:</span><br><span class="line">	jmp	LBB0_1</span><br><span class="line">LBB0_1:</span><br><span class="line">	.loc	1 0 11                  ## WeakDemo/main.m:0:11</span><br><span class="line">	movq	-80(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	.loc	1 33 11                 ## WeakDemo/main.m:33:11</span><br><span class="line">	callq	*_objc_release@GOTPCREL(%rip)</span><br><span class="line">Ltmp5:</span><br><span class="line">	.loc	1 34 9 is_stmt 1        ## WeakDemo/main.m:34:9</span><br><span class="line">	leaq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_destroyWeak</span><br><span class="line">	movq	-48(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	.loc	1 35 5                  ## WeakDemo/main.m:35:5</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>上述汇编对应的编译器的模拟源代码：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id tmp = objc_msgSend(<span class="name">NSObject</span>, <span class="string">&quot;new&quot;</span>)<span class="comment">;</span></span><br><span class="line">id obj1 = objc_initWeak(<span class="name">&amp;obj1</span>, tmp)<span class="comment">; //注册到对象的 weak 表中，这样对象销毁时指针变量会被置为 nil。</span></span><br><span class="line">objc_release(<span class="name">tmp</span>)<span class="comment">;</span></span><br><span class="line">id tmp1 = objc_loadWeakRetained(<span class="name">&amp;obj1</span>)<span class="comment">;  </span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, tmp1)<span class="comment">;</span></span><br><span class="line">objc_release(<span class="name">tmp1</span>)<span class="comment">;  </span></span><br><span class="line">objc_destroyWeak(<span class="name">&amp;obj1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看到objc_initWeak后，马上调用了objc_release，导致对象被释放销毁，同时 obj1 会被置为 nil，于是后面的 tmp1 也是 nil。打印也是 nil。</p>
<p>对于代码<code>id __weak obj1 = [NSObject new];</code>，由于__weak 修饰的指针变量无法持有对象，因此对象一创建就被销毁。</p>
<p>另外一个例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        <span class="type">id</span> __<span class="keyword">weak</span> ref = obj; <span class="comment">//_objc_initWeak(内部调用的是storeWeak)</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;ref-1：%@&quot;</span>, ref);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">id</span> obj2 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">            ref = obj2; <span class="comment">//_objc_storeWeak (内部调用的也是storeWeak)</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;ref-2：%@&quot;</span>, ref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p> <code>__weak</code> 修饰符作用：</p>
<p>1.当我们将一个对象赋值给一个 <code>__weak</code> 修饰符的指针变量时，编译器会插入 <code>objc_initWeak</code> 或 <code>objc_storeWeak</code> 函数将该弱指针变量从旧对象的weak表剔除（如果之前有指向对象的话）并注册到新对象的weak表里，然后将弱指针指向新对象。</p>
<p>2.当使用附有 <code>__weak</code> 修饰符的变量时，编译器会在使用前插入 <code>objc_loadWeakRetained</code> 函数将对象引用计数+1，保证对象在后面的使用过程中不被释放。并在使用后插入 <code>objc_release(tmp1);</code> 释放对象。</p>
<p>3.当弱指针变量超出作用域被废弃时，编译器会插入 <code>objc_destroyWeak</code> 将该变量从对象的weak表里剔除。</p>
<p>4.当对象销毁时，对象的weak表中的所有弱指针变量会被赋值为nil，避免了野指针崩溃，比如对nil对象发送消息不会有任何反应，但是如果是对nil进行解引用还是会崩溃的。</p>
<p>这些功能是assign所不具备的，assign唯一与weak相同的地方就是不会导致对象的引用计数+1。</p>
<h3 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h3><p>对于代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">id</span> __autoreleasing obj1 = obj; <span class="comment">//2</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp1:</span><br><span class="line">	.loc	1 31 18                 ## WeakDemo/main.m:31:18</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, -40(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">	.loc	1 31 12 is_stmt 0       ## WeakDemo/main.m:31:12</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">Ltmp2:</span><br><span class="line">	.loc	1 33 30 is_stmt 1       ## WeakDemo/main.m:33:30</span><br><span class="line">	movq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_retainAutorelease</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">	movq	%rax, -32(%rbp)</span><br><span class="line">	.loc	1 34 29                 ## WeakDemo/main.m:34:29</span><br><span class="line">	movq	-32(%rbp), %rsi</span><br><span class="line">	.loc	1 34 11 is_stmt 0       ## WeakDemo/main.m:34:11</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_NSLog</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">	movl	%edx, %esi</span><br><span class="line">Ltmp3:</span><br><span class="line">	.loc	1 36 5 is_stmt 1        ## WeakDemo/main.m:36:5</span><br><span class="line">	leaq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_storeStrong</span><br><span class="line">	movq	-40(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>模拟代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id obj = msg_Send(NSObject, <span class="string">&quot;new&quot;</span>);</span><br><span class="line">id obj1 = objc_retainAutorelease(obj); <span class="comment">//retain对象+注册对象到自动释放池</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">objc_storeStrong(&amp;obj, nil);</span><br></pre></td></tr></table></figure>
<p>objc_retainAutorelease实现：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">id</span></span><br><span class="line"><span class="function"><span class="title">objc_retainAutorelease</span>(<span class="variable">id</span> <span class="variable">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">return</span> <span class="function"><span class="title">objc_autorelease</span>(<span class="title">objc_retain</span>(<span class="variable">obj</span>));</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>会先 retain 对象，再将对象注册到自动释放池里。</p>
<p>所以<code>id __autoreleasing obj1 = obj;</code> 执行完后对象的引用计数其实是 2。</p>
<p>例子 2：</p>
<p>创建一个对象并赋值给__autoreleasing 的obj1</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          id __autoreleasing obj1 = [NSObject <span class="keyword">new</span>];</span><br><span class="line">          NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp1:</span><br><span class="line">	.loc	1 32 37                 ## WeakDemo/main.m:32:37</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, -32(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">	.loc	1 32 30 is_stmt 0       ## WeakDemo/main.m:32:30</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	callq	_objc_autorelease</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">	.loc	1 33 29 is_stmt 1       ## WeakDemo/main.m:33:29</span><br><span class="line">	movq	-24(%rbp), %rsi</span><br><span class="line">	.loc	1 33 11 is_stmt 0       ## WeakDemo/main.m:33:11</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_NSLog</span><br><span class="line">	movq	-32(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">Ltmp2:</span><br><span class="line">	.loc	1 35 5 is_stmt 1        ## WeakDemo/main.m:35:5</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>模拟代码：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id obj1 = msg_Send(<span class="name">NSObject</span>, <span class="string">&quot;new&quot;</span>)<span class="comment">;</span></span><br><span class="line">objc_autorelease(<span class="name">obj1</span>)<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1:%@&quot;</span>, obj1)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>objc_autorelease实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__attribute__((<span class="built_in">aligned</span>(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="function">id</span></span><br><span class="line"><span class="function"><span class="title">objc_autorelease</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">autorelease</span>(); <span class="comment">//将对象注册到自动释放池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to [this autorelease], with shortcuts if there is no override</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> id </span></span><br><span class="line"><span class="function"><span class="title">objc_object::autorelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">isTaggedPointer</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rootAutorelease</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, @<span class="built_in">selector</span>(autorelease));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是创建一个对象并赋值给__autoreleasing 的指针变量，则仅仅是将对象注册到自动释放池。</p>
<p>因此<code>id __autoreleasing obj1 = [NSObject new];</code>执行完成后，对象的引用计数为 1。</p>
<h3 id="unsafe-unretained-修饰符"><a href="#unsafe-unretained-修饰符" class="headerlink" title="__unsafe_unretained 修饰符"></a>__unsafe_unretained 修饰符</h3><p>代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = obj;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;obj1：%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ltmp0:</span><br><span class="line">	.loc	1 30 22 prologue_end    ## WeakDemo/main.m:30:22</span><br><span class="line">	callq	_objc_autoreleasePoolPush</span><br><span class="line">Ltmp1:</span><br><span class="line">	.loc	1 31 18                 ## WeakDemo/main.m:31:18</span><br><span class="line">	movq	_OBJC_CLASSLIST_REFERENCES_$_(%rip), %rcx</span><br><span class="line">	movq	_OBJC_SELECTOR_REFERENCES_(%rip), %rsi</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movq	%rax, -40(%rbp)         ## 8-byte Spill</span><br><span class="line">	callq	*_objc_msgSend@GOTPCREL(%rip)</span><br><span class="line">	leaq	L__unnamed_cfstring_(%rip), %rcx</span><br><span class="line">	.loc	1 31 12 is_stmt 0       ## WeakDemo/main.m:31:12</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">Ltmp2:</span><br><span class="line">	.loc	1 33 43 is_stmt 1       ## WeakDemo/main.m:33:43</span><br><span class="line">	movq	-24(%rbp), %rax</span><br><span class="line">	.loc	1 33 36 is_stmt 0       ## WeakDemo/main.m:33:36</span><br><span class="line">	movq	%rax, -32(%rbp)</span><br><span class="line">	.loc	1 34 33 is_stmt 1       ## WeakDemo/main.m:34:33</span><br><span class="line">	movq	-32(%rbp), %rsi</span><br><span class="line">	.loc	1 34 13 is_stmt 0       ## WeakDemo/main.m:34:13</span><br><span class="line">	movq	%rcx, %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_NSLog</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">	movl	%edx, %esi</span><br><span class="line">Ltmp3:</span><br><span class="line">	.loc	1 36 5 is_stmt 1        ## WeakDemo/main.m:36:5</span><br><span class="line">	leaq	-24(%rbp), %rdi</span><br><span class="line">	callq	_objc_storeStrong</span><br><span class="line">	movq	-40(%rbp), %rdi         ## 8-byte Reload</span><br><span class="line">	callq	_objc_autoreleasePoolPop</span><br><span class="line">	xorl	%eax, %eax</span><br></pre></td></tr></table></figure>
<p>编译器模拟代码：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id obj = objc_msgSend(<span class="name">NSObject</span>, <span class="string">&quot;new&quot;</span>)<span class="comment">;</span></span><br><span class="line">id obj1 = obj<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1：%@&quot;</span>, obj1)<span class="comment">;</span></span><br><span class="line">objc_storeStrong(<span class="name">&amp;obj</span>, <span class="literal">nil</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看到仅仅是指针变量间的赋值，其他什么操作都没有。</p>
<p>示例 2：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;obj1：%@&quot;</span>, obj1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器模拟代码：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id tmp = objc_msgSend(<span class="name">NSObject</span>, <span class="string">&quot;new&quot;</span>)<span class="comment">;</span></span><br><span class="line">id obj1 = tmp<span class="comment">;</span></span><br><span class="line">objc_release(<span class="name">tmp</span>)<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">&quot;obj1：%@&quot;</span>, obj1)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这一次会发生崩溃，因为obj1已经变成了一个野指针。</p>
<p><code>__unsafe_unretained</code>的功能和 assign 是一样的，只不过assign 既可以修饰对象类型也可以修饰基础类型。注意：没有<code>__assign</code>.</p>
<p>ps：个人感觉虽然 ARC 的优点是在合适的地方自动帮我们添加 retain 和 release，但作为开发者的我们如果没有查看汇编代码并不好确定它究竟会在哪些地方添加以及添加的啥函数调用，所以一些奇怪的现象可能会让你困惑。如果是 MRC 的话，我们就很清楚一个对象的释放与持有，弊端就是麻烦并且容易忘记 release导致内存泄漏。两种方案各有利弊，但总的来说还是 ARC 要更好一些。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><h4 id="Q0：ARC-适用范围？是否仅对-OC-文件起作用？"><a href="#Q0：ARC-适用范围？是否仅对-OC-文件起作用？" class="headerlink" title="Q0：ARC 适用范围？是否仅对 OC 文件起作用？"></a>Q0：ARC 适用范围？是否仅对 OC 文件起作用？</h4><p>这个没查到资料，也不敢确定，但个人感觉 ARC 开启后，编译器应该只对 OC 源文件做处理。毕竟 C++也有它自己的内存管理方式。因此切换语言后还是要注意内存管理的不同。</p>
<h4 id="Q1：把一个-weak-指针变量当做参数传给一个方法，当方法开始调用时，即使对象被其他线程释放了，此刻对象也不会被销毁，原因是什么？是形参这个指针变量又强引用了对象，导致对象不会被销毁，还是因为编译器插入的objc-loadWeakRetained函数？还是说两者都有？"><a href="#Q1：把一个-weak-指针变量当做参数传给一个方法，当方法开始调用时，即使对象被其他线程释放了，此刻对象也不会被销毁，原因是什么？是形参这个指针变量又强引用了对象，导致对象不会被销毁，还是因为编译器插入的objc-loadWeakRetained函数？还是说两者都有？" class="headerlink" title="Q1：把一个 weak 指针变量当做参数传给一个方法，当方法开始调用时，即使对象被其他线程释放了，此刻对象也不会被销毁，原因是什么？是形参这个指针变量又强引用了对象，导致对象不会被销毁，还是因为编译器插入的objc_loadWeakRetained函数？还是说两者都有？"></a>Q1：把一个 weak 指针变量当做参数传给一个方法，当方法开始调用时，即使对象被其他线程释放了，此刻对象也不会被销毁，原因是什么？是形参这个指针变量又强引用了对象，导致对象不会被销毁，还是因为编译器插入的objc_loadWeakRetained函数？还是说两者都有？</h4><p>两者都有，因为函数调用时会有一些压栈操作，如果没有objc_loadWeakRetained，那么在压栈操作期间，对象可能就销毁了。另外形参赋值的时候编译器也会插入objc_storeStrong这时形参指向的对象会被 retain ，当函数执行完成时，形参被废弃会调用release 方法。函数返回后继续执行<code>objc_release(tmp);</code>，释放对象。</p>
<p>编译器对方法的入参对象进行retain和release：</p>
<p>代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">self</span> testOjcParamCompilerInsertRetain];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testOjcParamCompilerInsertRetain &#123;</span><br><span class="line">    XQModel *obj = [XQModel new];</span><br><span class="line">    [<span class="keyword">self</span> hello:obj];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)hello:(XQModel *)model &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;model:%@&quot;</span>, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>NSLog(@&quot;model:%@&quot;, model);</code> 处打好断点，如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914173316.png" style="zoom:50%;" /></p>
<p>可以看到编译器会插入objc_storeStrong，从而对传入的 model 对象进行 retain，保证参数指向的对象在使用期间不被销毁。</p>
<p>可以po一下model的引用计数：已经变为2了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">(lldb) po <span class="built_in">NSLog</span>(<span class="string">@&quot;retain count = %ld\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge  <span class="built_in">CFTypeRef</span>)(model)));</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-14</span> <span class="number">17</span>:<span class="number">18</span>:<span class="number">20.496168</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">53997</span>:<span class="number">4829011</span>] <span class="keyword">retain</span> count = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>当方法执行完后，又会执行objc_storeStrong(&amp;model, nil); 释放对象。</p>
<p>这个其实在MRC下会经常写这样的代码，对入参对象retain，使用完后release。只不过在ARC下编译器帮你自动完成了这些操作。</p>
<h4 id="Q2：函数的调用过程究竟是怎样的？"><a href="#Q2：函数的调用过程究竟是怎样的？" class="headerlink" title="Q2：函数的调用过程究竟是怎样的？"></a>Q2：函数的调用过程究竟是怎样的？</h4><p>参考：</p>
<p><a href="https://segmentfault.com/a/1190000007977460">C函数调用过程原理及函数栈帧分析</a></p>
<p><a href="https://www.cnblogs.com/dongzhiquan/p/7828667.html">X86-64寄存器和栈帧</a></p>
<h4 id="Q3：在-OC-中-obj-hello-实际上是会变成objc-msgSend-obj-quot-hello-quot-的调用，-void-hello-方法其实是暗含了两个参数的一个是-id-self，一个是-sel-cmd，问-self-是否会强引用对象？"><a href="#Q3：在-OC-中-obj-hello-实际上是会变成objc-msgSend-obj-quot-hello-quot-的调用，-void-hello-方法其实是暗含了两个参数的一个是-id-self，一个是-sel-cmd，问-self-是否会强引用对象？" class="headerlink" title="Q3：在 OC 中 [obj hello]; 实际上是会变成objc_msgSend(obj, &quot;hello&quot;)的调用，-(void)hello;方法其实是暗含了两个参数的一个是 id self，一个是 sel _cmd，问 self 是否会强引用对象？"></a>Q3：在 OC 中 <code>[obj hello];</code> 实际上是会变成<code>objc_msgSend(obj, &quot;hello&quot;)</code>的调用，<code>-(void)hello;</code>方法其实是暗含了两个参数的一个是 <code>id self</code>，一个是 <code>sel _cmd</code>，问 self 是否会强引用对象？</h4><p>从观察到的现象来看是没有的，举例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">self</span> testObjLife];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark- weak</span></span><br><span class="line">- (<span class="type">void</span>)testObjLife &#123;</span><br><span class="line">    <span class="keyword">self</span>.obj = [ARCPerson new];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;self.obj:%@&quot;</span>, _obj);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">self</span>.obj = <span class="literal">nil</span>; <span class="comment">//释放对象</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;清除&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//    [_obj doTask]; //崩溃。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     使用[self.obj doTask];</span></span><br><span class="line"><span class="comment">     不会野指针崩溃，因为汇编代码里执行self.obj后会，接着调用的是objc_retainAutoreleasedReturnValue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  	<span class="comment">//这里其实是两个方法的调用:[[self obj] doTask];</span></span><br><span class="line">  	<span class="comment">//相当于ARCPerson *temp = [self obj]; //编译器会插入objc_retainAutoreleasedReturnValue。</span></span><br><span class="line">  	<span class="comment">//[temp doTask];</span></span><br><span class="line">  	<span class="comment">//temp超出作用域废弃时编译器插入objc_release，对应objc_retainAutoreleasedReturnValue。</span></span><br><span class="line">    [<span class="keyword">self</span>.obj doTask]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ARCPerson</span></span><br><span class="line">- (<span class="type">void</span>)doTask &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;开始计算&quot;</span>);</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">60000000</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">       f = f + sin(sin(sin(time(<span class="literal">NULL</span>) + i )));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;计算完成&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;model:%@  rs:%ld&quot;</span>, <span class="keyword">self</span>, (<span class="type">long</span>)f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行了<code>self.obj = nil; //释放对象</code>后，对象就销毁了，然后崩溃在doTask里。说明 self 并没有强引用对象。</p>
<p>为啥使用 <code>[self.obj doTask];</code> 就不会崩溃呢？</p>
<p>在 <code>[self.obj doTask];</code> 处打好断点：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914152010.png" style="zoom:50%;" /></p>
<p>会发现 <code>[self.obj doTask];</code> 等价于：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">id tmp = objc_msgSend(<span class="variable language_">self</span>, <span class="string">&quot;obj&quot;</span>); </span><br><span class="line">objc_retainAutoreleasedReturnValue(tmp); <span class="regexp">//</span>貌似只要前一句代码是非常规获得的对象都会有这个函数的出现。</span><br><span class="line">objc_msgSend(tmp, <span class="string">&quot;doTask&quot;</span>);</span><br><span class="line">objc_release(tmp); <span class="regexp">//</span>这里是objc_release而不是objc_storeStrong是因为我们的代码不是<span class="string">&quot;id obj = [self obj]; [obj doTask];&quot;</span></span><br></pre></td></tr></table></figure>
<p>单步执行，并进入到objc_retainAutoreleasedReturnValue函数里：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914153236.png" style="zoom:50%;" /></p>
<p>会发现objc_retainAutoreleasedReturnValue的参数就是tmp，继续跟踪的话会发现objc_retainAutoreleasedReturnValue内部调用了objc_retain，于是tmp的引用计数+1，所以使用 <code>[self.obj doTask];</code> 不会崩溃。</p>
<p>而直接使用示例变量 <code>[_obj doTask];</code> </p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914153831.png" style="zoom:50%;" /></p>
<p>则没有类似的objc_retainAutoreleasedReturnValue处理，因此2秒后当self.obj = nil;置为nil时，obj就会释放并销毁，doTask内部再访问self时会野指针崩溃。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914154649.png" alt=""></p>
<p>打印日志：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">43</span>.<span class="number">518910</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783450</span>] self.obj:&lt;ARCPerson: <span class="number">0</span>x6000039dc500&gt;</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">43</span>.<span class="number">519025</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783450</span>] 开始计算</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">45</span>.<span class="number">521771</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783607</span>] ARCPerson dealloc</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">45</span>.<span class="number">521966</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783607</span>] (null) <span class="number">2</span></span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">45</span>.<span class="number">522120</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783607</span>] 清除</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">09</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">59</span>.<span class="number">732099</span>+<span class="number">0800</span> iOSWeakDemo[<span class="number">52902</span>:<span class="number">4783450</span>] 计算完成</span><br></pre></td></tr></table></figure>
<p>可以看到还没计算完成，self指向的对象就已经销毁了。</p>
<h4 id="Q4：MRC下dealloc重写时super调用的位置？-super-dealloc-到底干了啥？"><a href="#Q4：MRC下dealloc重写时super调用的位置？-super-dealloc-到底干了啥？" class="headerlink" title="Q4：MRC下dealloc重写时super调用的位置？[super dealloc]到底干了啥？"></a>Q4：MRC下dealloc重写时super调用的位置？[super dealloc]到底干了啥？</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;MRCPerson dealloc&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 4&quot;</span>, <span class="keyword">self</span>.cat);</span><br><span class="line">    [<span class="variable language_">super</span> dealloc]; <span class="comment">//要放在最后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//崩溃写法</span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;MRCPerson dealloc&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ 4&quot;</span>, <span class="keyword">self</span>.cat); <span class="comment">//这里野指针崩溃。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dealloc方法就是释放对象自身的内存，以及析构它拥有的所有资源，比如实例变量对象。在MRC下，[super dealloc]必须放在最后。如果你放最开始的地方，那么执行完后对象就已经被销毁了，后面如果还有方法对象的地方将导致崩溃。</p>
<p>还是要看源码[super dealloc]。</p>
<p>参考：</p>
<p><a href="https://stackoverflow.com/questions/4566453/correct-super-dealloc">Correct [super dealloc]</a></p>
<p><a href="https://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">ARC下dealloc过程及.cxx_destruct的探究</a>  4星</p>
<h4 id="Q5：一个weak指针指向一个MRC对象，该MRC对象重写了dealloc但不调用-super-dealloc-，当该MRC对象销毁后，再打印该weak指针，会输出什么？nil还是对象地址？"><a href="#Q5：一个weak指针指向一个MRC对象，该MRC对象重写了dealloc但不调用-super-dealloc-，当该MRC对象销毁后，再打印该weak指针，会输出什么？nil还是对象地址？" class="headerlink" title="Q5：一个weak指针指向一个MRC对象，该MRC对象重写了dealloc但不调用[super dealloc]，当该MRC对象销毁后，再打印该weak指针，会输出什么？nil还是对象地址？"></a>Q5：一个weak指针指向一个MRC对象，该MRC对象重写了dealloc但不调用[super dealloc]，当该MRC对象销毁后，再打印该weak指针，会输出什么？nil还是对象地址？</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> test_subclass_do_not_call_super_dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;weakObj:%@&quot;</span>, _wobj);<span class="comment">//断点打在这</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test_subclass_do_not_call_super_dealloc &#123;</span><br><span class="line">    MRCPerson *per = [[MRCPerson alloc] init];</span><br><span class="line">    _wobj = per;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;_wobj:%@&quot;</span>, _wobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MRCPerson不调用[super dealloc]</span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ dealloc&quot;</span>, <span class="keyword">self</span>.class);</span><br><span class="line"><span class="comment">//    [super dealloc];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：输出nil。</p>
<p>分析：对象销毁时如果不调用[super dealloc]，理论上不会清除对象的weak表，自然weak指针也不会被置为nil，因此应该输出对象的地址，然而却输出了nil，这说明某个地方做了一些处理。从上面的分析我们已经知道使用weak指针时，编译器会在前面插入 <code>objc_loadWeakRetained</code> ，使用完后在后面插入 <code>objc_release</code> 。</p>
<p>因此 <code>NSLog(@&quot;weakObj:%@&quot;, _wobj);//断点打在这</code> 等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id tmp = objc_loadWeakRetained(&amp;_wobj);  </span><br><span class="line">NSLog(@<span class="string">&quot;weakObj:%@&quot;</span>, tmp);</span><br><span class="line">objc_release(tmp);  </span><br></pre></td></tr></table></figure>
<p>而 objc_loadWeakRetained 源码里会rootTryRetain：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="title function_">objc_loadWeakRetained</span><span class="params">(id *location)</span></span><br><span class="line">&#123;</span><br><span class="line">    id obj;</span><br><span class="line">    id result;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    SideTable *table;</span><br><span class="line">    </span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">// fixme std::atomic this load</span></span><br><span class="line">    obj = *location;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</span><br><span class="line">    </span><br><span class="line">    table = &amp;SideTables()[obj];</span><br><span class="line">    </span><br><span class="line">    table-&gt;lock();</span><br><span class="line">    <span class="keyword">if</span> (*location != obj) &#123;</span><br><span class="line">        table-&gt;unlock();</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result = obj;</span><br><span class="line"></span><br><span class="line">    cls = obj-&gt;ISA();</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;hasCustomRR()) &#123;</span><br><span class="line">        <span class="comment">// Fast case. We know +initialize is complete because</span></span><br><span class="line">        <span class="comment">// default-RR can never be set before then.</span></span><br><span class="line">        ASSERT(cls-&gt;isInitialized());</span><br><span class="line">        <span class="keyword">if</span> (! obj-&gt;rootTryRetain()) &#123;  <span class="comment">//这里rootTryRetain</span></span><br><span class="line">            result = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Slow case. We must check for +initialize and call it outside</span></span><br><span class="line">        <span class="comment">// the lock if necessary in order to avoid deadlocks.</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isInitialized() || _thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">            BOOL (*tryRetain)(id, SEL) = (BOOL(*)(id, SEL))</span><br><span class="line">                class_getMethodImplementation(cls, @selector(retainWeakReference));</span><br><span class="line">            <span class="keyword">if</span> ((IMP)tryRetain == _objc_msgForward) &#123;</span><br><span class="line">                result = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (! (*tryRetain)(obj, @selector(retainWeakReference))) &#123; <span class="comment">//retainWeakReference</span></span><br><span class="line">                result = nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            table-&gt;unlock();</span><br><span class="line">            class_initialize(cls, obj);</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    table-&gt;unlock();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rootTryRetain里会判断如果对象正在销毁，则返回nil，因此导致objc_loadWeakRetained也返回nil。于是tmp等于nil，自然打印的也是nil了。</p>
<p>我们可以重写retainWeakReference，返回yes，再运行一下，这时打印的就是对象的地址了。所以这里的nil并不是因为weak被清，weak指针被置为nil，而是因为objc_loadWeakRetained返回了nil。另外对于MRC来说重写dealloc方法一定要调用super的dealloc，否则销毁工作并没有完全结束，内存会有泄漏。</p>
<h4 id="Q6：如何理解OC中内存管理相关的方法命名规则？"><a href="#Q6：如何理解OC中内存管理相关的方法命名规则？" class="headerlink" title="Q6：如何理解OC中内存管理相关的方法命名规则？"></a>Q6：如何理解OC中内存管理相关的方法命名规则？</h4><p>在OC中对于以alloc/init/new/copy/mutableCopy开头的方法创建返回的对象，是自己拥有的对象需要自己释放。其他开头的方法创建返回的对象，则不是自己拥有的对象不能自己释放，一般而言这样的对象是注册到自动释放池的对象，会在自动释放池销毁时释放，当然在一些特定情况下系统会优化性能避免注册到自动释放池，这一切对于开发者而言是无感知的，即使如此你依然没有拥有该对象不能自己释放。</p>
<p>比如myPerson方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)myPerson &#123;</span><br><span class="line">    ARCPerson *p = [[ARCPerson alloc] init];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>return p;</code> 打好断点，如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914165036.png" style="zoom:50%;" /></p>
<p>在返回时系统会将对象注册到自动释放池里。因此自己不拥有该对象，也就不能调用release方法。</p>
<p>而对于newPerson方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)newPerson &#123;</span><br><span class="line">    ARCPerson *p = [[ARCPerson alloc] init];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200914165326.png" style="zoom:50%;" /></p>
<p>没有其他处理，返回的对象是自己拥有的，因此需要自己释放。</p>
<p>再比如getter方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MRCPerson *wobj;</span><br><span class="line"></span><br><span class="line">- (MRCPerson *)wobj &#123;</span><br><span class="line">    <span class="keyword">return</span> _wobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">iOSWeakDemo`-[ViewController wobj]:</span><br><span class="line">    <span class="number">0x101e945e0</span> &lt;<span class="number">+0</span>&gt;:  pushq  <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x101e945e1</span> &lt;<span class="number">+1</span>&gt;:  movq   <span class="variable">%rsp</span><span class="punctuation">,</span> <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x101e945e4</span> &lt;<span class="number">+4</span>&gt;:  subq   $<span class="number">0x10</span><span class="punctuation">,</span> <span class="variable">%rsp</span></span><br><span class="line">    <span class="number">0x101e945e8</span> &lt;<span class="number">+8</span>&gt;:  movq   <span class="variable">%rdi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">0x101e945ec</span> &lt;<span class="number">+12</span>&gt;: movq   <span class="variable">%rsi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">10</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">0x101e945f0</span> &lt;<span class="number">+16</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line">-&gt;  <span class="number">0x101e945f4</span> &lt;<span class="number">+20</span>&gt;: movq   <span class="number">0x968d</span>(<span class="variable">%rip</span>)<span class="punctuation">,</span> <span class="variable">%rcx</span>        <span class="comment">; ViewController._wobj</span></span><br><span class="line">    <span class="number">0x101e945fb</span> &lt;<span class="number">+27</span>&gt;: addq   <span class="variable">%rcx</span><span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line">    <span class="number">0x101e945fe</span> &lt;<span class="number">+30</span>&gt;: movq   <span class="variable">%rax</span><span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line">    <span class="number">0x101e94601</span> &lt;<span class="number">+33</span>&gt;: callq  <span class="number">0x101e96024</span>               <span class="comment">; symbol stub for: objc_loadWeakRetained</span></span><br><span class="line">    <span class="number">0x101e94606</span> &lt;<span class="number">+38</span>&gt;: movq   <span class="variable">%rax</span><span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line">    <span class="number">0x101e94609</span> &lt;<span class="number">+41</span>&gt;: addq   $<span class="number">0x10</span><span class="punctuation">,</span> <span class="variable">%rsp</span></span><br><span class="line">    <span class="number">0x101e9460d</span> &lt;<span class="number">+45</span>&gt;: popq   <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x101e9460e</span> &lt;<span class="number">+46</span>&gt;: jmp    <span class="number">0x101e96006</span>               <span class="comment">; symbol stub for: objc_autoreleaseReturnValue</span></span><br></pre></td></tr></table></figure>
<p>因为这里是weak指针，所以这里调用的objc_loadWeakRetained函数。另外还会调用objc_autoreleaseReturnValue注册到自动释放池if needed。</p>
<p>如果是strong属性：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">iOSWeakDemo`-[ViewController wobj]:</span><br><span class="line">    <span class="number">0x10529c5f0</span> &lt;<span class="number">+0</span>&gt;:  pushq  <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x10529c5f1</span> &lt;<span class="number">+1</span>&gt;:  movq   <span class="variable">%rsp</span><span class="punctuation">,</span> <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x10529c5f4</span> &lt;<span class="number">+4</span>&gt;:  movq   <span class="variable">%rdi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">0x10529c5f8</span> &lt;<span class="number">+8</span>&gt;:  movq   <span class="variable">%rsi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">10</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">0x10529c5fc</span> &lt;<span class="number">+12</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line">-&gt;  <span class="number">0x10529c600</span> &lt;<span class="number">+16</span>&gt;: movq   <span class="number">0x9689</span>(<span class="variable">%rip</span>)<span class="punctuation">,</span> <span class="variable">%rcx</span>        <span class="comment">; ViewController._wobj</span></span><br><span class="line">    <span class="number">0x10529c607</span> &lt;<span class="number">+23</span>&gt;: movq   (<span class="variable">%rax</span><span class="punctuation">,</span><span class="variable">%rcx</span>)<span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line">    <span class="number">0x10529c60b</span> &lt;<span class="number">+27</span>&gt;: popq   <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">0x10529c60c</span> &lt;<span class="number">+28</span>&gt;: jmp    <span class="number">0x10529e02c</span>               <span class="comment">; symbol stub for: objc_retainAutoreleaseReturnValue</span></span><br></pre></td></tr></table></figure>
<p>就只有objc_retainAutoreleaseReturnValue了。该函数的作用就是retain+autorelease。</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA算法原理介绍</title>
    <url>/2020/08/24/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>质数</strong></p>
<p><strong>质数</strong>又称素数，指<strong>在大于1的自然数中</strong>，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。大于1的自然数若不是素数，则称之为合数（也称为合成数）。最小的质数为2。</p>
<p><strong>互质关系</strong></p>
<p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是<a href="http://zh.wikipedia.org/zh-cn/互素">互质关系</a>（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p>
<p>关于互质关系，不难得到以下结论：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>. 任意两个质数构成互质关系，比如<span class="number">13</span>和<span class="number">61</span>。important</span><br><span class="line"></span><br><span class="line"><span class="attribute">2</span>. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如<span class="number">3</span>和<span class="number">10</span>。</span><br><span class="line"></span><br><span class="line"><span class="attribute">3</span>. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如<span class="number">97</span>和<span class="number">57</span>。</span><br><span class="line"></span><br><span class="line"><span class="attribute">4</span>. <span class="number">1</span>和任意一个自然数是都是互质关系，比如<span class="number">1</span>和<span class="number">99</span>。</span><br><span class="line"></span><br><span class="line"><span class="attribute">5</span>. p是大于<span class="number">1</span>的整数，则p和p-<span class="number">1</span>构成互质关系，比如<span class="number">57</span>和<span class="number">56</span>。 important</span><br><span class="line"></span><br><span class="line"><span class="attribute">6</span>. p是大于<span class="number">1</span>的奇数，则p和p-<span class="number">2</span>构成互质关系，比如<span class="number">17</span>和<span class="number">15</span>。</span><br></pre></td></tr></table></figure>
<h2 id="生成RSA密钥对，即公钥和私钥"><a href="#生成RSA密钥对，即公钥和私钥" class="headerlink" title="生成RSA密钥对，即公钥和私钥"></a>生成RSA密钥对，即公钥和私钥</h2><h3 id="1：随机找两个质数-p-和-q-p-与-q-越大，越安全。"><a href="#1：随机找两个质数-p-和-q-p-与-q-越大，越安全。" class="headerlink" title="1：随机找两个质数 p 和 q ,p 与 q 越大，越安全。"></a>1：随机找两个质数 p 和 q ,p 与 q 越大，越安全。</h3><p>比如 p = 3 ，q = 11。这里为了方便后面计算，选了2个很小的质数，实际应用需要选择两个非常大的质数。</p>
<h3 id="2：计算p和q的乘积n。"><a href="#2：计算p和q的乘积n。" class="headerlink" title="2：计算p和q的乘积n。"></a>2：计算p和q的乘积n。</h3><p>计算他们的乘积 n = 3 * 11 = 33 ，转化为二进制 10 0001，该加密算法即为 6 位，实际算法是 1024 位 或 2048 位，位数越长，算法越难被破解。</p>
<h3 id="3：计算-n-的欧拉函数-φ-n-。"><a href="#3：计算-n-的欧拉函数-φ-n-。" class="headerlink" title="3：计算 n 的欧拉函数 φ(n)。"></a>3：计算 n 的欧拉函数 φ(n)。</h3><p>φ(n) 表示在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数。例如：在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 φ(n) = 4。 如果 n = p <em> q，p 与 q 均为质数，则 φ(n) = φ(p </em> q)= φ(p - 1)φ(q - 1) = (p - 1)<em>(q - 1) 。 本例中 φ(3 </em> 11) = 2 * 10 = 20。</p>
<h3 id="4：随机选择一个整数-e，条件是1-lt-e-lt-φ-n-，且-e-与-φ-n-互质。"><a href="#4：随机选择一个整数-e，条件是1-lt-e-lt-φ-n-，且-e-与-φ-n-互质。" class="headerlink" title="4：随机选择一个整数 e，条件是1&lt; e &lt; φ(n)，且 e 与 φ(n) 互质。"></a>4：随机选择一个整数 e，条件是1&lt; e &lt; φ(n)，且 e 与 φ(n) 互质。</h3><p>这里我们随机选择 e = 7 请注意不要选择19 (即φ(n) - 1)这样的边界值，容易被人破解。实际应用中，常常选择65537。</p>
<h3 id="5：计算e对于φ-n-的模反元素d。"><a href="#5：计算e对于φ-n-的模反元素d。" class="headerlink" title="5：计算e对于φ(n)的模反元素d。"></a>5：计算e对于φ(n)的模反元素d。</h3><p>所谓<a href="http://zh.wikipedia.org/wiki/模反元素">“模反元素”</a>就是指有一个整数d，可以使得e * d除以φ(n)的余数为1。</p>
<p>即：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">e * d ≡ <span class="number">1</span> (<span class="built_in">mod</span> φ(<span class="built_in">n</span>))</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">e * d - <span class="number">1</span> <span class="operator">=</span> kφ(n)</span><br></pre></td></tr></table></figure>
<p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ex</span> + φ(n)y = <span class="number">1</span>  </span><br></pre></td></tr></table></figure>
<p>已知 e=7, φ(n)=20，</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">7x</span> + <span class="number">20</span>y = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这个方程可以用<a href="http://zh.wikipedia.org/wiki/扩展欧几里得算法">“扩展欧几里得算法”</a>求解，此处省略具体过程。总之，算出一组整数解为 (x,y)=(3,-1)，即 d=3。不同的 e 生成不同的 d，因此可以生成多个密钥对。</p>
<p>至此所有计算完成。</p>
<h3 id="6：将n和e封装成公钥，n和d封装成私钥。"><a href="#6：将n和e封装成公钥，n和d封装成私钥。" class="headerlink" title="6：将n和e封装成公钥，n和d封装成私钥。"></a>6：将n和e封装成公钥，n和d封装成私钥。</h3><p>在爱丽丝的例子中，n = 33，e = 7，d = 3，所以公钥（n，e）就是 (33, 7），私钥（n，d）就是（33, 3）。</p>
<p>实际应用中，公钥和私钥的数据都采用<a href="http://zh.wikipedia.org/zh-cn/ASN.1">ASN.1</a>格式表达（<a href="http://hi.baidu.com/mathack/item/d0ad4cc1514a3663f7c95da2">实例</a>）。</p>
<p>总结一下：</p>
<p>随机选择两个非常大的质数p,q—-&gt;计算p,q的乘积n——&gt;计算φ(n)—-&gt;选择一个与φ(n)互质的整数 e——&gt;计算e对于φ(n)的模反元素d。</p>
<p>得到公钥：（n，e）,私钥：（n，d）。</p>
<h2 id="加密明文"><a href="#加密明文" class="headerlink" title="加密明文"></a>加密明文</h2><p>公钥加密公式</p>
<blockquote>
<p>　　m^e ≡ c (mod n) </p>
<p>也可以写为</p>
<p>　　c = m^e mod n</p>
</blockquote>
<p>私钥解密公式</p>
<blockquote>
<p>　　c^d ≡ m (mod n)</p>
<p>也可以写为</p>
<p>　　m = c^d mod n</p>
</blockquote>
<p>参数说明：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">m:</span> 明文</span><br><span class="line"><span class="symbol">c:</span> 密文</span><br><span class="line"><span class="symbol">n:</span> 模数，两个很大的质数的乘积</span><br><span class="line"><span class="symbol">e:</span> 公钥指数</span><br><span class="line"><span class="symbol">d:</span> 私钥指数</span><br><span class="line">(n,e) 是公钥</span><br><span class="line">(n,d) 是私钥</span><br><span class="line">d是e对于φ(n)的模反元素</span><br></pre></td></tr></table></figure>
<p>注1：从上面的公式可以看出一个数模n，那么这个数肯定不能大于等于n，否则结果会无意义。比如n=13,那么13模上13结果为0，解密结果还是0，得不到原来的整数了。</p>
<p>注2：也可以使用私钥加密，公钥解密，这一过程通常称为签名。因为只有本人才有私钥，所以使用私钥加密得到的密文可以作为本人的签名。如果公钥能解开代表确实是由本人操作。</p>
<p>举个例子：对[6, 14, 7, 32]进行加密。应用上面的加密公式得到：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">6</span>^<span class="number">7</span> % <span class="number">33</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">14</span>^<span class="number">7</span> % <span class="number">33</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">7</span>^<span class="number">7</span> % <span class="number">33</span> = <span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">32</span>^<span class="number">7</span> % <span class="number">33</span> = <span class="number">32</span></span><br></pre></td></tr></table></figure>
<p>即[6, 14, 7, 32]加密后得到密文[30, 20, 28, 32]，如果没有私钥 d ,神仙也无法从密文[30, 20, 28, 32]中恢复出明文[6, 14, 7, 32]。</p>
<h2 id="解密密文"><a href="#解密密文" class="headerlink" title="解密密文"></a>解密密文</h2><p>应用上面的解密公式</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">m = c^d <span class="built_in">mod</span> <span class="built_in">n</span></span><br></pre></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">30</span>^<span class="number">3</span> % <span class="number">33</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">20</span>^<span class="number">3</span> % <span class="number">33</span> = <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">28</span>^<span class="number">3</span> % <span class="number">33</span> = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">32</span>^<span class="number">3</span> % <span class="number">33</span> = <span class="number">32</span></span><br></pre></td></tr></table></figure>
<p>即[30, 20, 28, 32]解密后得到明文[6, 14, 7, 32]。</p>
<h2 id="RSA应用"><a href="#RSA应用" class="headerlink" title="RSA应用"></a>RSA应用</h2><p>上面我们知道要想用RSA加密，需要满足两个条件：</p>
<ol>
<li>被加密的明文必须是整数</li>
<li>该整数必须大于0且小于 n。这意味着一次加密的明文不能太多。所以RSA是块加密。如果要加密的明文很长则必须分块加密。</li>
</ol>
<p>因此我们的明文需要转化为整数才能使用RSA加密，如果明文就是数字那就不用转化，如果是英文或者中文该怎么办呢？简单：各种编码方式，比如utf-8，gb2312。所以我们需要先将明文使用某种编码方式编码为数字，然后使用RSA加密。</p>
<p>怎么保证该整数一定小于 n呢？这个也很简单，只要明文长度小于n的长度即可。</p>
<h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><p>padding就是通过一些填充方式保证明文c的位数，且不能使c大于n.</p>
<p>padding可以让RSA对同一明文加密的结果每次都不一样，提高安全性，因为RSA加密是确定的，即给定一个密钥，特定明文总会映射到特定的密文。攻击者可以根据密文中统计信息获取明文的一些信息。</p>
<p>相同的明文在不管加密多少次，它的密文都是一样的。这在密码学中是一个大忌，很容易被破解者猜到内容。对称加密算法也有这个问题，需要用添加随机初始化向量IV，以实现相同的加密请求，每一次出来的结果都要不同。所以加密系统都会采取一定的手段确保每次加密结果都不一样。</p>
<p>Padding填充方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>填充方式</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>RSA_PKCS1_PADDING</td>
<td>必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11</td>
<td>和modulus一样长</td>
</tr>
<tr>
<td>RSA_PKCS1_OAEP_PADDING</td>
<td>RSA_size(rsa) – 41</td>
<td>和modulus一样长</td>
</tr>
<tr>
<td>RSA_NO_PADDING</td>
<td>可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充</td>
<td>和modulus一样长</td>
</tr>
</tbody>
</table>
</div>
<p>感兴趣的可以研究下padding是如何让rsa的加密结果变得随机的。简单来讲就是padding+明文组成新的明文再加密。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">02</span> <span class="function"><span class="title">xx</span> xx xx xx xx xx xx xx 00 ---&gt;</span>padding</span><br><span class="line"><span class="function"><span class="title">yy</span> yy yy yy yy yy yy yy yy yy yy ---&gt;</span>原始明文</span><br><span class="line">yy yy yy yy yy yy yy yy yy yy yy</span><br><span class="line">yy yy yy yy yy yy yy yy yy yy yy</span><br><span class="line">yy yy yy yy yy yy yy yy yy yy yy</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>假如n为1024位，则一个块就是128字节，由于最高位是00，所以明文的大小肯定小于n。加密后得到密文也是128字节（不足的最高位补0），解密后根据填充规则去掉开头的11个字节得到原始明文。</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">128字节块明文</span> <span class="literal">---</span>&gt; <span class="comment">RSA加解密系统</span> <span class="literal">----</span>&gt; <span class="comment">128字节块密文</span></span><br></pre></td></tr></table></figure>
<p>由于padding的存在，实际的有效明文长度是小于128字节的。因此RSA一次加密的明文长度是受模数位长度和padding共同影响的。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-为什么说RSA是难以破解的？"><a href="#1-为什么说RSA是难以破解的？" class="headerlink" title="1.为什么说RSA是难以破解的？"></a>1.为什么说RSA是难以破解的？</h3><p>我们已经知道RSA是公钥（n，e），私钥（n，d）加密系统。</p>
<p>通常公钥（n，e）是对外公开的，要想破解就必须知道私钥（n，d），其实就是要算出d。</p>
<p>d怎么来的呢？根据<code>e * d ≡ 1 (mod φ(n))</code> 计算得来的，因此需要知道φ(n)的值。</p>
<p>φ(n)怎么来的呢？φ(n) = (p - 1)*(q - 1)。p，q是n的两个质因数。也就是要对一个超大数n做质因数分解。以目前的计算机来说，还是很难的，所以说RSA是难以破解的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理（一）</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理（二）</a>  </p>
<p><a href="https://www.cnblogs.com/isyaya/p/11073149.html">RSA加密长度限制问题</a></p>
<p><a href="https://blog.cnbluebox.com/blog/2014/03/19/rsajia-mi/">RSA加密</a>  </p>
<p><a href="https://zhuanlan.zhihu.com/p/44185847">一文搞懂 RSA 算法</a>  举了一个小整数的例子</p>
<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem">RSA (cryptosystem)</a>) wiki英语版，必须是英文版的要不然公式会错乱。</p>
<p><a href="https://cloud.tencent.com/developer/article/1199963">RSA密钥长度、明文长度和密文长度</a></p>
<p><a href="https://blog.csdn.net/makenothing/article/details/88429511">RSA非对称加解密算法填充方式（Padding）</a></p>
<p><a href="https://blog.csdn.net/notechsolution/article/details/106954496">一文详解非对称加密算法之RSA Padding</a>  讲解了padding是如何让RSA的加密结果随机性的。</p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>OC内存管理之对象的引用计数</title>
    <url>/2020/09/16/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p>源码版本：<a href="https://opensource.apple.com/tarballs/objc4/objc4-781.tar.gz">objc4-781</a></p>
<p>我们都知道OC的内存管理是通过引用计数来管理的，对象刚创建时引用计数为1，retain后+1，release后-1，当引用计数减为0时就会被销毁。那么问题就来了，操作的这个引用计数值是保存在哪的？今天就来研究一下这个问题。</p>
<p>先说结论：早期OC对象的引用计数都是存储在引用计数表中的，但是后来Apple的工程师可能觉得每次都从表中查找修改效率有点低，于是做了一些优化，如果引用计数值较小时就保存在 <code>struct objc_object</code> 的isa成员变量里，只有当isa里装不下时才存放到引用计数表里，这一点可以从isa的类型变迁看出。除此之外，苹果还引入了Tagged pointer对象，这种对象实际上已经没有在堆上分配内存了，它的值就保存在指针里，这样的对象由于并没有真正在堆上分配内存因此讨论它的引用计数也就没有什么意义了。</p>
<p>之前的文章 <code>runtime源码分析(一)--类型</code> 里专门分析了 <code>struct objc_object</code> ，<code>struct objc_class</code>，<code>isa</code> 类型的定义，这里不再赘述，仅做简单说明。</p>
<h3 id="isa的定义"><a href="#isa的定义" class="headerlink" title="isa的定义"></a>isa的定义</h3><p>旧版本的定义：</p>
<p>isa是一个指针类型 <code>struct objc_class *</code> 。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class; </span><br><span class="line"></span><br><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY; <span class="comment">//旧版本isa为一个指针指向objc_class结构体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>
<p>新版本oc 2.0定义：</p>
<p>isa是一个联合类型 <code>union isa_t</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//objc-private.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">isa_t</span> isa; <span class="comment">//objc_object中有一个isa，但类型已经变成isa_t(union类型)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rawISA() assumes this is NOT a tagged pointer object or a non pointer ISA</span></span><br><span class="line">    <span class="function">Class <span class="title">rawISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">isaBits</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> &#123;</span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="type">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开isa_t</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> &#123;</span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="type">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls; <span class="comment">//一个指针指向objc_class结构体。这样就可以兼容旧版本。</span></span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">    <span class="comment">//这里展开的是arm64的</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> nonpointer        : <span class="number">1</span>; <span class="comment">//LSB。0 is raw isa, 1 is non-pointer isa.                                      </span></span><br><span class="line">      	<span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>; <span class="comment">//对象是否有关联对象                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>; <span class="comment">//对象是否有C++或ARC析构函数                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> <span class="comment">//Class地址。</span></span><br><span class="line">        <span class="type">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">//一个魔法数。用于区分是否初始化                                     </span></span><br><span class="line">        <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">//是否有弱引用指针。                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>; <span class="comment">//是否正在被销毁                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>; <span class="comment">//是否有sidetable引用计数。对象的引用计数太大而不能在内部保存时会将引用计数保存到sidetable                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> extra_rc          : <span class="number">19</span> <span class="comment">//MSB。对象的引用计数超过1时会存在这里。因此extra_rc加1后就是对象的引用计数。由于只有19位所以只有对象的引用计数不太大的时候才保存在这里</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line"><span class="meta">      uintptr_t nonpointer        : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_assoc         : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_cxx_dtor      : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t shiftcls          : 33; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span></span><br><span class="line"><span class="meta">      uintptr_t magic             : 6;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t weakly_referenced : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t deallocating      : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_sidetable_rc  : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t extra_rc          : 19</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)  <span class="comment">//刚好位于extra_rc的最低位，因此+RC_ONE，就表示extra_rc+1</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br></pre></td></tr></table></figure>
<p>上面的注释已经写得很明白了，至于isa为什么可以用结构体位域定义，主要是因为在64位系统中指针的长度为8个字节，64位，而类的地址通常占不满64位导致会空出许多bit，于是苹果的工程师充分利用这些bit，极大的提高了引用计数的操作效率。（至于为啥类的地址达不到64位，我也不知道，从上面的定义看应该只有33位有效位。）</p>
<p>接下来看一下retain和release的实现，进一步验证。</p>
<h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p>源码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="type">id</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootRetain(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NEVER_INLINE <span class="type">id</span></span><br><span class="line">_objc_rootRetain(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj-&gt;rootRetain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="type">id</span> </span><br><span class="line">objc_object::rootRetain()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRetain(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NEVER_INLINE <span class="type">id</span> </span><br><span class="line">objc_object::rootRetain_overflow(<span class="type">bool</span> tryRetain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRetain(tryRetain, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="type">id</span> </span><br><span class="line">objc_object::rootRetain(<span class="type">bool</span> tryRetain, <span class="type">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="type">id</span>)<span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123; <span class="comment">//纯pointer的则调用sidetable_retain，</span></span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> (<span class="type">id</span>)<span class="variable language_">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="type">id</span>)<span class="variable language_">this</span> : <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don&#x27;t check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致流程：</p>
<ol>
<li>首先判断是不是TaggedPointer对象，如果是则直接返回。上面也说了TaggedPointer对象并没有真正在堆上分配内存存储对象，所以这些retain，release操作都是无意义的。</li>
<li>如果isa是纯pointer类型则调用sidetable_retain，查询到对象的引用计数表后+1。另：slowpath表示该条件一般不会成立，用于编译器优化。</li>
<li>如果是tryRetain并且正在销毁则返回nil，即tryRetain失败。这里稍微提一句 <code>objc_loadWeakRetained</code> 函数里面有调用 <code>obj-&gt;rootTryRetain()</code> ，如果tryRetain失败， <code>objc_loadWeakRetained</code> 会返回nil。</li>
<li>如果isa是nonpointer，则调用<code>addc(newisa.bits, RC_ONE, 0, &amp;carry)</code> ,extra_rc++。由于extra_rc只有19bit所以需要处理进位的问题。同样进位也不是经常发生，所以进位的处理也是slowpath。</li>
<li>处理进位情况，当发生进位时，就需要把一部分引用计数加到引用计数表里去了，所以先加好锁sidetable_lock。更新transcribeToSideTable为true表示需要将一部分引用计数加到sidetable，更新isa.extra_rc=RC_HALF, 更新has_sidetable_rc为true表明使用到了引用计数表。</li>
</ol>
<p>从retain的处理逻辑不难看出，引用计数值的保存与操作是有经过优化的。接下来看一下sidetable_retain的操作。</p>
<h4 id="sidetable-retain"><a href="#sidetable-retain" class="headerlink" title="sidetable_retain"></a>sidetable_retain</h4><p>源码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span></span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="variable language_">this</span>];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="variable language_">this</span>];</span><br><span class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> SideTablesMap.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致流程：</p>
<ol>
<li>将对象地址映射为索引，然后从SideTables哈希数组里取得对象的SideTable</li>
<li>将对象地址映射为索引，从SideTable的refcnts哈希数组里取得当前引用计数值</li>
<li>+1</li>
</ol>
<p>这里稍微介绍下refcnts：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SideTable</span> &#123;</span><br><span class="line">    <span class="type">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts; <span class="comment">//指向一个引用计数表</span></span><br><span class="line">    <span class="type">weak_table_t</span> weak_table; <span class="comment">//指向一个弱引用表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RefcountMap disguises its pointers because we </span></span><br><span class="line"><span class="comment">// don&#x27;t want the table to act as a root for `leaks`.</span></span><br><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="type">size_t</span>,RefcountMapValuePurgeable&gt; RefcountMap;</span><br></pre></td></tr></table></figure>
<p>它是SideTable的一个成员变量，是一个哈希表DenseMap，DenseMap继承自DenseMapBase。DenseMapBase里实现了扩容操作，所以不用担心引用计数表容量不够的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DenseMapBase</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LookupKeyT&gt;</span><br><span class="line">    <span class="function">BucketT *<span class="title">InsertIntoBucketImpl</span><span class="params">(<span class="type">const</span> KeyT &amp;Key, <span class="type">const</span> LookupKeyT &amp;Lookup,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  BucketT *TheBucket)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// If the load of the hash table is more than 3/4, or if fewer than 1/8 of</span></span><br><span class="line">      <span class="comment">// the buckets are empty (meaning that many are filled with tombstones),</span></span><br><span class="line">      <span class="comment">// grow the table.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The later case is tricky.  For example, if we had one empty bucket with</span></span><br><span class="line">      <span class="comment">// tons of tombstones, failing lookups (e.g. for insertion) would have to</span></span><br><span class="line">      <span class="comment">// probe almost the entire table until it found the empty bucket.  If the</span></span><br><span class="line">      <span class="comment">// table completely filled with tombstones, no lookup would ever succeed,</span></span><br><span class="line">      <span class="comment">// causing infinite loops in lookup.</span></span><br><span class="line">      <span class="type">unsigned</span> NewNumEntries = <span class="built_in">getNumEntries</span>() + <span class="number">1</span>;</span><br><span class="line">      <span class="type">unsigned</span> NumBuckets = <span class="built_in">getNumBuckets</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">LLVM_UNLIKELY</span>(NewNumEntries * <span class="number">4</span> &gt;= NumBuckets * <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">grow</span>(NumBuckets * <span class="number">2</span>); <span class="comment">//扩容</span></span><br><span class="line">        <span class="built_in">LookupBucketFor</span>(Lookup, TheBucket);</span><br><span class="line">        NumBuckets = <span class="built_in">getNumBuckets</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">LLVM_UNLIKELY</span>(NumBuckets-(NewNumEntries+<span class="built_in">getNumTombstones</span>()) &lt;=</span><br><span class="line">                               NumBuckets/<span class="number">8</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">grow</span>(NumBuckets);</span><br><span class="line">        <span class="built_in">LookupBucketFor</span>(Lookup, TheBucket);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">ASSERT</span>(TheBucket);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Only update the state after we&#x27;ve grown our bucket space appropriately</span></span><br><span class="line">      <span class="comment">// so that when growing buckets we have self-consistent entry count.</span></span><br><span class="line">      <span class="comment">// If we are writing over a tombstone or zero value, remember this.</span></span><br><span class="line">      <span class="keyword">if</span> (KeyInfoT::<span class="built_in">isEqual</span>(TheBucket-&gt;<span class="built_in">getFirst</span>(), <span class="built_in">getEmptyKey</span>())) &#123;</span><br><span class="line">        <span class="comment">// Replacing an empty bucket.</span></span><br><span class="line">        <span class="built_in">incrementNumEntries</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KeyInfoT::<span class="built_in">isEqual</span>(TheBucket-&gt;<span class="built_in">getFirst</span>(), <span class="built_in">getTombstoneKey</span>())) &#123;</span><br><span class="line">        <span class="comment">// Replacing a tombstone.</span></span><br><span class="line">        <span class="built_in">incrementNumEntries</span>();</span><br><span class="line">        <span class="built_in">decrementNumTombstones</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// we should be purging a zero. No accounting changes.</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(ValueInfoT::<span class="built_in">isPurgeable</span>(TheBucket-&gt;<span class="built_in">getSecond</span>()));</span><br><span class="line">        TheBucket-&gt;<span class="built_in">getSecond</span>().~<span class="built_in">ValueT</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> TheBucket;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对SideTablesMap感兴趣可以参考</p>
<p><a href="https://cloud.tencent.com/developer/article/1586223">iOS SideTable</a></p>
<p>这里简单说一下，SideTablesMap就是一个全局的哈希表，它的元素个数是固定的8个或64个，里面装的就是SideTable对象。</p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="keyword">oneway</span> <span class="type">void</span>)release &#123;</span><br><span class="line">    _objc_rootRelease(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NEVER_INLINE <span class="type">void</span></span><br><span class="line">_objc_rootRelease(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootRelease();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="type">bool</span> </span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="type">bool</span> </span><br><span class="line">objc_object::rootRelease(<span class="type">bool</span> performDealloc, <span class="type">bool</span> handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//TaggedPointer对象不处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don&#x27;t check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// don&#x27;t ClearExclusive()</span></span><br><span class="line">            <span class="keyword">goto</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    <span class="comment">// newisa.extra_rc-- underflowed: borrow from side table or deallocate</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// abandon newisa to undo the decrement</span></span><br><span class="line">    newisa = oldisa; <span class="comment">//发生下溢时就保持isa不变了。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transfer retain count from side table to inline storage.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Need to start over to avoid a race against </span></span><br><span class="line">            <span class="comment">// the nonpointer -&gt; raw pointer transition.</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to remove some retain counts from the side table.        </span></span><br><span class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To avoid races, has_sidetable_rc must remain set </span></span><br><span class="line">        <span class="comment">// even if the side table count is now zero.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Side table retain count decreased.</span></span><br><span class="line">            <span class="comment">// Try to add them to the inline count.</span></span><br><span class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;  <span class="comment">// redo the original decrement too</span></span><br><span class="line">            <span class="type">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed. </span></span><br><span class="line">                <span class="comment">// Try it again right now. This prevents livelock on LL/SC </span></span><br><span class="line">                <span class="comment">// architectures where the side table access itself may have </span></span><br><span class="line">                <span class="comment">// dropped the reservation.</span></span><br><span class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 = oldisa2;</span><br><span class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</span><br><span class="line">                    <span class="keyword">if</span> (!overflow) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed.</span></span><br><span class="line">                <span class="comment">// Put the retains back in the side table.</span></span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Decrement successful after borrowing from side table.</span></span><br><span class="line">            <span class="comment">// This decrement cannot be the deallocating decrement - the side </span></span><br><span class="line">            <span class="comment">// table lock and has_sidetable_rc bit ensure that if everyone </span></span><br><span class="line">            <span class="comment">// else tried to -release while we worked, the last one would block.</span></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Side table is empty after all. Fall-through to the dealloc path.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Really deallocate.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">        <span class="comment">// does not actually return</span></span><br><span class="line">    &#125;</span><br><span class="line">    newisa.deallocating = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((<span class="type">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="variable language_">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很多但逻辑并不复杂：</p>
<ol>
<li>将引用计数-1</li>
<li>当引用计数减为“0”时，调用对象的dealloc方法。</li>
</ol>
<p>为啥这里0打了引号，这是因为对象刚创建出来不管是引用计数表里的值还是extra_rc的值其实都是0，这时候调用release，那就是0-1会发生underflow，所以这种情况下实际上要处理underflow，所以源码里有注释：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">newisa.<span class="keyword">extra_rc-- </span>underflowed: <span class="keyword">borrow </span>from side table <span class="keyword">or </span>deallocate</span><br></pre></td></tr></table></figure>
<p>因此实际上是引用计数先-1，当发生下溢时可能就会调用deallocate，当然这种情况下也就不更新引用计数值为负数了。</p>
<h4 id="sidetable-release"><a href="#sidetable-release" class="headerlink" title="sidetable_release"></a>sidetable_release</h4><p>实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rdar://20206767</span></span><br><span class="line"><span class="comment">// return uintptr_t instead of bool so that the various raw-isa </span></span><br><span class="line"><span class="comment">// -release paths all return zero in eax</span></span><br><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release(<span class="type">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="variable language_">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">    auto it = table.refcnts.try_emplace(<span class="variable language_">this</span>, SIDE_TABLE_DEALLOCATING);</span><br><span class="line">    auto &amp;refcnt = it.first-&gt;second;</span><br><span class="line">    <span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refcnt &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&#x27;t change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        refcnt |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (refcnt &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcnt -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((<span class="type">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="variable language_">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a>retainCount</h3><p>实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootRetainCount(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uintptr_t</span><br><span class="line">_objc_rootRetainCount(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (uintptr_t)<span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">        uintptr_t rc = <span class="number">1</span> + bits.extra_rc; <span class="comment">//加1后才是真正的引用计数，因为对象刚创建时extra_rc为0</span></span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount(); <span class="comment">//纯pointer的情况直接从sidetable获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sidetable-retainCount"><a href="#sidetable-retainCount" class="headerlink" title="sidetable_retainCount"></a>sidetable_retainCount</h4><p>实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="variable language_">this</span>];</span><br><span class="line"></span><br><span class="line">    size_t refcnt_result = <span class="number">1</span>; <span class="comment">//默认是1</span></span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">return</span> refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果对象是一个nonpointer对象，则引用计数较小时会直接保存在对象的isa成员变量里，只有当isa里装不下时才存放到引用计数表里，引用计数表是一个哈希表key为对象的地址，value就是引用计数值。</p>
<p>如果对象是一个pointer对象，则引用计数就存储在引用计数表里。</p>
<p>本文没有对上溢和下溢的处理细节做过多分析，有兴趣的可以细细研究。</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS stack overflow导致的EXC_BAD_ACCESS崩溃</title>
    <url>/2021/03/28/iOS-stack-overflow%E5%AF%BC%E8%87%B4%E7%9A%84EXC_BAD_ACCESS%E5%B4%A9%E6%BA%83/</url>
    <content><![CDATA[<p>最近想学习一下mmap的使用，没想到一来就掉坑里了。</p>
<p>测试代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_mmap &#123;</span><br><span class="line">    __autoreleasing <span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">//    self.videoData = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;ddcada74ee08d06dda5cd13b4117ad30&quot; ofType:@&quot;mp4&quot;] options:0 error:&amp;er];</span></span><br><span class="line"><span class="comment">//    self.videoData = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;ddcada74ee08d06dda5cd13b4117ad30&quot; ofType:@&quot;mp4&quot;] options:NSDataReadingUncached error:&amp;er];</span></span><br><span class="line">    <span class="keyword">self</span>.videoData = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;ddcada74ee08d06dda5cd13b4117ad30&quot;</span> ofType:<span class="string">@&quot;mp4&quot;</span>] options:<span class="built_in">NSDataReadingMappedIfSafe</span> error:&amp;err];  <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;er:%@&quot;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;videoData:%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="keyword">self</span>.videoData.length);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    long bufferSize = 4096;</span></span><br><span class="line">    <span class="type">long</span> bufferSize = <span class="number">1000000</span>;</span><br><span class="line"><span class="comment">//    long bufferSize = 1024 * 1024 - 30 * 1024;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[bufferSize];</span><br><span class="line">    [<span class="keyword">self</span>.videoData getBytes:buffer range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, bufferSize)]; <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">NSData</span> *someData = [[<span class="built_in">NSData</span> alloc] initWithBytes:buffer length:bufferSize];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;someData:%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)someData.length);</span><br><span class="line">    [<span class="keyword">self</span> saveDataToCaches:someData];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.videoData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)saveDataToCaches:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cachespath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).lastObject;</span><br><span class="line">    <span class="built_in">NSString</span> *fileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, <span class="built_in">NSDate</span>.date];</span><br><span class="line">    <span class="built_in">NSString</span> *filePath = [cachespath stringByAppendingPathComponent:fileName];</span><br><span class="line">    <span class="built_in">NSError</span> *err;</span><br><span class="line">    <span class="type">BOOL</span> ret = [data writeToFile:filePath options:<span class="built_in">NSDataWritingAtomic</span> error:&amp;err];</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;写入错误：%@&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;ret:%d&quot;</span>, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1处通过mmap的方式读取一个500多兆的视频数据，2处读取视频中某一段的数据。最开始的时候bufferSize设置的是4096，运行的时候一切正常。正常之后自然想改个其他的值试试，于是就设置bufferSize为视频大小，结果一运行就崩溃了很快啊，然后就是提示EXC_BAD_ACCESS。当时觉得很奇怪怎么会EXC_BAD_ACCESS呢？也没看到哪个地方有过度释放的对象啊。最后一点点修改bufferSize的大小，发现小于1000000代码就可以正常运行，而超过则会EXC_BAD_ACCESS。不过依然搞不懂为啥会这样。百思不得其解之后只能求助Google，不过也不知道怎么搜索关键字，一通搜索之后也没找到有用的东西，期间一度想放弃，不过还是坚持了下来。</p>
<p>直接上结论：上述崩溃的原因就是stack overflow了。</p>
<p>我们可以验证一下，打好断点后分别<strong>p &amp;err</strong>，<strong>p &amp;cachespath</strong>得到：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(lldb) p <span class="operator">&amp;</span>err</span><br><span class="line">(<span class="type">NSError</span> <span class="operator">**</span>) <span class="variable">$0</span> <span class="operator">=</span> <span class="number">0x000000016f5b97d0</span></span><br><span class="line">(lldb) p <span class="operator">&amp;</span>cachespath</span><br><span class="line">(<span class="type">NSString</span> <span class="operator">**</span>) <span class="variable">$1</span> <span class="operator">=</span> <span class="number">0x000000016f4c5470</span></span><br></pre></td></tr></table></figure>
<p>$0 - $1 = 0xF4360 = 1000288 = 0.954M，基本上快占满整个栈空间了（这里有点马后炮了因为很多人可能都不知道主线程的栈空间有多大，甚至都没有栈溢出这个概念自然也不会往这个方面想了）。因此代码可能会崩溃在后面的任意一行代码，具体是哪一行视栈的剩余空间大小。比如有可能崩溃在</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">NSError <span class="number">*e</span>rr;  Thread 1: EXC_BAD_ACCESS (<span class="attribute">code</span>=2, <span class="attribute">address</span>=0x16f4bfad0)</span><br></pre></td></tr></table></figure>
<p>也有可能会崩溃在：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">NSString <span class="number">*f</span>ileName = [NSString stringWithFormat:@<span class="string">&quot;%@&quot;</span>, NSDate.date];  Thread 1: EXC_BAD_ACCESS (<span class="attribute">code</span>=2, <span class="attribute">address</span>=0x16ebfbae0)</span><br></pre></td></tr></table></figure>
<p>如果平时不太注意栈空间大小的话，出现这样的崩溃很容易让人摸不着头脑。比如崩溃在fileName这一行，但这一行显然是没有什么问题的。遇到这种情况，我们就不要死死盯在这一行代码上了，因为很有可能是其他地方的代码出了问题，而仅仅在这一行体现出了症状（感觉跟人生病有点相似出现症状的地方有可能并不是真正的病因）。这时应该往上仔细查找，边查找边排除掉那些不太可能出现问题的代码，缩小范围，找出那些最有可能出现问题的代码。当然这依然需要你有扎实的基础，比如这里</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> bufferSize = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buffer[bufferSize];</span><br></pre></td></tr></table></figure>
<p>谁又能想得到是这里申请了太多的栈空间导致后面的随机崩溃呢？EXC_BAD_ACCESS崩溃有些不是必现的这就导致复现很困难，而有些是崩溃的地方是不固定的。这也是EXC_BAD_ACCESS崩溃让人感到可怕的地方。</p>
<p>解决办法：在堆上申请空间。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> bufferSize = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * buffer = <span class="built_in">malloc</span>(bufferSize * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br></pre></td></tr></table></figure>
<p>最后记得free。</p>
<p>总结：</p>
<p>1.对于大内存变量或者无法预知大小的变量尽量在堆上申请空间而不是在栈上申请空间，始终牢记栈空间是有大小限制的。</p>
<p>2.尽量使用循环而不是递归。<br>虽然以前并太不认同这一点，劳资就用递归怎么啦。不过现在看来递归确实更容易导致栈溢出，能用循环的时候尽量用循环，确实困难再用递归。</p>
<p>3.iOS主线程栈空间大小为1MiB，子线程栈空间大小为512KiB。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://initlife.com/blog/2015/10/28/iosli-de-zhan-xian-zhi-yin-fa-de-crash/">iOS里的栈限制引发的crash</a>  </p>
<p><a href="https://xionghengheng.github.io/2019/01/06/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BAcrash/">一个有意思的栈溢出crash</a></p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook Pro外接显示器(一)之网购显示器</title>
    <url>/2021/04/05/MacBook%20Pro%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8(%E4%B8%80)%E4%B9%8B%E7%BD%91%E8%B4%AD%E6%98%BE%E7%A4%BA%E5%99%A8/</url>
    <content><![CDATA[<p>MacBook Pro笔记本的显示器着实是小了点，想买一个外接显示器。没想到买个显示器也是有很多知识是需要学习的。在京东上随便挑了一个卖的靠前的显示器三星C24F390FHC，牌子是三星的感觉问题不大，价格999块也还能接受。参数啥的看了一下，但因为什么都不懂看了也仅仅是看了。</p>
<p>买回来装好，心情还有点小激动，连上电脑后一看效果傻了，显示器显示的文字毛边太明显了，看着太闹心了。用久了苹果的产品以为显示器都是retina屏的。然后看了一下产品参数是1920x1080p的，但一般宣传上写的是“1920x1080p（全高清）”，看到全高清三个字对于小白的我来说以为妥了，肯定够用了，殊不知上面还有2K屏，4K屏。产品营销文案确实是一个值得玩味的东西，随便一个术语就可以把一个小白唬的一愣一愣的。装好体验了几分钟实在受不了这种模糊的感觉，只能退了，等京东退钱后再打算加点钱换个4K屏的。</p>
<p>总结：<br>1.买电子产品前最好做一下功课。了解一下电子产品的参数，这些参数的含义。明确好自己的需求，挑出能够满足自己需求的几个关键性参数，如果产品达不到自己的硬性要求就不要买了。<br>不过这一点好像挺难，可能大多数人都不知道有哪些关键性参数需要重点考虑。比如我自己以为所有的显示器都是retina屏的，压根就没想到原来还有很多低分辨率的显示器。难道是我脱离生活太久变成了何不食肉糜的晋惠帝了？所幸在发达的互联网我们可以搜几篇科普文扫扫盲，这样就能够确定好自己需要关注的参数了。<br>2.了解下电子产品的附件。显示器是附赠HDMI线的有的还送DP线的，这是连接电脑和显示器线的。当时买的时候也没看，额外买了一根HDMI线。<br>3.网购的时候是否有必要随大流选所谓的热销的、爆款的？<br>这个我也不太清楚，网上的东西假的太多，好评基本没有参考价值。但是买东西前做下功课确定好自己想买什么而不是头脑发热掉进商家的宣传，刷爆了信用卡，空悲切。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>MacBook Pro外接显示器(二)之MacBook Pro外接键盘控制外接显示器亮度和声音</title>
    <url>/2021/04/07/MacBook%20Pro%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8(%E4%BA%8C)%E4%B9%8BMacBook%20Pro%E5%A4%96%E6%8E%A5%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E4%BA%AE%E5%BA%A6%E5%92%8C%E5%A3%B0%E9%9F%B3/</url>
    <content><![CDATA[<p>最近给我的MacBook Pro外接了显示器和键盘，显示器是三星的 LU28R55 ，键盘是惠普的。<br>但是发现外接显示器、键盘后有几个影响体验的问题：<br>1.外接的显示器是没有内置扬声器的需要额外接个音响才行，否则设置声音的输出为外接显示器也没用。<br>2.外接的显示器调节亮度和声音只能用显示器自带的按钮按，无法通过键盘控制。</p>
<p>于是Google了一下发现使用 MonitorControl + Karabiner 这两个软件可以达到外接键盘控制外接显示器的亮度和声音。<br>MonitorControl下载地址<br><a href="https://github.com/MonitorControl/MonitorControl/releases/tag/v2.1.0">https://github.com/MonitorControl/MonitorControl/releases/tag/v2.1.0</a></p>
<p>Karabiner下载地址<br><a href="https://github.com/pqrs-org/Karabiner-Elements/releases/tag/v13.4.0">https://github.com/pqrs-org/Karabiner-Elements/releases/tag/v13.4.0</a></p>
<p>MonitorControl的作用是通过软件控制外接显示器的亮度和声音。</p>
<p>Karabiner的作用是按键映射。为什么需要这个APP呢？因为外接显示器后笔记本基本上是合盖使用的，自然就没法使用笔记本的键盘了，而我这里外接的键盘是惠普的键盘跟苹果的键盘是不一样的，所以需要映射一下。当然如果你的外接键盘是苹果的配件那使用MonitorControl就够了。</p>
<p>MonitorControl的安装很简单，这里主要说一下Karabiner，Karabiner安装后会多出两个APP：Karabiner-Elements 和 Karabiner-EventViewer。这里主要使用Karabiner-Elements，而Karabiner-EventViewer这里虽然使用不到但需要打开一下以允许一些权限。要不然仅使用Karabiner-Elements在Mac的一些系统上可能会出现即使设置了但却没效果的现象。<br><img src="https://upload-images.jianshu.io/upload_images/1503319-2105b2367d07d034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Karabiner-Elements的设置也很简单，当然对于小白的我来说也是整了一会的主要是没注意到Karabiner-EventViewer还要打开一下这个坑。<br>Karabiner-Elements最好多设置几个profile，方便切换，用回笔记本自身的键盘时就切换为默认的。<br>profile：<br><img src="https://upload-images.jianshu.io/upload_images/1503319-1bd699b1c59b2857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>按键的映射：<br><img src="https://upload-images.jianshu.io/upload_images/1503319-7b901ef531d0eb63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这样就可以通过非苹果外接键盘控制苹果电脑的扬声器了。</p>
<p>现在，你可以通过外接键盘控制声音和外接显示器的亮度了，是不是感觉体验度瞬间上升了好几楼了呢？</p>
<p>另外吐槽下三星的 LU28R55，这款显示器亮度设为0了后感觉还是挺亮的，真不知道当初设计的人是怎么想的就不能让它继续调低吗？在我看来完全是一个缺陷。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>MacBook Pro外接显示器(三)之Mac上的SwitchResX完全卸载</title>
    <url>/2021/04/17/MacBook%20Pro%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8(%E4%B8%89)%E4%B9%8BMac%E4%B8%8A%E7%9A%84SwitchResX%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD/</url>
    <content><![CDATA[<p>最近在折腾外接显示器，一直达不到4k@60hz。然后稀里糊涂安装了SwitchResX。SwitchResX是干什么的这里就不多说了，本文主要讲一下怎么卸载。</p>
<p>在系统偏好设置中点击移除就完事了，但事实并没有这么简单。虽然卸载了但是打开显示器会发现显示器的名称中还是带有SwitchResX而不是默认的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1503319-b237f40e28001761.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这说明SwitchResX虽然卸载了但是还残留了一些文件。那么如何恢复显示器的默认名称呢？这个问题实在是有点冷门，花了我好几个小时才搜到解决办法，主要是不知道该怎么搜问题的关键字。搜个卸载出来的都是让你安装清理软件APP的。</p>
<p>最终解决办法如下：</p>
<ol>
<li>确保已经退出SwitchResX，然后在系统偏好设置中点击移除删除APP包</li>
<li><code>/Library/Displays/Contents/Resources/Overrides</code> 里的文件全部删掉</li>
<li><code>/Library/Colorsync/Profiles/Displays</code> 删掉SwitchRes开头的</li>
<li>重启电脑</li>
</ol>
<p>ps：连带的MonitorControl突然无法使用提示“未发现支持的显示器”的问题也解决了（一度以为是升级到Big Sur系统导致）。真正原因估计就是SwitchResX改了显示器的名称导致。</p>
<p>总结：<br>1.Mac中删除一个APP，系统只是删掉了这个应用，但是这个应用在使用的过程中产生的一些文件并不会被删除。<br>一个APP在使用过程中或多或少会产生一些文件比如缓存，但这些缓存一般对我们的使用不会产生影响顶多占用了一些磁盘空间，但有些APP会产生一些配置文件这就导致即使删除了这个APP，只要它的配置文件还在那么就会存在副作用。因此要想彻底卸载一个应用除了删掉这个应用还要把它使用过程中产生的文件也要删除掉才行。至于APP会在哪些目录产生哪些文件那就只能网上搜索了。<br>2.如果你想设置分辨率的话还不如用EasyRes，目前还没看到有啥问题。<br>3.英语好还是很有用的。在搜一些问题的时候直接上英文关键字比中文的好多了。用中文搜可能来来回回都是那几篇还是抄来抄去的。</p>
<p><strong>参考</strong><br><a href="https://discussions.apple.com/thread/7053660">how reset my display profile it’s show “SwitchResX4 - Color LCD”</a><br>有一个人的回答：<br><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">It<span class="comment">&#x27;s not a problem. SwitchResX is doing that on purpose, and for absolutely no good reason.</span></span><br><span class="line"></span><br><span class="line">The app doesn<span class="comment">&#x27;t do anything useful. Correctly and entirely delete SwitchResX according to the instructions </span></span><br><span class="line"><span class="keyword">on</span> their site <span class="built_in">and</span> your issue should be solved. Though after its removal, you<span class="comment">&#x27;ll have to empty out the Displays </span></span><br><span class="line">profile folder again so the OS can pull another <span class="built_in">new</span> copy <span class="keyword">of</span> the <span class="keyword">default</span> display profile that won<span class="comment">&#x27;t be tagged </span></span><br><span class="line"><span class="keyword">with</span> their application name.</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>MacBook Pro外接显示器(四)之4K屏60Hz的艰难旅程</title>
    <url>/2021/04/20/MacBook%20Pro%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8(%E5%9B%9B)%E4%B9%8B4K%E5%B1%8F60Hz%E7%9A%84%E8%89%B0%E9%9A%BE%E6%97%85%E7%A8%8B/</url>
    <content><![CDATA[<p>为什么要让外接显示器达到4K@60Hz的刷新率？</p>
<p>因为4K@30Hz的刷新率鼠标移动时会有明显的延迟感。刷新率越高画面才能越丝滑。4K的显示屏至少需要60Hz的刷新率，当然如果支持144Hz的那更好。对于一般用户60Hz基本足够。</p>
<p>外接显示器达到4K@60Hz刷新率的条件</p>
<p>主机支持（主要是主机的显卡），显示器支持，线材支持。该条件符合木桶原理只要其中一个不满足就无法达到4K@60Hz的刷新率。为了到达这个目标需要我们对主机的端口，显示器参数，线材等有一个基本的了解。下面一个个介绍。</p>
<p><strong>主机支持</strong></p>
<p>我的电脑是MacBook Pro 13寸 2014mid的。可以从苹果官网 <a href="https://support.apple.com/kb/sp703?locale=zh_CN">macbook pro 2014mid</a> 查到这款电脑的参数说明，如下端口部分是我们重点关注的：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/1C147D43EA0F9787EC5FA06822136426.jpg" style="zoom:50%;" /></p>
<p>可以看到HDMI端口只能输出60Hz的1080p。而4K的只能到30Hz或24Hz。所以我们就不能使用该端口作为视频输出。相应的我们就不能买HDMI（主机）—HDMI（显示器）线或HDMI—DP线材。不管这根HDMI线支持的版本是多少都不能买。（ps:这里线材使用”主机端口—显示器端口“表示，下同）</p>
<p>而对于Thunderbolt2端口支持原生MiniDP输出，但没有写明能否支持到4K@60Hz。搞得我一度以为通过MiniDP—DP能达到4K@60Hz，然而换了几次线后发现还是不行，最后又搜索了好久的资料基本可以确定这款机器不管通过什么端口都不能达到4K@60Hz。所以如果技术规格里没写明的话基本上是支持不了的。</p>
<p>让我们看一下2015年中的15寸的mbp的技术规格：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20210420095501.png" alt=""></p>
<p>这里通过雷雳数字视频输出写了支持高达5K@60Hz的外接显示屏并且还得是配备AMD的机型，因此这款电脑才有可能通过雷电端口达到4K@60Hz，同样如果使用HDMI端口则只能到4K@30Hz。相应的线材只能买MiniDP—DP或MiniDP—HDMI。</p>
<p>小结：由于主机不支持，所以后面折腾了好几根MiniDP—DP线材还是没用，搞得心力交瘁。</p>
<p><strong>显示器支持</strong></p>
<p>我的显示器是三星的LU28R55，可以去官网查一下它的参数：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20210418000306.png" style="zoom:50%;" /></p>
<p>可以看到显示器是支持4K@60Hz的。再看一下显示器提供的端口：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20210418000540.png" style="zoom:50%;" /></p>
<p>提供一个1.2版本的DP接口，和两个2.0版本的HDMI端口。提供的配件：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20210418000742.png" style="zoom:50%;" /></p>
<p>只提供了一根HDMI—HDMI线。</p>
<p><strong>线材支持</strong></p>
<p>如果你的mbp是旧款的并且确定支持4K@60Hz，那么主机最好使用MiniDP端口输出，而显示器可以使用DP或HDMI端口。因此线材的选择基本就很明确了：需要一根MiniDP—DP的线或MiniDP—HDMI的线。这根线的DP需要是1.2版本及以上，或者HDMI需要2.0版本及以上。具体买哪种主要看你的显示器提供的端口丰不丰富，所以买显示器或电脑的时候端口的丰富程度也是一个重要的考虑点。</p>
<p>买线经历：<br>买显示器的时候没有注意显示器是附带一条HDMI—HDMI线的，然后多买了一根HDMI—HDMI2.0版本的线30¥。外接键盘和鼠标后发现USB端口用完了，于是想买个扩展坞但当时并不清楚端口的种类，买了个type-c公头的扩展坞149¥，结果发现电脑没有Type-C口，不想退了，于是又买了个USB转Type-C母的转接器30¥。多花了130¥。</p>
<p>由于刚开始的时候不知道主机不支持4K@60Hz，然后试了绿联和moshi的MiniDP—DP线结果自然是都不行，只好都退了。另外买线或扩展坞的时候一定要看清楚能到多少Hz和线端口的版本。找线期间看了一下绿联的MiniDP—HDMI的线的介绍只能用很讲究来形容了真正做到了真话说一半，假话全不说的境界。介绍说是支持4K但不说能到多少Hz反正我找遍整个详情也没看到。事实上它的外包装标的是只支持30Hz的，不知道为啥不在详情页标明。</p>
<p>ps：显示器的信息里：67.5kHz 30Hz的含义是：67.5kHz：表示传输码率（分辨率越高码率越高） 30Hz：表示刷新率，就是每秒帧数。</p>
<p>总结：</p>
<p>1.对于消费者而言不要看商家说了什么而是要看他没说什么，自己的需求是什么。这样才能不被那些花里胡哨的信息淹没自己。</p>
<p>目前用着显示器自带的HDMI—HDMI线，只能到4K@30Hz。因为电脑不支持4K@60Hz，也就不折腾了。4K屏的60Hz艰难之旅到此结束。</p>
<p><strong>参考</strong></p>
<p><a href="https://helpdeskgeek.com/help-desk/how-is-4k-different-from-uhd-and-2160p/">How Is 4K Different From UHD and 2160p?</a></p>
<p><a href="https://support.apple.com/zh-cn/HT201736">识别 Mac 上的端口</a></p>
<p><a href="https://www.mf8.biz/wo-de-4k-screen-biji/">我的 4K 外接显示器笔记</a></p>
<p><a href="https://www.expreview.com/56309.html">显示器刷新率上不去？可能是线材、接口的锅</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/268572741">Mac 外接显示器详细分析与推荐 2021</a></p>
<p><a href="https://support.apple.com/zh-cn/HT201300">识别 MacBook Pro 机型</a></p>
<p>​                                    </p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>博客收藏</title>
    <url>/2021/07/08/%E5%8D%9A%E5%AE%A2%E6%94%B6%E8%97%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/ming1016/study/wiki">ming1016-study</a>  网友个人收集的比较全的iOS开发技术点</p>
<p><a href="https://github.com/iOS-Mayday/heji">Mayday-heji</a>  iOS面试相关的，有加群卖广告嫌疑</p>
<p><a href="https://xiaozhuanlan.com/">小专栏</a> 质量较高，不过大部分都要收费。</p>
<h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><p><a href="http://oncenote.com/">Jamin</a></p>
<p><a href="https://www.desgard.com">Gua</a></p>
<p><a href="https://kingcos.me/">kingcos</a> </p>
<p><a href="https://tbfungeek.github.io">Edgar</a>  安卓iOS一系列文章</p>
<p><a href="http://yulingtianxia.com/">yulingtianxia’s blog</a>  messageThrottle作者</p>
<p><a href="https://ai-chan.top/">酷酷的哀殿</a>   llvm、汇编、编译、底层</p>
<p><a href="https://cloud.tencent.com/developer/user/2586061">灵魂画师牧码</a>  后台开发，知识面广，学习路线</p>
<p><a href="https://www.junmajinlong.com/">骏马金龙</a>  linux，shell</p>
<p><a href="https://xaoxuu.com/">XAOXUU</a>  界面不错</p>
<p><a href="https://wuqiuhao.github.io/">Hale’s Blog</a> 界面不错</p>
<h3 id="公司博客"><a href="#公司博客" class="headerlink" title="公司博客"></a>公司博客</h3><p><a href="https://techblog.toutiao.com/">今日头条</a></p>
<p><a href="https://tech.meituan.com/">美团技术团队</a></p>
<p><a href="https://buglydevteam.github.io/">Bugly技术团队</a></p>
<p><a href="https://sq.163yun.com/blog">网易云</a></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/00.01.html">编程的艺术—gitbook</a></p>
]]></content>
      <categories>
        <category>参考资料</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS推送证书更新</title>
    <url>/2021/07/09/iOS%E6%8E%A8%E9%80%81%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>首先确保你登录的账号权限要能够修改证书。</p>
<p><strong>导出p12文件</strong></p>
<p>打开钥匙串访问，点“登陆—&gt;我的证书”，选中刚安装的通用证书（不带development的是通用环境（开发，生产都可以用）），导出为p12，设置好密码，上传到个推网站上。也可以同时上传专门用于开发的p12。</p>
<p><strong>更新profiles文件</strong></p>
<p>更新推送证书后别忘了更新profile文件。选中侧边栏Profiles，选中对应profile，进入后点击edite，然后勾选select all，点击保存。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/iotjin/article/details/118302860">iOS - 推送证书更新（Apple Development和极光）</a></p>
<p><a href="https://www.jianshu.com/p/be9415a0a6fb?from=timeline">iOS 推送证书加入到钥匙串后,无法导出P12文件</a></p>
]]></content>
      <categories>
        <category>APP上架</category>
      </categories>
      <tags>
        <tag>推送证书更新</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook Pro外接显示器(五)之我的电脑烧坏了</title>
    <url>/2021/07/28/MacBook%20Pro%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8(%E4%BA%94)%E4%B9%8B%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E7%83%A7%E5%9D%8F%E4%BA%86/</url>
    <content><![CDATA[<p>又是一个安静的晚上，我的MacBook Pro和往常一样外接着一个4k的显示屏看着电视，突然屏幕黑屏，摸了一下电脑、扩展坞都挺热的，然后赶紧拔掉外接显示器，按了几下开机键发现开不了机了。</p>
<p>等电脑凉下来后，尝试了网上说的各种组合键后，还是开不了机。顿感大事不妙，大概率是主板烧坏了。预约了周末去天才吧，到了之后给工作人员说明了下情况，工作人员说要去检查下才知道，大概20分钟后工作人员告诉我确实是主板烧坏了，我问还能不能修，他回复说因为是14年的旧款了已经没有配件修了。我又问如果到外面修大概要多少钱，他说他也不清楚，说如果太贵的话不建议我修，建议我买新的电脑。</p>
<p>想到电脑也用了差不多6年半了，也可以换一台新的了，但真要换还是有点肉疼的，看了一下价格基本上要1w左右。考虑了几分钟，决定还是先回去吧，换电脑的事往后稍稍。</p>
<p>哎，从4月份买了4k显示屏到现在一共用了差不多3个月，结果跟随我6年半的电脑没了。我想了下烧坏的原因大概有这么几点：</p>
<ol>
<li>电脑确实有点旧了。就是不外接显示器，浏览器看视频多打开几个，电脑都有些烫手。外接显示器后属实勉强带动，散热跟不上。</li>
<li>电脑连接到外接显示器链路太长。电脑—转接头—扩展坞—显示器。因为买扩展坞的时候没注意接口的问题，导致中间还接了根转接头，链路太长各设备的稳定性，散热，兼容性问题隐患就会很大。</li>
<li>扩展坞不是苹果原装的，用的国产的绿联。怎么说呢有钱的话扩展坞之类的最好用原装的，国产的除了便宜其他真不好说，把电脑烧坏了是真伤不起。后来搜了一下，用绿联外接显示器烧坏主机的不是什么稀奇事，慎重。</li>
</ol>
<p>总结：</p>
<ol>
<li>电脑如果用了4,5年了最好不要再外接啥设备了，特别是电脑稍微多开几个应用就发热厉害的话最好别外接了。</li>
<li>外接设备时链路最好最短，最好是电脑—线—显示器就完了。</li>
<li>如果真要扩展坞啥的首选原装，次选国外大品牌比如moshi啥的。</li>
</ol>
<p>后记：8月份换了新电脑，因为穷买的是低配版，接口一点都不丰富，就两个雷电口，于是买了个苹果原装的转接头，之前外接是扩展坞，电脑都烫手，现在除了转接头有点发热，电脑已经不发热了。现在外接显示器终于是4k@60hz了，纵享丝滑。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>TAS、CAS简介</title>
    <url>/2021/08/01/TAS%E3%80%81CAS%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>原子操作是指操作是不可分割的，要么发生，要么不发生。事物只会处于原始状态和成功状态两种中的一种，不会处于一种完成一半的状态。</p>
<p>TAS和CAS指令是原子操作，但我感觉原子操作不仅是原子操作而且还是排他的，一个线程正在执行某个原子操作时，其他线程不能同时再执行该原子操作。</p>
<h3 id="C语言里的volatile"><a href="#C语言里的volatile" class="headerlink" title="C语言里的volatile"></a>C语言里的volatile</h3><p>作用：</p>
<ol>
<li><p>保证可见性</p>
<p>表示用到这个变量时必须每次都重新从内存里读取这个变量的值，而不是使用保存在寄存器里的备份。主要用于防止编译器的一些优化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例一</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> a = i; <span class="comment">//优化</span></span><br><span class="line">	<span class="type">int</span> b = i;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;i = %d\n&quot;</span>, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> a = i; <span class="comment">//未优化</span></span><br><span class="line">	<span class="type">int</span> b = i; <span class="comment">//这里会继续从内存里读取i的值而不是用上面读过的缓存。</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;i = %d\n&quot;</span>, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止指令重排（貌似只在Java里有这个功能）</p>
<p>保证volatile所修饰的变量之前的代码不会在该变量之后执行，该变量之后的代码不会在该变量之前执行。</p>
</li>
</ol>
<p>volatile不能保证原子性。仅使用 volatile 修饰 i，i++也不是线程安全的。</p>
<p>不知道C语言里的volatile是否和Java里的意义一样？</p>
<h3 id="TAS（Test-And-Set）"><a href="#TAS（Test-And-Set）" class="headerlink" title="TAS（Test And Set）"></a>TAS（Test And Set）</h3><p>TAS指令的语义是：向某个内存地址写入值1，并且返回这块内存地址存的原始值。TAS指令是原子的，这是由实现TAS指令的硬件保证的（这里的硬件可以是CPU，也可以是实现了TAS的其他硬件）。</p>
<p>伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">testAndSet</span><span class="params">(<span class="type">bool</span> *target)</span> &#123;</span><br><span class="line">		<span class="type">bool</span> old = *target;</span><br><span class="line">		*target = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用维基百科上的一段话：</p>
<p>In <a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, the <strong>test-and-set</strong> instruction is an instruction used to write 1 (set) to a memory location and return its old value as a single <a href="https://en.wikipedia.org/wiki/Atomic_(computer_science">atomic</a>) (i.e., non-interruptible) operation. <strong>If multiple processes may access the same memory location, and if a process is currently performing a test-and-set, no other process may begin another test-and-set until the first process’s test-and-set is finished.</strong> A <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> may use a test-and-set instruction offered by another electronic component, such as <a href="https://en.wikipedia.org/wiki/DPRAM">dual-port RAM</a>; a CPU itself may also offer a test-and-set instruction.</p>
<p>这段话消除了我的一个疑惑：对于同一个内存地址如果有一个线程正在执行test-and-set指令，那么其他线程需要等到它执行完成后才能继续执行test-and-set指令。这可以在硬件层面做到。具体是怎么做到的以后有空可以研究一下。</p>
<p>因此可以说TAS即是原子操作也是线程安全的，由硬件保证。</p>
<h3 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h3><p>CAS的语义是：让CPU比较某个内存地址的值与一个给定值（<strong>这个给定值是上一刻从此内存地址读出来的</strong>）是否相同，如果相等，则把一个新值写入到此内存地址，否则什么都不做。</p>
<p>CAS是项<strong>乐观锁</strong>技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>CAS指令需要三个参数，一个内存地址(V)、一个期望旧值(E)、一个新值(N)。</p>
<p>CAS指令的执行过程：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>比较内存<span class="variable">V</span>的值是否与<span class="built_in">E</span>相等？</span><br><span class="line"><span class="number">2.</span>如果相等，则用新值<span class="built_in">N</span>替换内存位置<span class="variable">V</span>的旧值</span><br><span class="line"><span class="number">3.</span>如果不相等，不做任何操作。</span><br><span class="line"><span class="number">4.</span>无论哪个情况，<span class="variable">CAS</span>都会把内存<span class="variable">V</span>原来的值返回。</span><br></pre></td></tr></table></figure>
<p>伪代码：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> CAS(<span class="built_in">int</span> *<span class="built_in">ptr</span>,<span class="built_in">int</span> oldvalue,<span class="built_in">int</span> newvalue)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">int</span> temp = *<span class="built_in">ptr</span><span class="comment">;</span></span><br><span class="line">   <span class="keyword">if</span>(temp == oldvalue)</span><br><span class="line">       *<span class="built_in">ptr</span> = newvalue<span class="comment">;</span></span><br><span class="line">   <span class="keyword">return</span> temp<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种是返回 bool 结果：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cas</span><span class="params">(<span class="type">long</span> *addr, <span class="type">long</span> old, <span class="type">long</span> <span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Executes atomically. */</span></span><br><span class="line">    <span class="keyword">if</span>(*addr != old)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *addr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上过程在CAS指令中是原子操作。</p>
<p>CAS应用示例：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;  </span><br><span class="line">   备份旧数据； </span><br><span class="line">   基于旧数据构造新数据； </span><br><span class="line">&#125;<span class="keyword">while</span>(!<span class="built_in">CAS</span>( 内存地址，备份的旧数据，新数据 ))  <span class="comment">//CAS修改失败则继续尝试，线程并不会被挂起阻塞。</span></span><br></pre></td></tr></table></figure>
<p><strong>ABA 现象</strong></p>
<p>ABA 现象指的是线程 1 先读取了变量的值为A作为期望旧值，然后将要执行 CAS 指令时，变量的值在其他线程已经由 A 改为 B，又改回了 A。但是当线程 1 执行 CAS 时是无法感知这一变化的，因此它判断是相等的所以依然执行成功。</p>
<p>ABA 现象不一定就会出问题，取决于具体的场景，在某些场景下 ABA 现象就会变成 ABA 问题。</p>
<p>解决的办法就是在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code>。添加了版本号后线程 1 读取到的 E 将是 1A，而当它执行 CAS 时重新获取变量的值将为 3A，于是不相等，CAS 将执行失败。</p>
<p>例子：<a href="https://blog.csdn.net/WSYW126/article/details/53979918">AtomicInteger、Unsafe类、ABA问题</a></p>
<p><strong>疑问</strong></p>
<p>Q1：线程 1 将要执行 CAS(v, 1, 2)，线程 2 将要执行 CAS(v, 1, 2)，对于多核 CPU 会不会同时执行这两条CAS 指令？</p>
<p>个人觉得对于同一变量的 CAS 指令，同一时刻CPU只会执行其中一条 CAS 操作。执行完其中一条后才会继续执行下一条。要不然一样导致结果不符合预期，线程不安全。</p>
<p>Q2：原子指令是否具有排他性？比如线程1正在对某个变量执行原子操作，那么线程2能不能同时也对这个变量执行该原子操作？线程2能不能同时执行该变量的其他原子操作？</p>
<p>不太确定的结论：同一个原子操作会排他，不同原子操作不会。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">线程<span class="number">1</span>：<span class="built_in">TAS</span>(v)</span><br><span class="line">线程<span class="number">2</span>：<span class="built_in">CAS</span>(v, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">线程<span class="number">1</span>还没有写入<span class="number">1</span>时，线程<span class="number">2</span>比较发现相等写入了<span class="number">3</span>，线程<span class="number">1</span>继续执行写入了<span class="number">1</span>.那么v最终是<span class="number">1</span>？</span><br></pre></td></tr></table></figure>
<p>Q3：在执行类似CAS这种复杂原子指令期间，其他线程能不能读写该变量的内存？</p>
<p>不太确定的结论：貌似可以。可能上面的结论是错误，没查到资料，也可能是：在执行原子指令时，其他线程不能访问该变量的内存。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">线程<span class="number">1</span>：<span class="built_in">fetch_and_add</span>(<span class="attribute">x</span>, <span class="number">1</span>)</span><br><span class="line">线程<span class="number">2</span>：<span class="attribute">x</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Q：一条汇编指令能不能被多核 CPU 同时执行？</p>
<p>可以。但如果锁内存总线后，就可以保证同时只有一个核来执行该指令，从而避免了多核下发生的问题。</p>
<p>上面的结论有些可能是错误的，知道的老铁可以留言指明一下。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://bitdewy.github.io/blog/2013/09/02/atomic-operation/">C++11中的原子操作 (Atomic Operation)</a>  只讲了使用没有讲原理。</p>
<p><a href="https://juejin.im/post/5ce8f2a86fb9a07ee062f298">锁的硬件实现</a></p>
<p><a href="https://steemit.com/cn/@cifer/c-volatile">如何使用 C 语言中的 volatile 关键字?</a>  偏硬件层面对 volatile 的解释</p>
<p><a href="https://en.wikipedia.org/wiki/Test-and-set">Test-and-set</a>  Test-and-set维基百科介绍</p>
<p>CAS 相关：</p>
<p><a href="https://juejin.im/post/5c87afa06fb9a049f1550b04">CAS原理分析及ABA问题详解</a>  </p>
<p><a href="https://blog.csdn.net/WSYW126/article/details/53979918">AtomicInteger、Unsafe类、ABA问题</a></p>
<p><a href="https://www.jianshu.com/p/fb6e91b013cc">深入浅出CAS</a></p>
<p><a href="https://blog.csdn.net/a7980718/article/details/82860505">CAS操作在ARM和x86下的不同实现</a>  硬件汇编层面分析</p>
<p><a href="https://infilos.com/reading/RD02-VM/Dive-Into-Jvm/CH13.html">CH13-线程安全与锁优化</a>  一本书，还不错。</p>
<p><a href="https://blog.codingnow.com/2007/12/fence_in_multi_core.html">多核环境下的内存屏障指令</a></p>
<p><a href="https://yemablog.com/posts/cache-locking">x86 cache locking 的猜想</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>TAS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS synchronized实现原理</title>
    <url>/2021/08/01/iOS%20synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>源码版本：objc4-781</p>
<h4 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="@synchronized介绍"></a>@synchronized介绍</h4><p><code>@synchronized</code> 所做的事情跟锁（lock）一样：它防止不同的线程同时执行同一段代码。但相比于使用 <code>NSLock</code> 创建锁对象、加锁和解锁来说，<code>@synchronized</code> 用着更方便，可读性更高。</p>
<p><code>@synchronized</code>是对<code>mutex</code>递归锁的封装， <code>@synchronized(obj)</code>内部会根据传入的同步对象obj得到一把递归锁，然后进行加锁、解锁操作。</p>
<p>使用示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)increment</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [_elements addObject:element];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到synchronized的使用是非常简单的。</p>
<p>关于synchronized有几个重要问题？</p>
<p>1.锁是如何与你传入 <code>@synchronized</code> 的对象关联上的？</p>
<p>2.<code>@synchronized</code>会保持（retain，增加引用计数）被锁住的对象么？</p>
<p>3.假如你传入 <code>@synchronized</code> 的对象在 <code>@synchronized</code> 的代码块里面被赋值为 <code>nil</code> 将会怎么样？</p>
<p>4.给<code>@synchronized</code>传入nil会怎样？</p>
<h4 id="原理探究"><a href="#原理探究" class="headerlink" title="原理探究"></a>原理探究</h4><p>对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSObject *obj = [NSObject new];</span><br><span class="line">        @synchronized (obj) &#123;</span><br><span class="line">            NSLog(@<span class="string">&quot;obj is @synchronized&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clang -rewrite-objc main.m</code>  得到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSObject *obj = ((NSObject *(*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;NSObject&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;new&quot;</span>));</span><br><span class="line">        &#123;</span><br><span class="line">            id _rethrow = <span class="number">0</span>; </span><br><span class="line">          	id _sync_obj = (id)obj; </span><br><span class="line">          	<span class="built_in">objc_sync_enter</span>(_sync_obj);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">_SYNC_EXIT</span> &#123;</span><br><span class="line">                    _SYNC_EXIT(id arg) : <span class="built_in">sync_exit</span>(arg) &#123;&#125;</span><br><span class="line">                    ~_SYNC_EXIT() &#123;<span class="built_in">objc_sync_exit</span>(sync_exit);&#125;</span><br><span class="line">                    id sync_exit;</span><br><span class="line">                &#125; _sync_exit(_sync_obj);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_5z_1pxqzfcn77s2n7z4gmr63sdr0000gn_T_main_4eec76_mi_0);</span><br><span class="line">            &#125; <span class="built_in">catch</span> (id e) &#123;</span><br><span class="line">              _rethrow = e;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">_FIN</span> &#123;</span><br><span class="line">                    _FIN(id reth) : <span class="built_in">rethrow</span>(reth) &#123;&#125;</span><br><span class="line">                    ~_FIN() &#123; <span class="keyword">if</span> (rethrow) <span class="built_in">objc_exception_throw</span>(rethrow); &#125;</span><br><span class="line">                    id rethrow;</span><br><span class="line">                &#125; _fin_force_rethow(_rethrow);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出 <code>@synchronized (obj)</code> 的工作流程：</p>
<p>1.新建一个作用域将同步代码块包裹在内。</p>
<p>2.将传入的同步对象赋值给一个临时变量<code>id _sync_obj = (id)obj;</code>，后续的操作使用的都是该临时变量。 因此以前的变量的值发生更改对本次加解锁不会产生影响，但是当下一次其他线程执行到@synchronized时由于同步对象已经发生改变因此获取到的将不是同一把锁于是其他线程此时也能够进入临界区，这样就有可能临界区同一时刻有多个线程在访问，从而造成多线程问题。因此使用synchronized时需要保证指向同步对象的变量的值不被更改，同步对象自身的生命周期最好也不能太短。</p>
<p>3.调用objc_sync_enter函数加锁，objc_sync_enter(_sync_obj);    </p>
<p>4.对同步代码块进行try-catch，try作用域结束时，调用objc_sync_exit(sync_exit)解锁;</p>
<p>5.同步代码块中如果出现异常，则在作用域结束时重新抛出。</p>
<p>不知道大家注意到没有<code>objc_sync_exit(sync_exit);</code>并不是在什么@finally里面调用的，而是<code>_sync_exit</code>实例销毁时在自身析构函数里调用的。难道它就不怕try里面发生崩溃吗？如果try里面发生崩溃那么_sync_exit实例将不会销毁，析构函数也不会执行自然objc_sync_exit也不会调用，那么加解锁次数就不一致了，其他线程将永远获取不到锁了。这种情况如果在OC文件代码里默认情况下确实会这样，但是在C++里编译器会产生一些代码确保即使try里发生崩溃，try里的临时对象也会被销毁。所以不会出现上述情况。</p>
<p>这样try里面即使发生崩溃，<code>_sync_exit</code>实例也会执行析构函数，从而调用<code>objc_sync_exit(sync_exit);</code>进行解锁。另外需要注意的一点，由于异常会被重新抛出，所以当代码块里面真的会崩溃时，还是需要我们自己try-catch的。</p>
<p>接下来就是objc_sync_enter和objc_sync_exit两个函数了。前面我们大概也知道了objc_sync_enter对应着加锁，objc_sync_exit对应着解锁，但是我们并不知道锁是怎么得来的和传入的同步对象又有什么关系？想知道这一切的话就得深入objc_sync_enter/exit的实现了。</p>
<h4 id="objc-sync-enter"><a href="#objc-sync-enter" class="headerlink" title="objc_sync_enter"></a>objc_sync_enter</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on &#x27;obj&#x27;. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with &#x27;obj&#x27; if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">objc_sync_enter</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        ASSERT(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_sync_enter的作用：</p>
<p>如果obj不等于nil，则根据传入的obj找到一个SyncData，SyncData中有一把递归锁，然后加锁。</p>
<p>如果obj等于nil，则执行<code>objc_sync_nil；</code>。其实就是什么也不做直接返回OBJC_SYNC_SUCCESS，此时代码块就没有进行加锁保护。</p>
<p>objc_sync_nil实现：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">BREAKPOINT_FUNCTION(</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">objc_sync_nil</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure>
<p>宏BREAKPOINT_FUNCTION的定义：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">#   define <span class="type">BREAKPOINT_FUNCTION</span>(proto<span class="keyword">type</span>)                             \</span><br><span class="line">    <span class="type">OBJC_EXTERN</span> __attribute__((noinline, used, visibility(<span class="string">&quot;hidden&quot;</span>))) \</span><br><span class="line">    proto<span class="keyword">type</span> &#123; asm(&quot;&quot;); &#125;</span><br></pre></td></tr></table></figure>
<p>展开后等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> __attribute__((noinline, used, visibility(<span class="string">&quot;hidden&quot;</span>))) </span><br><span class="line"><span class="type">void</span> <span class="title function_">objc_sync_nil</span><span class="params">(<span class="type">void</span>)</span> &#123; 		 		</span><br><span class="line">  <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>宏BREAKPOINT_FUNCTION的作用就是定义了一个函数，函数只有一行实现<code>asm(&quot;&quot;);</code>，从BREAKPOINT_FUNCTION语义上也可以明白定义的函数只是用来打断点的。没有什么实际用途。</p>
<p>具体是如何根据obj获取锁的，还得看id2data()函数的实现：</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="SyncData"><a href="#SyncData" class="headerlink" title="SyncData"></a>SyncData</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate a lock only when needed.  Since few locks are needed at any point</span></span><br><span class="line"><span class="comment">// in time, keep them on a single list.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">alignas</span><span class="params">(CacheLineSize)</span> SyncData &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class="line">    <span class="type">int32_t</span> threadCount;  <span class="comment">// number of THREADS using this block。只会是0和1。0代表空闲，SyncData可被复用</span></span><br><span class="line">    <span class="type">recursive_mutex_t</span> mutex;</span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure>
<p>nextData：指向下一个SyncData，因此SyncData是一个单链表。</p>
<p>object：传入的同步对象，DisguisedPtr<objc_object>类型，其实就是记录对象的地址</p>
<p>threadCount：使用该block的线程数，该计数器作用：</p>
<p>1用于安全判断</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span> (result-&gt;</span><span class="function"><span class="title">threadCount</span> &lt;= 0  ||  item-&gt;</span>lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;id2data cache is buggy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 如果等于0，说明mutex处于空闲状态，那么SyncData就可以复用了，复用时 object 属性可以赋值其他对象，也就避免了创建SyncData的开销。</p>
<p>mutex：分配的递归锁，用于加解锁。</p>
<p>为了能够更高效的根据同步对象获得一把锁，系统做了缓存。</p>
<h5 id="SyncCacheItem"><a href="#SyncCacheItem" class="headerlink" title="SyncCacheItem"></a>SyncCacheItem</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockCount;  <span class="comment">// number of times THIS THREAD locked this block</span></span><br><span class="line">&#125; SyncCacheItem;</span><br></pre></td></tr></table></figure>
<p>data：SyncData对象</p>
<p>lockCount：当前线程锁住该block（block应该指的是同步代码块）的次数。外部需要根据它来清除缓存，加锁时计数器加1，解锁时计数器减1。减到0时，FastCache就会将保存的SyncData对象清除。虽然递归锁内部也有个计数器但是由于外部不能访问到，所以SyncCacheItem这里不得不定义一个lockCount。</p>
<p>为何要维护lockCount和threadCount，用其中一个不行吗？个人认为因为操作threadCount需要加锁，而操作lockCount只会在单一线程所以维护两个变量可以提高性能。</p>
<h5 id="SyncCache"><a href="#SyncCache" class="headerlink" title="SyncCache"></a>SyncCache</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SyncCache</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> allocated;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> used;</span><br><span class="line">    SyncCacheItem <span class="built_in">list</span>[<span class="number">0</span>]; <span class="comment">//数组，默认个数是4个</span></span><br><span class="line">&#125; SyncCache;</span><br></pre></td></tr></table></figure>
<p>存储于TLS(线程本地存储)。</p>
<p>allocated：分配的SyncCacheItem内存空间个数，默认是4个。当used==allocated时，会扩容为原来的2倍。</p>
<p>used：已使用的SyncCacheItem内存空间个数</p>
<p>list：数组，保存已使用的SyncCacheItem</p>
<h5 id="SyncList"><a href="#SyncList" class="headerlink" title="SyncList"></a>SyncList</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncList</span> &#123;</span></span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="type">constexpr</span> <span class="title function_">SyncList</span><span class="params">()</span> : <span class="title function_">data</span><span class="params">(nil)</span>, <span class="title function_">lock</span><span class="params">(fork_unsafe_lock)</span> &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>包裹了一个链表和自旋锁，用于处理多线程操作链表。</p>
<h5 id="StripedMap-lt-SyncList-gt"><a href="#StripedMap-lt-SyncList-gt" class="headerlink" title="StripedMap&lt;SyncList&gt;"></a>StripedMap<code>&lt;SyncList&gt;</code></h5><p>另外还有一个类型为StripedMap的全局变量sDataLists，StripedMap里面有一个数组总长度为8（iPhone），数组的元素是SyncList。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="type">static</span> StripedMap&lt;SyncList&gt; sDataLists; <span class="comment">//是在哪里初始化的？</span></span><br></pre></td></tr></table></figure>
<p>LOCK_FOR_OBJ(object)和LIST_FOR_OBJ(object)就是从全局StripedMap变量sDataLists的数组属性中找到一个SyncList。</p>
<p>StripedMap的部分定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StripedMap&lt;T&gt; is a map of void* -&gt; T, sized appropriately </span></span><br><span class="line"><span class="comment">// for cache-friendly lock striping. </span></span><br><span class="line"><span class="comment">// For example, this may be used as StripedMap&lt;spinlock_t&gt;</span></span><br><span class="line"><span class="comment">// or as StripedMap&lt;SomeStruct&gt; where SomeStruct stores a spin lock.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StripedMap</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PaddedT</span> &#123;</span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) &#123; </span><br><span class="line">        <span class="keyword">return</span> array[<span class="built_in">indexForPointer</span>(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>StripedMap里定义了一个总长度为8的数组<code>PaddedT array[StripeCount];</code></p>
<p>如何根据object查找到一个SyncList呢？</p>
<p>其实就是把object对象的地址映射为一个数组索引，然后从索引处获取一个SyncList。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> addr = reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>地址右移四位的结果 按位异或 地址右移九位的结果 再模上数组总长度。这样处理后不同地址得到相同的结果可能性会小一些。</p>
<p>可以看到sDataLists就是一个哈希表。根据传入的object从哈希表里找到一个SyncList，然后从SyncList单链表中查找SyncData的同步对象与传入的object相等的SyncData。该哈希表采用的是拉链法处理哈希冲突的。</p>
<h4 id="id2data"><a href="#id2data" class="headerlink" title="id2data"></a>id2data</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> SyncData* <span class="title function_">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">spinlock_t</span> *lockp = &amp;LOCK_FOR_OBJ(object);</span><br><span class="line">    SyncData **listp = &amp;LIST_FOR_OBJ(object);</span><br><span class="line">    SyncData* result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="comment">// Check per-thread single-entry fast cache for matching object</span></span><br><span class="line">    <span class="type">bool</span> fastCacheOccupied = NO;</span><br><span class="line">    SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        fastCacheOccupied = YES;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;object == object) &#123;</span><br><span class="line">            <span class="comment">// Found a match in fast cache.</span></span><br><span class="line">            <span class="type">uintptr_t</span> lockCount;</span><br><span class="line"></span><br><span class="line">            result = data;</span><br><span class="line">            lockCount = (<span class="type">uintptr_t</span>)tls_get_direct(SYNC_COUNT_DIRECT_KEY);</span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;id2data fastcache is buggy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span>(why) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE: &#123;</span><br><span class="line">                lockCount++;</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                lockCount--;</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">if</span> (lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// remove from fast cache</span></span><br><span class="line">                    tls_set_direct(SYNC_DATA_DIRECT_KEY, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount); <span class="comment">//threadCount-1，很重要</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">    SyncCache *cache = fetch_cache(NO);</span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;used; i++) &#123;</span><br><span class="line">            SyncCacheItem *item = &amp;cache-&gt;<span class="built_in">list</span>[i];</span><br><span class="line">            <span class="keyword">if</span> (item-&gt;data-&gt;object != object) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a match.</span></span><br><span class="line">            result = item-&gt;data;</span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  item-&gt;lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;id2data cache is buggy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">switch</span>(why) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE:</span><br><span class="line">                item-&gt;lockCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                item-&gt;lockCount--;</span><br><span class="line">                <span class="keyword">if</span> (item-&gt;lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                    cache-&gt;<span class="built_in">list</span>[i] = cache-&gt;<span class="built_in">list</span>[--cache-&gt;used];</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);<span class="comment">//threadCount-1，很重要</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread cache didn&#x27;t find anything.</span></span><br><span class="line">    <span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line">    <span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line">    <span class="comment">// locks for the same new object.</span></span><br><span class="line">    <span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line">    <span class="comment">// more than 20 or so distinct locks active, but we don&#x27;t do that now.</span></span><br><span class="line">    </span><br><span class="line">    lockp-&gt;lock();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;object == object ) &#123;</span><br><span class="line">                result = p;</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">                OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">                firstUnused = p;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">        <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// an unused one was found, use it</span></span><br><span class="line">        <span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            result-&gt;object = (objc_object *)object;</span><br><span class="line">            result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a new SyncData and add to list.</span></span><br><span class="line">    <span class="comment">// XXX allocating memory with a global lock held is bad practice,</span></span><br><span class="line">    <span class="comment">// might be worth releasing the lock, allocating, and searching again.</span></span><br><span class="line">    <span class="comment">// But since we never free these guys we won&#x27;t be stuck in allocation very often.</span></span><br><span class="line">    posix_memalign((<span class="type">void</span> **)&amp;result, <span class="keyword">alignof</span>(SyncData), <span class="keyword">sizeof</span>(SyncData));</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    new (&amp;result-&gt;mutex) <span class="type">recursive_mutex_t</span>(fork_unsafe_lock);</span><br><span class="line">    result-&gt;nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line">    lockp-&gt;unlock();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">        <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">        <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">        <span class="keyword">if</span> (why == RELEASE) &#123;</span><br><span class="line">            <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">            <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">&quot;id2data is buggy&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;object != object) _objc_fatal(<span class="string">&quot;id2data is buggy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">        <span class="keyword">if</span> (!fastCacheOccupied) &#123;</span><br><span class="line">            <span class="comment">// Save in fast thread cache</span></span><br><span class="line">            tls_set_direct(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">            tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = fetch_cache(YES);</span><br><span class="line">            cache-&gt;<span class="built_in">list</span>[cache-&gt;used].data = result;</span><br><span class="line">            cache-&gt;<span class="built_in">list</span>[cache-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line">            cache-&gt;used++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> SyncCache *<span class="title function_">fetch_cache</span><span class="params">(<span class="type">bool</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">    _objc_pthread_data *data;</span><br><span class="line">    </span><br><span class="line">    data = _objc_fetch_pthread_data(create);</span><br><span class="line">    <span class="keyword">if</span> (!data) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data-&gt;syncCache) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!create) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">4</span>;</span><br><span class="line">            data-&gt;syncCache = (SyncCache *)</span><br><span class="line">                <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(SyncCache) + count*<span class="keyword">sizeof</span>(SyncCacheItem));</span><br><span class="line">            data-&gt;syncCache-&gt;allocated = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure there&#x27;s at least one open slot in the list.</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;syncCache-&gt;allocated == data-&gt;syncCache-&gt;used) &#123;</span><br><span class="line">        data-&gt;syncCache-&gt;allocated *= <span class="number">2</span>;</span><br><span class="line">        data-&gt;syncCache = (SyncCache *)</span><br><span class="line">            <span class="built_in">realloc</span>(data-&gt;syncCache, <span class="keyword">sizeof</span>(SyncCache) </span><br><span class="line">                    + data-&gt;syncCache-&gt;allocated * <span class="keyword">sizeof</span>(SyncCacheItem));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data-&gt;syncCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_fetch_pthread_data</span></span><br><span class="line"><span class="comment">* Fetch objc&#x27;s pthread data for this thread.</span></span><br><span class="line"><span class="comment">* If the data doesn&#x27;t exist yet and create is NO, return NULL.</span></span><br><span class="line"><span class="comment">* If the data doesn&#x27;t exist yet and create is YES, allocate and return it.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">_objc_pthread_data *_objc_fetch_pthread_data(<span class="type">bool</span> create)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_pthread_data *data;</span><br><span class="line"></span><br><span class="line">    data = (_objc_pthread_data *)tls_get(_objc_pthread_key);</span><br><span class="line">    <span class="keyword">if</span> (!data  &amp;&amp;  create) &#123;</span><br><span class="line">        data = (_objc_pthread_data *)</span><br><span class="line">            <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(_objc_pthread_data));</span><br><span class="line">        tls_set(_objc_pthread_key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc&#x27;s key for pthread_getspecific</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _objc_pthread_key TLS_DIRECT_KEY</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">tls_key_t</span> _objc_pthread_key;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>该函数的实现比较复杂，大体上分为四个部分：</p>
<p>1 如果支持SUPPORT_DIRECT_THREAD_KEYS，则先从TLS（Thread Local Storage，线程本地存储）中的FastCache缓存中获取锁。</p>
<p>2 从TLS中的SyncCache缓存中获取锁。</p>
<p>3 从全局变量sDataLists哈希表中获取锁，并优先加入到FastCache缓存(SUPPORT_DIRECT_THREAD_KEYS并且FastCache空闲)，如果FastCache已经占用则加入到SyncCache缓存。</p>
<p>4 新创建一把锁，并添加到sDataLists中的对应单链表中以及加入到FastCache缓存或SyncCache缓存。</p>
<h5 id="从TLS中的FastCache缓存里获取锁"><a href="#从TLS中的FastCache缓存里获取锁" class="headerlink" title="从TLS中的FastCache缓存里获取锁"></a>从TLS中的FastCache缓存里获取锁</h5><p>如果定义了SUPPORT_DIRECT_THREAD_KEYS则先从Fast cache里获取，Fast cache解释如下：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Fast cache: two fixed pthread keys store a single SyncCacheItem. </span></span><br><span class="line"><span class="comment">  This avoids malloc of the SyncCache for threads that only synchronize </span></span><br><span class="line"><span class="comment">  a single object at a time.</span></span><br><span class="line"><span class="comment">  SYNC_DATA_DIRECT_KEY  == SyncCacheItem.data</span></span><br><span class="line"><span class="comment">  SYNC_COUNT_DIRECT_KEY == SyncCacheItem.lockCount</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>FastCache也是系统为了提高获取锁的效率做的一个优化。如果一个线程只同步一个对象就没必要为它再分配SyncCache内存，系统为这种情况在TLS中保留了一个存储SyncCacheItem的空间，通过SYNC_DATA_DIRECT_KEY和SYNC_COUNT_DIRECT_KEY来获取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="comment">// Check per-thread single-entry fast cache for matching object</span></span><br><span class="line">    <span class="type">bool</span> fastCacheOccupied = NO;</span><br><span class="line">    SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        fastCacheOccupied = YES;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;object == object) &#123;</span><br><span class="line">            <span class="comment">// Found a match in fast cache.</span></span><br><span class="line">            <span class="type">uintptr_t</span> lockCount;</span><br><span class="line"></span><br><span class="line">            result = data;</span><br><span class="line">            lockCount = (<span class="type">uintptr_t</span>)tls_get_direct(SYNC_COUNT_DIRECT_KEY);</span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  lockCount &lt;= <span class="number">0</span>) &#123; <span class="comment">//从缓存中拿出来的SyncData，它的threadCount，lockCount不可能为0，因为新建锁时会设置为1，然后才丢到缓存中去的。下面的SyncCache同样的道理。</span></span><br><span class="line">                _objc_fatal(<span class="string">&quot;id2data fastcache is buggy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span>(why) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE: &#123;</span><br><span class="line">                lockCount++;</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                lockCount--;</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">if</span> (lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// remove from fast cache</span></span><br><span class="line">                    tls_set_direct(SYNC_DATA_DIRECT_KEY, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果在TLS的FastCache中找到一个SyncData，即<code>if (data-&gt;object == object)</code>为真。</p>
<p>则根据是加锁还是解锁操作lockCount计数器。当lockCount等于0时也就是当前线程即将释放该锁，将SyncData从FastCache中移除，FastCache重新变为空的，同时将SyncData的threadCount减1。</p>
<p>执行完switch后返回找到的SyncData。</p>
<p>如果<code>if (data-&gt;object == object)</code>为假，表明FastCache中虽然存在SyncData对象但是同步对象不一样，此时会执行后续代码。</p>
<p>这种情况就是synchronized嵌套但传入的同步对象不一样：</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line">@<span class="title function_">synchronized</span>(<span class="params">A</span>) &#123;</span><br><span class="line">		<span class="operator">...</span><span class="operator">...</span></span><br><span class="line">		@<span class="title function_">synchronized</span>(<span class="params">B</span>) &#123;</span><br><span class="line">				<span class="operator">...</span>.</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="从TLS中的SyncCache缓存中获取锁"><a href="#从TLS中的SyncCache缓存中获取锁" class="headerlink" title="从TLS中的SyncCache缓存中获取锁"></a>从TLS中的SyncCache缓存中获取锁</h5><p>如果在FastCache中没有找到与同步对象关联的锁，则继续在SyncCache缓存中查找。</p>
<p>SyncCache也是存储于TLS中的，也就是每个线程都有自己的SyncCache。如果线程之前为同步对象分配过锁那么下一次再获取时直接从缓存中获取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">SyncCache *cache = fetch_cache(NO);</span><br><span class="line"><span class="keyword">if</span> (cache) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;used; i++) &#123;</span><br><span class="line">        SyncCacheItem *item = &amp;cache-&gt;<span class="built_in">list</span>[i];</span><br><span class="line">        <span class="keyword">if</span> (item-&gt;data-&gt;object != object) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Found a match.</span></span><br><span class="line">        result = item-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  item-&gt;lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;id2data cache is buggy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(why) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACQUIRE:</span><br><span class="line">            item-&gt;lockCount++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RELEASE:</span><br><span class="line">            item-&gt;lockCount--;</span><br><span class="line">            <span class="keyword">if</span> (item-&gt;lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                cache-&gt;<span class="built_in">list</span>[i] = cache-&gt;<span class="built_in">list</span>[--cache-&gt;used];</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CHECK:</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑和FastCache差不多。当lockCount等于0时，将SyncCacheItem从SyncCache中移除，同时将SyncData的threadCount减1：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remove from per-thread cache</span></span><br><span class="line"><span class="function"><span class="title">cache</span>-&gt;</span><span class="function"><span class="title">list</span>[i] = cache-&gt;</span><span class="function"><span class="title">list</span>[--cache-&gt;</span>used];</span><br><span class="line"><span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">OSA<span class="function"><span class="title">tomicDecrement32Barrier</span>(&amp;result-&gt;</span>threadCount);</span><br></pre></td></tr></table></figure>
<p>它这里移除有点意思，因为list是个c数组，如果真的删除某个元素的话，那后面的元素还得往前挪动，然而该场景下并不需要这么严格的删除，所以这里就用最后一个SyncCacheItem替换掉当前SyncCacheItem就可以了。</p>
<h5 id="从全局变量sDataLists哈希表中获取"><a href="#从全局变量sDataLists哈希表中获取" class="headerlink" title="从全局变量sDataLists哈希表中获取"></a>从全局变量sDataLists哈希表中获取</h5><p>如果没能在上述缓存中找到，则继续在sDataLists列表中查找。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread cache didn&#x27;t find anything.</span></span><br><span class="line"><span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line"><span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line"><span class="comment">// locks for the same new object.</span></span><br><span class="line"><span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line"><span class="comment">// more than 20 or so distinct locks active, but we don&#x27;t do that now.</span></span><br><span class="line"></span><br><span class="line">lockp-&gt;lock();</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    SyncData* p;</span><br><span class="line">    SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;object == object ) &#123;</span><br><span class="line">            result = p;</span><br><span class="line">            <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">            OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">            firstUnused = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">    <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an unused one was found, use it</span></span><br><span class="line">    <span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        result = firstUnused;</span><br><span class="line">        result-&gt;object = (objc_object *)object;</span><br><span class="line">        result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>刚开始的几个变量定义：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">spinlock_t</span> *<span class="variable">lockp</span> = &amp;<span class="function"><span class="title">LOCK_FOR_OBJ</span>(<span class="variable"><span class="class">object</span></span>);</span></span><br><span class="line"><span class="function"><span class="variable">SyncData</span> **<span class="variable">listp</span> = &amp;<span class="title">LIST_FOR_OBJ</span>(<span class="variable"><span class="class">object</span></span>);</span></span><br><span class="line"><span class="function"><span class="variable">SyncData</span>* <span class="variable"><span class="class">result</span></span> = <span class="variable"><span class="literal">NULL</span></span>;</span></span><br></pre></td></tr></table></figure>
<p>从全局的sDataLists中根据传入的object找到一个SyncList没有就创建。</p>
<p>不同于在TLS中的查找，这里查找和操作的是一个全局变量，所以代码首先使用SyncList里的自旋锁进行加锁，保证后续的查找与操作同时只有一个线程。</p>
<p>然后在SyncData这个单链表上开始查找：</p>
<p>如果找到一个与object相等的SyncData，则threadCount加1并执行后续done操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SyncData* p;</span><br><span class="line">SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( p-&gt;object == object ) &#123;</span><br><span class="line">        result = p;</span><br><span class="line">        <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">        <span class="built_in">OSAtomicIncrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">        firstUnused = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没找到与object相等的SyncData，但找到一个未使用的SyncData那就使用它，复用了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// an unused one was found, use it</span></span><br><span class="line"><span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    result = firstUnused;</span><br><span class="line">    result-&gt;<span class="keyword">object</span> = (objc_object *)<span class="keyword">object</span>;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SyncData中的object更新为传入object，threadCount更新为1。执行后续done操作。</p>
<p>从全局变量sDataLists列表中的查找就结束了，如果依然没有找到可用的SyncData则只能创建新的SyncData了。</p>
<p>SyncData使用后它的object值是没有擦除的，能不能复用看的是threadCount是否等于0，等于0说明可以复用，object就会被赋值一个新的对象地址。</p>
<h5 id="新创建锁"><a href="#新创建锁" class="headerlink" title="新创建锁"></a>新创建锁</h5><p>最后是新创建一把锁，并添加到sDataLists中的某个单链表中以及加入到FastCache缓存或SyncCache缓存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread cache didn&#x27;t find anything.</span></span><br><span class="line"><span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line"><span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line"><span class="comment">// locks for the same new object.</span></span><br><span class="line"><span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line"><span class="comment">// more than 20 or so distinct locks active, but we don&#x27;t do that now.</span></span><br><span class="line"></span><br><span class="line">lockp-&gt;lock();</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    SyncData* p;</span><br><span class="line">    SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;object == object ) &#123;</span><br><span class="line">            result = p;</span><br><span class="line">            <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">            OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">            firstUnused = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">    <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an unused one was found, use it</span></span><br><span class="line">    <span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        result = firstUnused;</span><br><span class="line">        result-&gt;object = (objc_object *)object;</span><br><span class="line">        result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a new SyncData and add to list.</span></span><br><span class="line"><span class="comment">// XXX allocating memory with a global lock held is bad practice,</span></span><br><span class="line"><span class="comment">// might be worth releasing the lock, allocating, and searching again.</span></span><br><span class="line"><span class="comment">// But since we never free these guys we won&#x27;t be stuck in allocation very often.</span></span><br><span class="line">posix_memalign((<span class="type">void</span> **)&amp;result, <span class="keyword">alignof</span>(SyncData), <span class="keyword">sizeof</span>(SyncData));</span><br><span class="line">result-&gt;object = (objc_object *)object;</span><br><span class="line">result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">new (&amp;result-&gt;mutex) <span class="type">recursive_mutex_t</span>(fork_unsafe_lock);</span><br><span class="line">result-&gt;nextData = *listp;</span><br><span class="line">*listp = result;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">lockp-&gt;unlock();</span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">    <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">    <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">    <span class="keyword">if</span> (why == RELEASE) &#123;</span><br><span class="line">        <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">        <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">&quot;id2data is buggy&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (result-&gt;object != object) _objc_fatal(<span class="string">&quot;id2data is buggy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="keyword">if</span> (!fastCacheOccupied) &#123;</span><br><span class="line">        <span class="comment">// Save in fast thread cache</span></span><br><span class="line">        tls_set_direct(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">        tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Save in thread cache</span></span><br><span class="line">        <span class="keyword">if</span> (!cache) cache = fetch_cache(YES);</span><br><span class="line">        cache-&gt;<span class="built_in">list</span>[cache-&gt;used].data = result;</span><br><span class="line">        cache-&gt;<span class="built_in">list</span>[cache-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line">        cache-&gt;used++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>同样创建新的SyncData时也是在自旋锁保护区里的，主要的创建代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a new SyncData and add to list.</span></span><br><span class="line"><span class="comment">// XXX allocating memory with a global lock held is bad practice,</span></span><br><span class="line"><span class="comment">// might be worth releasing the lock, allocating, and searching again.</span></span><br><span class="line"><span class="comment">// But since we never free these guys we won&#x27;t be stuck in allocation very often.</span></span><br><span class="line">posix_memalign((<span class="type">void</span> **)&amp;result, <span class="keyword">alignof</span>(SyncData), <span class="keyword">sizeof</span>(SyncData));</span><br><span class="line">result-&gt;object = (objc_object *)object; <span class="comment">//记录传入的对象地址</span></span><br><span class="line">result-&gt;threadCount = <span class="number">1</span>; </span><br><span class="line">new (&amp;result-&gt;mutex) <span class="type">recursive_mutex_t</span>(fork_unsafe_lock); <span class="comment">//创建一把新锁</span></span><br><span class="line">result-&gt;nextData = *listp; <span class="comment">//添加到链表里，注意这里是添加到链表头部</span></span><br><span class="line">*listp = result;</span><br></pre></td></tr></table></figure>
<p>新创建的SyncData会作为头结点添加到当前SyncList中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result-&gt;nextData = *listp;</span><br><span class="line">*listp = result;</span><br></pre></td></tr></table></figure>
<p>最后是done操作了：</p>
<p>前面在TLS的缓存中如果查找到可用的SyncData是不会走到done操作的，只有在哈希表里找到的或者新创建的SyncData才会走到done。</p>
<p>done的作用就是把从哈希表里或者新创建的SyncData加入到TLS中的FastCache或SyncCache。</p>
<p>到此为止id2data函数的工作流程就结束了。</p>
<p>总结一下：</p>
<p>id2data函数根据传入的同步对象获取锁的过程大体上分为四个部分：</p>
<p>1 从TLS（Thread Local Storage，线程本地存储）中的FastCache缓存中获取锁</p>
<p>2 从TLS中的SyncCache（普通数组）缓存中获取锁</p>
<p>3 从全局变量sDataLists哈希表中获取锁，并加入到FastCache缓存或SyncCache缓存</p>
<p>4 新创建一把锁，并添加到sDataLists哈希表中的对应单链表中以及加入到FastCache缓存或SyncCache缓存</p>
<p>id2data函数中为了能够更高效的根据同步对象获得一把锁，系统做了缓存。1和2是TLS中的缓存，3是哈希表中的缓存。</p>
<p>1和2对synchronized嵌套使用情况优化提升较大，但如果临界区不需要递归锁的特性，那么1和2的缓存对性能提升不是那么大。</p>
<p>即使系统做了如此多的优化，但是synchronized锁在效率上依然是所有锁中最低的，毕竟里面缓存操作也是要消耗时间的。</p>
<h4 id="objc-sync-exit"><a href="#objc-sync-exit" class="headerlink" title="objc_sync_exit"></a>objc_sync_exit</h4><p>最后是objc_sync_exit()的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// End synchronizing on &#x27;obj&#x27;. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">objc_sync_exit</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上述的id2data函数的分析，这里就很简单了。</p>
<p>就是根据传入的obj获取到SyncData后，进行解锁，传入nil则什么也不做。使用<code>@synchronized (obj)&#123;...&#125;</code>时，objc_sync_enter和objc_sync_exit的参数obj必然是同一个obj，因此获取到的自然也是同一把锁。</p>
<p>写到这里突然有一个疑问，SyncData会被添加到哈希表里，貌似是没看到销毁的（因为里面有复用逻辑），那么SyncData会不会一直持有同步对象，导致同步对象无法销毁呢？实际上是不会持有同步对象的，同步对象能正常销毁，但又是如何做到的呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">alignas</span><span class="params">(CacheLineSize)</span> SyncData &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class="line">    <span class="type">int32_t</span> threadCount;  <span class="comment">// number of THREADS using this block</span></span><br><span class="line">    <span class="type">recursive_mutex_t</span> mutex;</span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure>
<p>可以看到SyncData的object的类型是DisguisedPtr<objc_object>类型。</p>
<p>DisguisedPtr：对指针进行伪装的类，将指针强转为 uintptr_t （unsigned long）类型的负值，这样类似 leaks 这样的查内存泄漏的工具便无法跟踪到对象。</p>
<p>查看DisguisedPtr模板类的实现，其内部并没有一个T类型的指针指向传入的object，在给DisguisedPtr变量赋值时，其实是将传入的对象的地址转化为一个无符号整数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DisguisedPtr&lt;T&gt;&amp; operator = (T* rhs) &#123;</span><br><span class="line">    value = disguise(rhs);</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title function_">disguise</span><span class="params">(T* ptr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -(<span class="type">uintptr_t</span>)ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> T* <span class="title function_">undisguise</span><span class="params">(<span class="type">uintptr_t</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T*)-val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SyncDisguise &#123;</span><br><span class="line">    DisguisedPtr&lt;Person&gt; object;</span><br><span class="line">    int32_t threadCount;</span><br><span class="line">&#125; SyncDisguise;</span><br><span class="line">    </span><br><span class="line">SyncDisguise myStruct;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XQContainer</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testDisguise &#123;</span><br><span class="line">    Person *li = [Person new];</span><br><span class="line">    li.name = <span class="string">@&quot;li&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    myStruct.threadCount = <span class="number">1</span>;</span><br><span class="line">    myStruct.object = li;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;disguise1: %p&quot;</span>, &amp;myStruct);</span><br><span class="line">    </span><br><span class="line">    Person *pox = (Person *)myStruct.object; <span class="comment">//需要在MRC下，ARC下编译通不过</span></span><br><span class="line">    </span><br><span class="line">    [li release];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>DisguisedPtr重载了赋值操作符，因此myStruct.object = li;会调用<code>DisguisedPtr&lt;T&gt;&amp; operator = (T* rhs)</code>，而该函数内部是将传入的对象地址转化为了一个无符号整数，这样就把一个对象的地址给隐藏起来了。与之相反的操作是解伪装：将一个无符号整数转化为一个对象地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> T* <span class="title function_">undisguise</span><span class="params">(<span class="type">uintptr_t</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T*)-val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Person *pox = (Person *)myStruct.object;</code>会调用<code>undisguise</code>函数进行解伪装，于是又可以重新获取到对象的地址。</p>
<p><code>DisguisedPtr&lt;Person&gt; object;</code>类似于<code>Person *</code>但并不是真正的<code>Person *</code>，因此myStruct并不会持有传入的对象，在ARC下testDisguise方法执行完后Person对象就释放销毁了。</p>
<p>总结：SyncData对象虽然会被缓存而一直存活，但SyncData对象并没有持有传入的object对象，因此object对象会正常的释放。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>@synchronized (obj)&#123;...&#125;</code>就是根据传入的obj获取到一把递归锁，在代码块开始处先加锁，代码块执行完后再解锁。传nil，则不加锁。</p>
<p>到此为止我们可以回答一下开头的几个问题</p>
<p>1.锁是如何与你传入 <code>@synchronized</code> 的对象关联上的？</p>
<p>这个就是id2data函数的工作流程了：</p>
<ul>
<li><p>从TLS（Thread Local Storage，线程本地存储）中的FastCache缓存中获取锁</p>
</li>
<li><p>从TLS中的SyncCache缓存中获取锁</p>
</li>
<li><p>从全局变量sDataLists哈希表中获取锁（复用的对象），并加入到FastCache缓存或SyncCache缓存</p>
</li>
<li><p>都没有则新创建一把锁，并添加到sDataLists哈希表中的对应单链表中以及加入到FastCache缓存或SyncCache缓存</p>
</li>
</ul>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2023-03-27%2021.58.52.png" style="zoom: 50%;" /></p>
<p>2.<code>@synchronized</code>会保持（retain，增加引用计数）被锁住的对象么？</p>
<p>MRC下不会，ARC下会。</p>
<p>因为@synchronized{…}等价于</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> _rethrow = <span class="number">0</span>; </span><br><span class="line">    <span class="type">id</span> _sync_obj = (<span class="type">id</span>)obj; </span><br><span class="line">    objc_sync_enter(_sync_obj);</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">struct</span> _SYNC_EXIT &#123;</span><br><span class="line">            _SYNC_EXIT(<span class="type">id</span> arg) : sync_exit(arg) &#123;&#125;</span><br><span class="line">            ~_SYNC_EXIT() &#123;objc_sync_exit(sync_exit);&#125;</span><br><span class="line">            <span class="type">id</span> sync_exit;</span><br><span class="line">        &#125; _sync_exit(_sync_obj);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_5z_1pxqzfcn77s2n7z4gmr63sdr0000gn_T_main_4eec76_mi_0);</span><br><span class="line">    &#125; catch (<span class="type">id</span> e) &#123;</span><br><span class="line">      _rethrow = e;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> _FIN &#123;</span><br><span class="line">            _FIN(<span class="type">id</span> reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">            ~_FIN() &#123; <span class="keyword">if</span> (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">            <span class="type">id</span> rethrow;</span><br><span class="line">        &#125; _fin_force_rethow(_rethrow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而id _sync_obj = (id)obj;在MRC下这仅仅是一个赋值语句因此obj的引用计数不变，但在ARC下编译后会插入一条retain语句。当@synchronized代码块执行完后，临时变量销毁时又会释放对象。因此ARC下在@synchronized代码块内同步对象是被强引用的，代码块没执行完同步对象是不会被销毁的。</p>
<p>可以打印下引用计数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_synchronized_retain_obj1 &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    printf(<span class="string">&quot;1retain count = %ld\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(obj))); <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">@synchronized</span> (obj) &#123;</span><br><span class="line">        printf(<span class="string">&quot;2retain count = %ld\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(obj))); <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;3retain count = %ld\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(obj))); <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.假如你传入 <code>@synchronized</code> 的对象在 <code>@synchronized</code> 的代码块里面被赋值为 <code>nil</code> 将会怎么样？</p>
<p>对本次加解锁不会造成影响，但是当被置为nil后，如果此时恰好有一个线程执行到@synchronized，那么@synchronized(obj) 相当于@synchronized(nil)即无锁状态，于是会导致多个线程同时访问临界区代码，造成线程安全问题。</p>
<p>4.给@synchronized()传入nil会怎样？</p>
<p>@synchronized(nil)等于没加锁，代码块内的代码可以被多个线程同时访问，会造成线程安全问题。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://jianli2017.top/wiki/IOS/Runtime/objc/18_syncsize/">@synchronized 内幕揭秘</a>   synchronized锁的源码分析</p>
<p><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/">关于 @synchronized，这儿比你想知道的还要多 </a>   很不错，国外的程序员写的，尤其是提出的几个问题</p>
<p>关于try-catch内存管理的</p>
<p><a href="https://blog.csdn.net/lvmaker/article/details/88723115">iOS try-catch memory leak详解</a></p>
<p><a href="https://yingkong1987.github.io/blog/2014/01/11/bewareofmemorymanagementwithexception-safe.html">异常安全代码的内存管理需谨慎!</a></p>
<p>关于TLS的</p>
<p><a href="https://yq.aliyun.com/articles/691215">线程局部存储</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>NSURLSession简单介绍</title>
    <url>/2021/08/29/NSURLSession%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="NSURLSession介绍"><a href="#NSURLSession介绍" class="headerlink" title="NSURLSession介绍"></a>NSURLSession介绍</h2><p>NSURLSession是苹果对网络会话的封装，可以完全替代原来的NSURLConnection。相比于NSURLConnection，NSURLSession具备以下优势:</p>
<p>与NSURLConnection相比不再需要处理RunLoop相关的东西<br>支持HTTP/2 和 HTTP/3协议<br>支持在APP未运行或挂起时进行后台下载/上传<br>提供了全局的session，使用方便<br>提供了丰富的代理方法<br>支持监测整个HTTP事务各个阶段的网络指标</p>
<h3 id="支持的协议"><a href="#支持的协议" class="headerlink" title="支持的协议"></a>支持的协议</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">The URLSession class natively supports <span class="keyword">the</span> data, <span class="built_in">file</span>, <span class="keyword">ftp</span>, <span class="keyword">http</span>, <span class="keyword">and</span> <span class="keyword">https</span> <span class="built_in">URL</span> schemes, <span class="keyword">with</span> transparent support <span class="keyword">for</span> proxy servers <span class="keyword">and</span> SOCKS gateways, <span class="keyword">as</span> configured <span class="keyword">in</span> <span class="keyword">the</span> user’s <span class="keyword">system</span> preferences.</span><br><span class="line"></span><br><span class="line">URLSession supports <span class="keyword">the</span> HTTP/<span class="number">1.1</span>, HTTP/<span class="number">2</span>, <span class="keyword">and</span> HTTP/<span class="number">3</span> protocols. HTTP/<span class="number">2</span> support, <span class="keyword">as</span> described <span class="keyword">by</span> RFC <span class="number">7540</span>, requires <span class="keyword">a</span> server that supports Application-Layer Protocol Negotiation (ALPN).</span><br><span class="line"></span><br><span class="line">You can also <span class="built_in">add</span> support <span class="keyword">for</span> your own custom networking protocols <span class="keyword">and</span> <span class="built_in">URL</span> schemes (<span class="keyword">for</span> your app’s <span class="keyword">private</span> use) <span class="keyword">by</span> subclassing URLProtocol.</span><br></pre></td></tr></table></figure>
<p>URLSession原生支持data, file, ftp, http, 和 https协议，当然你也可以子类化URLProtocol来支持自己的私有网络协议。URLSession支持的HTTP版本为HTTP/1.1, HTTP/2, 和 HTTP/3，当然要想使用到HTTP/2, HTTP/3服务器端也必须得支持才行。</p>
<h2 id="URLSessionConfiguration"><a href="#URLSessionConfiguration" class="headerlink" title="URLSessionConfiguration"></a>URLSessionConfiguration</h2><h3 id="httpMaximumConnectionsPerHost"><a href="#httpMaximumConnectionsPerHost" class="headerlink" title="httpMaximumConnectionsPerHost"></a>httpMaximumConnectionsPerHost</h3><p>同一时间，同一个host的最大http连接数量，默认6个。该限制是针对单个session的，如果你有多个session，那么你的App可能就会超过这个限制。受当前连接资源影响，单个session的实际httpMaximumConnectionsPerHost可能会小于你设置的值。</p>
<h2 id="NSURLSession的基础用法"><a href="#NSURLSession的基础用法" class="headerlink" title="NSURLSession的基础用法"></a>NSURLSession的基础用法</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">  - (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSURLSessionConfiguration</span> *config = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">  <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">  queue.maxConcurrentOperationCount = <span class="number">3</span>; <span class="comment">//设置代理回调队列的最大并发数。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:config delegate:<span class="keyword">self</span> delegateQueue:queue];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, <span class="keyword">self</span>.session);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:landscapeUrl];</span><br><span class="line">  <span class="built_in">NSMutableURLRequest</span> *req = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url cachePolicy:<span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span> timeoutInterval:<span class="number">60</span> * <span class="number">5</span>];</span><br><span class="line">  <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:req];</span><br><span class="line">  [dataTask resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;收到响应:%@     \ndataTask:%@&quot;</span>, response, dataTask);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.mData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line">  completionHandler(disposition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">  didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%@收到data:%ld&quot;</span>,[<span class="built_in">NSThread</span> currentThread] ,data.length);</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span>.mData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;完成, error:%@&quot;</span>, error);</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">      <span class="comment">//在完成的时候,之前收到的data怎么取到?不借助其他的变量,在该方法里取不到?</span></span><br><span class="line">      <span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:<span class="keyword">self</span>.mData options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, dict);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不把本次session Invalidate,那么session持有的delegate不会被释放.</span></span><br><span class="line">  [session finishTasksAndInvalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于方法 </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLSession</span> *)sessionWithConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration </span><br><span class="line">								  delegate:(<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">NSURLSessionDelegate</span>&gt;)delegate </span><br><span class="line">							 delegateQueue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure>
<p>delegate和delegateQueue会被session强引用。只有当session被 invalidate后,delegate在<code>URLSession:didBecomeInvalidWithError</code>结束后才会被释放.对于delegateQueue,实际使用时delegateQueue最好不要设置为主队列（会增加主线程负担）.当delegateQueue不是主队列时,didReceiveData:方法将随机在某个线程执行.</p>
<p>基本上一个APP,生成一个urlSession就够了.没必要一次请求,创建一个session,请求结束后又将session Invalidate.因此也就没必要去管delegate和delegateQueue的内存释放问题,这三个对象基本上是等到APP结束才会销毁的.一般的做法是常规的API请求使用一个session，上传下载的请求使用另一个session。</p>
<p>对于代理方法: </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br></pre></td></tr></table></figure>
<p><strong>在该方法中,为什么收到响应后,还要调用completionHandler?</strong><br>因为在该方法中,通过disposition参数,调用completionHandler后,可以更细粒度的控制本次请求是继续还是取消还是转为下载任务.如果是取消,则后面请求的响应体不会接收.如果是转为下载任务,那么通过调用completionHandler,NSURLSession将调用Delegate的 <code>URLSession:dataTask:didBecomeDownloadTask:</code>方法并将新生成的Download task对象作为参数传入。在此调用之后，Delegate将不再接收来自Data task的回调消息，并开始接收Download task的回调消息。<br>注意:如果不调用</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">NSURLSessionResponseDisposition disposition <span class="operator">=</span> NSURLSessionResponseAllow<span class="comment">;</span></span><br><span class="line">completionHandler(disposition)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>后面的didReceiveData:代理方法将不会执行.</p>
<h2 id="delegateQueue"><a href="#delegateQueue" class="headerlink" title="delegateQueue"></a>delegateQueue</h2><p>回调的派发队列，方法参数说明：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">An operation queue <span class="keyword">for</span> scheduling the <span class="keyword">delegate</span> calls <span class="keyword">and</span> completion handlers. The queue should be a serial queue, <span class="keyword">in</span> <span class="keyword">order</span> <span class="keyword">to</span> <span class="keyword">ensure</span> the correct ordering <span class="keyword">of</span> callbacks. <span class="keyword">If</span> <span class="keyword">nil</span>, the session creates a serial operation queue <span class="keyword">for</span> performing all <span class="keyword">delegate</span> <span class="keyword">method</span> <span class="title function_">calls</span> <span class="title function_">and</span> <span class="title function_">completion</span> <span class="title function_">handler</span> <span class="title function_">calls</span>.</span><br></pre></td></tr></table></figure>
<p>用于执行delegate回调和完成处理的派发队列，delegateQueue最好是一个串行队列，这样可以确保正确的回调顺序。默认是一个串行队列。注意这个只是回调方法的派发队列，和网络请求的线程不是同一个。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">网络请求线程        回调队列</span><br><span class="line">    |<span class="string">               </span>|</span><br><span class="line">    |<span class="string">  callback1    </span>|</span><br><span class="line">    |<span class="string">-----------&gt;   </span>|</span><br><span class="line">    |<span class="string">               </span>|</span><br><span class="line">    |<span class="string">  callback2    </span>|</span><br><span class="line">    |<span class="string">-----------&gt;   </span>|</span><br><span class="line">    |<span class="string">               </span>|</span><br></pre></td></tr></table></figure>
<p>这里文档是should，如果用个并发队列会怎样？我们项目里用的就是并发队列，用了这么久好像也没什么影响。</p>
<p>场景：点击按钮，发起1个请求，故意阻塞didReceiveData回调。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.mData appendData:data];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time = MAX(<span class="number">1</span>, arc4random() % <span class="number">4</span>);</span><br><span class="line">    sleep(time*<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;本次接收:%ld,总共接收:%ld,线程：%@&quot;</span>, data.length, <span class="keyword">self</span>.mData.length, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使delegateQueue的最大并发数设置为3，但是didReceiveData的回调行为还是类似串行（虽然每次线程确实会不一样），不会出现两个线程同时回调didReceiveData。</p>
<p>通过实验可以得出：</p>
<p>1.delegateQueue的最大并发数设置为1，那么回调就是串行的，由于多个请求共用这一个回调派发队列，如果其中一个请求的代理方法比较耗时，那么其他请求的回调将会等待前面的回调。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = dataTask.originalRequest.URL;</span><br><span class="line">    <span class="built_in">NSMutableData</span> *dataContainer = [<span class="keyword">self</span> dataWithURL:url];</span><br><span class="line">    [dataContainer appendData:data];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;本次接收1:%ld,线程：%@, url:%@&quot;</span>, data.length, [<span class="built_in">NSThread</span> currentThread], url.lastPathComponent);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url.absoluteString == landscapeUrl) &#123; <span class="comment">//故意让landscapeUrl的请求回调阻塞一下，其他url不阻塞。</span></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;本次接收2:%ld,总共接收:%ld,线程：%@, url:%@&quot;</span>, data.length, dataContainer.length, [<span class="built_in">NSThread</span> currentThread], url.lastPathComponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过一般情况下didReceiveData不可能出现这种故意阻塞的写法，所以delegateQueue的并发数设置为1几乎没有什么影响，如果没有什么特别的理由还是按文档上来设置为1吧。</p>
<p>2.delegateQueue的最大并发数设置为3（大于1的情况），那么回调就是并发的，目前没看到有什么异常影响。因为是并发队列，其他请求的回调不用等待前面的回调完成因而可以快速被回调。</p>
<p>3.即使delegateQueue的最大并发数设置为3，对于同一个请求的回调，didReceiveData的回调行为还是类似串行（虽然每次线程确实会不一样），不会出现两个线程同时回调didReceiveData。</p>
<h2 id="defaultSession-和-ephemeralSession"><a href="#defaultSession-和-ephemeralSession" class="headerlink" title="defaultSession 和 ephemeralSession"></a>defaultSession 和 ephemeralSession</h2><p>ephemeralSession，不会将响应缓存到磁盘，也不会使用磁盘缓存的响应。最多将一些session-related的数据保存在内存。APP结束，所有会话信息都会随着内存回收而被清除。</p>
<p>defaultSession，默认session，如果响应能够缓存则会将响应持久化到磁盘。</p>
<h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="1-NSURLSession对象是被谁强引用了-如何释放"><a href="#1-NSURLSession对象是被谁强引用了-如何释放" class="headerlink" title="1.NSURLSession对象是被谁强引用了?如何释放?"></a>1.NSURLSession对象是被谁强引用了?如何释放?</h3><p>NSURLSession对象应该是被系统的runloop强引用了,就类似于定时器一样,需要invalid后,才会被释放销毁.<br>题外话:如果timer属性是strong,那么invalidate后最好将其置为nil,否则invalid后timer因为还有人持有它,而不能销毁.strong情况下,timer的释放: <code>[self.timer invalidate];self.timer = nil;</code>定时器对象是注册到runloop里的,应该通过invalidate来告诉runloop释放它.所以self不应该持有该对象,因此timer属性最好为weak.</p>
<h3 id="2-在didCompleteWithError-完成的时候-之前收到的data怎么取到-不借助其他的变量-在该方法里取不到"><a href="#2-在didCompleteWithError-完成的时候-之前收到的data怎么取到-不借助其他的变量-在该方法里取不到" class="headerlink" title="2. 在didCompleteWithError:完成的时候,之前收到的data怎么取到?不借助其他的变量,在该方法里取不到?"></a>2. 在didCompleteWithError:完成的时候,之前收到的data怎么取到?不借助其他的变量,在该方法里取不到?</h3><p>完成回调里是取不到data的。需要在相应的代理方法里保存数据。</p>
<h3 id="3-请求转为下载任务时，为什么会转移到其他的代理方法比如didBecomeDownloadTask？"><a href="#3-请求转为下载任务时，为什么会转移到其他的代理方法比如didBecomeDownloadTask？" class="headerlink" title="3. 请求转为下载任务时，为什么会转移到其他的代理方法比如didBecomeDownloadTask？"></a>3. 请求转为下载任务时，为什么会转移到其他的代理方法比如didBecomeDownloadTask？</h3><p>这是因为下载任务的资源一般较大，接收到的数据不能像普通请求那样直接缓存在内存，否则会导致APP OOM。所以必须转移到其他代理方法边接收边缓存到磁盘。</p>
<h3 id="4-TCP接收到数据后是怎么传给NSURLSession的，NSURLSession又是怎么传给delegateQueue执行各个代理方法的，线程关系？TODO"><a href="#4-TCP接收到数据后是怎么传给NSURLSession的，NSURLSession又是怎么传给delegateQueue执行各个代理方法的，线程关系？TODO" class="headerlink" title="4.TCP接收到数据后是怎么传给NSURLSession的，NSURLSession又是怎么传给delegateQueue执行各个代理方法的，线程关系？TODO"></a>4.TCP接收到数据后是怎么传给NSURLSession的，NSURLSession又是怎么传给delegateQueue执行各个代理方法的，线程关系？TODO</h3><p>不知道。</p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>NSURLSession</tag>
      </tags>
  </entry>
  <entry>
    <title>OC关联对象实现原理</title>
    <url>/2021/09/28/OC%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="objc-AssociationPolicy"><a href="#objc-AssociationPolicy" class="headerlink" title="objc_AssociationPolicy"></a>objc_AssociationPolicy</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Policies related to associative references.</span></span><br><span class="line"><span class="comment"> * These are options to objc_setAssociatedObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">OBJC_ENUM</span><span class="params">(<span class="type">uintptr_t</span>, objc_AssociationPolicy)</span> &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span><span class="number">0x0301</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span><span class="number">0x0303</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应的内部枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    OBJC_ASSOCIATION_SETTER_ASSIGN      = <span class="number">0</span>,</span><br><span class="line">    OBJC_ASSOCIATION_SETTER_RETAIN      = <span class="number">1</span>,</span><br><span class="line">    OBJC_ASSOCIATION_SETTER_COPY        = <span class="number">3</span>,            <span class="comment">// <span class="doctag">NOTE:</span>  both bits are set, so we can simply test 1 bit in releaseValue below.</span></span><br><span class="line">    OBJC_ASSOCIATION_GETTER_READ        = (<span class="number">0</span> &lt;&lt; <span class="number">8</span>),</span><br><span class="line">    OBJC_ASSOCIATION_GETTER_RETAIN      = (<span class="number">1</span> &lt;&lt; <span class="number">8</span>),</span><br><span class="line">    OBJC_ASSOCIATION_GETTER_AUTORELEASE = (<span class="number">2</span> &lt;&lt; <span class="number">8</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：上面的01401是八进制写法，对应的十六进制是0x0301。我说怎么后面的switch看不懂呢。</p>
<h4 id="AssociationPolicy中NONATOMIC-和-ATOMIC-的区别"><a href="#AssociationPolicy中NONATOMIC-和-ATOMIC-的区别" class="headerlink" title="AssociationPolicy中NONATOMIC 和 ATOMIC 的区别"></a>AssociationPolicy中NONATOMIC 和 ATOMIC 的区别</h4><p>对于setter方法，<code>NONATOMIC</code> 和 <code>ATOMIC</code> 没有什么区别</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_object_set_associative_reference(id object, <span class="type">const</span> <span class="type">void</span> *key, id value, <span class="type">uintptr_t</span> policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line">    <span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line">    <span class="comment">// rdar://problem/44094390</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">&quot;objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects&quot;</span>, object, object_getClassName(object));</span><br><span class="line"></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isFirstAssociation = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;<span class="title function_">associations</span><span class="params">(manager.get())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">          	<span class="comment">//try_emplace会先查找，没找到才创建新的ObjectAssociationMap，创建时会根据需要扩容AssociationsHashMap。</span></span><br><span class="line">            <span class="keyword">auto</span> refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123; <span class="comment">//指定的disguised，以前没有值，这里是新创建的。则做好标记isFirstAssociation。</span></span><br><span class="line">                <span class="comment">/* it&#x27;s the first association we make */</span></span><br><span class="line">                isFirstAssociation = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* establish or replace the association */</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;refs = refs_result.first-&gt;second; <span class="comment">//refs是ObjectAssociationMap哈希表</span></span><br><span class="line">            <span class="keyword">auto</span> result = refs.try_emplace(key, <span class="built_in">std</span>::move(association)); <span class="comment">//try_emplace作用同上。</span></span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123; <span class="comment">//指定的key有旧值，进行swap，这样association保存的就是旧值，后面就执行释放旧值的操作。</span></span><br><span class="line">                association.swap(result.first-&gt;second); <span class="comment">//result.first-&gt;second是ObjcAssociation对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> refs_it = associations.find(disguised);</span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.end()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;refs = refs_it-&gt;second;</span><br><span class="line">                <span class="keyword">auto</span> it = refs.find(key);</span><br><span class="line">                <span class="keyword">if</span> (it != refs.end()) &#123;</span><br><span class="line">                    association.swap(it-&gt;second);</span><br><span class="line">                    refs.erase(it);</span><br><span class="line">                    <span class="keyword">if</span> (refs.size() == <span class="number">0</span>) &#123; <span class="comment">//ObjectAssociationMap哈希表全空时，则将其从AssociationsHashMap中清除。</span></span><br><span class="line">                        associations.erase(refs_it); <span class="comment">//清除AssociationsHashMap的某个桶。erase里还会对AssociationsHashMap进行减容或扩容。</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call setHasAssociatedObjects outside the lock, since this</span></span><br><span class="line">    <span class="comment">// will call the object&#x27;s _noteAssociatedObjects method if it</span></span><br><span class="line">    <span class="comment">// has one, and this may trigger +initialize which might do</span></span><br><span class="line">    <span class="comment">// arbitrary stuff, including setting more associated objects.</span></span><br><span class="line">    <span class="keyword">if</span> (isFirstAssociation)</span><br><span class="line">        object-&gt;setHasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">acquireValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_value) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (_policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">            _value = objc_retain(_value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">            _value = ((id(*)(id, SEL))objc_msgSend)(_value, @selector(copy));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">releaseHeldValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_value &amp;&amp; (_policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN)) &#123;</span><br><span class="line">        objc_release(_value); <span class="comment">//_policy是带retain或copy的这里都会进行release。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">swap</span><span class="params">(ObjcAssociation &amp;other)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(_policy, other._policy);</span><br><span class="line">    <span class="built_in">std</span>::swap(_value, other._value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致步骤：</p>
<ol>
<li>retain新值，if needed。使用OBJC_ASSOCIATION_ASSIGN策略是不会retain的。</li>
<li>AssociationsManagerLock加锁</li>
<li>将新值保存到哈希表中，将旧值保存到association里，用于后续释放。</li>
<li>AssociationsManagerLock解锁</li>
<li>标记object有关联对象</li>
<li>release旧值，if needed。</li>
</ol>
<p><code>NONATOMIC</code> 和 <code>ATOMIC</code> 的区别只体现在 <code>objc_getAssociatedObject</code> 的实现上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="title function_">objc_getAssociatedObject</span><span class="params">(id object, <span class="type">const</span> <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_object_get_associative_reference(id object, <span class="type">const</span> <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager; <span class="comment">//临时变量manager，里面有全局锁，相当于对代码块进行了加锁解锁，常见写法。</span></span><br><span class="line">        AssociationsHashMap &amp;<span class="title function_">associations</span><span class="params">(manager.get())</span>;</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs.find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs.end()) &#123;</span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">retainReturnedValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_value &amp;&amp; (_policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN)) &#123;</span><br><span class="line">        objc_retain(_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> id <span class="title function_">autoreleaseReturnedValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(_value &amp;&amp; (_policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE))) &#123;</span><br><span class="line">        <span class="keyword">return</span> objc_autorelease(_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>ATOMIC</code>调用getter方法时，获取到的是retain后注册到自动释放池里的对象：</p>
<ol>
<li>AssociationsManagerLock加锁</li>
<li>获取关联对象</li>
<li><strong>retain关联对象</strong></li>
<li>AssociationsManagerLock解锁</li>
<li>将关联对象注册到自动释放池，并返回给调用者</li>
</ol>
<p>而<code>NONATOMIC</code> 只是简单的返回对象的地址：</p>
<ol>
<li>AssociationsManagerLock加锁</li>
<li>获取关联对象</li>
<li>AssociationsManagerLock解锁</li>
<li>将关联对象返回给调用者。</li>
</ol>
<p>因此使用 <code>NONATOMIC</code> 选项，可能会出现这种情况：A线程调用getter方法得到对象的地址，后面B线程调用setter方法，而setter方法会释放旧值，于是A线程获得的对象被销毁了，A线程在使用时存在野指针风险。而使用 <code>ATOMIC</code> 选项，因为getter方法里会retain并注册到自动释放池所以A线程获得对象在使用期间不会被销毁。实验时应该采用MRC环境。</p>
<p>正是由于上述细微的不同，所以对于关联对象该用 <code>ATOMIC</code> 选项时，还得用 <code>ATOMIC</code> 选项。</p>
<h3 id="关联对象的存储"><a href="#关联对象的存储" class="headerlink" title="关联对象的存储"></a>关联对象的存储</h3><p>通过objc_setAssociatedObject完成设值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setNonatomicBook:(<span class="built_in">NSString</span> *)nonatomicBook &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(nonatomicBook), nonatomicBook, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:关联的值只能为对象，不能为基础类型。</p>
<p>那么该方法究竟把传入的对象保存到哪里去了呢？数据结构出场。</p>
<h4 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> AssociationsManagerLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> objc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjcAssociation</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> _policy;</span><br><span class="line">    id _value; <span class="comment">//只能是对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ObjcAssociation</span>(<span class="type">uintptr_t</span> policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    <span class="built_in">ObjcAssociation</span>() : _policy(<span class="number">0</span>), _value(nil) &#123;&#125;</span><br><span class="line">    <span class="built_in">ObjcAssociation</span>(<span class="type">const</span> ObjcAssociation &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    ObjcAssociation &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ObjcAssociation &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ObjcAssociation</span>(ObjcAssociation &amp;&amp;other) : <span class="built_in">ObjcAssociation</span>() &#123;</span><br><span class="line">        <span class="built_in">swap</span>(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(ObjcAssociation &amp;other)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(_policy, other._policy);</span><br><span class="line">        std::<span class="built_in">swap</span>(_value, other._value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title">policy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _policy; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> id <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">acquireValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_value) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (_policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">                _value = <span class="built_in">objc_retain</span>(_value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">                _value = ((<span class="built_in">id</span>(*)(id, SEL))objc_msgSend)(_value, @<span class="built_in">selector</span>(copy));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DenseMap&lt;<span class="type">const</span> <span class="type">void</span> *, ObjcAssociation&gt; ObjectAssociationMap;</span><br><span class="line"><span class="keyword">typedef</span> DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt; AssociationsHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class AssociationsManager manages a lock / hash table singleton pair.</span></span><br><span class="line"><span class="comment">// Allocating an instance acquires the lock</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AssociationsManager</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Storage = ExplicitInitDenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt;;</span><br><span class="line">    <span class="type">static</span> Storage _mapStorage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AssociationsManager</span>()   &#123; AssociationsManagerLock.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">    ~<span class="built_in">AssociationsManager</span>()  &#123; AssociationsManagerLock.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AssociationsHashMap &amp;<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _mapStorage.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _mapStorage.<span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AssociationsManager::Storage AssociationsManager::_mapStorage;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace objc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We cannot use a C++ static initializer to initialize certain globals because</span></span><br><span class="line"><span class="comment">// libc calls us before our C++ initializers run. We also don&#x27;t want a global</span></span><br><span class="line"><span class="comment">// pointer to some globals because of the extra indirection.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ExplicitInit / LazyInit wrap doing it the hard way.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitInit</span> &#123;</span><br><span class="line">    <span class="built_in">alignas</span>(Type) <span class="type">uint8_t</span> _storage[<span class="built_in">sizeof</span>(Type)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(Ts &amp;&amp;... Args)</span> </span>&#123; <span class="comment">//上面的init方法</span></span><br><span class="line">        <span class="keyword">new</span> (_storage) <span class="built_in">Type</span>(std::forward&lt;Ts&gt;(Args)...); <span class="comment">//堆上的容器。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type &amp;<span class="title">get</span><span class="params">()</span> </span>&#123;<span class="comment">//上面的get方法</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;Type *&gt;(_storage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>字段：</p>
<p>AssociationsManagerLock：一把<strong>全局</strong>自旋锁。</p>
<p>_mapStorage：一个局部静态变量哈希表AssociationsHashMap，键为对象地址，值为一个哈希表ObjectAssociationMap。哈希表ObjectAssociationMap的键为关联对象的key（必须为一个常量字符串，如果是alloc动态生成的即使字符相等也会有问题），值为ObjcAssociation。ObjcAssociation里记录了policy和value（传入的关联对象）。</p>
<p>因此整个数据结构就很清楚了，就是哈希表套哈希表。这种数据结构在源码里用的很普遍。</p>
<p>设值过程如下：</p>
<ol>
<li>加锁。</li>
<li>根据对象的地址从哈希表AssociationsHashMap中找到哈希表ObjectAssociationMap。</li>
<li>再根据关联对象的key从哈希表ObjectAssociationMap中找到ObjcAssociation。</li>
<li>新值替换旧值。</li>
<li>解锁。结束。</li>
</ol>
<h4 id="AssociationsHashMap-ObjectAssociationMap扩容减容时机"><a href="#AssociationsHashMap-ObjectAssociationMap扩容减容时机" class="headerlink" title="AssociationsHashMap/ObjectAssociationMap扩容减容时机"></a>AssociationsHashMap/ObjectAssociationMap扩容减容时机</h4><p>这里全是C++代码，看不懂。</p>
<p>哈希表在插入元素时会根据需要进行扩容，在删除元素时会进行减容或扩容（删除后会检查是否满足扩容条件）。AssociationsHashMap初始化后有一个默认容量（不会很大），后续根据需要扩容和减容。</p>
<h3 id="关联对象的获取"><a href="#关联对象的获取" class="headerlink" title="关联对象的获取"></a>关联对象的获取</h3><p>获取过程类似。</p>
<h3 id="添加weak关联对象"><a href="#添加weak关联对象" class="headerlink" title="添加weak关联对象"></a>添加weak关联对象</h3><p>从objc_AssociationPolicy枚举中，可以看到是没有weak选项的，只有一个assign，但assign在关联对象销毁后，指针并不会被置为nil，因此有野指针访问风险。至于系统为啥没有帮我们实现weak选项，可能的原因是因为类别添加的属性其实是没有实例变量对应的，所以没办法把指针变量地址注册到关联对象的weak表中去，不过具体原因不得而知，我也想象不到。</p>
<p>但我们自己可以实现这个weak选项。</p>
<p>weak主要的作用就是对象销毁后，所有指向它的指针都将被置为nil，从而避免了野指针访问。因此我们只需要在关联对象销毁时，再次调用objc_setAssociatedObject置为nil就可以了。</p>
<p>一种简洁的实现：利用block能够捕获自动变量的特点以及现成的weak特性。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XQDetailViewController</span> (<span class="title">Book</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) Book *myBook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line">- (Book *)myBook &#123;</span><br><span class="line">    <span class="type">id</span> (^block)(<span class="type">void</span>) = objc_getAssociatedObject (<span class="keyword">self</span>, <span class="keyword">@selector</span>(myBook));</span><br><span class="line">    <span class="type">id</span> obj = (block ? block () : <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setMyBook:(Book *)myBook &#123;</span><br><span class="line">    <span class="type">id</span> __<span class="keyword">weak</span> weakObject = myBook;</span><br><span class="line">    <span class="type">id</span> (^block)(<span class="type">void</span>) = ^&#123; <span class="keyword">return</span> weakObject; &#125;;</span><br><span class="line">    objc_setAssociatedObject (<span class="keyword">self</span>, <span class="keyword">@selector</span> (myBook), block, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种办法：利用中间层。</p>
<p>第三种办法：给关联对象添加一个stub存根对象，存根对象是随同关联对象销毁的，存根对象销毁的dealloc方法里面调用block将宿主对象的手动设置为nil。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (Person *)person &#123;</span><br><span class="line">    <span class="type">id</span> obj = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(person));</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setPerson:(Person *)person &#123;</span><br><span class="line">    __<span class="keyword">weak</span> XQDetailViewController *obj = <span class="keyword">self</span>;</span><br><span class="line">    [person jj_deallocBlock:^&#123;</span><br><span class="line">      	<span class="comment">/// person对象销毁后手动置为nil.</span></span><br><span class="line">        objc_setAssociatedObject(obj, <span class="keyword">@selector</span> (person), <span class="literal">nil</span>, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">/// 这里不能再是retain了，只能是assign。然后关联对象销毁的时候再手动置为nil.</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span> (person), person, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有通用的方法？从系统层面解决？</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.codenong.com/jsed65d71554d8/">如何使用 Runtime 给现有的类添加 weak 属性</a></p>
<p><a href="https://sunsetroads.github.io/2020/03/22/weak-associated-object/">Weak Associated Object</a></p>
<p><a href="https://stackoverflow.com/questions/29934289/objc-setassociatedobject-retain-atomic-or-nonatomic">objc_setAssociatedObject retain atomic or nonatomic</a></p>
<p><a href="https://xcqromance.top/2018/05/16/2018-05-16/">iOS开发遇坑总结</a></p>
<p><a href="https://blog.csdn.net/weixin_52093215/article/details/124852296">C++ 声明未知大小的全局数组</a> 只能使用</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Q：1-全局哈希表或数组它的容量后面还能扩容吗？"><a href="#Q：1-全局哈希表或数组它的容量后面还能扩容吗？" class="headerlink" title="Q：1.全局哈希表或数组它的容量后面还能扩容吗？"></a>Q：1.全局哈希表或数组它的容量后面还能扩容吗？</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="type">char</span> a[MAX]; <span class="comment">//全局区</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> b[MAX]; <span class="comment">//栈区</span></span><br><span class="line">	<span class="type">char</span> *c=(<span class="type">char</span> *)<span class="built_in">malloc</span>(MAX * <span class="keyword">sizeof</span>(<span class="type">char</span>));  <span class="comment">//堆区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组的大小其实是固定的。扩容并不是在原来的内存基础上增加内存，而是重新申请一片内存，然后把之前的数据拷贝过来，效果上看起来像是原来的数组变大了。而为了表述方便就把这个过程称为扩容。能够扩容说明这段内存是由程序员管理的，而只有堆区的内存是由程序员负责申请和释放。而全局区的内存是由系统分配管理的，所以无法在全局区内存进行数组扩容。上面的全局关联哈希表实际上类似于一个全局指针变量，指向一个堆上的哈希表。因此可以扩容减容。weak中的全局SideTablesMap哈希表也是一样的。目前很少看到使用直接在全局区创建的数组，一般都是使用指针。</p>
<p><strong>十进制(decimal)</strong>：非0开头,所以其他进制的写法要前补0用于区分；</p>
<p><strong>二进制（binary）</strong>： 0b 或 0B开头；</p>
<p><strong>八进制(Octal缩写OCT或O)</strong> ：常常以数字0开始表明该数字是八进制；</p>
<p><strong>十六进制（（简写为hex或下标16））</strong>：0x或0X开头；</p>
<p><strong>负数</strong>：前面加 -</p>
<p>左移：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">NSInteger</span> a = <span class="number">0</span> &lt;&lt; <span class="number">8</span>; //           <span class="number">0</span></span><br><span class="line"><span class="attribute">NSInteger</span> b = <span class="number">1</span> &lt;&lt; <span class="number">8</span>; // <span class="number">01</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="attribute">NSInteger</span> c = <span class="number">2</span> &lt;&lt; <span class="number">8</span>; // <span class="number">10</span> <span class="number">0000</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>关联对象</tag>
      </tags>
  </entry>
  <entry>
    <title>类别导致的target-action方法不调用问题</title>
    <url>/2021/12/01/%E7%B1%BB%E5%88%AB%E5%AF%BC%E8%87%B4%E7%9A%84target-action%E6%96%B9%E6%B3%95%E4%B8%8D%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><p>描述：ZATextField 自己添加自己作为target后，发现action方法不被调用。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>ZATextField的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ZATextField.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZATextField</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="built_in">UITextFieldTextDidBeginEditingNotification</span> object:<span class="keyword">self</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weakSelf.rightView &amp;&amp; weakSelf.rightViewMode == <span class="built_in">UITextFieldViewModeWhileEditing</span>) &#123;</span><br><span class="line">                weakSelf.rightView.hidden = weakSelf.text.length &gt; <span class="number">0</span> ? <span class="literal">NO</span> : <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (weakSelf.leftView &amp;&amp; weakSelf.leftViewMode == <span class="built_in">UITextFieldViewModeWhileEditing</span>) &#123;</span><br><span class="line">                weakSelf.leftView.hidden = weakSelf.text.length &gt; <span class="number">0</span> ? <span class="literal">NO</span> : <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="built_in">UITextFieldTextDidChangeNotification</span> object:<span class="keyword">self</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weakSelf.rightView &amp;&amp; weakSelf.rightViewMode == <span class="built_in">UITextFieldViewModeWhileEditing</span>) &#123;</span><br><span class="line">                weakSelf.rightView.hidden = weakSelf.text.length &gt; <span class="number">0</span> ? <span class="literal">NO</span> : <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (weakSelf.leftView &amp;&amp; weakSelf.leftViewMode == <span class="built_in">UITextFieldViewModeWhileEditing</span>) &#123;</span><br><span class="line">                weakSelf.leftView.hidden = weakSelf.text.length &gt; <span class="number">0</span> ? <span class="literal">NO</span> : <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(xxxxchange:) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)xxxxchange:(<span class="built_in">UITextField</span> *)sender &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;text:%@&quot;</span>, <span class="keyword">self</span>.text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光标大小设置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)caretRectForPosition:(<span class="built_in">UITextPosition</span> *)position &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> originalRect = [<span class="variable language_">super</span> caretRectForPosition:position];</span><br><span class="line">    <span class="built_in">CGFloat</span> caretHeight = <span class="keyword">self</span>.font.lineHeight - <span class="number">4</span>;</span><br><span class="line">    originalRect.size.height = caretHeight;</span><br><span class="line">    originalRect.origin.y = (<span class="keyword">self</span>.frame.size.height - caretHeight) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> originalRect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>自己添加了自己作为target:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(xxxxchange:) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</span><br></pre></td></tr></table></figure>
<p>理论上讲当有文字输入时，xxxxchange方法肯定会调用的，但是实际没有。</p>
<h3 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>1.方法被其他地方的类别覆盖了。</p>
<p>2.target被移除了。</p>
<p>针对第一点，改了一个很随意的方法名称xxxxchange:，但是没有用。说明不是因为类别覆盖的原因。</p>
<p>针对第二点，调试时打印了allTargets，竟然发现self赫然在列。WTF！一时间没有任何思路，一度以为事件传递有问题，浪费很多时间。最终搜索所有与UITextField相关的类别，子类等，结果发现：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">ZATextField *textField = [[ZATextField alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">textField.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">21</span>];</span><br><span class="line">textField.textColor = [<span class="built_in">UIColor</span> colorWithHexString:<span class="string">@&quot;#26273C&quot;</span>];</span><br><span class="line">textField.placeholder = <span class="string">@&quot;请输入密码&quot;</span>;</span><br><span class="line">textField.delegate = <span class="keyword">self</span>;</span><br><span class="line">textField.backgroundColor = <span class="built_in">UIColor</span>.whiteColor;</span><br><span class="line">textField.layer.cornerRadius = <span class="number">28</span>;</span><br><span class="line">textField.layer.masksToBounds = <span class="literal">YES</span>;</span><br><span class="line">textField.secureTextEntry = <span class="literal">YES</span>;</span><br><span class="line">textField.keyboardType = <span class="built_in">UIKeyboardTypeASCIICapable</span>;</span><br><span class="line">textField.xq_limitTextLength = <span class="number">20</span>; <span class="comment">//就是这里</span></span><br></pre></td></tr></table></figure>
<p>ZATextField有用到一个长度限制的类别，实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)xq_limitTextLength</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *limit = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(xq_limitTextLength));</span><br><span class="line">    <span class="keyword">return</span> limit.integerValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setXq_limitTextLength:(<span class="built_in">NSInteger</span>)xq_limitTextLength</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(xq_limitTextLength), @(xq_limitTextLength), OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> removeTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(xq_textFieldTextDidChanged:) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</span><br><span class="line">    [<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(xq_textFieldTextDidChanged:) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面有removeTarget的操作，但是</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> removeTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(xq_textFieldTextDidChanged:) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</span><br></pre></td></tr></table></figure>
<p>这句代码的意思不是移除self—UIControlEventEditingChanged—xq_textFieldTextDidChanged键值对吗？怎么以前的也移除了？看来是我对removeTarget理解的有问题。</p>
<h3 id="重新理解addTarget-removeTarget"><a href="#重新理解addTarget-removeTarget" class="headerlink" title="重新理解addTarget/removeTarget"></a>重新理解addTarget/removeTarget</h3><p>addTarget:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add target/action for particular event. you can call this multiple times and you can specify multiple target/actions for a particular event.</span></span><br><span class="line"><span class="comment">// passing in nil as the target goes up the responder chain. The action may optionally include the sender and the event in that order</span></span><br><span class="line"><span class="comment">// the action cannot be NULL. Note that the target is not retained.</span></span><br><span class="line">- (<span class="type">void</span>)addTarget:(<span class="keyword">nullable</span> <span class="type">id</span>)target action:(SEL)action forControlEvents:(<span class="built_in">UIControlEvents</span>)controlEvents;</span><br></pre></td></tr></table></figure>
<p>Note that the target is not retained.新发现，原来UIControl并不会强引用target。所以self addTarget:self，并不会引起内存问题。不过这跟我们现在的问题没啥关系。</p>
<p>removeTarget：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">// remove the <span class="keyword">target</span>/<span class="keyword">action</span> for a set of events. <span class="keyword">pass</span> <span class="keyword">in</span> NULL for the <span class="keyword">action</span> to remove <span class="built_in">all</span> actions for that <span class="keyword">target</span></span><br><span class="line">- (void)removeTarget:(nullable id)<span class="keyword">target</span> <span class="keyword">action</span>:(nullable SEL)<span class="keyword">action</span> forControlEvents:(UIControlEvents)controlEvents;</span><br></pre></td></tr></table></figure>
<p>文档说明：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Use this <span class="keyword">method</span> <span class="keyword">to</span> prevent the delivery <span class="keyword">of</span> control events <span class="keyword">to</span> target objects associated <span class="keyword">with</span> control. <span class="keyword">If</span> you specify a <span class="keyword">valid</span> <span class="keyword">object</span> <span class="keyword">in</span> the target parameter, this <span class="keyword">method</span> stops the delivery <span class="keyword">of</span> the specified events <span class="keyword">to</span> <span class="keyword">all</span> action methods associated <span class="keyword">with</span> that <span class="keyword">object</span>. <span class="keyword">If</span> you specify nil <span class="keyword">for</span> the target parameter, this <span class="keyword">method</span> prevents the delivery <span class="keyword">of</span> those events <span class="keyword">to</span> <span class="keyword">all</span> action methods <span class="keyword">of</span> <span class="keyword">all</span> target objects.</span><br><span class="line">Although the action parameter <span class="keyword">is</span> <span class="keyword">not</span> considered <span class="keyword">when</span> stopping the delivery <span class="keyword">of</span> events, you should specify an appropriate <span class="keyword">value</span> anyway. <span class="keyword">If</span> the specified target/action combination <span class="keyword">no</span> longer has <span class="keyword">any</span> <span class="keyword">valid</span> control events associated <span class="keyword">with</span> it, the control cleans up its corresponding <span class="type">internal</span> data structures. Doing so can affect the <span class="keyword">set</span> <span class="keyword">of</span> objects returned <span class="keyword">by</span> the allTargets <span class="keyword">method</span>.</span><br></pre></td></tr></table></figure>
<p>里面有一句重要说明：</p>
<p>If you specify a valid object in the target parameter, this method stops the delivery of the specified events to all action methods associated with that object.If you specify nil for the target parameter, this method prevents the delivery of those events to all action methods of all target objects.</p>
<p>翻译过来就是，当传入一个有效的target和指定事件，调用该方法后，该target的所有指定事件的action方法都不会再执行了。如果传入的是nil，那么指定事件的所有target的所有action方法都不会再执行。</p>
<p>也就是说removeTarget方法的三个参数中，action参数没有实际用处，有用的是target和controlEvents参数。</p>
<p>很有可能内部的数据结构是这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">controlEvents : [<span class="built_in">target1</span>(m1,m2,m3), <span class="built_in">target2</span>(m1), <span class="built_in">target3</span>(m1)]</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[textF addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBeginA:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br><span class="line">[textF addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBeginB:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br><span class="line">[textF addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBeginC:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [textF removeTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBeginA:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br><span class="line">    [textF addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBeginD:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>刚开始时数据结构为：</p>
<p>UIControlEventEditingDidBegin ： [self(printBeginA, printBeginB, printBeginC)]</p>
<p>调用removeTarget后</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[textF removeTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBeginA:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br></pre></td></tr></table></figure>
<p>数据结构变为：</p>
<p>UIControlEventEditingDidBegin ：[]，有可能这一栏都没有了。</p>
<p>最后又addTarget，数据结构变为：</p>
<p>UIControlEventEditingDidBegin ：[self(printBeginD)]</p>
<p>所以最后只有printBeginD响应了。</p>
<p>而重复addTarget</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[textF addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBegin:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br><span class="line">[textF addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBegin:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br><span class="line">[textF addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBegin:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br><span class="line">[textF addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(printBegin:) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span>];</span><br></pre></td></tr></table></figure>
<p>数据结构为：</p>
<p>UIControlEventEditingDidBegin ：[self(printBegin)]</p>
<p>因此重复addTarget同一action没有什么影响，事件来了，action方法只会执行一次。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>删除类别里的removeTarget即可。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> removeTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(xq_textFieldTextDidChanged:) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>removeTarget没办法移除指定target的指定事件的指定action。这是在开发过程中需要注意的。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>UITextField</tag>
        <tag>removeTarget</tag>
      </tags>
  </entry>
  <entry>
    <title>类别覆盖原始实现引发的薛定谔的bug</title>
    <url>/2021/12/18/%E7%B1%BB%E5%88%AB%E8%A6%86%E7%9B%96%E5%8E%9F%E5%A7%8B%E5%AE%9E%E7%8E%B0%E5%BC%95%E5%8F%91%E7%9A%84%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84bug/</url>
    <content><![CDATA[<h4 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h4><p>出现机型：iPhone7Plus iOS15.1。</p>
<p>描述：在开发过程中发现弹出弹窗点击关闭之后界面就卡死了。多次尝试之后，最终发现只有在调试的时候出现，把线一拔不调试的时候一切又正常了。拿另一部iPhone6Plus iOS12.5.4的手机又都不会出现。顿时感觉遇到”薛定谔的bug”了。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>项目中对UIAlertController做了一层简单的封装，是在自己的window上present出来的，这样在使用的时候就不用操心谁来present了。</p>
<p>方法接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (void)showActionSheetWithTitle:(nullable NSString *)title message:(nullable NSString *)message cancelButtonTitle:(nullable NSString *)cancelButtonTitle destructiveButtonIndex:(NSInteger)destructiveButtonIndex buttonTitles:(nullable NSArray *)buttonTitles showedPatternHandler:(nullable NSDictionary *(^)(void))showedPatternHandler buttonClickedHandler:(nullable void(^)(NSUInteger buttonIndex))buttonClickedHandler;</span><br></pre></td></tr></table></figure>
<p>内部部分实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIAlertController *alertController = [UIAlertController alertControllerWithTitle:title message:message preferredStyle:preferredStyle];</span><br><span class="line">alertController.alertWindow = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line">alertController.alertWindow.backgroundColor = [UIColor clearColor];</span><br><span class="line">alertController.alertWindow.hidden = NO;</span><br><span class="line">...</span><br><span class="line">alertController.alertWindow.rootViewController = [UIViewController new];</span><br><span class="line">[alertController.alertWindow.rootViewController presentViewController:alertController animated:YES completion:nil];</span><br></pre></td></tr></table></figure>
<p>刚开始时，对象持有关系：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">alertController</span>------&gt;</span><span class="function"><span class="title">alertWindow</span>------&gt;</span>rootViewController</span><br></pre></td></tr></table></figure>
<p>当present后</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[alertController.alertWindow.rootViewController presentViewController:alertController animated:YES completion:nil]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>rootViewController的控制器栈会持有alertController，于是对象关系变为：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">alertController</span>------&gt;</span><span class="function"><span class="title">alertWindow</span>------&gt;</span>rootViewController</span><br><span class="line">        ↑----------------------------------------|</span><br></pre></td></tr></table></figure>
<p>形成了一个循环，因此三者都不会被释放。</p>
<p>当点击alertController上的某个按钮时系统会自动调用dismiss于是alertController从控制器栈移除，于是rootViewController不再持有alertController，循环被打破，三者释放，window自然也被移除。为方便表述暂且将这种打破循环的方式称为自动打破。</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">alertController</span><span class="literal">------</span>&gt;<span class="comment">alertWindow</span><span class="literal">------</span>&gt;<span class="comment">rootViewController</span></span><br><span class="line">        <span class="comment">↑</span><span class="literal">------------------</span> <span class="comment">X</span> <span class="literal">-------------------</span> <span class="comment">|</span></span><br></pre></td></tr></table></figure>
<p>由于循环会自动打破，因此内存能够正常回收。调用dismiss后，在iOS10.3.3、iOS12.5.4、iOS15.1上都能销毁，和分析的一致。</p>
<p>在看实现的时候，看到封装的人为了避免潜在的引用循环，在<strong>类别</strong>里重写了viewDidDisappear:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidDisappear:animated];</span><br><span class="line">    <span class="keyword">self</span>.alertWindow = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当弹窗控制器dismiss时，viewDidDisappear会被调用，alertWindow会被置为nil，循环被打破。这里将这种循环打破方式称为主动打破。</p>
<p>比较一下这两种打破方式，</p>
<p>自动打破：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">alertController</span><span class="literal">------</span>&gt;<span class="comment">alertWindow</span><span class="literal">------</span>&gt;<span class="comment">rootViewController</span></span><br><span class="line">        <span class="comment">↑</span><span class="literal">------------------</span> <span class="comment">X</span> <span class="literal">-------------------</span> <span class="comment">|</span></span><br></pre></td></tr></table></figure>
<p>主动打破：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">alertController</span><span class="literal">---</span><span class="comment">X</span><span class="literal">---</span>&gt;<span class="comment">alertWindow</span><span class="literal">------</span>&gt;<span class="comment">rootViewController</span></span><br><span class="line">        <span class="comment">↑</span><span class="literal">------------------</span> <span class="comment">X</span> <span class="literal">-------------------</span> <span class="comment">|</span></span><br></pre></td></tr></table></figure>
<p>可以看到当dismiss时主动打破有两处打破的地方。</p>
<p>考虑如下场景，假如有其他地方强引用了alertController，对于自动打破关系图为：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">obj</span>------&gt;</span><span class="function"><span class="title">alertController</span>------&gt;</span><span class="function"><span class="title">alertWindow</span>------&gt;</span>rootViewController</span><br><span class="line">                ↑----------------------------------------|</span><br></pre></td></tr></table></figure>
<p>当调用dismiss后，关系图变为：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">obj</span>------&gt;</span><span class="function"><span class="title">alertController</span>------&gt;</span><span class="function"><span class="title">alertWindow</span>------&gt;</span>rootViewController</span><br><span class="line">                ↑--------------------X--------------------|</span><br></pre></td></tr></table></figure>
<p>可以看到window并不会被销毁，window不销毁会出现调用dismiss后弹窗虽然消失了，但由于没有将window隐藏，它其实还在视图层级中，只不过是透明的，这时用户是无法点击看到的控件的，整个APP就像卡死了一样，实际上是因为最上层有一层透明的window，事件都被这个透明的window吃了。</p>
<p>而主动打破关系图为：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">obj</span><span class="literal">------</span>&gt;<span class="comment">alertController</span><span class="literal">---</span><span class="comment">X</span><span class="literal">---</span>&gt;<span class="comment">alertWindow</span><span class="literal">------</span>&gt;<span class="comment">rootViewController</span></span><br><span class="line">                <span class="comment">↑</span><span class="literal">--------------------</span><span class="comment">X</span><span class="literal">--------------------</span><span class="comment">|</span></span><br></pre></td></tr></table></figure>
<p>可以确保window被销毁，window被销毁了自然不会出现在视图层级中，因此就算有外部强引用alertController也不会发生上面的可怕bug。然而实际情况却出现了上面的bug。WTF？</p>
<h4 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h4><p>有没有一种可能，在iPhone7plus iOS15.1上，脱机时dismiss弹窗代码走的是类别的实现viewDidDisappear，但是联机时代码走的是系统的viewDidDisappear实现。而在iOS12.5.4上走的都是类别的实现？</p>
<p>但是这又跟我看的runtime底层实现类别的加载有冲突，按照类别的加载机制，类别会覆盖原类的实现，如果有多个类别则最后一个编译的类别有效果。所以肯定是不会走系统的实现啊！OMG！</p>
<p>先不管了，先搜一下跟UIAlertController相关的代码，结果发现项目中居然有三个UIAlertController的类别而且都实现了viewDidDisappear:</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/49B6C945762D605C86403C144A2AD6F7.jpg" alt=""></p>
<p>真是不搜不要紧，一搜吓一跳。</p>
<p>于是把这三个类别拖出来，做了一个小demo验证一下。</p>
<p>这是脱机打印日志：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20211218151539.png" alt=""></p>
<p>符合编译顺序：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20211218151559.png" alt=""></p>
<p>这是联机时的日志：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/84166464.png" alt=""></p>
<p>viewDidDisappear的日志没了？？？实际上代码走的是系统的实现，这一点可以打符号断点验证。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20211218151901.png" alt=""></p>
<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20211218152155.png" alt=""></p>
<p>神奇不神奇？完全无视runtime底层实现类别的加载，走的竟然是系统的实现。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>至此，真相终于大白，和猜想一致，在iPhone7plus iOS15.1上，脱机时dismiss弹窗代码会走类别的实现viewDidDisappear，但是联机时代码走的是系统的viewDidDisappear实现。而在iOS12.5.4上走的都是类别的实现。</p>
<p>有两种解决办法：一种是在load里hook原类的viewDidDisappear，一种是子类化UIAlertController。考虑到load太多影响启动时间，还是子类化吧，这样viewDidDisappear和dealloc方法都可以重写。</p>
<p>从此以后我再也没有遇到这只薛定谔的猫了。不过我还是有疑惑联机调试的时候为啥就走到系统的实现？是系统出Bug了吗？不得而知，或许事情的真相只有系统他自己才知道了。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>类别覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS定时器杂记</title>
    <url>/2022/05/01/iOS%E5%AE%9A%E6%97%B6%E5%99%A8%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><p>NSTimer是使用最多的一种定时器，虽然但是NSTimer还是有很多的注意事项：</p>
<ol>
<li><p>不注意使用的话有循环引用的隐患。因为NSTimer会强引用target，如果target再强引用NSTimer那么就会发生循环引用。比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_normal_timer1 &#123;</span><br><span class="line">    <span class="keyword">self</span>.normalStrongTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSome) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.normalStrongTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">    [<span class="keyword">self</span>.normalStrongTimer fire];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就会发生循环引用。此时即使页面返回，但是因为循环引用，ViewController的dealloc将不会被执行，因此invalidate不能放在dealloc里，只能在其他时机比如viewDidDisappear里调用。所以一般使用weak来弱引用定时器，这样就可以在dealloc里调用invalidate。</p>
</li>
<li><p>需要在合适的地方invalid定时器，否则定时器会一直强引用target从而延长target的生命周期。</p>
<p>在开发中很容易忘记invalid定时器，一旦忘记invalid定时器，定时器就会延长target的生命周期，比如页面返回了但实际还没有被销毁，从而产生一些诡异问题。这也是使用NSTimer必须注意的地方。</p>
</li>
<li><p>使用时必须保证有一个活跃的runloop，并且需要指定mode。因此在子线程中使用不是很方便。</p>
</li>
<li><p>精度可能不够。</p>
</li>
<li><p>网上的一个说法：创建和撤销必须在同一个线程上，在多线程环境下使用不便。(这一条存疑，经过验证在子线程创建一个定时器，在另一个子线程invalidate并没有发现有什么问题)</p>
</li>
<li><p>iOS10开始支持block使用，同样在使用block时一定要注意循环引用。</p>
</li>
</ol>
<p>为了从根本上避免上述问题，一个弱引用target的、能够在自身销毁时自动invalid的定时器想必是极好的。解决办法就是封装GCD定时器。</p>
<h2 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h2><p>基本使用：</p>
<p>1.创建定时器源</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,</span><br><span class="line"><span class="built_in">                                            0,</span></span><br><span class="line"><span class="built_in">                                            0,</span></span><br><span class="line">                                            self.privateSerialQueue)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>2.设置定时器</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int64</span>_t <span class="built_in">int</span>ervalInNanoseconds = (<span class="built_in">int64</span>_t)(self.timeInterval * NSEC_PER_SEC);</span><br><span class="line"><span class="built_in">int64</span>_t toleranceInNanoseconds = (<span class="built_in">int64</span>_t)(self.tolerance * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_timer(self.timer,</span><br><span class="line">                          dispatch_time(DISPATCH_TIME_NOW, <span class="built_in">int</span>ervalInNanoseconds),</span><br><span class="line">                          (<span class="built_in">uint64</span>_t)<span class="built_in">int</span>ervalInNanoseconds,</span><br><span class="line">                          toleranceInNanoseconds</span><br><span class="line">                          );</span><br></pre></td></tr></table></figure>
<p>3.设置事件回调</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dispatch_source_set_event_handler</span>(self.timer, ^&#123;</span><br><span class="line">    <span class="selector-attr">[weakSelf timerFired]</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>4.启动定时器</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_resume</span>(self.timer);</span><br></pre></td></tr></table></figure>
<p>5.撤销定时器</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_source_cancel</span>(timer);</span><br></pre></td></tr></table></figure>
<h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="1-在子线程中使用定时器"><a href="#1-在子线程中使用定时器" class="headerlink" title="1. 在子线程中使用定时器"></a>1. 在子线程中使用定时器</h3><p>最佳实践就是使用GCD定时器，因为GCD定时器不需要添加在runloop中，并且本身也支持指定事件回调的派发队列。</p>
<p>如果你非得使用NSTimer+NSThread，那么必须注意runloop的操作。runloop有下面三种开启方式：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)run; </span><br><span class="line">- (<span class="type">void</span>)runUntilDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br><span class="line">- (<span class="type">BOOL</span>)runMode:(<span class="built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br></pre></td></tr></table></figure>
<p>run：启动前如果没有添加任何源那么runloop一启动就会马上退出，方法也会马上返回（三种方式都遵守）。而如果有添加源则runloop将一直运行，不会退出。即使手动移除了源，也不会使得runloop会退出。</p>
<p>runUntilDate：和run差不多，只是多了一个截止日期。截止日期到了，则退出runloop，方法返回。</p>
<p>runMode：运行一次runloop后会退出。比如runloop期间处理了一个输入源事件，处理后会退出runloop，方法也会返回。注意处理定时器事件不会使得runloop退出，但如果调用invalidate则会退出。所以如果你想让runloop能够退出的话最好使用该方法。</p>
<p>前面两种方法即使调用 <code>[self.timer invalidate];</code> ，runloop也不会退出（少量情况下也会退出），这样线程就会一直存在，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程也是会强引用target的，所以这里线程和self循环引用了。</span></span><br><span class="line"><span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(createTimer1) object:<span class="literal">nil</span>];</span><br><span class="line">[<span class="keyword">self</span>.thread start];</span><br></pre></td></tr></table></figure>
<p>线程一直存在就会一直持有self，导致页面即使返回了也不会销毁。而如果在当前线程中强行调用 <code>+ (void)exit;</code> 退出线程，会因为一些资源没有正常释放而造成内存泄露，经过验证self依然是没有被释放的。所以只能使用第三种启动方式。</p>
<p>因此，在子线程中使用定时器，最佳实践就是使用GCD定时器。</p>
<h3 id="2-为什么MSWeakTimer的invalidate方法里必须是异步取消，同步取消不行吗？"><a href="#2-为什么MSWeakTimer的invalidate方法里必须是异步取消，同步取消不行吗？" class="headerlink" title="2.为什么MSWeakTimer的invalidate方法里必须是异步取消，同步取消不行吗？"></a>2.为什么MSWeakTimer的invalidate方法里必须是异步取消，同步取消不行吗？</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)invalidate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We check with an atomic operation if it has already been invalidated. Ideally we would synchronize this on the private queue,</span></span><br><span class="line">    <span class="comment">// but since we can&#x27;t know the context from which this method will be called, dispatch_sync might cause a deadlock.</span></span><br><span class="line">    <span class="keyword">if</span> (!OSAtomicTestAndSetBarrier(<span class="number">7</span>, &amp;_timerFlags.timerIsInvalidated))</span><br><span class="line">    &#123;</span><br><span class="line">        dispatch_source_t timer = <span class="keyword">self</span>.timer;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.privateSerialQueue, ^&#123;</span><br><span class="line">            dispatch_source_cancel(timer);</span><br><span class="line">            ms_release_gcd_object(timer);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如注释写的，如果我们在回调的方法里调用invalidate方法，那么将导致队列死锁。所以这里必须采用异步invalidate。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/aeae7b73aee2">Dispatch Source学习</a></p>
<p><a href="http://blog.lessfun.com/blog/2016/08/05/reliable-timer-in-ios/">更可靠和高精度的 iOS 定时器</a></p>
<p><a href="https://blog.csdn.net/qianlima210210/article/details/54799476">dispatch source理解</a></p>
<p><a href="https://juejin.cn/post/6844903486677581831">NSRunLoop的退出方式</a> 挺不错的</p>
<p><a href="https://juejin.cn/post/6844903775816122375">关于 performSelector 的一些小探讨</a></p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>NSTimer</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS循环播放视频</title>
    <url>/2022/05/29/iOS%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>有一个需求需要循环播放一个视频，UI希望的效果是无缝循环播放。当时觉得应该问题不大，但事实却并非如此。如果只是单纯的循环播放，确实简单。但是想要无缝丝滑连贯的循环播放却并不那么简单。</p>
<h3 id="方案一：ijkplayer"><a href="#方案一：ijkplayer" class="headerlink" title="方案一：ijkplayer"></a>方案一：ijkplayer</h3><p>项目中用的ijkplayer，刚开始是监听播放完成通知，播放完后重新播放，结果发现每次播完后都要停顿一下才会继续播放。达不到无缝循环的要求。</p>
<p>一顿搜索之后，发现可以通过设置option的loop属性，设置为100就是循环播放100次，设置1就是播放一次，设置0就是无线循环播放。这一次以为稳了，然并卵，还是每次播完后都要停顿一下才会继续播放。</p>
<p>又是一顿搜索，发现了ijkplayer可以播放contact文件，所谓contact文件就是按照一定的格式将要播放的视频地址按顺序写入一个文件，把这个文件丢给ijkplayer，ijkplayer就会按照顺序一个个播放，当时就在想是不是这种方式可以无缝播放呢？于是将视频的地址写了1000遍，这样ijkplayer就会播放1000次，达到一个循环播放的假象。然而还是没有什么卵用，效果和上面一样。</p>
<p>总结一下：ijkplayer的播放机制就是播完后会暂停，这一暂停就导致不连贯了，因此可以很明显的看到会停顿一下才继续播放。使用ijkplayer基本上做不到无缝循环播放视频。当然也有可能是我才疏学浅没找到正确的方式。</p>
<h3 id="方案二：AVPlayer"><a href="#方案二：AVPlayer" class="headerlink" title="方案二：AVPlayer"></a>方案二：AVPlayer</h3><p>ijkplayer既然不行，那就只能试一下系统的AVPlayer了，还是同样的思路，监听播放完成通知，播放完后重新播放，结果发现效果一样。</p>
<h3 id="方案三：AVQueuePlayer"><a href="#方案三：AVQueuePlayer" class="headerlink" title="方案三：AVQueuePlayer"></a>方案三：AVQueuePlayer</h3><p>最后找到一篇文章说是要使用AVPlayer的子类AVQueuePlayer，试了一下发现效果确实很不错，几乎看不出来有停顿的感觉。AVQueuePlayer应该会预加载要播放的资源，这样播放完后就可以立即加载渲染下一个视频的画面了。</p>
<p>总结：如果要无缝循环播放视频，AVQueuePlayer是一个不错的选择。</p>
<h3 id="方案四：GIF-Webp播放"><a href="#方案四：GIF-Webp播放" class="headerlink" title="方案四：GIF/Webp播放"></a>方案四：GIF/Webp播放</h3><p>本来我们项目中对ijkplayer做了一些修改支持播放透明视频，结果因为ijkplayer循环播放不丝滑，只能另辟蹊径。而系统播放器可定制程度不高，如果你需要先处理视频画面再播放，那么AVQueuePlayer可能也不行了，比如透明视频的无缝循环播放。然而这个需求就是需要透明视频的无缝循环播放，这不是巧了吗，于是AVQueuePlayer也被pass了。</p>
<p>最后实在是没有办法了，突然想到反正是播一个没声音的视频，为什么不直接自己一帧一帧播图片呢，这样连贯性肯定有保障了。于是让UI出了一个Webp资源，配合YYAnimateImageView播放，可以说是非常的丝滑。唯一不足的是资源大小变大了一倍，不过还能接受。</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>hexo next主题给文章添加版权信息</title>
    <url>/2022/05/07/hexo-next%E4%B8%BB%E9%A2%98%E7%BB%99%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="next主题下给文章添加版权信息"><a href="#next主题下给文章添加版权信息" class="headerlink" title="next主题下给文章添加版权信息"></a>next主题下给文章添加版权信息</h2><p>1、修改<code>_config.yml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>
<p>post的值改为true表示文章开启添加版权信息。</p>
<p>至此，部署后就可以看到每篇文章下面都会有版权信息了。但是有一些文章我们不想添加版权信息，那么还需要接着设置：</p>
<p>2、打开文件 <code>themes/next/layout/_macro/post.swig</code> ：</p>
<p>找到creative_commons那一行改为：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">&#123;%- if theme.creative_commons.license and theme.creative_commons.post and page.copyright %&#125;</span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123; <span class="name"><span class="built_in">partial</span></span>(<span class="name">&#x27;_partials/post/post-copyright.swig&#x27;</span>) &#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#123;%- endif %&#125;</span></span><br></pre></td></tr></table></figure>
<p>就是添加了 page.copyright ，这样就可以单独控制某篇文章是否添加版权信息了。</p>
<p>在文章开头的头部添加 <code>copyright: true</code> 表示当前文章要添加版权信息，false表示不需要。</p>
<p>可以修改模板文件，这样默认就有 <code>copyright: true</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://choubin.site/2019/12/30/CustomBlogTheme/">hexo 个人博客基于 NexT 主题的基本配置和定制优化</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>find命令</title>
    <url>/2022/06/19/find%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>在指定目录下查找文件。</p>
<p>使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件（即默认递归查找）。并且将查找到的子目录和文件全部进行显示。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> <span class="built_in">path</span> expression</span><br></pre></td></tr></table></figure>
<p>expression：表达式，选项，参数。</p>
<p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p>
<p>注意：path最好不要省略。</p>
<p>expression 中可使用的选项有二三十个之多，用到的时候可以查一下。</p>
<p>常见的有：</p>
<p>-print</p>
<p>-name</p>
<p>-iname</p>
<p>-maxdepth</p>
<p>-type</p>
<p>-and</p>
<p>-or</p>
<p>-not</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>eg1：列出当前目录及子目录下所有文件和文件夹</p>
<p><code>find .</code></p>
<p>结果：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line"><span class="string">./.DS_Store</span></span><br><span class="line"><span class="string">./compress.sh</span></span><br><span class="line"><span class="string">./compressed</span></span><br><span class="line"><span class="string">./compressed/</span>疑问<span class="string">.png</span></span><br><span class="line"><span class="string">./compressed/QQ20220619-004415</span>@2x.png</span><br><span class="line"><span class="string">./compressed/v2-ae634956702d53f64862c9fe58691e7d_1440w.jpg</span></span><br></pre></td></tr></table></figure>
<p>eg2：仅在当前目录查找。</p>
<p><code>find . -maxdepth 1</code></p>
<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">./.DS_Store</span><br><span class="line">./compress.sh</span><br><span class="line">./compressed</span><br></pre></td></tr></table></figure>
<p>eg3：在当前目录中查找指定的文件</p>
<p><code>find /Applications/Xcode.app -name symbolicatecrash</code></p>
<p>结果：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/</span>WatchSimulator.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/PrivateFrameworks/</span>DVTFoundation.framework/symbolicatecrash</span><br><span class="line"><span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/</span>AppleTVSimulator.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/PrivateFrameworks/</span>DVTFoundation.framework/symbolicatecrash</span><br><span class="line"><span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/PrivateFrameworks/</span>DVTFoundation.framework/symbolicatecrash</span><br><span class="line"><span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>SharedFrameworks<span class="regexp">/DVTFoundation.framework/</span>Versions<span class="regexp">/A/</span>Resources/symbolicatecrash</span><br></pre></td></tr></table></figure>
<p>在当前路径下递归查找以.txt结尾的文件</p>
<p><code>find . -name &quot;*.txt&quot;</code></p>
<p>eg4：仅在当前路径下查找以.png、.jpg、.jpeg结尾的文件</p>
<p><code>find . -maxdepth 1 -name &quot;*.png&quot; -or -name &quot;*.jpg&quot; -or -name &quot;*.jpeg&quot;</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wangchujiang.com/linux-command/c/find.html">find</a>  Linux命令搜索的一个网站</p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>find</tag>
      </tags>
  </entry>
  <entry>
    <title>自动压缩图片--你的第一个脚本</title>
    <url>/2022/06/19/%E8%87%AA%E5%8A%A8%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87--%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>在往图床上丢图片时，有时候总是因为图片太大而要等很久的时间，面对这种情况压缩图片后再上传是一个不错的选择。但是每次都要先打开图片压缩软件，再丢图片压缩，再找到压缩后的图片，再上传到图床，这一系列操作也是繁琐。今天就来解决一下这个问题。</p>
<p>很显然脚本能够帮助我们自动完成这些烦人的操作。我们希望这个脚本能够自动压缩当前文件夹的所有图片，压缩后将图片转移到另一个文件夹方便查找。</p>
<p>说干就干，lets go!</p>
<p>首先，我们需要安装一个图片压缩软件，这个图片压缩软件要能支持命令行操作，这里选择ImageOptim: <a href="https://imageoptim.com">https://imageoptim.com</a> ，到官网下载后安装即可。</p>
<p>其次，我们需要安装ImageOptim-CLI，有了它就可以用命令行操作图片压缩软件ImageOptim了。推荐使用npm安装特别是M1芯片的Mac，打开终端输入：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g imageoptim-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<p>安装完成后查看一下版本确定是否安装成功：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">imageoptim</span> --version</span><br><span class="line"><span class="attribute">3</span>.<span class="number">0</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>最后，就是写脚本了：目前我们只压缩png，jpg，jpeg，gif</p>
<p>随便打开一个文本编辑器比如记事本，拷贝下面的代码并保存为 <code>compress.sh</code> ，保存路径随意这里为桌面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">png=<span class="string">&quot;*.png&quot;</span></span><br><span class="line">jpg=<span class="string">&quot;*.jpg&quot;</span></span><br><span class="line">jpeg=<span class="string">&quot;*.jpeg&quot;</span></span><br><span class="line">gif=<span class="string">&quot;*.gif&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;目前只压缩：&quot;</span><span class="variable">$png</span><span class="string">&quot;、&quot;</span><span class="variable">$jpg</span><span class="string">&quot;、&quot;</span><span class="variable">$jpeg</span><span class="string">&quot;、&quot;</span><span class="variable">$gif</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始压缩&quot;</span></span><br><span class="line">imageoptim <span class="variable">$png</span> <span class="variable">$jpg</span> <span class="variable">$jpeg</span> <span class="variable">$gif</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;完成压缩&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始将图片移到compressed文件夹&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p compressed</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(find . -maxdepth 1 -name <span class="string">&quot;<span class="variable">$png</span>&quot;</span> -or -name <span class="string">&quot;<span class="variable">$jpg</span>&quot;</span> -or -name <span class="string">&quot;<span class="variable">$jpeg</span>&quot;</span> -or -name <span class="string">&quot;<span class="variable">$gif</span>&quot;</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;移动文件:<span class="variable">$&#123;file&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">mv</span> <span class="variable">$&#123;file&#125;</span> compressed</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;完成将图片移到compressed文件夹&quot;</span></span><br></pre></td></tr></table></figure>
<p>脚本很简单，就是压缩当前文件夹里的png，jpg，jpeg，gif图片，然后将这些压缩好的图片转移到compressed文件夹。当然这个时候计算机还只是认为它是一个普通的文本文件。我们需要将它赋予可执行属性：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~/Desktop</span><br><span class="line">chmod +x <span class="keyword">compress</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>这样compress.sh就变为一个可执行文件了。</p>
<p>最后测试一下效果吧^_^</p>
<p>在桌面创建一个文件夹pictureStorage，将compress.sh拖入到该文件夹里，再准备几张图片也放入到该文件夹里。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/QQ20220619-154224%402x.png" alt=""></p>
<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Desktop/pictureStorage</span><br><span class="line">./compress.sh</span><br></pre></td></tr></table></figure>
<p>就可看到打印日志：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">目前只压缩：<span class="operator">*</span>.png、<span class="operator">*</span>.jpg、<span class="operator">*</span>.jpeg、<span class="operator">*</span>.gif</span><br><span class="line">开始压缩</span><br><span class="line">Running ImageOptim...</span><br><span class="line">✓ 疑问.png <span class="params">was:</span> <span class="number">223</span>kB <span class="params">now:</span> <span class="number">180</span>kB <span class="params">saving:</span> <span class="number">43.3</span>kB (<span class="number">19.44</span>%)</span><br><span class="line">✓ v2-ae634956702d53f64862c9fe58691e7d_1440w.jpg <span class="params">was:</span> <span class="number">22.3</span>kB <span class="params">now:</span> <span class="number">5.39</span>kB <span class="params">saving:</span> <span class="number">16.9</span>kB (<span class="number">75.86</span>%)</span><br><span class="line">✓ 王境泽<span class="number">1</span>.gif <span class="params">was:</span> <span class="number">1.02</span>MB <span class="params">now:</span> <span class="number">935</span>kB <span class="params">saving:</span> <span class="number">85.4</span>kB (<span class="number">8.37</span>%)</span><br><span class="line">✓ TOTAL <span class="params">was:</span> <span class="number">1.27</span>MB <span class="params">now:</span> <span class="number">1.12</span>MB <span class="params">saving:</span> <span class="number">146</span>kB (<span class="number">11.51</span>%)</span><br><span class="line">✓ Finished</span><br><span class="line">完成压缩</span><br><span class="line">开始将图片移到compressed文件夹</span><br><span class="line">移动文件:.<span class="operator">/</span>疑问.png</span><br><span class="line">移动文件:.<span class="operator">/</span>王境泽<span class="number">1</span>.gif</span><br><span class="line">移动文件:<span class="symbol">./v2-ae634956702d53f64862c9fe58691e7d_1440w.jpg</span></span><br><span class="line">完成将图片移到compressed文件夹</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/QQ20220619-155225%402x.png" alt=""></p>
<p>三张图片一共减少了146kB，还是可以的。</p>
<p>以后你就只需要将图片丢到pictureStorage文件夹，然后执行 <code>./compress.sh</code> 脚本就可以了！完全不需要打开ImageOptim，一张张选了。真是安全又方便！</p>
]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>图片压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>字节序解析</title>
    <url>/2022/07/01/%E5%AD%97%E8%8A%82%E5%BA%8F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节间的顺序。主要有两种：大端序和小端序。当然你也可以规定其他的顺序，但这两种顺序是规则最简单的了。</p>
<p>内存：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">内存：   -------------------------------&gt;</span><br><span class="line">内存地址：0      <span class="number"> 1 </span>     <span class="number"> 2 </span>      3</span><br></pre></td></tr></table></figure>
<p>大端序：从左往右读，最左边为最高位。反映在内存即最低地址为最高位，最高地址为最低位。<br>小端序：从右往左读，最右边为最高位。反映在内存即最低地址为最低位，最高地址为最高位。<br>可以看到，大端序和小端序最高位到最低位的顺序刚好相反，是翻转的关系。</p>
<p>为什么会有字节序？<br>因为一串数字可以从左开始读，也可以从右开始读。如果不规定读的顺序，那么就无法得知正确的信息。<br>比如：一张纸上写着1234<br>按大端序读，最左边的1就是最高位，结果就是一千两百三十四<br>按小端序读，最右边4就是最高位，最左边的1反而是最低位，结果就是四千三百二十一<br>可以看到对于同一串文本，读的顺序不同，得到的结果也会不同。大部分国家都是从左到右读，但也有的国家是从右到左读的。没有好坏，纯属习惯问题。因此数字“一千两百三十四”，对于从左到右读的国家，书写出来就是1234。而对于从右到左读的国家，书写出来就是4321。大小端只是记法不同，表达的数字还是同一个。</p>
<p>CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。所以一般计算机的内部处理都是小端字节序（目前为止我就还没遇到过采用大端存储的机器）。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合比如网络传输和文件储存，几乎都是用的大端字节序。</p>
<p>举例：</p>
<p>0x1234<br>0001 0010 0011 0100 （采用大端序存储）-&gt; 0010 1100 0100 1000（采用小端序存储，根据大端翻转即可）<br>1234                                                            -&gt;  3412（第一个字节代表的就是0x34，小端从右往左读）</p>
<p>0x01<br>0000 0000 0000 0000 0000 0000 0000 0001（大端序）<br>-&gt;<br>1000 0000 0000 0000 0000 0000 0000 0000（小端序）</p>
<h4 id="判断当前机器的端序"><a href="#判断当前机器的端序" class="headerlink" title="判断当前机器的端序"></a>判断当前机器的端序</h4><p>可以采用以下代码判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b;</span><br><span class="line">&#125;c;</span><br><span class="line">c.a = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> isLittleEndian = <span class="number">1</span> == c.b;</span><br></pre></td></tr></table></figure>
<p>如果是小端序那么最低位1在最低地址，char占一个字节，c.b就等于1。<br>如果是大端序那么最低位1在最高地址，char占一个字节，c.b就等于0。</p>
<p>虽然大部分计算机的内部处理都是采用小端字节序，但还是有一些计算机采用的是大端字节序。那么这两台计算机通信时该如何确保正确性呢？<br>很简单，可以规定网络传输时必须采用大端字节序传输即先传输最高字节依此类推直到最低字节，两端收到后各自自行转换即可。这样就不必增加协议传递字节序信息了。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">hton端转换器  &lt;--&gt;  网络传输 &lt;--&gt; ntoh端转换器</span><br><span class="line">   |　　　　　　　　　　　　　　　　　　|</span><br><span class="line"> A电脑　　　　　　　　　　　　　　　　B电脑</span><br></pre></td></tr></table></figure>
<p>通过端转换器，以及规定网络传输时必须采用大端字节序，就可以屏蔽电脑的具体字节序了。所以如果你要发送一个数字给对方，你要先用端转换器将host端转为大端，另一端收到后再将大端转换为host端，这样你们两个理解的才是同一个数字。测试代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> test_bit_data1(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="type">short</span> a = <span class="number">0x5678</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *dataA = [[<span class="built_in">NSData</span> alloc] initWithBytes:&amp;a length:<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;a = %d, hex:0x%x, data:%@&quot;</span>, a, a, dataA); <span class="comment">//hex:0x5678 data:0x7856</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传输时将host端序转为大端序</span></span><br><span class="line">    <span class="type">short</span> b = <span class="built_in">NSSwapHostShortToBig</span>(a);</span><br><span class="line">    <span class="built_in">NSData</span> *dataB = [[<span class="built_in">NSData</span> alloc] initWithBytes:&amp;b length:<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;b = %d, hex:0x%x, data:%@&quot;</span>, b, b, dataB); <span class="comment">//hex:0x7856 data:0x5678</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">    [dataB getBytes:&amp;c range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>))];</span><br><span class="line">    <span class="built_in">NSData</span> *dataC = [[<span class="built_in">NSData</span> alloc] initWithBytes:&amp;c length:<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;c = %d, hex:0x%x, data:%@&quot;</span>, c, c, dataC); <span class="comment">//hex:0x7856 data:0x5678</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//收到后将大端序转为host端序</span></span><br><span class="line">    <span class="type">short</span> d = <span class="built_in">NSSwapBigShortToHost</span>(c);</span><br><span class="line">    <span class="built_in">NSData</span> *dataD = [[<span class="built_in">NSData</span> alloc] initWithBytes:&amp;d length:<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;d = %d, hex:0x%x, data:%@&quot;</span>, d, d, dataD); <span class="comment">//hex:0x5678 data:0x7856</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比特序"><a href="#比特序" class="headerlink" title="比特序"></a>比特序</h3><p>比特间的顺序。事实上只要有两位bit，就需要规定读顺序了。比特序同样分为大端比特序和小端比特序。通常小端字节序的CPU也采用小端比特序，大端字节序的CPU采用大端比特序。但是这个不绝对，也有大端字节序的CPU采用小端比特序。比特序对于软件层是个黑箱通常不需要关心，不必纠结机器到底是采用哪种比特序存储一个字节的。</p>
<p>对于一个字节的整型值机器到底是采用哪种比特序存储的，我曾经花了很长的时间去查资料，但是说啥的都有。最后还是自己写了个程序验证一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_bit_order_in_byte</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bs</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> b0: <span class="number">1</span>,</span><br><span class="line">                          b1: <span class="number">1</span>,</span><br><span class="line">                          b2: <span class="number">1</span>,</span><br><span class="line">                          b3: <span class="number">1</span>,</span><br><span class="line">                          b4: <span class="number">1</span>,</span><br><span class="line">                          b5: <span class="number">1</span>,</span><br><span class="line">                          b6: <span class="number">1</span>,</span><br><span class="line">                          b7: <span class="number">1</span>;</span><br><span class="line">        &#125;data;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bs1</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> b0_1: <span class="number">2</span>,</span><br><span class="line">                          b2_3: <span class="number">2</span>,</span><br><span class="line">                          b4_5: <span class="number">2</span>,</span><br><span class="line">                          b6_7: <span class="number">2</span>;</span><br><span class="line">        &#125;data1;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bs2</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> b0_3: <span class="number">4</span>,</span><br><span class="line">                          b4_7: <span class="number">4</span>;</span><br><span class="line">        &#125;data2;</span><br><span class="line">    &#125;ua;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     0x34</span></span><br><span class="line"><span class="comment">     大端：0011 0100</span></span><br><span class="line"><span class="comment">     小端：0010 1100</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     //0010 1100</span></span><br><span class="line"><span class="comment">     //0 1 3 0</span></span><br><span class="line"><span class="comment">     //4 3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ua.a = <span class="number">0x34</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:%d\n&quot;</span>, ua.a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b0:%d\n&quot;</span>, ua.data.b0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b1:%d\n&quot;</span>, ua.data.b1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b2:%d\n&quot;</span>, ua.data.b2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b3:%d\n&quot;</span>, ua.data.b3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b4:%d\n&quot;</span>, ua.data.b4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b5:%d\n&quot;</span>, ua.data.b5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b6:%d\n&quot;</span>, ua.data.b6);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b7:%d\n&quot;</span>, ua.data.b7);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b0_1:%d\n&quot;</span>, ua.data1.b0_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b2_3:%d\n&quot;</span>, ua.data1.b2_3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b4_5:%d\n&quot;</span>, ua.data1.b4_5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b6_7:%d\n&quot;</span>, ua.data1.b6_7);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b0_3:%d\n&quot;</span>, ua.data2.b0_3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b4_7:%d\n&quot;</span>, ua.data2.b4_7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小端字节序机器运行：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span>:<span class="number">52</span></span><br><span class="line"><span class="attribute">b0</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">b1</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">b2</span>:<span class="number">1</span></span><br><span class="line"><span class="attribute">b3</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">b4</span>:<span class="number">1</span></span><br><span class="line"><span class="attribute">b5</span>:<span class="number">1</span></span><br><span class="line"><span class="attribute">b6</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">b7</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">b0_1</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">b2_3</span>:<span class="number">1</span></span><br><span class="line"><span class="attribute">b4_5</span>:<span class="number">3</span></span><br><span class="line"><span class="attribute">b6_7</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">b0_3</span>:<span class="number">4</span></span><br><span class="line"><span class="attribute">b4_7</span>:<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>可以看到小端字节序机器，对于0x34，它的比特顺序是0010 1100，还是小端。如果小端字节序的CPU采用大端比特序这不疯了吗。所以我更倾向于：小端字节序的CPU也采用小端比特序，大端字节序的CPU采用大端比特序。</p>
<p>但是网络传输的时候还是一个bit接一个bit发送的，那比特顺序不一样的两台机器收发不会出问题吗？比如发一个unsigned char 整型值0x34。从实际情况来看，确实没有问题，怎么做到的？查了很多资料，比较可信的说法：<br>在以太网(Ethernet)中，发送一个字节是从最低有效比特位到最高有效比特位的发送顺序，也就是最低有效比特位首先发送。接收方接收到的数据顺序和发送方发送的bit顺序一致，收到后网卡会把接收到的比特序转换成主机的比特序。这一过程对CPU、软件都是不可见的，所以一般不需要关心比特间的顺序，只需要关心字节间的顺序。比如单字节0x34，不管发送方是大端还是小端，对端收到后肯定还是0x34。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">发送端大端:</span> <span class="number">0011 </span><span class="number">0100</span>      </span><br><span class="line"><span class="string">网络传输:</span>   <span class="number">0010 </span><span class="number">1100</span>    </span><br><span class="line"><span class="string">接收端小端:</span> <span class="number">0010 </span><span class="number">1100</span>    </span><br><span class="line"></span><br><span class="line"><span class="string">发送端小端:</span> <span class="number">0010 </span><span class="number">1100</span> </span><br><span class="line"><span class="string">网络传输:</span>   <span class="number">0010 </span><span class="number">1100</span></span><br><span class="line"><span class="string">接收端大端:</span> <span class="number">0011 </span><span class="number">0100</span></span><br></pre></td></tr></table></figure>
<p>单个字节不需要端序转换，两端也能正确理解，两端中的比特顺序可能不一致，但表达的是同一个数字。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Q1：真机查看一下整数、字符串在内存里的二进制表示？</p>
<p>测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_number_and_char</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;1234&quot;</span>; <span class="comment">//字符1对应的ascii码就是0x31</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = 0x%x, ch = %s\n&quot;</span>, a, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小端机器运行</p>
<p>int整型0x1234</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/image-20221020110929974.png" alt=""></p>
<p>数字在内存里是按小端字节序存储的。</p>
<p>字符串”1234”</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20221020110814.png" alt=""></p>
<p>可以看到小端机器，字符串在内存里是按大端字节序存储的。</p>
<p>Q2：查看文本文件的字节序？</p>
<p>作为一个文本文件，个人觉得是要说明编码规则和字节序的。当然有的编码不需要特别说明字节序比如utf-8。（有空再研究吧）</p>
<p>Q3：一段字符串从A电脑网络传输到B电脑需要考虑字节序吗？</p>
<p>不需要，因为字符串无论在大端还是小端机器都是以大端字节序存储的，网络传输时也是按大端字节序传输的，对端收到后同样是大端字节顺序，所以两端理解的是同一个东西。至于单字节里的比特序可能会不一样。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://cloud.tencent.com/developer/article/1476226">字节序: 一个不是很重要的概念</a></p>
<p><a href="https://www.wikiwand.com/en/Bit_numbering">Bit numbering</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/544398250">一文带你秒懂 字节序(byte order)，比特序(bit order)，位域(bit field)</a></p>
<p><a href="https://blog.csdn.net/shaohui973/article/details/115766497">Ethernet下字节序和bit序的总结</a>   这两篇文章bit发送顺序的观点刚好相反。</p>
<p><a href="https://www.linecall.de/wp-content/uploads/2016/11/802.3-2015_SECTION1.pdf">MAC帧的八位字节发送顺序</a>  优先发送最低位。Each octet of the MAC frame, with the exception of the FCS, is transmitted least significant bit first.</p>
<p><a href="https://blog.csdn.net/liuxingen/article/details/45420455">字节序(byte order)和位序(bit order)</a>  3⭐️</p>
<p><a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html">理解字节序</a></p>
<p><a href="https://blog.erratasec.com/2016/11/how-to-teach-endian.html#.Y05SIexBxvc">How to teach endian</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1673920">C语言打印数据的二进制格式-原理解析与编程实现</a></p>
<p><a href="https://www.cnblogs.com/leesf456/p/5317574.html">【字符编码】彻底理解字符编码</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>字节序</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP各版本特性</title>
    <url>/2022/03/28/HTTP%E5%90%84%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="HTTP各版本特性"><a href="#HTTP各版本特性" class="headerlink" title="HTTP各版本特性"></a>HTTP各版本特性</h3><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h4><p>1991年发布</p>
<p>基本上只是一个草稿，设计的初衷只是为了获取简单的HTML对象。只支持GET。没怎么使用就被HTTP 1.0代替了。</p>
<h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h4><p>1996年5月发布规范 rfc1945</p>
<p>第一个广泛使用的版本。</p>
<p><strong>相比HTTP 0.9</strong>：</p>
<ol>
<li><p>增加了对多媒体对象的处理，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。</p>
</li>
<li><p>增加了一些方法：POST，HEAD。丰富了浏览器与服务器的互动手段。</p>
</li>
<li><p>新增了HTTP首部。比较重要的有Content-Type ，Content-Length，Content-Encoding</p>
</li>
<li><p>HTTP请求和响应格式的改变。</p>
</li>
<li><p>其他新增功能。比如状态码的定义。</p>
</li>
</ol>
<p>请求报文：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">请求行  eg：GET <span class="symbol">/u/2167612f3a86</span> HTTP<span class="symbol">/1.1</span></span><br><span class="line">请求头</span><br><span class="line"></span><br><span class="line">请求体</span><br></pre></td></tr></table></figure>
<p>响应报文：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">响应行  eg：HTTP/<span class="number">1.1 200</span> OK</span><br><span class="line">响应头</span><br><span class="line"></span><br><span class="line">响应体</span><br></pre></td></tr></table></figure>
<p><strong>HTTP/1.0 缺点：</strong></p>
<p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>
<p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p>
<p>为了解决这个问题，在还没出HTTP/1.1规范时，各个公司可能会有一些自己的优化手段。有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Connection</span>: keep-alive</span><br><span class="line"><span class="keyword">Connection</span>: <span class="keyword">close</span></span><br></pre></td></tr></table></figure>
<p>Connection头部，用于决定当前的事务完成后，是否会关闭网络连接。</p>
<p>如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得<strong>对同一个服务器的请求</strong>可以继续在该连接上完成。</p>
<p>如果该值是“close”表明客户端或服务器想要关闭该网络连接。</p>
<p>像这种做的比较好的优化可能就会被放到下一次的RFC规范中去。Connection头部就被HTTP/1.1规范所采用。</p>
<h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h4><p>1999年6月发布规范 rfc2616</p>
<p>进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>
<p><strong>相比HTTP/1.0：</strong></p>
<p><strong>1.引入了持久连接（persistent connection）</strong></p>
<p>通过Connection头部控制，HTTP/1.0默认是close，HTTP/1.1默认是keep-alive。请求完成后TCP连接默认不关闭，因此可以被多个请求复用。</p>
<p>在HTTP 1.0中，没有官方的keepalive操作。通常是在现有协议上添加一个首部。如果浏览器支持keep-alive，它会在请求的包头中添加：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Connection:</span> <span class="meta">Keep</span>-Alive</span><br></pre></td></tr></table></figure>
<p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Connection:</span> <span class="meta">Keep</span>-Alive</span><br></pre></td></tr></table></figure>
<p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。</p>
<p>在HTTP 1.1中所有的连接默认都是持续连接，除非特殊声明不支持。</p>
<p>持久连接的好处：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Persistent HTTP connections have a <span class="built_in">number</span> <span class="keyword">of</span> advantages:</span><br><span class="line">• By opening <span class="keyword">and</span> closing fewer TCP connections, CPU <span class="built_in">time</span> <span class="keyword">is</span> saved <span class="keyword">in</span> routers <span class="keyword">and</span> hosts (clients, servers, proxies, gateways, tunnels, <span class="keyword">or</span> caches), <span class="keyword">and</span> memory used <span class="keyword">for</span> TCP protocol control blocks can be saved <span class="keyword">in</span> hosts.</span><br><span class="line"></span><br><span class="line">• HTTP requests <span class="keyword">and</span> responses can be pipelined <span class="keyword">on</span> a connection. Pipelining allows a client <span class="keyword">to</span> make multiple requests <span class="keyword">without</span> waiting <span class="keyword">for</span> each response, allowing a single TCP connection <span class="keyword">to</span> be used much more efficiently, <span class="keyword">with</span> much lower elapsed <span class="built_in">time</span>.</span><br><span class="line"></span><br><span class="line">• Network congestion <span class="keyword">is</span> reduced <span class="keyword">by</span> reducing <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> packets caused <span class="keyword">by</span> TCP opens, <span class="keyword">and</span> <span class="keyword">by</span> allowing TCP sufficient <span class="built_in">time</span> <span class="keyword">to</span> determine <span class="keyword">the</span> congestion state <span class="keyword">of</span> <span class="keyword">the</span> network.</span><br><span class="line"></span><br><span class="line">• Latency <span class="keyword">on</span> subsequent requests <span class="keyword">is</span> reduced <span class="keyword">since</span> there <span class="keyword">is</span> no <span class="built_in">time</span> spent <span class="keyword">in</span> TCP’s connection opening handshake.</span><br><span class="line"></span><br><span class="line">• HTTP can evolve more gracefully, <span class="keyword">since</span> errors can be reported <span class="keyword">without</span> <span class="keyword">the</span> penalty <span class="keyword">of</span> closing <span class="keyword">the</span> TCP connection. Clients using future versions <span class="keyword">of</span> HTTP might optimistically <span class="keyword">try</span> a new feature, <span class="keyword">but</span> <span class="keyword">if</span> communicating <span class="keyword">with</span> an older server, retry <span class="keyword">with</span> old semantics <span class="keyword">after</span> an <span class="keyword">error</span> <span class="keyword">is</span> reported.</span><br><span class="line"></span><br><span class="line">HTTP implementations SHOULD implement persistent connections.</span><br></pre></td></tr></table></figure>
<p>RFC 上列举了这么多其实就两点</p>
<ol>
<li>持久连接为连接的复用提供基础，从而减少了额外的TCP连接，以及TCP刚连接时的慢启动带来的损耗。</li>
<li>持久连接为管线机制提供基础。</li>
</ol>
<p>注意：使用持久连接时，就不能通过连接的断开作为报文的终止符了。每个报文最好提供一个Content-Length要不然没法区分各报文的边界。而对于动态生成的文件因为无法提供content-length，所以最好采用分块（chunked）传输，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束。</p>
<p>使用了持久连接对比图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/D7A734A6FA0923F4C7E86A2F647AB26B.jpg" alt=""></p>
<p><strong>2.管线机制（Pipelining）</strong></p>
<p>在使用持久连接后，管线机制可以让客户端在上一个响应还没回来时就可以发送下一个请求。但是服务器端返回的响应的顺序必须按照接收到的请求的顺序来发送（如果服务器没有按照该规则实现的话，客户端接收到的将是混杂数据）。参考 <a href="https://github.com/AFNetworking/AFNetworking/issues/528">AF issue #528</a></p>
<p>比如服务器收到客服端发来的A-B-C三个请求，那么返回响应时必须A的响应发完后才能再发B的，B的发完后再发C的。</p>
<p>聪明的你可能已经看到管线机制的缺点了，如果第一个请求需要处理的时间非常长，那么后续的请求即使已经被服务器处理完成，响应也不能立即返回，而是存储在服务端的缓存区中，等待第一个响应的完成，才能按照FIFO顺序返回。这就是队头阻塞。</p>
<p>正是由于存在这样或那样的问题，HTTP管道技术的应用比较有限，并没有大面积推广开来，基本上是关的，即使一些支持它的浏览器也仅仅把它作为一个高级选项。这些缺点将在HTTP2中得以解决。</p>
<p>使用了管线机制对比图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/MbAOA.png" alt=""></p>
<p>这里需要对pipelining图做一点解释</p>
<p>管线机制，A，B，C的响应数据是不可以交叉返回的。因为如果交叉的话，客户端根本无法区分收到的数据属于哪个请求。既然A，B，C的响应是顺序返回的也就是A的响应必须发完后才能再发B的，那么如果A是一个下载大文件的请求，B，C都是小数据请求，那么客户端将会等很久才能收到B，C的响应，这就是队头阻塞。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/sdCNX.png" alt=""></p>
<p><strong>3.新增了一些方法</strong></p>
<p>OPTIONS，PUT，DELETE，TRACE，CONNECT。</p>
<p><strong>4.新增了一大波状态码</strong></p>
<p>在HTTP1.1中新增了24个错误状态响应码。</p>
<p><strong>5.完善了缓存机制</strong></p>
<p>在 HTTP 1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP 1.1则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
<p>关于HTTP的缓存机制这里不做展开，因为这又是一个很大的话题。</p>
<p><strong>6.新增了一大波首部</strong></p>
<p>比如跟缓存控制相关的就增加了很多，还有Content-Range， Host， Range等。</p>
<p><strong>Host首部</strong></p>
<p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。由于HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。</p>
<p><strong>7.带宽优化</strong></p>
<p>HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。</p>
<p>另外一种情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。注意，HTTP/1.0的客户端不支持100响应码。但可以让客户端在请求消息中加入Expect头域，并将它的值设置为100-continue。</p>
<p><strong>8.分块传输编码</strong></p>
<p>HTTP消息中可以包含任意长度的实体，通常它们使用Content-Length来给出消息结束标志。但是，对于很多动态产生的响应，只能通过缓冲完整的消息来判断消息的大小，但这样做会加大延迟。</p>
<p>1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/分块传输编码">“分块传输编码”</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。</p>
<p>新增MIME类型 <code>multipart/form-data</code> 等。</p>
<p><strong>HTTP/1.1缺点：</strong></p>
<p><strong>1.队头阻塞</strong></p>
<p>在使用持久连接后，管线机制可以让客户端在上一个响应还没回来时就可以发送下一个请求。但是服务器端返回的响应的顺序必须按照接收到的请求的顺序来发送。如果第一个请求需要处理的时间非常长，那么后续的请求即使已经被服务器处理完成，响应也不能立即返回，而是存储在服务端的缓存区中，等待第一个响应的完成，才能按照FIFO顺序返回。这就是队头阻塞。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、雪碧图、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<p>另外HTTP连接也不是想开多少就开多少的，HTTP1.1，Chrome浏览器通常允许每个域名同时发出的最大连接数为6个。这意味着在同一个页面中，您可以同时发出6个同源请求。请注意，这个限制是针对每个域名的，如果您的页面使用了多个域名（例如使用CDN），那么您可以同时发出更多的请求。对于超过限制数目的请求会被阻塞直到一些请求完成才会继续发出。所以一些优化就会把资源放在不同的域名下。</p>
<p><a href="https://stackoverflow.com/questions/14810890/what-are-the-disadvantages-of-using-http-pipelining">What are the disadvantage(s) of using HTTP pipelining?</a>  讨论管线机制的缺点的。里面参考资料中我大苹果WWDC2015里就已经对比了HTTP1.1和HTTP2的性能，奈何自己没看WWDC。作为一个iOS开发者，WWDC必看才行。</p>
<p><strong>2.无状态特性 – 带来巨大的 HTTP 头部</strong></p>
<p>由于报文 Header 一般会携带”User Agent” “Cookie”“Accept””Server”等许多固定的头字段（如下图），多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、 204/301/304 响应），成了不折不扣的“大头儿子”。Header 里携带的内容过大，在一定程度上增加了传输成本。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费。</p>
<h4 id="SPDY协议"><a href="#SPDY协议" class="headerlink" title="SPDY协议"></a>SPDY协议</h4><p>谷歌出品，于2009 年公开</p>
<p>因为 HTTP/1 的问题，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议本身，直到 2009 年，谷歌公开了自行研发的 SPDY 协议，它主要解决 HTTP/1.1 效率不高的问题。</p>
<p>直到这时，才算是正式改造了 HTTP 协议本身。SPDY 进行延迟降低、header 压缩等改进，其实践证明了这些优化的效果，也最终带来了 HTTP/2 的诞生。</p>
<h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h4><p>2015年5月发布规范 rfc7540</p>
<p><strong>相比HTTP/1.1：</strong></p>
<p><strong>1.二进制协议</strong></p>
<p>之前的HTTP版本可以说是一个文本协议，需要按照一定的书写格式，双方才能正确解析。但HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<p>接下来我们介绍几个重要的概念：</p>
<ul>
<li>流（Stream）：流是连接中的一个虚拟信道，<strong>可以承载双向的消息</strong>；每个流都有一个唯一的整数标识符（1、2…N）；</li>
<li>消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li>
<li>帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等</li>
</ul>
<p>一个 TCP 连接（HTTP2 连接建立在 TCP 连接之上）里可以发送若干个流（stream），每个流中可以传输若干条消息（message），每条消息由若干二进制帧（frame）组成。</p>
<p>注：流还是挺复杂的，具体可以看一下流的状态图。</p>
<p>HTTP 2的帧布局如下：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20200821155127.png" alt=""></p>
<p>所有的帧都以一个固定的9字节的头开始，后面跟着的是长度可变的payload。</p>
<p>帧头字段的定义：</p>
<p>Length：24bit，无符号整型，最大2^14 (16,384) ，帧的长度还受到SETTINGS_MAX_FRAME_SIZE帧的限制。该值不包含固定的9字节帧头，就是payload的长度。</p>
<p>Type：8bit，代表帧的类型。比如DATA帧和HEADERS帧。对于各种帧可以抓包学习一下。</p>
<p>Flags：具体帧的标识</p>
<p>R：保留位。</p>
<p>Stream Identifier：流ID。无符号31位整型。值0是保留的。每个流都有一个唯一的整数 ID。流ID就是用来标识该帧属于哪个流的，这样一个连接上传输的帧才能知道自己属于哪个流，接收方才能正确的进行拼接帧不至于拼接了别的流的帧。可以预见单个流的所有帧之间是有序的。</p>
<p>RFC规定由客户端初始化的流使用奇数ID，由服务器初始化的流使用偶数ID，这里不是很懂，什么情况下服务器会初始化流？请求不都是由客户端发起的吗？</p>
<p>在RFC 8.2.2.  Push Responses中有说明：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">After sending <span class="keyword">the</span> PUSH_PROMISE frame, <span class="keyword">the</span> server can begin delivering</span><br><span class="line"><span class="keyword">the</span> pushed response <span class="keyword">as</span> <span class="keyword">a</span> response (Section <span class="number">8.1</span><span class="number">.2</span><span class="number">.4</span>) <span class="keyword">on</span> <span class="title">a</span> <span class="title">server</span>-</span><br><span class="line">initiated stream that uses <span class="keyword">the</span> promised stream identifier.</span><br></pre></td></tr></table></figure>
<p>果然是服务器推送时，服务器会初始化流，此时流的ID就为偶数。</p>
<p><strong>二进制分帧层</strong></p>
<p>在不改动 HTTP/1.1 的语义、⽅法、状态码、URI 以及⾸部字段等等的情况下, HTTP/1.1 是如何转到HTTP/2呢? </p>
<p>答案就是HTTP/1.1 的报文先经过⼀个⼆进制分帧层将其转化为HTTP/2 二进制协议，后面的就是一样的了。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/2860230-0c2d3d66de3e9a87.png" alt=""></p>
<p>在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，这一特性，使性能有了极大提升：</p>
<ul>
<li><strong>同个域名</strong>只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应，消除了因多个 TCP 连接而带来的延时和内存消耗。</li>
<li>可以并行交错地发送多个请求，请求之间互不影响。</li>
<li>可以并行交错地发送多个响应，响应之间互不干扰。</li>
<li>在 HTTP/2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li>
</ul>
<p><strong>2.多路复用</strong></p>
<p>HTTP/2 复用TCP连接，在一个连接里，客户端可以同时发送多个请求，服务器端回复的响应也不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>
<p>客户端根据流ID来区分不同的帧从而分别得到A和B的响应。</p>
<p><strong>3.Header 压缩</strong></p>
<p>HTTP2.0 使用 HPACK 算法对 header 的数据进行压缩，减少请求的大小，减少流量消耗，提高效率。因为之前存在一个问题是，每次请求都要带上 header，而这个 header 中的数据通常是不变的。</p>
<p><strong>4.Server Push</strong></p>
<p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>
<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
<p><strong>HTTP/2 缺点：</strong></p>
<p><strong>1.没有彻底解决队头阻塞</strong></p>
<p>HTTP/2 并没有彻底解决队头阻塞，由于HTTP2是在一个TCP连接上发送请求，接收请求的。一旦出现丢包，丢失的包必须要等待重新传输确认，因此HTTP/2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP 连接中的所有请求。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反倒只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p>
<p><strong>2.TCP 和 TCP+TLS 建立连接的延时</strong></p>
<p>HTTP/2 是使用 TCP 协议来传输的。如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</p>
<p>上面两个问题要动大刀才能解决，因为这是底层支撑的 TCP 协议造成的。要想优化的话，只能替换底层的TCP了。</p>
<p>HTTP/3及谷歌的QUIC协议（主要是谷歌，毕竟只要谷歌搞完后测试正常，RFC直接将其定为规范就完事了）就是为解决上述问题而提出的方案。</p>
<p><strong>参考</strong></p>
<p><a href="https://developers.google.com/web/fundamentals/performance/http2">HTTP/2 简介</a></p>
<p><a href="https://blog.wangriyu.wang/2018/05-HTTP2.html">HTTP2 详解</a></p>
<p><a href="https://skyao.io/learning-http2/frame/">HTTP2/帧</a></p>
<h4 id="QUIC和HTTP-3"><a href="#QUIC和HTTP-3" class="headerlink" title="QUIC和HTTP/3"></a>QUIC和HTTP/3</h4><p>HTTP/3 已于 2022年6月6日正式发布了，被标准化为 RFC 9114。</p>
<p>QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以就比 TCP 来得快。此外，QUIC 也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="为什么要复用连接"><a href="#为什么要复用连接" class="headerlink" title="为什么要复用连接?"></a>为什么要复用连接?</h4><p>HTTP耗时 = TCP握手</p>
<p>HTTPS耗时 = TCP握手 + SSL握手</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">curl <span class="operator">-</span>w <span class="string">&quot;TCP handshake: %&#123;time_connect&#125;, SSL handshake: %&#123;time_appconnect&#125;<span class="char escape_">\n</span>&quot;</span> <span class="operator">-</span>so <span class="symbol">/dev/null</span> https:<span class="symbol">//www.alipay.com</span></span><br><span class="line">TCP <span class="params">handshake:</span> <span class="number">0.035926</span>, SSL <span class="params">handshake:</span> <span class="number">0.138877</span></span><br></pre></td></tr></table></figure>
<p>上面命令中的w参数表示指定输出格式，time_connect变量表示TCP握手的耗时，time_appconnect变量表示SSL握手的耗时（更多变量请查看<a href="http://curl.haxx.se/docs/manpage.html">文档</a>和<a href="https://josephscott.org/archives/2011/10/timing-details-with-curl/">实例</a>），s参数和o参数用来关闭标准输出。另外青花瓷抓包也可以看到各阶段的耗时。</p>
<p>可以看到如果不复用连接，那么每次都要3次TCP握手建立TCP连接，7次SSL握手建立SSL连接，而这些连接的建立都需要耗时，特别是建立SSL连接耗时更大，差不多是TCP的2-3倍。</p>
<p>除了建立连接耗时外，TCP的慢启动机制也会影响传输速度。</p>
<p>因此从HTTP1.1版本开始就支持连接的复用了，只不过HTTP1.1版本的连接复用还不成熟，毕竟技术都有一个不断优化的过程，从来都不是一蹴而就的。</p>
<p><a href="https://www.iteye.com/blog/a280606790-1095085">HTTP协议头部与Keep-Alive模式详解</a></p>
<h4 id="HTTP2，帧间顺序如何保证？"><a href="#HTTP2，帧间顺序如何保证？" class="headerlink" title="HTTP2，帧间顺序如何保证？"></a>HTTP2，帧间顺序如何保证？</h4><p>（网上的博客）:流内部的帧是有严格顺序的（不确定是由协议字段来保证还是由发送端严格按照顺序发送来保证，感觉应该是由发送端来保证，因为协议里没有相关字段），但是流之间互相独立；<strong>流 ID 不能重用</strong>，只能<strong>顺序</strong>递增，客户端发起的 Stream ID 是奇数，服务器端发起的 Stream ID 是偶数；</p>
<h4 id="HTTP1-1如何协商升级到HTTP2"><a href="#HTTP1-1如何协商升级到HTTP2" class="headerlink" title="HTTP1.1如何协商升级到HTTP2"></a>HTTP1.1如何协商升级到HTTP2</h4><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade, HTTP2-Settings</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>h2c</span><br><span class="line"><span class="attribute">HTTP2-Settings</span><span class="punctuation">: </span>&lt;base64url encoding of HTTP/2 SETTINGS payload&gt;</span><br></pre></td></tr></table></figure>
<p>如果服务端不支持 HTTP/2，它会忽略 <code>Upgrade</code> 字段，直接返回 HTTP/1.1 响应，例如：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>243</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-node-repl"><span class="meta prompt_">...</span></span></span><br></pre></td></tr></table></figure>
<p>如果服务端支持 HTTP/2，那就可以回应 <code>101</code> 状态码及对应头部，并且在响应正文中可以直接使用 HTTP/2 二进制帧：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>h2c</span><br><span class="line"></span><br><span class="line"><span class="language-angelscript"><span class="string">[ HTTP/2 connection ... ]</span></span></span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://lixiaoyu.cc/2018/09/04/computer-network-12-http-version-differences/">HTTP 各版本差异</a>  </p>
<p><a href="https://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门</a>   阮一峰</p>
<p><a href="https://www.infoq.cn/article/kU4OkqR8vH123a8dLCCJ">解密 HTTP/2 与 HTTP/3 的新特性</a></p>
<p><a href="https://www.zhihu.com/question/34074946">HTTP/2 相比 1.0 有哪些重大改进？</a>  知乎回答</p>
<p><a href="https://segmentfault.com/a/1190000007219256">深入研究：HTTP2 的真正性能到底如何</a></p>
<p><a href="https://www.cnblogs.com/syfwhu/p/6116277.html">HTTP 1.1学习笔记</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/140739394">深入解读HTTP3的原理及应用</a></p>
<p><a href="https://tools.ietf.org/html/rfc1945">rfc1945—Hypertext Transfer Protocol — HTTP/1.0</a></p>
<p><a href="https://tools.ietf.org/html/rfc2616">rfc2616—Hypertext Transfer Protocol — HTTP/1.1 </a></p>
<p><a href="https://tools.ietf.org/html/rfc7540">rfc7540—Hypertext Transfer Protocol Version 2 (HTTP/2)</a></p>
<p><a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html">Hypertext Transfer Protocol Version 3 (HTTP/3)</a></p>
<p><a href="https://www.cnblogs.com/noKing/p/9334243.html">HTTP/HTTPS协议</a>  面试问题</p>
<p><a href="https://hungryturbo.com/HTTP3-explained/">HTTP/3详解</a>  4</p>
<p><a href="https://imququ.com/post/protocol-negotiation-in-http2.html">谈谈 HTTP/2 的协议协商机制</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title>runloop使用</title>
    <url>/2022/07/15/runloop%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>runloop启动前必须先添加输入源或定时器源，否则runloop一启动就会退出。总之runloop需要有监听的事件，否则就会退出。</p>
<h2 id="启动runloop"><a href="#启动runloop" class="headerlink" title="启动runloop"></a>启动runloop</h2><p>NSRunLoop提供了如下3种启动runloop的方法。当然NSRunLoop其实封装的是CFRunloop。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)run <span class="built_in">NS_SWIFT_UNAVAILABLE_FROM_ASYNC</span>(<span class="string">&quot;run cannot be used from async contexts.&quot;</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)runUntilDate:(<span class="built_in">NSDate</span> *)limitDate <span class="built_in">NS_SWIFT_UNAVAILABLE_FROM_ASYNC</span>(<span class="string">&quot;run(until:) cannot be used from async contexts.&quot;</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)runMode:(<span class="built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="built_in">NSDate</span> *)limitDate <span class="built_in">NS_SWIFT_UNAVAILABLE_FROM_ASYNC</span>(<span class="string">&quot;run(_:before:) cannot be used from async contexts.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>相同点：如果没有输入源或定时器源附加到runloop上，runloop会马上退出，并且方法也会立即退出。</p>
<p>run<br>它会让runloop置身在一个永久的循环当中.即使runloop因为处理完了某个输入源事件而退出,该方法又会让它重新运行.因此如果你想处理完某个事件后能够退出runloop,那么你就不能使用该方法了。runloop运行在default模式。</p>
<p>runUntilDate：<br>和run方法差不多只是多了个截止时间，截止时间到了runloop就会退出。runloop同样运行在default模式。</p>
<p>runMode:beforeDate:<br>可以指定runloop运行的模式以及一个截止时间。处理定时器源事件后不会退出runloop，但处理输入源事件后会退出runloop，因此需要外部重新驱动进入runloop。</p>
<h2 id="退出runloop"><a href="#退出runloop" class="headerlink" title="退出runloop"></a>退出runloop</h2><p>根据官方文档，手动移除输入源或定时器源不能确保runloop会退出。最好的办法是使用runMode:beforeDate:方法启动runloop，设立标志位，给子线程发送消息perform selector。</p>
<h2 id="runloop使用场景"><a href="#runloop使用场景" class="headerlink" title="runloop使用场景"></a>runloop使用场景</h2><p>由于主线程的runloop默认是开启的，所以一般是子线程应用runloop。</p>
<ol>
<li>在子线程上使用定时器</li>
<li>其他线程需要与该子线程通信，比如perform selector或其他source。</li>
</ol>
<h2 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a>CocoaAsyncSocket</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">NSThread</span> *cfstreamThread;  <span class="comment">// Used for CFStreams</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> uint64_t cfstreamThreadRetainCount;   <span class="comment">// setup &amp; teardown</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> cfstreamThreadSetupQueue; <span class="comment">// setup &amp; teardown</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)startCFStreamThreadIfNeeded</span><br><span class="line">&#123;</span><br><span class="line">	LogTrace();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</span><br><span class="line">	<span class="built_in">dispatch_once</span>(&amp;predicate, ^&#123;</span><br><span class="line">		</span><br><span class="line">		cfstreamThreadRetainCount = <span class="number">0</span>;</span><br><span class="line">		cfstreamThreadSetupQueue = dispatch_queue_create(<span class="string">&quot;GCDAsyncSocket-CFStreamThreadSetup&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(cfstreamThreadSetupQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (++cfstreamThreadRetainCount == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cfstreamThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line">			                                         selector:<span class="keyword">@selector</span>(cfstreamThread:)</span><br><span class="line">			                                           object:<span class="literal">nil</span>];</span><br><span class="line">			[cfstreamThread start];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程保活—runloop"><a href="#线程保活—runloop" class="headerlink" title="线程保活—runloop"></a>线程保活—runloop</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)cfstreamThread:(<span class="type">id</span>)unused &#123; <span class="keyword">@autoreleasepool</span></span><br><span class="line">&#123;</span><br><span class="line">	[[<span class="built_in">NSThread</span> currentThread] setName:GCDAsyncSocketThreadName];</span><br><span class="line">	</span><br><span class="line">	LogInfo(<span class="string">@&quot;CFStreamThread: Started&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// We can&#x27;t run the run loop unless it has an associated input source or a timer.</span></span><br><span class="line">	<span class="comment">// So we&#x27;ll just create a timer that will never fire - unless the server runs for decades.</span></span><br><span class="line">	[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:[[<span class="built_in">NSDate</span> distantFuture] timeIntervalSinceNow]</span><br><span class="line">	                                 target:<span class="keyword">self</span></span><br><span class="line">	                               selector:<span class="keyword">@selector</span>(ignore:)</span><br><span class="line">	                               userInfo:<span class="literal">nil</span></span><br><span class="line">	                                repeats:<span class="literal">YES</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">NSThread</span> *currentThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">	<span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">	</span><br><span class="line">	<span class="type">BOOL</span> isCancelled = [currentThread isCancelled];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (!isCancelled &amp;&amp; [currentRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]])</span><br><span class="line">	&#123;</span><br><span class="line">		isCancelled = [currentThread isCancelled];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LogInfo(<span class="string">@&quot;CFStreamThread: Stopped&quot;</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>将一个可重复的、间隔时间为永远的（也就是永远不会触发的定时器）定时器添加到runloop,这样就确保了runloop不至于一启动就退出。</p>
<p>调用<code>- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;</code> 来启动runloop,这样runloop在处理输入源后就会退出。</p>
<p>while循环判断线程是否被取消，如果不是被取消则重新启动runloop。</p>
<h3 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)stopCFStreamThreadIfNeeded</span><br><span class="line">&#123;</span><br><span class="line">	LogTrace();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// The creation of the cfstreamThread is relatively expensive.</span></span><br><span class="line">	<span class="comment">// So we&#x27;d like to keep it available for recycling.</span></span><br><span class="line">	<span class="comment">// However, there&#x27;s a tradeoff here, because it shouldn&#x27;t remain alive forever.</span></span><br><span class="line">	<span class="comment">// So what we&#x27;re going to do is use a little delay before taking it down.</span></span><br><span class="line">	<span class="comment">// This way it can be reused properly in situations where multiple sockets are continually in flux.</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> delayInSeconds = <span class="number">30</span>;</span><br><span class="line">	dispatch_time_t when = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">	dispatch_after(when, cfstreamThreadSetupQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> clang diagnostic <span class="keyword">warning</span> <span class="string">&quot;-Wimplicit-retain-self&quot;</span></span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (cfstreamThreadRetainCount == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LogWarn(<span class="string">@&quot;Logic error concerning cfstreamThread start / stop&quot;</span>);</span><br><span class="line">			return_from_block;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (--cfstreamThreadRetainCount == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			[cfstreamThread cancel]; <span class="comment">// set isCancelled flag</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// wake up the thread</span></span><br><span class="line">            [[<span class="keyword">self</span> <span class="keyword">class</span>] performSelector:<span class="keyword">@selector</span>(ignore:)</span><br><span class="line">                                 onThread:cfstreamThread</span><br><span class="line">                               withObject:[<span class="built_in">NSNull</span> null]</span><br><span class="line">                            waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">            </span><br><span class="line">			cfstreamThread = <span class="literal">nil</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">	&#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结束线程这里调的是cancel方法，由于线程还启动了runloop，所以在子线程上调用performSelector，唤醒线程，runloop处理后会退出，由于已经cancel，所以while也不会再启动runloop，于是线程正常结束。</p>
<p>线程的创建和结束都是在一个串行队列里操作的，所以不会出现多线程操作的情况。</p>
<h2 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h2><h3 id="创建线程-1"><a href="#创建线程-1" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程保活—runloop-1"><a href="#线程保活—runloop-1" class="headerlink" title="线程保活—runloop"></a>线程保活—runloop</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)networkRequestThreadEntryPoint:(<span class="type">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加了一个基于端口的输入源（虽然并没有真正使用到），确保runloop不至于一启动就退出。调用<code>run</code> 来启动runloop，该方法在runloop退出后会重新启动runloop继续运行。AFNetworking创建的这个线程在整个APP内都不会销毁的。二者无一例外的使用全局变量来引用线程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/d8c790bcf10e">CFRunloop的多线程隐患</a></p>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
      <tags>
        <tag>runloop</tag>
      </tags>
  </entry>
  <entry>
    <title>ifconfig</title>
    <url>/2022/07/20/ifconfig/</url>
    <content><![CDATA[<p>ifconfig</p>
<p>全称：interfaces config,主要用于设置或显示网络设备信息的。</p>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lo0</span>: flags=<span class="number">8049</span>&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu <span class="number">16384</span></span><br><span class="line">	<span class="attribute">options</span>=<span class="number">1203</span>&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt;</span><br><span class="line">	<span class="attribute">inet</span> <span class="number">127.0.0.1</span> netmask <span class="number">0</span>xff000000</span><br><span class="line">	<span class="attribute">inet6</span> ::<span class="number">1</span> prefixlen <span class="number">128</span></span><br><span class="line">	<span class="attribute">inet6</span> fe80::<span class="number">1</span>%lo0 prefixlen <span class="number">64</span> scopeid <span class="number">0</span>x1</span><br><span class="line">	<span class="attribute">nd6</span> options=<span class="number">201</span>&lt;PERFORMNUD,DAD&gt;</span><br><span class="line"><span class="attribute">gif0</span>: flags=<span class="number">8010</span>&lt;POINTOPOINT,MULTICAST&gt; mtu <span class="number">1280</span></span><br><span class="line"><span class="attribute">stf0</span>: flags=<span class="number">0</span>&lt;&gt; mtu <span class="number">1280</span></span><br><span class="line"><span class="attribute">en0</span>: flags=<span class="number">8863</span>&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu <span class="number">1500</span></span><br><span class="line">	<span class="attribute">options</span>=<span class="number">50</span>b&lt;RXCSUM,TXCSUM,VLAN_HWTAGGING,AV,CHANNEL_IO&gt;</span><br><span class="line">	<span class="attribute">ether</span> b0:e5:f9:f3:a8:de   //mac地址</span><br><span class="line">	<span class="attribute">inet6</span> fe80::<span class="number">1</span>c2c:<span class="number">2</span>b1d:<span class="number">6</span>af8:<span class="number">3558</span>%en0 prefixlen <span class="number">64</span> secured scopeid <span class="number">0</span>x6  //ipv6地址</span><br><span class="line">	<span class="attribute">inet</span> <span class="number">10.1.63.198</span> netmask <span class="number">0</span>xffffff00 broadcast <span class="number">10.1.63.255</span> //ipv4地址、子网掩码、广播地址</span><br><span class="line">	<span class="attribute">nd6</span> options=<span class="number">201</span>&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">	<span class="attribute">media</span>: autoselect (<span class="number">1000</span>baseT &lt;full-duplex&gt;)</span><br><span class="line">	<span class="attribute">status</span>: active</span><br></pre></td></tr></table></figure>
<p>ifconfig打印的是所有网络设备的信息，并且名称是专有名词比如en0，一般来说如果电脑只连了WIFI那么en0代表的就是WIFI网卡信息，如果还插了网线那么en0代表的就是以太网网卡信息，en1代表的才是WIFI网卡信息。可以配合<code>networksetup -listallhardwareports</code> 查看。</p>
<p>networksetup -listallhardwareports</p>
<p>打印：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">Hardware <span class="params">Port:</span> Ethernet</span><br><span class="line"><span class="params">Device:</span> en0</span><br><span class="line">Ethernet <span class="params">Address:</span> b0:e5:f9:f3:a8:de</span><br><span class="line"></span><br><span class="line">Hardware <span class="params">Port:</span> USB <span class="number">10</span><span class="symbol">/100/1000</span> LAN</span><br><span class="line"><span class="params">Device:</span> en4</span><br><span class="line">Ethernet <span class="params">Address:</span> <span class="number">00</span>:e0:<span class="number">4</span>c:<span class="number">89</span>:fe:<span class="number">55</span></span><br><span class="line"></span><br><span class="line">Hardware <span class="params">Port:</span> Ethernet Adapter (en5)</span><br><span class="line"><span class="params">Device:</span> en5</span><br><span class="line">Ethernet <span class="params">Address:</span> <span class="number">16</span>:<span class="number">6</span>a:<span class="number">42</span>:<span class="number">01</span>:<span class="number">62</span>:<span class="number">87</span></span><br><span class="line"></span><br><span class="line">Hardware <span class="params">Port:</span> Ethernet Adapter (en6)</span><br><span class="line"><span class="params">Device:</span> en6</span><br><span class="line">Ethernet <span class="params">Address:</span> <span class="number">16</span>:<span class="number">6</span>a:<span class="number">42</span>:<span class="number">01</span>:<span class="number">62</span>:<span class="number">88</span></span><br><span class="line"></span><br><span class="line">Hardware <span class="params">Port:</span> Wi-Fi</span><br><span class="line"><span class="params">Device:</span> en1</span><br><span class="line">Ethernet <span class="params">Address:</span> b0:e5:f9:f2:<span class="number">56</span>:<span class="number">75</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>networksetup -listallnetworkservices</p>
<p>打印：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">An asterisk</span> <span class="comment">(*) denotes that a network service is disabled.</span></span><br><span class="line"><span class="comment">Wi-Fi</span></span><br><span class="line"><span class="comment">Ethernet</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ss64.com/osx/ifconfig.html">ifconfig man手册</a></p>
<p><a href="https://www.runoob.com/linux/linux-comm-ifconfig.html">Linux ifconfig命令</a></p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>ifconfig</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型简介</title>
    <url>/2022/07/25/IO%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>大致有下面五种IO模型：</p>
<p>阻塞IO模型，非阻塞IO模型，IO复用模型，信号驱动IO模型，异步IO模型。</p>
<h2 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h2><p>读数据，发现没有数据，线程就一直等待直到有数据读取。</p>
<h2 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h2><p>读数据，发现没有数据，线程不等待直接返回读错误码。由于不知道什么时候会有数据所以这种非阻塞IO模型需要调用方不断检查是否有数据。</p>
<p>fd默认是阻塞IO访问，可以使用fcntl函数设置为非阻塞IO:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">status</span> = fcntl(socketFD, F_SETFL, O_NONBLOCK)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h2><p>对非阻塞IO模型的一种改进，因为非阻塞IO模型需要不断检查是否有数据可读。假如有100个fd要读，那么就需要100个线程各自在不断的检查是否有数据可读，这显然浪费了大量的CPU和内存。</p>
<p>事实上，我们可以用一条线程去轮询fd集合，当某个fd有数据可读时就返回该fd并通知应用程序读。系统内核提供了select内核函数，select函数会帮我们做上述事情，当线程调用select函数后会阻塞在select函数，当有数据可读时select函数会返回该fd，于是我们再开线程读取数据。</p>
<h2 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h2><p>信号驱动IO模型是对上述模型中轮询策略的一种改进，因为轮询的效率是很低的，绝大多数时候是没有数据可读的，因此轮询做了大量无用功。</p>
<p>我们可以向系统内核注册一个信号，系统内核发现有数据可读时再发送该信号通知我们，于是我们才去读数据。</p>
<h2 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h2><p>异步IO模型是对信号驱动IO模型进一步改进。因为信号驱动IO模型只是告诉了我们读数据的时机，我们还是需要调用recvfrom函数去读把数据从内核空间复制到用户空间。</p>
<p>事实上，我们可以把信号驱动IO模型的两步并做一步，向系统内核发起一个read请求，随即返回。系统内核接收请求，当发现有数据可读时直接帮我们把数据从内核空间复制到用户空间并通知应用。</p>
<p>这几种模型体现了技术的不断发展，体现了人们对性能的不断追求。技术不是一蹴而就的而是从一个粗糙的东西不断迭代最终才变成一个精细的东西的。所以完美的事物是不存在的，你不必完美。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/115912936">100%弄明白5种IO模型</a>  </p>
<p><a href="https://blog.csdn.net/hguisu/article/details/7453390">socket阻塞与非阻塞，同步与异步、I/O模型</a>  主要看那几幅图。</p>
<p><a href="https://www.itzhai.com/articles/necessary-knowledge-of-network-programming-graphic-socket-core-insider-and-five-io-models.html">网络编程必备知识：图解Socket核心内幕以及五大IO模型 | 阻塞IO,非阻塞IO,IO复用,信号驱动式IO,异步IO</a>   感觉很吊的样子</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>I/O模型</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习一个框架</title>
    <url>/2022/07/25/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>在读了一些框架源码后，个人觉得应该从以下几个方面学习一个框架：</p>
<p>1.框架实现的功能<br>这个框架是用来干嘛的。</p>
<p>2.框架的工作流程<br>高屋建瓴的描述一下框架的工作流程。</p>
<p>3.简单的使用框架<br>做一个小demo。</p>
<p>4.框架使用的基础库<br>基于哪些系统框架或其他第三方库。</p>
<p>5.框架的设计<br>架构设计，设计模式，数据结构和算法，类的UML图。</p>
<p>6.框架的实现细节<br>语言的高级使用，多线程处理，复用，内存优化，CPU优化，<strong>边界情况处理</strong>等等。</p>
<p>7.框架的优缺点<br>在对框架达到一定的了解后，明白框架的最佳使用场景及局限性。</p>
<p>8.对框架的改进<br>尝试解决框架中存在的不足。</p>
]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
  </entry>
  <entry>
    <title>MacBook Pro外接显示器(六)之我的电脑修好了</title>
    <url>/2022/05/08/MacBook%20Pro%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8(%E5%85%AD)%E4%B9%8B%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E4%BF%AE%E5%A5%BD%E4%BA%86/</url>
    <content><![CDATA[<p>自从电脑坏了之后就一直没有拿去修，没空是一方面，更多的是担心修不好还被坑维修费。就这样磨磨蹭蹭过了差不多大半年，今年五一放假也没啥去处，于是想干脆去华强北修一修，万一修好了呢。本来是想5月1日去修的，结果起太晚了磨蹭到2点感觉有点晚了，就想着第二天去吧，结果第二天下了一天的雨，也没去成。</p>
<p>5月3日天气有点阴沉，但好歹没下雨了。于是从角落把电脑翻出来发现盖子都有点发霉了，简单的清理了一下便装进背包，向华强北出发。华强北虽然经过过几次，但没去里边修过东西，出发前搜了下华强北修电脑的帖子，广告很多，被骗被坑的回答也很多，很多答主说要慎重，说有的店就是拖着你说修不好让你低价卖给他，有的还会偷换电脑零件，反正啥样的都有。看完之后还是有点忐忑的，倒不是怕偷换零件，毕竟我这个电脑用了6年半了也没啥好零件了，主要是怕漫天要价，拖着不修，扯皮闹心。</p>
<p>不过还是决定去试一下，下午两点到了华强路A出口，一出来就看到几家手机电脑维修的店子，我也不知道哪家好，也没有多问多选，直接走进了第一家。进去之后没有说修电脑的事，当时手机拍照有黑斑，就先问了下手机的问题能不能修，维修的几个人都是年轻人，说能修大概160-180块钱，只需要清洗一下摄像头就可以弄好。</p>
<p>这里说一下维修店的模式，基本上店面都是一个小门面，相当于一个小工作台，这里只会做一些简单的维修比如换个屏，贴个膜，初步检测下设备啥的，如果问题比较大或者需要其他设备，他们会拿到他们所谓的维修间里，两个地方是有一段距离的而且你是不可能跟着去的，顾客只能在店面等着。</p>
<p>话说回来，让他拆下摄像头后我问要洗多久，他说大概要等1个小时。感觉还行便问这里能不能修电脑，他说能修电脑，于是我把电脑给他看了看，告诉他是主板烧坏了，他拿着万用表测了测，说的原因我也记不住，大概的意思是芯片供电模块短路。</p>
<p>我：修好大概要多少钱</p>
<p>他：550</p>
<p>我：有点贵</p>
<p>他：已经是最低价了，这样吧，加上那个洗摄像头的费用一共700怎么样</p>
<p>我：那要修多久啊</p>
<p>他：大概1个半小时</p>
<p>我心里想要是能修好的话，也还能接收。于是便答应了，由于要等1个多小时也不能干等着，便四处逛了下，华强北确实名不虚传，整个一条街两边全是手机电脑维修的，从一头走到另一头估计得要二三十分钟。</p>
<p>两个小时后，我回到店里，他们也已经修完了。手机摄像头装上，检查了下黑斑没了，感觉还是挺开心的。电脑他也开了机给我看了下，我用了几分钟打开浏览器看了下视频调了下音量亮度等感觉没啥毛病，于是关了机，付了钱就坐地铁回家了。心里想华强北不亏是华强北是真的强。</p>
<p>然而事情并没有这么完美，由于第一次去非官方修电脑没啥经验，修好后自己都没怎么测试就装包回家了，这埋下了伏笔。事实上像主板烧坏开不了机的情况，修好后一定要各种开关机的情况都测试一下才行。等我吃完饭回到家，想打开我久违的电脑看看时，结果一按开机键没任何反应，试了好几次都没有任何反应。心里真是日了狗，看来明天还得去一趟。</p>
<p>5月4日天气晴朗，我不出意料的又起的很晚已经12点了，想想就不吃早餐了，于是直接吃了午餐就背着包去了华强北，到了之后已经1点半了。一进店昨天的维修小哥估计也有点吃惊怎么第二天就来了，我跟他说应该没修好，还是开不了机。他拿过机器拆开后到处测了测说其实是能开机是连接显示器的某个接口接触不稳定导致，</p>
<p>我：修好大概要多少钱</p>
<p>他：340</p>
<p>我：那要修多久啊</p>
<p>他：两个小时</p>
<p>我：确定能修好吗</p>
<p>他：肯定能</p>
<p>我说行，两个小时后，我回来问他修的咋样了，他告诉我说接触还是不稳定，说要想完全修好得换接口，并一再强调肯定可以修好。我心里一想完了是不是掉坑里了。</p>
<p>我：那修好大概要多少钱</p>
<p>他：换接口的话要再多加430块，一共770</p>
<p>我：你这也太贵了，能不能便宜点啊</p>
<p>他：最少700，这次肯定能给你修好，我们拿原装的给你换上。</p>
<p>我：还是太贵了，我不能接受。</p>
<p>他：这已经是最低价了，就挣你个手工钱了。</p>
<p>我：500，行不行</p>
<p>他：500真不行，500我都亏本了。拿货都拿不到</p>
<p>我：实话跟你说吧，第一我也不指望我这电脑一定要修好我不可能无上限的去修这台电脑（事实上我早就买了新电脑了，修这台电脑完全是情怀），第二我最多只能给到600如果你觉得还是不行的话，那就只能把我电脑还给我我坐地铁回去了。</p>
<p>又是一顿扯皮后，最终他答应了，我说就600啊，如果最后又说还有其他问题又要换啥的我可不干啊，他说这一次是换东西，肯定能修好。我说要修多久，他不敢说了差不多2个小时吧。我看了下手机现在4点半了，那我6点半再来。</p>
<p>然后又把华强北周边走了一大圈，说实话华强北电子街人还是挺多的。疫情下大家都带着口罩，喇叭里一遍又一遍的播放着打疫苗领奖品。夕阳西下，熙熙攘攘，不过快乐是他们的。</p>
<p>差不多6点45，我回到了店里，问他修的咋样了，他说快了在测试了，结果一直等到7点半，终于他说测试好了，一会给我拿过来。拿过来后确实可以开机了，然后电脑给到我，我现在放聪明了，各种开关机测试，正常开关机，强制开关机，测了十多分钟，期间他说哪有你这么测的，我说要是真修好了肯定没问题的，最后确认没啥问题后，我又仔细检查了下外观，发现后盖有几个螺丝没拧好，又让他们拧好，最后付了钱。</p>
<p>背上背包，到了这个点都有些饿了，于是在周边吃了饭才回去了。这次修电脑总共修了我1150，等了7个小时，不过总算是修好了，也还能接受。</p>
<p>说一下这次修电脑的感悟：</p>
<ol>
<li>关于苹果电脑维修。苹果电脑是一年整机保修，两年主要部件保修（主要部件包括主板 (MLB)、处理器 (CPU)、内存、硬盘 (HDD/SSD)、电源适配器、键盘和显示屏 (LCD)），电池是不算的。如果你的电脑是两年内出问题了最好去苹果直营店也就是天才吧预约维修，基本上非人为原因都不用出钱。两年~三年内建议还是到官方维修，虽然贵但是有保障（不过是真的贵看情况吧）。3年以上的到外面修还是便宜一点不过保障肯定不如原厂。</li>
<li>华强北也没有网上说的那么妖魔鬼怪。小马过河的课文大家应该都学过，有时候还是得亲自试一下才知道，别人的意见可以作为参考留个心眼。个人感觉还行华强北还是有点技术的，当然里面的套路应该还是有的。</li>
<li>修好后自己检测的时候要根据问题针对性的仔细测试。</li>
<li>修电脑还是假期去，做好准备，毕竟不是一下就能修好的。</li>
</ol>
<p>最后附一张修好后的图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/IMG_3562.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>字符串操作range注意事项</title>
    <url>/2022/07/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9Crange%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *ret = [string stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">0</span>) withString:<span class="string">@&quot;因吹斯汀&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;string:%@\nret:%@&quot;</span>, string, ret); <span class="comment">//因吹斯汀</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = <span class="string">@&quot;倒计时开关是&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *ret = [string stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">0</span>) withString:<span class="string">@&quot;因吹斯汀&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;string:%@\nret:%@&quot;</span>, string, ret); <span class="comment">//因吹斯汀倒计时开关是</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = <span class="string">@&quot;倒计时开关是&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *ret = [string stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:<span class="string">@&quot;因吹斯汀&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;string:%@\nret:%@&quot;</span>, string, ret); <span class="comment">//因吹斯汀计时开关是</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = <span class="string">@&quot;倒计时开关是&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *ret = [string stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(string.length, <span class="number">0</span>) withString:<span class="string">@&quot;因吹斯汀&quot;</span>]; <span class="comment">//倒计时开关是因吹斯汀</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;string:%@\nret:%@&quot;</span>, string, ret);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = <span class="string">@&quot;倒计时开关是&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *ret = [string stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(string.length - <span class="number">1</span>, <span class="number">1</span>) withString:<span class="string">@&quot;因吹斯汀&quot;</span>]; <span class="comment">//倒计时开关因吹斯汀</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;string:%@\nret:%@&quot;</span>, string, ret);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = <span class="string">@&quot;倒计时开关是&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *ret = [string stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(string.length, <span class="number">1</span>) withString:<span class="string">@&quot;因吹斯汀&quot;</span>]; <span class="comment">//崩溃</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;string:%@\nret:%@&quot;</span>, string, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>传入的range必须满足：(range.location + range.length) &lt;= string.length，否则会发生越界崩溃。</p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>补码完全指南</title>
    <url>/2022/07/31/%E8%A1%A5%E7%A0%81%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>本文基于自己的理解，试图让猪都能理解补码的概念^_^。老规矩，先是几个概念。</p>
<h2 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h2><p>机器数是将符号数字化的数，最高位是符号位，正数符号位为0，负数符号位为1，其余位表示数值。</p>
<h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><p>机器数所对应的实际数值。　</p>
<h2 id="编程语言类型"><a href="#编程语言类型" class="headerlink" title="编程语言类型"></a>编程语言类型</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>全部二进制位均代表数值，没有符号位。</p>
<h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><p>最高位代表符号位(“0”表示“+”，“1”表示“-”)，其余位表示数值。</p>
<h3 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h3><p>在计算机系统中，数值一律用补码来存储。对于一串二进制数字，被解释为无符号数或有符号数它对应的真值可能是不相等的。比如内存中的一串二进制1111 1111，被解释为无符号数时则表示127，被解释为有符号数时则表示-1。在强转类型时特别要注意，特别是语言的隐式强转，很容易就出bug。</p>
<h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><ul>
<li>最高位为符号位，“0”表示正号，“1”表示负号。</li>
<li>其余的n-1位表示数值的绝对值。</li>
<li>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。</li>
<li>数字“0”有“+0”和“- 0”两种表示形式：0000 0000（+0）、1000 0000（-0）。</li>
<li>对于机器字长为n+1位的机器，原码表示法可表示的数值范围为：-2^n+1 ≤ X ≤ 2^n-1。比如8位字长，原码能够表示的数值范围为[-127, 127]。</li>
</ul>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><ul>
<li>最高位为符号位，“0”表示正号，“1”表示负号。</li>
<li>其余的n-1位表示数值。</li>
<li>正数的反码与原码相同。</li>
<li>负数的反码则是在其原码的基础上, 符号位不变，其余各个位取反。</li>
<li>数字“0”有“+0”和“- 0”两种表示形式：0111 1111（+0）、1111 1111（-0）。</li>
<li>对于机器字长为n+1位的机器，反码表示法可表示的数值范围为：-2^n+1 ≤ X ≤ 2^n-1。比如8位字长，反码能够表示的数值范围为[-127, 127]。</li>
</ul>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><ul>
<li>最高位为符号位，“0”表示正号，“1”表示负号。</li>
<li>数字“0”只有一种表示形式：0000 0000。</li>
<li>正数的补码与原码相同。</li>
<li>负数的补码是将其对应正数按位取反再加1。（ps：这不是规定，后面有推导）</li>
<li>对于机器字长为n+1位的机器，补码表示法可表示的数值范围为：-2^n ≤ X ≤ 2^n-1。比如8位字长，补码能够表示的数值范围为[-128, 127]。这就有意思了，-128已经超出了原码和反码的表示范围，因此-128有补码表示（1000 0000）但却没有对应的8位字长的原码和反码表示。所以计算一个数的补码最好不要用大部分网上说的先算原码再算反码啥的，先算原码就会有特例-128，运算规则就不统一，而且还很难理解-128的补码。最好就是用上面的办法。</li>
</ul>
<p>eg:</p>
<p>1.已知真值求补码</p>
<p>正数的补码与原码相同。负数的补码是将其对应正数按位取反再加1。</p>
<p>求-1的补码。-1的绝对值为1，二进制为0000 0001，按位取反得到1111 1110，再加1，得到补码1111 1111。</p>
<p>求-128的补码。-128的绝对值为128，二进制为1000 0000，按位取反得到0111 1111，再加1，得到补码1000 0000。</p>
<p>2.已知补码求真值</p>
<p>先看最高位，确定符号，如果是0，则直接算得其真值。如果为负数则按位取反，再加1，得到其真值的绝对值，符号+绝对值得到真值。</p>
<p>求补码1000 0000的真值。最高位为1，说明真值是一个负数，按位取反得到0111 1111，再加1，得到真值的绝对值1000 0000即128，所以最终真值为-128。</p>
<p>求补码1111 1111的真值。最高位为1，说明真值是一个负数，按位取反得到0000 0000，再加1，得到真值的绝对值0000 0001即1，所以最终真值为-1。</p>
<p>可以看出对一个负数的补码再取反加1得到的就是负数的绝对值。</p>
<h3 id="为什么使用补码"><a href="#为什么使用补码" class="headerlink" title="为什么使用补码"></a>为什么使用补码</h3><p><strong>在有模的计量系统中</strong>，减一个数等于加上它的补数。比如3 - 1 = 3 + [-1]补 = 3 + 255 = 0000 0011 + 1111 1111 = 0000 0010（最高位丢弃） = 2</p>
<p>上面这个例子可能不是很好理解，一般都是用时钟系统来举例。</p>
<p>假设现在是3点钟，逆时针旋转代表减，顺时针旋转代表加，那么- 1，就是逆时针旋转1格，指向2，所以3 - 1 = 2。事实上我们可以顺时针旋转11格，同样最终会指向2。因此在这个系统里 3 - 1 等价于 3 + 11。11就是-1的补码。</p>
<p>有了补码，我们就可以使用加法来计算减法了。就不用单独设计一套减法器了，直接使用加法器就可以了。</p>
<p>玩过DNF PK的人都知道，要想成为一个PK高手，计算对手的蹲伏时间、萝莉的草人时间非常重要，并且还要计算的非常快，如果你计算的不快可能都忘了对手什么时候交的蹲伏了。如果你熟悉补码的话，那你就可以计算的非常快。</p>
<p>比如对手3分18秒交的蹲伏，20秒后蹲伏冷却。那么他下一次冷却的时间就是3分18秒 - 20秒 = 2分58秒。如果你直接去算减法的话可能会很绕。算加法就很简单，秒时间是一个模为60的系统，-20就相当于+40，因此18 - 20 = 18 + 40 = 58，很快就算出来对手的下一次蹲伏是58秒。分钟一般不用考虑。</p>
<p>再比如魔道的草人是48秒，如果对手3分13秒交的草人，那么他下一次冷却的时间就是3分13秒 - 48秒，-48相当于+12， 因此 13 + 12 = 25，即2分25秒魔道的草人再次冷却。如果秒的倒计时大于48就不要用补码去算了，比如3分52秒，52 - 48 = 4。当然如果你想用补码去算也没有问题，52 + 12 = 64，6是进位舍去，结果也是4。</p>
<h3 id="补码的计算方式由来"><a href="#补码的计算方式由来" class="headerlink" title="补码的计算方式由来"></a>补码的计算方式由来</h3><p>为什么负数的补码是将其对应正数按位取反再加1？</p>
<p>对于8位机器字长，它的模就是256，一个负数的补码就等于模加上这个负数。其实正数的补码也等于模加上这个数只不过舍去进位就是正数自身，所以正数的补码就是其原码。</p>
<p>比如：-1，它的补码就是256+(-1) = 256 - 1 = 255 - 1 + 1 = 1111 1111 - 0000 0001 + 1 = 1111 1110 + 1 = 1111 1111</p>
<p>1111 1111减去一个正数A等价于A按位取反。因此一个负数的补码是将其对应正数按位取反再加1。</p>
<h2 id="加减法电路"><a href="#加减法电路" class="headerlink" title="加减法电路"></a>加减法电路</h2><p>如图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/4%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8.png" alt=""></p>
<p>上图表示的是一个4位加减法器，可以计算加法和减法。</p>
<p>输入为A3A2A1A0，B3B2B1B0，输出为S3S2S1S0。K信号代表加减操作，K=0表示做加法，K=1表示做减法，同时K也作为输入。三角形为异或门，矩形为全加器。该电路主要部件还是加法器，配合异或器和加减标志信号后，就可以做减法了。可以看到两个数的减法最终被转换为另两个数的加法，避免了单独设计减法器。</p>
<p>比如5 - 2 = 0101 - 0010，因为是减法所以K=1，0010与1异或，其实就是按位取反，同时K作为输入相加，正好就是加1。所以5 - 2 = 0101 - 0010 = 0101 + 1101 + 1 = 0101 + 1110 = 5 +  [-2]补 = 10011，因为是4位机最高位舍去，结果就是0011，也就是3。</p>
<p>再比如5 + 2，因为是加法K = 0 ，0010与0异或，其实就是不变，真是太巧了。直接加就完了。0101 + 0010 = 0111 = 7。</p>
<p>再比如4 - (-1) ，由于负数是以补码存储的，所以4 - (-1) = 0100 - 1111 = 0100 + 0000 + 1 = 0100 + 0001 = 4 + 1 = 5。</p>
<p>再比如3 + (-1) = 0011 + 1111 = 10010，最高位舍去，结果就是0010 = 2。</p>
<p>int i = -1; =&gt; i = 0 - 1 = 0000 + 1111 = 1111。1111存入内存。上述过程其实就是把1进行按位取反再加1，这正是补码的算法。以上电路实现了整数以补码进行存储。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>补码</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议报文</title>
    <url>/2022/07/29/TCP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>传输控制协议（Transmission Control Protocol，TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>TCP协议位于四层模型中的传输层</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.jpg" alt=""></p>
<h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/032325597971641.jpg" alt=""></p>
<p><strong>源端口</strong>：16bit，共65536个端口，端口0有特殊含义，不能使用，这样可用端口最多只有65535。</p>
<p><strong>目的端口</strong>：16bit，接收方的端口号。</p>
<p><strong>序号</strong>：32bit，可靠传输服务的关键字段。序号（sequence number， seq）是报文段首字节的字节流编号，TCP把数据看成是有序的字节流，TCP会隐式地对数据流的每个字节进行编号。第一个包的编号由本地随机产生，到达2^32-1后会再回到0。客户端、服务器端有各自的seq序号。序号主要<strong>用来解决网络包乱序（reordering）问题</strong>。</p>
<p><strong>确认号</strong>：32bit，可靠传输服务的关键字段。确认号（acknowledgment number，ack）是期望的对方的下一个序号。主要<strong>用来解决不丢包的问题</strong>。</p>
<p><strong>首部长度</strong>：4bit，以32bits4字节为单位，这样首部最大长度为15 * 4 = 60字节。除去固定部分的长度20字节，可变部分的长度最大为40字节。首部长度也称数据偏移，由于报头的长度可变 ，首部长度指示了数据区在报文段中的起始偏移值 。</p>
<p><strong>保留</strong>：6bits。</p>
<p><strong>标志</strong>：6bits。URG、ACK、PSH、RST、SYN、FIN共6个，每一个控制位表示一个控制功能。（这里需要注意的是不要把这里的标志位SYN，ACK和上面的序号seq和确认号ack相混淆，这两个是不同的东西）</p>
<ul>
<li><p>URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。</p>
</li>
<li><p>ACK：确认号标志，为1时确认号有效 ，为0时确认号无效。TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</p>
</li>
<li><p>PSH：推送标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</p>
</li>
<li><p>RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。</p>
</li>
<li><p>SYN：同步序号标志，用于建立连接，在连接建立时同步序号，SYN=1时表示这是一个连接请求或连接接受报文</p>
<blockquote>
<p>当SYN=1且ACK=0时，表明这是一个连接请求报文段</p>
<p>当SYN=1且ACK=1时，表明对方同意建立连接</p>
</blockquote>
<p>SYN=1的报文<strong>不能携带数据</strong>，但要<strong>消耗掉一个序号</strong>。SYN=0、ACK=1的报文<strong>可以携带数据</strong>，如果不携带数据则不消耗序号，此时下一个报文的序号与当前报文的序号相同(注意理解这里)。</p>
</li>
<li><p>FIN：终止标志，用于释放连接，值为1表示要发送的数据报已经发送完毕，需要释放传输连接。</p>
</li>
</ul>
<p><strong>窗口</strong>：16bit，单位字节。滑动窗口大小，用于接收端告知发送端，本接受端的<strong>缓存大小</strong>，以此控制发送端发送数据的速率，从而达到<strong>流量控制</strong>。窗口最大为2^16-1=65535字节。这也限制了TCP的吞吐量，可以通过窗口缩放选项对这个值进行缩放。</p>
<p><strong>校验和</strong>：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字节进行计算所得。由发送端计算和存储，并由接收端进行验证。</p>
<p><strong>紧急指针</strong>：只有在URG字段打开时才有效。暂时不清楚有啥用</p>
<p><strong>选项</strong>：长度可变，最长40字节，当没有选项时报头长度是20字节。常见的有MSS，window scale，时间戳，SACK。</p>
<p><strong>填充</strong>：选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</p>
<p><strong>数据部分</strong>： TCP 报文段中的数据部分是可选的。<br>在一个连接建立和终止时，双方交换的报文段仅有 TCP 报头。如果一方没有数据要发送，也使用没有任何数据的报头来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报头。</p>
<h3 id="ACK标志为1的TCP报文能否携带数据？"><a href="#ACK标志为1的TCP报文能否携带数据？" class="headerlink" title="ACK标志为1的TCP报文能否携带数据？"></a>ACK标志为1的TCP报文能否携带数据？</h3><p>ACK标志为1的TCP报文，表示报文中的确认号有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。可以携带数据也可以不携带数据，如果不携带数据则不消耗序号。ACK只是TCP的一种确认机制，接收端接收到数据后不需要马上回复一条ACK报文，接收端可以延迟确认，也可以跟随将要发送的数据一起过去这时ACK虽然为1但是却携带了数据，避免传输只有TCP头的空报文。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/a19881029/article/details/38091243?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase">理解TCP序列号（Sequence Number）和确认号（Acknowledgment Number）</a>   译文,通过抓包来解释seq number和ack number。</p>
<p><a href="https://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/">Understanding TCP Sequence and Acknowledgment Numbers</a>  原文</p>
<p><a href="https://andrewpqc.github.io/2018/07/17/sequence-number-and-ack-number-in-tcp/">TCP中的序号和确认号</a></p>
<p><a href="http://jm.taobao.org/2017/06/08/20170608/">就是要你懂 TCP</a>   阿里中间件团队博客 </p>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP报文</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix domain Socket简介</title>
    <url>/2022/08/05/Unix-domain-Socket%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>uds server与client是怎么进行数据通信的？</p>
<p>uds socket文件的作用？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.flydean.com/17-unix-domain-socket/">网络协议之:socket协议详解之Unix domain Socket</a></p>
<p><a href="https://mp.weixin.qq.com/s/fHzKYlW0WMhP2jxh2H_59A">Unix Domain Socket工作原理</a></p>
]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>UDS</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果官方文档查询</title>
    <url>/2022/08/04/%E8%8B%B9%E6%9E%9C%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p><a href="https://developer.apple.com/library/archive/navigation/">Documentation Archive</a>   :搜xx编程指南，缺点就是苹果已经不再更新了。eg:CFNetwork Programming Guide、Stream Programming Guide。</p>
<p><a href="https://developer.apple.com/documentation/technologies">documentation-Technologies</a>  :苹果目前维护更新的官方文档地址，可以用来搜API说明。缺点：都是一些API的介绍说明，原理性、系统性的东西很少。</p>
]]></content>
      <categories>
        <category>参考资料</category>
      </categories>
      <tags>
        <tag>苹果官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title>干眼症辅助治疗</title>
    <url>/2022/08/06/%E5%B9%B2%E7%9C%BC%E7%97%87%E8%BE%85%E5%8A%A9%E6%B2%BB%E7%96%97/</url>
    <content><![CDATA[<p>具体是什么时候开始有干眼症的症状已经记不清楚了，大概是2016年患干眼症，目前（2022年08月06日）干眼症症状：干燥、异物感、瘙痒、灼痛，闭眼睡觉（不管是白天还是晚上，只要是闭眼一段时间）特别明显，睁眼后不明显。</p>
<p>干眼症目前治疗水平：干眼症是一种慢性、并且通常是进行性病症。根据其原因和严重程度，干眼症有时并不能完全治愈。但在大多数情况下，干眼症的疾病管理可以很成功，通过施以适当的治疗手段，可以明显改善眼睛舒适度、缓解干眼症状、并且有时甚至可以获得更清晰的视力。</p>
<h2 id="辅助治疗方案"><a href="#辅助治疗方案" class="headerlink" title="辅助治疗方案"></a>辅助治疗方案</h2><p>去医院看过几次，不过效果不大。由于是慢性长期的病，所以还是要有一套能够随手就用的辅助治疗方案。</p>
<ol>
<li><p>早睡早起。23:00准备入睡。23:30—7:30。</p>
</li>
<li><p>按摩热敷。早晚各一次。每次12分钟。</p>
</li>
<li><p>食疗。多喝水，忌辛辣，油腻，冰的。</p>
</li>
<li><p>多户外活动。进行户外跑步。建议每周两次户外跑，每次锻炼半小时，大概可以跑3-4公里。</p>
</li>
<li><p>改善日常生活习惯。</p>
<ul>
<li><p>多眨眼。</p>
</li>
<li><p>在电脑使用过程中经常休息。一个比较好的方法是——至少每隔30分钟远眺（半米以外）至少直径为半米以上的物体3分钟，它可以帮助缓解干眼症和电脑眼疲劳。</p>
</li>
<li><p>不躺着玩手机、不在关灯后玩手机。</p>
</li>
<li><p>减少电子设备的使用。少玩游戏，少玩手机、电脑。初期建议每次玩游戏时间不超过2小时。</p>
</li>
</ul>
</li>
<li><p>保持积极心态。不要啥也不干，天天躺着。空闲时间多读书，听书也行。</p>
</li>
</ol>
<p>辅助治疗方案需要长期的坚持下去。希望能够对干眼症有所缓解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>医学上早就确认减少眨眼率的活动会增加干眼症的患病率。例如，在计算机上花费很长时间是干眼症的一个确定的风险因素。由于干眼症可能有多种原因，因此采用的治疗方法可能各有不同。通常并没有能够“快速治愈”干眼症的方法。</p>
<h3 id="热敷疗法"><a href="#热敷疗法" class="headerlink" title="热敷疗法"></a>热敷疗法</h3><p>该方法可以作为睑板腺疗法的一种更加舒适的替代手段，它通过简单地对闭合的眼睑施热敷以软化睑板。不过为了达到更好的效果，一些研究人员指出必须使热敷在42摄氏度下保持超过10分钟，并且压敷必须在这段时间内至少施加两次。大多数人不能或不愿意正确地进行这种干眼治疗，只在较低温度下进行压敷，所以经常达不到预期效果。</p>
<h3 id="营养疗法"><a href="#营养疗法" class="headerlink" title="营养疗法"></a>营养疗法</h3><p>通过食物进行营养补充可以作为干眼症治疗的一部分。研究发现含有omega-3脂肪酸的食物可以减少干眼症状。omega-3的良好食物来源主要是各类冷水鱼，如鲑鱼、沙丁鱼、鲱鱼和鳕鱼，也可以从亚麻籽油中来获得。此外，喝更多的水也可以对干眼症有所帮助。轻度脱水常常会使干眼症状恶化，在炎热，干燥和多风的天气中情况尤其如此。简单地喝更多的水有时会减少干眼症的症状。</p>
<h3 id="改善日常生活习惯"><a href="#改善日常生活习惯" class="headerlink" title="改善日常生活习惯"></a>改善日常生活习惯</h3><ul>
<li><p>更频繁的眨眼。当使用电脑、手机或其他数码设备时，我们往往比平时更少的眨眼，这可能会导致或恶化干眼症。应当有意识地注意这一点，在使用这些电子设备时更频繁地眨眼。</p>
</li>
<li><p>在电脑使用过程中经常休息。一个比较好的方法是——至少每隔20分钟远眺（半米以外）至少直径为半米以上的物体，它可以帮助缓解干眼症和电脑眼疲劳。</p>
</li>
<li><p>清洁眼皮。在睡前洗脸时，轻轻地清洗眼睑以清除可能会导致睑缘炎和睑板腺问题的细菌。睡前可以将温暖湿润的毛巾热敷眼睛一两分钟，然后用温和的洗浴用品（如稀释后的婴儿洗发水）轻轻擦洗眼睑和睫毛。</p>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/38201841">干眼症治疗的12种方法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/421364423">结膜炎 干眼症 治疗方案与康复记录</a></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>隐式类型转换导致的诡异bug</title>
    <url>/2022/07/27/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%9A%84%E8%AF%A1%E5%BC%82bug/</url>
    <content><![CDATA[<p>看以下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">NSUInteger</span> b = <span class="number">104</span>;</span><br><span class="line"><span class="built_in">NSUInteger</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">NSInteger</span> ret = a - b;</span><br><span class="line"><span class="keyword">if</span> (ret &gt; c) &#123; <span class="comment">//ret被隐式转换为无符号整型</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &gt; (<span class="built_in">NSInteger</span>)c) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;ret:%ld&quot;</span>, (<span class="type">long</span>)ret);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;ret:%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)ret);</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">30</span> <span class="number">13</span>:<span class="number">10</span>:<span class="number">02</span>.<span class="number">474708</span>+<span class="number">0800</span> PodDemo[<span class="number">22390</span>:<span class="number">3868894</span>] <span class="number">1</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">30</span> <span class="number">13</span>:<span class="number">10</span>:<span class="number">02</span>.<span class="number">474798</span>+<span class="number">0800</span> PodDemo[<span class="number">22390</span>:<span class="number">3868894</span>] ret:-<span class="number">4</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">30</span> <span class="number">13</span>:<span class="number">10</span>:<span class="number">02</span>.<span class="number">474845</span>+<span class="number">0800</span> PodDemo[<span class="number">22390</span>:<span class="number">3868894</span>] ret:<span class="number">18446744073709551612</span></span><br></pre></td></tr></table></figure>
<p>po 与 p：对象最好使用po，基础数据类型使用p。</p>
<p>swift则会溢出崩溃：swift直接写上面的代码编译都通不过，得拐个弯：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">myoverflow</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="type">UInt64</span> <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">    <span class="keyword">let</span> b: <span class="type">UInt64</span> <span class="operator">=</span> <span class="number">103</span></span><br><span class="line">    _myoverflow(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_myoverflow</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">UInt64</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">UInt64</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret <span class="operator">=</span> a <span class="operator">-</span> b <span class="comment">//Thread 1: Swift runtime failure: arithmetic overflow</span></span><br><span class="line">    <span class="keyword">let</span> c: <span class="type">Int</span> <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">    <span class="keyword">if</span> ret <span class="operator">&gt;</span> c &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;sd&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swift确实是一门安全的语言。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>隐式类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>IP协议报文</title>
    <url>/2022/07/29/IP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>网络模型常见的有7，4，5层模型。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.jpg" alt=""></p>
<p>IP协议位于四层模型中的网络层。</p>
<h3 id="IP报文"><a href="#IP报文" class="headerlink" title="IP报文"></a>IP报文</h3><p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/pictures/20170301092349308.png" alt=""></p>
<p><strong>版本</strong>：IP协议的版本，占4bit，目前的IP协议版本号为4，下一代IP协议版本号为6。注意这里讨论的是IPv4的报文，IPv6的报文已经不长这个样了。</p>
<p><strong>首部长度</strong>：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，以32bits4字节为单位，代表IP报头的最大长度可以为15个32bits（4字节），也就是最长可为15*4=60字节，除去固定部分的长度20字节，可变部分的长度最大为40字节。</p>
<p><strong>服务类型</strong>：Type Of Service。</p>
<p><strong>总长度</strong>：IP报文的总长度。报头的长度和数据部分的长度之和。用16位二进制数表示，单位为8bits1字节，因此，IP报文的最大长度为65535字节。但由于MTU的限制，超过的话需要分片传输。所以就必须要有分片相关信息的字段，后面三个就是分片相关的字段。</p>
<p><strong>标识</strong>：唯一的标识主机发送的每一份数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。</p>
<p><strong>标志</strong>：共3位。R、DF、MF三位。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。</p>
<p><strong>片偏移</strong>：本分片在原先数据报文中相对首位的偏移量，字段长度为13位，以8bit1字节为单位，主要作用是为了使分片数据的接收者能够<strong>按照正确的顺序</strong>重组报文。如果没有这个片偏移值那么接收方收到分片后就不知道把这个分片的数据拼接在哪个位置了。</p>
<p><strong>生存时间</strong>：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL（Time To Live）减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。</p>
<p><strong>协议</strong>：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.</p>
<p><strong>首部校验和</strong>：计算IP头部的校验和，检查IP报头的完整性。</p>
<p><strong>源IP地址</strong>：标识IP数据报的源端设备。32位，最大可以标识 <code>2^32</code>（约等于43亿）个设备。43亿看起来很多，但现在已经所剩无几，所以才出了IPv6，把IP地址直接干到128位，最大可以标识 <code>2^128</code> （43亿 <em> 43亿 </em> 43亿 * 43亿）个设备，应该是用不完的。</p>
<p><strong>目的IP地址</strong>：标识IP数据报的目的地址。</p>
<p>有兴趣的可以研究下IP分片与分片重组。</p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/mary19920410/article/details/59035804">IP报文格式详解</a></p>
<p><a href="http://www.023wg.com/message/message/cd_feature_ip_message_format.html">IP报文格式</a></p>
<h3 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h3><h4 id="1-IP报文中的TTL设置的规则是什么，最大值255会不会不够？"><a href="#1-IP报文中的TTL设置的规则是什么，最大值255会不会不够？" class="headerlink" title="1. IP报文中的TTL设置的规则是什么，最大值255会不会不够？"></a>1. IP报文中的TTL设置的规则是什么，最大值255会不会不够？</h4><p>现行的 IP 网络看似非常庞大，但得益于骨干网络优化，任意两点的最短路径并不长。所以就目前阶段来说TTL一般设置为64或128足以。</p>
<p>参考:</p>
<p><a href="https://fasionchan.com/network/ip/ttl/">TTL，IP包存活时间</a>  系列文章，作者写的还不错。</p>
<h4 id="2-IP报文怎么计算数据部分长度"><a href="#2-IP报文怎么计算数据部分长度" class="headerlink" title="2. IP报文怎么计算数据部分长度"></a>2. IP报文怎么计算数据部分长度</h4><p>IP报文中有两个字段首部长度、总长度，因此IP报文的数据部分长度就等于总长度-首部长度。</p>
<h4 id="3-IP报文为什么需要总长度字段"><a href="#3-IP报文为什么需要总长度字段" class="headerlink" title="3.IP报文为什么需要总长度字段"></a>3.IP报文为什么需要总长度字段</h4><p>网上博客的解释：<br>因为一些数据链路（以太网）有MTU最大传输单元限制，小于最小MTU需要填充一些数据以达到最小长度，大于最大MTU需要对数据报进行分片处理，所以需要总长度来确定 IP 数据部分的内容。</p>
<p>主要原因还是因为以太帧可能会进行填充。</p>
<p><a href="https://qinnsang.github.io/2019/09/10/%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B9%8BIP%E5%8D%8F%E8%AE%AE/">网络层之IP协议</a></p>
<h4 id="4-为什么以太网MTU通常被设置为1500？"><a href="#4-为什么以太网MTU通常被设置为1500？" class="headerlink" title="4.为什么以太网MTU通常被设置为1500？"></a>4.为什么以太网MTU通常被设置为1500？</h4><p>RFC标准定义以太网的默认MTU值为1500。那么这1500的取值是怎么来的呢？</p>
<p>早期的以太网使用共享链路的工作方式，为了保证CSMA/CD（载波多路复用/冲突检测）机制，所以规定了以太帧长度最小为64字节，最大为1518字节。最小64字节是为了保证最极端的冲突能被检测到，64字节是能被检测到的最小值；最大不超过1518字节是为了防止过长的帧传输时间过长而占用共享链路太长时间导致其他业务阻塞。所以规定以太网帧大小为64~1518字节，虽然技术不断发展，但协议一直没有更改。</p>
<p>以太网最大的数据帧是1518字节，这样刨去帧头14字节和帧尾<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html">CRC</a>校验部分4字节，那么剩下承载上层IP报文的地方最大就只有1500字节，这个值就是以太网的默认MTU值。这个MTU就是网络层协议非常关心的地方，因为网络层协议比如IP协议会根据这个值来决定是否把上层传下来的数据进行分片，如果单个IP报文长度大于MTU，则会在发送出接口前被分片，被切割为小于或等于MTU长度的IP包。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/MTU.png" alt=""></p>
<h4 id="5-超过MTU的报文如何进行分片？"><a href="#5-超过MTU的报文如何进行分片？" class="headerlink" title="5.超过MTU的报文如何进行分片？"></a>5.超过MTU的报文如何进行分片？</h4><p>以太网缺省MTU=1500字节，这是以太网接口对IP层的约束，如果IP层有&lt;=1500字节需要发送，只需要一个IP包就可以完成发送任务；如果IP层有&gt;1500字节数据需要发送，需要分片才能完成发送。</p>
<p>以主机发送一个数据载荷长度为2000字节的报文为例说明其分片的过程（假设出接口的MTU值为1500）。在网络层会对报文进行封装，其结构组成：IP头部20字节+数据载荷长度2000字节，报文封装后，整个报文长度为2020字节。在出接口进行转发的时候，发现IP报文的长度超过了MTU的值1500，因此要进行分片处理，详情见下图。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/IP%E5%88%86%E7%89%87%E7%A4%BA%E6%84%8F.png" alt=""></p>
<p>第一片报文，IP报文头固定20字节，数据载荷可以封装1480字节（MTU值1500字节-IP报文头20字节，数据载荷长度须是8的倍数）；</p>
<p>第二片报文，复制第一片的IP头，IP报文头固定20字节，数据载荷为剩余的520字节（总数据载荷长度2000字节减去第一片中已封装的1480字节）。如果最后一片报文的长度不足46字节(MTU最小值为46字节)，会自动填充至46字节。（可以看到这里会自动填充到46字节，假如整个IP包只有30字节，如果不知道IP包的总长度那么就无法得知IP包的界限。由于分片和填充的原因，所以IP包里面需要有一个总长度的字段。）</p>
<p>所有分片报文在发送至目的主机后，在目的主机进行分片重组，恢复为原报文。在进行重组时，通过IP标志位中的MF用来分辨这是不是最后一个分片，片偏移用来分辨这个分片相对原数据报的位置。通过这几个字段，可以准确的完成数据报的重组操作。</p>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>IP报文</tag>
      </tags>
  </entry>
  <entry>
    <title>父子、子子控制器间的通信</title>
    <url>/2022/08/10/%E7%88%B6%E5%AD%90%E3%80%81%E5%AD%90%E5%AD%90%E6%8E%A7%E5%88%B6%E5%99%A8%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>有一个容器控制器P，它下面有三个子控制器A、B、C。有时候我们需要在ABC之间共享一些状态信息。</p>
<p>一种可行的做法：在P下面挂一个statusContext对象（信息少也可以直接平铺在P下），三个子控制器访问这个statusContext对象达到数据通信的目的。这种方案适合状态查询这种非即时处理的场景，如果是那种需要即时处理事件的场景，那么还是使用代理，通知，block比较好。</p>
<p>另外一种方法：直接单例搞起，单例在ABC之间穿梭。不太推荐。有几个原因：1.单例因为使用过于方便导致很容易被滥用，滥用后，会很难追踪某个属性到底是在哪个地方修改的。2.单例创建后一般不会主动销毁，导致很难维护它上面的状态信息，下一次使用时可能会残存上一次的状态信息。</p>
]]></content>
      <categories>
        <category>业务开发</category>
      </categories>
      <tags>
        <tag>数据通信</tag>
      </tags>
  </entry>
  <entry>
    <title>MessageKit源码分析</title>
    <url>/2022/08/17/MessageKit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>MessageKit是一个开源的IM 消息聊天UI框架。</p>
<p>MessageKit采用UICollectionView而非UITableView作为主体架构（为什么要这么设计Why?），采用UICollectionViewCell实现聊天cell。一个section对应一条聊天消息，默认一个section里面只有一个cell（为什么要这么设计Why？）。</p>
<p>作为一个框架，难就难在如何封装各种风格迥异的聊天cell？MessageKit自定义了一种CollectionView布局方式MessagesCollectionViewFlowLayout，它继承自UICollectionViewFlowLayout。对应需要自定义layoutAttributes—MessagesCollectionViewLayoutAttributes，继承自UICollectionViewLayoutAttributes。</p>
<p>框架内部提供了几种默认的消息类型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// An enum representing the kind of message and its underlying kind.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">MessageKind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A standard text message.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Note: The font used for this message will be the value of the</span></span><br><span class="line">    <span class="comment">/// `messageLabelFont` property in the `MessagesCollectionViewFlowLayout` object.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Using `MessageKind.attributedText(NSAttributedString)` doesn&#x27;t require you</span></span><br><span class="line">    <span class="comment">/// to set this property and results in higher performance.</span></span><br><span class="line">    <span class="keyword">case</span> text(<span class="type">String</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// A message with attributed text.</span></span><br><span class="line">    <span class="keyword">case</span> attributedText(<span class="type">NSAttributedString</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A photo message.</span></span><br><span class="line">    <span class="keyword">case</span> photo(<span class="type">MediaItem</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A video message.</span></span><br><span class="line">    <span class="keyword">case</span> video(<span class="type">MediaItem</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A location message.</span></span><br><span class="line">    <span class="keyword">case</span> location(<span class="type">LocationItem</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// An emoji message.</span></span><br><span class="line">    <span class="keyword">case</span> emoji(<span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// An audio message.</span></span><br><span class="line">    <span class="keyword">case</span> audio(<span class="type">AudioItem</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// A contact message.</span></span><br><span class="line">    <span class="keyword">case</span> contact(<span class="type">ContactItem</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A link preview message.</span></span><br><span class="line">    <span class="keyword">case</span> linkPreview(<span class="type">LinkItem</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A custom message.</span></span><br><span class="line">    <span class="comment">/// - Note: Using this case requires that you implement the following methods and handle this case:</span></span><br><span class="line">    <span class="comment">///   - MessagesDataSource: customCell(for message: MessageType, at indexPath: IndexPath, in messagesCollectionView: MessagesCollectionView) -&gt; UICollectionViewCell</span></span><br><span class="line">    <span class="comment">///   - MessagesLayoutDelegate: customCellSizeCalculator(for message: MessageType, at indexPath: IndexPath, in messagesCollectionView: MessagesCollectionView) -&gt; CellSizeCalculator</span></span><br><span class="line">    <span class="keyword">case</span> custom(<span class="keyword">Any</span><span class="operator">?</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - Not supported yet</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    case system(String)</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    case placeholder</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每种消息类型提供了默认的cell样式，如果不想用默认的样式可以通过代理自己返回。每种cell对应一种CellSizeCalculator，用于提供cell的宽高。内部提供的比如：TextMessageCell—TextMessageSizeCalculator、MediaMessageCell—MediaMessageSizeCalculator、AudioMessageCell—AudioMessageSizeCalculator。</p>
<p>MessageKit的设计思想真的吊，框架提供了默认样式，如果不想用默认的样式可以通过代理自己返回。</p>
<h2 id="几种基类"><a href="#几种基类" class="headerlink" title="几种基类"></a>几种基类</h2><p>MessagesViewController—&gt;UIViewController</p>
<p>实际使用时可以继承MessagesViewController或拷贝其源码到自己的控制器。</p>
<p>MessagesCollectionView—&gt;UICollectionView</p>
<p>xxx—&gt;MessageContentCell—&gt;MessageCollectionViewCell—&gt;UICollectionViewCell</p>
<p>MessageContentCell里已经添加了很多必要的控件，比如：avatarView、messageContainerView、cellTopLabel等等。</p>
<p>xxx—&gt;MessageSizeCalculator—&gt;CellSizeCalculator</p>
<p>Calculator负责配置LayoutAttributes，并计算cell的size。MessageSizeCalculator内部已经帮你计算好了，子控件的高度由外部代理。</p>
<p>MessagesCollectionViewFlowLayout—&gt;UICollectionViewFlowLayout</p>
<p>MessagesCollectionViewFlowLayout负责返回cell的size，实际的size计算由cell对应的Calculator完成。由于cell的种类繁多，Layout内部已经内置了各种Calculator，也可以由外部传入（代理）。</p>
<p>MessagesCollectionViewLayoutAttributes—&gt;UICollectionViewLayoutAttributes</p>
<h3 id="MessagesCollectionView"><a href="#MessagesCollectionView" class="headerlink" title="MessagesCollectionView"></a>MessagesCollectionView</h3><p>内部已经注册了几种默认的样式cell:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Methods</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">registerReusableViews</span>() &#123;</span><br><span class="line">    register(<span class="type">TextMessageCell</span>.<span class="keyword">self</span>)</span><br><span class="line">    register(<span class="type">MediaMessageCell</span>.<span class="keyword">self</span>)</span><br><span class="line">    register(<span class="type">LocationMessageCell</span>.<span class="keyword">self</span>)</span><br><span class="line">    register(<span class="type">AudioMessageCell</span>.<span class="keyword">self</span>)</span><br><span class="line">    register(<span class="type">ContactMessageCell</span>.<span class="keyword">self</span>)</span><br><span class="line">    register(<span class="type">TypingIndicatorCell</span>.<span class="keyword">self</span>)</span><br><span class="line">    register(<span class="type">LinkPreviewMessageCell</span>.<span class="keyword">self</span>)</span><br><span class="line">    register(<span class="type">MessageReusableView</span>.<span class="keyword">self</span>, forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.elementKindSectionHeader)</span><br><span class="line">    register(<span class="type">MessageReusableView</span>.<span class="keyword">self</span>, forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.elementKindSectionFooter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认cell样式"><a href="#默认cell样式" class="headerlink" title="默认cell样式"></a>默认cell样式</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/MessageKit/</span>MessageKit<span class="regexp">/master/</span>Assets/CellStructure.png</span><br></pre></td></tr></table></figure>
<h2 id="自定义cell样式"><a href="#自定义cell样式" class="headerlink" title="自定义cell样式"></a>自定义cell样式</h2><p>虽然框架已经提供了很多种cell样式了，但是UI是最容易变的。所以还是需要完全自定义cell样式。</p>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>MessageKit</tag>
      </tags>
  </entry>
  <entry>
    <title>malloc、calloc、realloc简介</title>
    <url>/2022/08/09/malloc%E3%80%81calloc%E3%80%81realloc%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>函数声明：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">void	*<span class="built_in">malloc</span>(size_t __size) __result_use_check <span class="built_in">__alloc_size</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Initialization: <strong>malloc()</strong> allocates memory block of given size (in bytes) and returns a pointer to the beginning of the block. malloc() doesn’t initialize the allocated memory. If we try to acess the content of memory block then we’ll get garbage values.</p>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p>函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>	*<span class="title">calloc</span><span class="params">(<span class="type">size_t</span> __count, <span class="type">size_t</span> __size)</span> __result_use_check __<span class="title">alloc_size</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ol>
<li>Number of blocks to be allocated.</li>
<li>Size of each block.</li>
</ol>
<p><strong>calloc()</strong> allocates the memory and also initializes the allocates memory block to zero. If we try to access the content of these blocks then we’ll get 0.</p>
<p>因为calloc会将申请的内存初始化为0或NULL，所以在需要初始化的场景下该函数会很方便，比如创建一个结构体，创建一个数组。</p>
<h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p>函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>	*<span class="title">realloc</span><span class="params">(<span class="type">void</span> *__ptr, <span class="type">size_t</span> __size)</span> __result_use_check __<span class="title">alloc_size</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><strong>ptr</strong> − This is the pointer to a memory block previously allocated with malloc, calloc or realloc to be reallocated. If this is NULL, a new block is allocated and a pointer to it is returned by the function.</li>
<li>This is the new size for the memory block, in bytes. If it is 0 and ptr points to an existing block of memory, the memory block pointed by ptr is deallocated and a NULL pointer is returned.</li>
</ul>
<p>函数说明：</p>
<p>realloc可以用来重新调整之前分配的内存大小。指针p必须为指向堆内存空间的指针，即由malloc函数、calloc函数或realloc函数分配空间的指针或者为NULL。size  = 0，行为未定义，一种实现是：释放指针p指向的内存，并返回NULL。</p>
<p>realloc函数有两种行为：</p>
<ol>
<li>在原来的内存空间上进行扩张或收缩。min(newSize, oldSize)区域内的内容不变。如果是扩张则扩张部分的内存空间是未初始化的。</li>
<li>申请一块全新的内存空间，并将原来指向空间的内容依次复制到新的内存空间上，p之前指向的空间被释放。扩张部分的内存空间是未初始化的。</li>
</ol>
<p>调用realloc后，不应该再使用原来的指针p，如果使用则行为未定义。</p>
<p>上面三个申请内存的函数，在使用完后都需要调用free释放内存。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.tutorialspoint.com/c_standard_library/c_function_realloc.htm">realloc</a>  比较清晰</p>
<p><a href="https://en.cppreference.com/w/c/memory/realloc">realloc</a>  很详细。这个网站也不错，囊括了大部分C++的函数说明。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode真机调试提示Unable to install [appName]</title>
    <url>/2022/08/18/Xcode%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E6%8F%90%E7%A4%BAUnable-to-install-appName/</url>
    <content><![CDATA[<p>git拉代码到本地后，编译没有问题，但是Xcode一运行在安装app的时候就失败,弹窗提示</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Details</span><br><span class="line"></span><br><span class="line">Unable <span class="keyword">to</span> install &quot;XXX&quot;</span><br><span class="line"><span class="keyword">Domain</span>: com.apple.dt.MobileDeviceErrorDomain</span><br><span class="line">Code: <span class="number">-402653081</span></span><br><span class="line">Recovery Suggestion: Please <span class="keyword">check</span> your project settings <span class="keyword">and</span> ensure that a <span class="keyword">valid</span> product has been built.</span><br><span class="line"><span class="keyword">User</span> <span class="keyword">Info</span>: &#123;</span><br><span class="line">    DVTErrorCreationDateKey = &quot;2022-08-18 07:53:05 +0000&quot;;</span><br><span class="line">    IDERunOperationFailingWorker = IDEInstalliPhoneLauncher;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line">There was an <span class="type">internal</span> API error.</span><br><span class="line"><span class="keyword">Domain</span>: com.apple.dt.MobileDeviceErrorDomain</span><br><span class="line">Code: <span class="number">-402653081</span></span><br><span class="line"><span class="keyword">User</span> <span class="keyword">Info</span>: &#123;</span><br><span class="line">    DVTRadarComponentKey = <span class="number">261622</span>;</span><br><span class="line">    MobileDeviceErrorCode = &quot;(0xE8000067)&quot;;</span><br><span class="line">    &quot;com.apple.dtdevicekit.stacktrace&quot; = (</span><br><span class="line">	<span class="number">0</span>   DTDeviceKitBase                     <span class="number">0x000000028daad614</span> DTDKCreateNSErrorFromAMDErrorCode + <span class="number">272</span></span><br><span class="line">	<span class="number">1</span>   DTDeviceKitBase                     <span class="number">0x000000028dae6dd8</span> __90-[DTDKMobileDeviceToken installApplicationBundleAtPath:withOptions:andError:withCallback:]_block_invoke + <span class="number">160</span></span><br><span class="line">	<span class="number">2</span>   DVTFoundation                       <span class="number">0x0000000102eb5bd0</span> DVTInvokeWithStrongOwnership + <span class="number">76</span></span><br><span class="line">	<span class="number">3</span>   DTDeviceKitBase                     <span class="number">0x000000028dae6b30</span> -[DTDKMobileDeviceToken installApplicationBundleAtPath:withOptions:andError:withCallback:] + <span class="number">1336</span></span><br><span class="line">	<span class="number">4</span>   IDEiOSSupportCore                   <span class="number">0x0000000133351590</span> __118-[DVTiOSDevice(DVTiPhoneApplicationInstallation) processAppInstallSet:appUninstallSet:installOptions:completionBlock:]_block_invoke<span class="number">.301</span> + <span class="number">2916</span></span><br><span class="line">	<span class="number">5</span>   DVTFoundation                       <span class="number">0x0000000102fdcf50</span> __DVT_CALLING_CLIENT_BLOCK__ + <span class="number">16</span></span><br><span class="line">	<span class="number">6</span>   DVTFoundation                       <span class="number">0x0000000102fde068</span> __DVTDispatchAsync_block_invoke + <span class="number">364</span></span><br><span class="line">	<span class="number">7</span>   libdispatch.dylib                   <span class="number">0x00000001a2504e60</span> _dispatch_call_block_and_release + <span class="number">32</span></span><br><span class="line">	<span class="number">8</span>   libdispatch.dylib                   <span class="number">0x00000001a2506bac</span> _dispatch_client_callout + <span class="number">20</span></span><br><span class="line">	<span class="number">9</span>   libdispatch.dylib                   <span class="number">0x00000001a250e330</span> _dispatch_lane_serial_drain + <span class="number">672</span></span><br><span class="line">	<span class="number">10</span>  libdispatch.dylib                   <span class="number">0x00000001a250eea4</span> _dispatch_lane_invoke + <span class="number">392</span></span><br><span class="line">	<span class="number">11</span>  libdispatch.dylib                   <span class="number">0x00000001a2519708</span> _dispatch_workloop_worker_thread + <span class="number">656</span></span><br><span class="line">	<span class="number">12</span>  libsystem_pthread.dylib             <span class="number">0x00000001a26c15b0</span> _pthread_wqthread + <span class="number">288</span></span><br><span class="line">	<span class="number">13</span>  libsystem_pthread.dylib             <span class="number">0x00000001a26c02c4</span> start_wqthread + <span class="number">8</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">Analytics Event: com.apple.dt.IDERunOperationWorkerFinished : &#123;</span><br><span class="line">    &quot;device_model&quot; = &quot;iPhone9,2&quot;;</span><br><span class="line">    &quot;device_osBuild&quot; = &quot;15.6 (19G71)&quot;;</span><br><span class="line">    &quot;device_platform&quot; = &quot;com.apple.platform.iphoneos&quot;;</span><br><span class="line">    &quot;launchSession_schemeCommand&quot; = Run;</span><br><span class="line">    &quot;launchSession_state&quot; = <span class="number">1</span>;</span><br><span class="line">    &quot;launchSession_targetArch&quot; = arm64;</span><br><span class="line">    &quot;operation_duration_ms&quot; = <span class="number">6186</span>;</span><br><span class="line">    &quot;operation_errorCode&quot; = &quot;-402653081&quot;;</span><br><span class="line">    &quot;operation_errorDomain&quot; = &quot;com.apple.dt.MobileDeviceErrorDomain&quot;;</span><br><span class="line">    &quot;operation_errorWorker&quot; = IDEInstalliPhoneLauncher;</span><br><span class="line">    &quot;operation_name&quot; = IDEiPhoneRunOperationWorkerGroup;</span><br><span class="line">    &quot;param_consoleMode&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_debugger_attachToExtensions&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_debugger_attachToXPC&quot; = <span class="number">1</span>;</span><br><span class="line">    &quot;param_debugger_type&quot; = <span class="number">5</span>;</span><br><span class="line">    &quot;param_destination_isProxy&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_destination_platform&quot; = &quot;com.apple.platform.iphoneos&quot;;</span><br><span class="line">    &quot;param_diag_MainThreadChecker_stopOnIssue&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_MallocStackLogging_enableDuringAttach&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_MallocStackLogging_enableForXPC&quot; = <span class="number">1</span>;</span><br><span class="line">    &quot;param_diag_allowLocationSimulation&quot; = <span class="number">1</span>;</span><br><span class="line">    &quot;param_diag_gpu_frameCapture_enable&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_gpu_shaderValidation_enable&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_gpu_validation_enable&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_memoryGraphOnResourceException&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_queueDebugging_enable&quot; = <span class="number">1</span>;</span><br><span class="line">    &quot;param_diag_runtimeProfile_generate&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_sanitizer_asan_enable&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_sanitizer_tsan_enable&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_sanitizer_tsan_stopOnIssue&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_sanitizer_ubsan_stopOnIssue&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_showNonLocalizedStrings&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_diag_viewDebugging_enabled&quot; = <span class="number">1</span>;</span><br><span class="line">    &quot;param_diag_viewDebugging_insertDylibOnLaunch&quot; = <span class="number">1</span>;</span><br><span class="line">    &quot;param_install_style&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_launcher_UID&quot; = <span class="number">2</span>;</span><br><span class="line">    &quot;param_launcher_allowDeviceSensorReplayData&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_launcher_kind&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_launcher_style&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_launcher_substyle&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_runnable_appExtensionHostRunMode&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_runnable_productType&quot; = &quot;com.apple.product-type.application&quot;;</span><br><span class="line">    &quot;param_runnable_swiftVersion&quot; = &quot;5.6.1&quot;;</span><br><span class="line">    &quot;param_runnable_type&quot; = <span class="number">2</span>;</span><br><span class="line">    &quot;param_testing_launchedForTesting&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_testing_suppressSimulatorApp&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;param_testing_usingCLI&quot; = <span class="number">0</span>;</span><br><span class="line">    &quot;sdk_canonicalName&quot; = &quot;iphoneos15.5&quot;;</span><br><span class="line">    &quot;sdk_osVersion&quot; = &quot;15.5&quot;;</span><br><span class="line">    &quot;sdk_variant&quot; = iphoneos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">System</span> Information</span><br><span class="line"></span><br><span class="line">macOS <span class="keyword">Version</span> <span class="number">12.0</span><span class="number">.1</span> (Build <span class="number">21</span>A559)</span><br><span class="line">Xcode <span class="number">13.4</span><span class="number">.1</span> (<span class="number">20504</span>) (Build <span class="number">13</span>F100)</span><br><span class="line"><span class="type">Timestamp</span>: <span class="number">2022</span><span class="number">-08</span><span class="number">-18</span>T15:<span class="number">53</span>:<span class="number">05</span>+<span class="number">08</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>先clean工程，再删DerivedData文件，重启手机，重启电脑，但是都没有用。clean、删除好几遍都没有用，其实到这里就可以肯定是和缓存没关系了，再怎么clean都没用，因为可能是其他地方的原因导致的。完全clean两次如果没用就应该找其他原因了，如果早意识到这一点还可以节省点时间。</p>
<p>查了1个半小时，就发现一篇文章提到删除target里的通知扩展，删除后确实可以运行安装，但是这不是解决办法啊。估摸着大概就是通知扩展那一块有问题，于是比对好的工程的设置，最终发现是NotificationService.swift文件没有加到NotificationService target里去导致的。添加后解决。网上好多类似的问题，但和我这个完全一样的几乎没有，好浪费时间无语。</p>
]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
  </entry>
  <entry>
    <title>给第三方库动态添加方法实现</title>
    <url>/2022/09/20/%E7%BB%99%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>给NextGrowingTextView添加扩展，支持设置光标大小。</p>
<p>NextGrowingTextView是一个第三方库，内部有一个继承自UITextView的NextGrowingInternalTextView，这个textview外部是访问不了的。而设置textview的光标大小需要继承UITextView并重写UITextInput.caretRect(for:)方法。怎么办呢？</p>
<p>大概有三种办法：</p>
<p>1、私有化NextGrowingTextView。直接改NextGrowingInternalTextView类。这种最简单，但是以后就需要自己维护这个库了。</p>
<p>2、方法交换UITextView的caretRect(for:)实现。这种也比较简单，但是由于交换的是UITextView的实现，影响的范围比较大。</p>
<p>3、动态给NextGrowingInternalTextView添加caretRect(for:)实现。这个影响的范围只有NextGrowingInternalTextView，并且也不需要私有化NextGrowingTextView。个人觉得是最佳的解决办法了。这个方案的难点是添加自己的实现后怎么调用父类的实现。解决办法就是先获取父类的IMP，再添加自己的实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">NextGrowingTextView</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> <span class="title class_">AssociatedKeys</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> caretSize <span class="operator">=</span> <span class="string">&quot;caretSize&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> caretSize: <span class="type">CGSize</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span><span class="type">AssociatedKeys</span>.caretSize) <span class="keyword">as?</span> <span class="type">CGSize</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span><span class="type">AssociatedKeys</span>.caretSize, newValue, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">            hookCaretRectMethodOnce()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">hookCaretRectMethodOnce</span>() &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.once &#123;</span><br><span class="line">            <span class="keyword">let</span> cls: <span class="type">AnyClass</span> <span class="operator">=</span> <span class="built_in">type</span>(of: <span class="keyword">self</span>.textView)</span><br><span class="line">            <span class="keyword">let</span> sel: <span class="type">Selector</span> <span class="operator">=</span> <span class="keyword">#selector</span>(<span class="type">UITextInput</span>.caretRect(for:))</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> originalMethod <span class="operator">=</span> class_getInstanceMethod(cls, sel) <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> originalIMP <span class="operator">=</span> method_getImplementation(originalMethod)</span><br><span class="line">            <span class="keyword">typealias</span> <span class="type">Function</span> <span class="operator">=</span> <span class="keyword">@convention(c)</span> (<span class="type">AnyObject</span>, <span class="type">Selector</span>, <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">CGRect</span></span><br><span class="line">            <span class="keyword">let</span> function <span class="operator">=</span> <span class="built_in">unsafeBitCast</span>(originalIMP, to: <span class="type">Function</span>.<span class="keyword">self</span>)</span><br><span class="line">            <span class="keyword">let</span> implementBlock: <span class="keyword">@convention(block)</span> (<span class="type">UITextView</span>, <span class="type">UITextPosition</span>) -&gt; <span class="type">CGRect</span> <span class="operator">=</span> &#123; (textView, position) -&gt; <span class="type">CGRect</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">var</span> rect <span class="operator">=</span> function(textView, sel, position)</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> parentView <span class="operator">=</span> textView.superview <span class="keyword">as?</span> <span class="type">NextGrowingTextView</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> rect&#125;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> caretSize <span class="operator">=</span> parentView.caretSize <span class="keyword">else</span> &#123;<span class="keyword">return</span> rect&#125;</span><br><span class="line">                rect.origin.y <span class="operator">-=</span> (caretSize.height <span class="operator">-</span> rect.size.height)</span><br><span class="line">                rect.size <span class="operator">=</span> caretSize</span><br><span class="line">                <span class="keyword">return</span> rect</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> types <span class="operator">=</span> <span class="string">&quot;&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;@:@&quot;</span></span><br><span class="line">            class_addMethod(cls, sel, imp_implementationWithBlock(<span class="built_in">unsafeBitCast</span>(implementBlock, to: <span class="type">AnyObject</span>.<span class="keyword">self</span>)), types)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://swift.gg/2016/05/18/swift-qa-2016-05-18/">每周 Swift 社区问答：@convention</a></p>
]]></content>
      <categories>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>NextGrowingTextView</tag>
      </tags>
  </entry>
  <entry>
    <title>可变参数的函数</title>
    <url>/2022/10/03/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="如何声明一个可变参数的函数"><a href="#如何声明一个可变参数的函数" class="headerlink" title="如何声明一个可变参数的函数"></a>如何声明一个可变参数的函数</h3><p>在无法给出所有传递给函数的参数的类型和数目时，可以使用省略号（…）指定函数参数表。有如下几种形式：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b, ...)</span></span>; <span class="comment">//给出确定的几个参数，其他用省略号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a ...)</span></span>;            <span class="comment">//省略号前有或者没有逗号都是可以的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">(...)</span></span>;                  <span class="comment">//也可以不确定任何参数，但和没有参数是不一样的</span></span><br></pre></td></tr></table></figure>
<p>举个例子：计算n个整数的和。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">int</span>)test_n_number_add:(<span class="type">int</span>)n, ... &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    va_list ap; <span class="comment">//声明</span></span><br><span class="line">    va_start(ap, n); <span class="comment">//绑定</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += va_arg(ap, <span class="type">int</span>); <span class="comment">//获取参数。va_arg返回的就是参数的值。</span></span><br><span class="line">        n -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap); <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;res:%d&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>va_list存在的两个隐患：</p>
<p>1.如何确定参数的类型。</p>
<p>没有其他办法，就是通过强制转换。va_arg就是把当前指针所指向的内容强制转换到指定类型。像printf函数还有个格式化参数来说明后面参数的类型。如果是自己写的，同样得事先约定好一套规则。</p>
<p>2.如何确定参数的个数。也就是参数结束标志。</p>
<p>也没有规定，同样得事先约定好一套规则。比如这里第一个固定参数说明了后续可变参数的个数。再比如求自然数的平方和，那么可以把负数和0作为它的结束标志。其他系统函数如scanf把接收到的回车符作为结束标志，大家熟知的printf对字符串的处理用’\0’作为结束标志。</p>
<p>由于上面的原因，对于可变参数的函数，外部调用者和实现者必须遵守共同的约定才行。可变参数的函数，一般在格式化函数中用的比较多。</p>
<h3 id="NSLog-和-NSLogv"><a href="#NSLog-和-NSLogv" class="headerlink" title="NSLog 和 NSLogv"></a>NSLog 和 NSLogv</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="type">void</span> <span class="built_in">NSLog</span>(<span class="built_in">NSString</span> *format, ...) <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="built_in">NS_NO_TAIL_CALL</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="type">void</span> <span class="built_in">NSLogv</span>(<span class="built_in">NSString</span> *format, va_list args) <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">1</span>,<span class="number">0</span>) <span class="built_in">NS_NO_TAIL_CALL</span>;</span><br></pre></td></tr></table></figure>
<p>NSLogv可以传入一个可变参数列表，而NSLog不能（废话）。</p>
<p>考虑这样一种情况：函数A接受可变参数，函数B也接受可变参数。A内部要调用函数B，那么怎么把可变参数传给B呢？那么就可以使用va_list先获取到可变参数列表，再传给B。</p>
<p>举例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_nslog &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *format = <span class="string">@&quot;this is object:%@, age = %d, ch = %c&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(format, <span class="keyword">self</span>, age, <span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test_nslogv:(<span class="built_in">NSString</span> *)format, ... &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *myLogFormat = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;[my log v0]:%@&quot;</span>, format];</span><br><span class="line">    </span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    <span class="built_in">NSLogv</span>(myLogFormat, ap); <span class="comment">//获取到参数列表后，直接传给NSLogv。因为我们并不关心参数列表里究竟是啥参数。</span></span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/pengdonglin137/p/3345911.html">理解可变参数va_list、va_start、va_arg、va_end原理及使用方法</a></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>可变参数</tag>
      </tags>
  </entry>
  <entry>
    <title>OC内存管理变迁</title>
    <url>/2022/10/10/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%98%E8%BF%81/</url>
    <content><![CDATA[<p>OC的内存管理大致可以分为MRC阶段和ARC阶段。</p>
<p>MRC：手动引用计数，“手动”很好理解就是亲自动手写代码，“引用计数”就是数数，数一下这个对象的引用次数。当我们需要用这个对象的时候先调用一下retain，引用计数就加1，不用了就调用一下release，引用计数就减1，减到0系统就会帮我们释放这个对象的内存。</p>
<p>为什么会有“引用计数”这么个东西？<br>试想一下如果没有引用计数会怎样，比如你创建了一个对象，这个对象传来传去在很多个地方使用，那么什么时候调用free销毁对象成了一个难题。如下：类A创建了一个对象obj，然后obj作为参数传给类B。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)function</span><br><span class="line">&#123;</span><br><span class="line">	  <span class="type">id</span> obj = [xxx new];</span><br><span class="line">	  [B someMethod:obj];</span><br><span class="line">	  ...</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obj传给类B后，B有可能保存也可能不保存obj。这时类A对obj的处理就非常尴尬了，如果贸然调用free，万一类B还在用就会导致野指针访问崩溃，不调用吧，万一类B又没在用就会内存泄露。但是通过引用计数，我们就不需要考虑什么时候调用free了，系统会根据引用计数是否为0来决定是否销毁对象，你只需要retain和release。</p>
<p>举个生活中的例子：</p>
<p>场景1：张三去厕所拉屎，里面一片漆黑，于是张三打开灯，找了个坑位关上门开始造。造完后，出来关上灯。完美！</p>
<p>场景2：还是张三去厕所拉屎，里面一片漆黑，于是张三打开灯，找了个坑位关上门开始造。这时，李四也来拉屎，由于灯是亮的于是李四径直找了个坑位关上门开始造。过了一会张三拉完了，由于张三并不知道李四进来了，于是出门把灯关了。只听见在漆黑里的李四一声卧槽！</p>
<p>从上面的例子可以看出什么时候关灯确实是个问题，怎么解决这个问题呢？方法有很多比如进去之后大喊一声俺来了让里面所有人都知道有人来了。但是最简单的办法还是大家都遵守一套规则：进门前请按加号键，出门后请按减号键。这就相当于引用计数了。</p>
<p>场景3：张三去厕所拉屎，里面一片漆黑，外面告示写着进门前请按加号键，出门后请按减号键。这时张三按了一下墙壁上的加号键，灯亮了，于是找了个坑位关上门开始造。这时李四也来拉屎，他也按照告示按了下墙壁上的加号键，接着他找了个坑位开始安心拉屎。这时张三拉完屎，出门时按照告示按下了减号键，灯没有灭，这时张三明白了期间又来人了，虽然不知道在哪个坑位，但肯定是有人正在拉。当李四拉完后，也按了下墙壁上的减号键，这时确实没人在拉屎了，于是灯灭了，非常的完美。在这个系统里，你不需要知道中途进来了多少人，也不需要任何交流，只需要遵守外面的告示，就解决了灯何时灭的问题。</p>
<p>retain代表你拥有了这个对象，不再需要时要调用release，将引用计数减1。除了retain方法代表你拥有这个对象，有一些方法也代表你拥有这个对象，不用了也需要调用release，究竟是哪些方法呢？人们定义了一套命名规则，规定以alloc/new/copy/mutableCopy开头的方法创建的对象是你自己拥有的对象，不用了也需要调用release。除此之外获得的对象则不是自己拥有的对象，不能调用release。这就是手动引用计数。</p>
<p>举个例子：</p>
<p>XQCat 为ARC，ViewController为MRC</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> test_creat_obj];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test_creat_obj &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        XQCat *cat1 = [XQCat newCat];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;cat1:%@&quot;</span>, cat1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        XQCat *cat2 = [XQCat newerCat];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;cat2:%@&quot;</span>, cat2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        XQCat *cat3 = [XQCat allocCat];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;cat3:%@&quot;</span>, cat3);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        XQCat *cat4 = [XQCat allocationCat];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;cat4:%@&quot;</span>, cat4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XQCat</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@销毁&quot;</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)newCat &#123;</span><br><span class="line">    <span class="type">id</span> cat = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)newerCat &#123;</span><br><span class="line">    <span class="type">id</span> cat = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocCat &#123;</span><br><span class="line">    <span class="type">id</span> cat = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocationCat &#123;</span><br><span class="line">    <span class="type">id</span> cat = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2022</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">27</span>:<span class="number">25</span>.<span class="number">267602</span>+<span class="number">0800</span> MRCDemo[<span class="number">4032</span>:<span class="number">1406589</span>] cat1:&lt;XQCat: <span class="number">0</span>x600003110be0&gt;</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">27</span>:<span class="number">25</span>.<span class="number">267668</span>+<span class="number">0800</span> MRCDemo[<span class="number">4032</span>:<span class="number">1406589</span>] cat2:&lt;XQCat: <span class="number">0</span>x60000310c140&gt;</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">27</span>:<span class="number">25</span>.<span class="number">267708</span>+<span class="number">0800</span> MRCDemo[<span class="number">4032</span>:<span class="number">1406589</span>] cat3:&lt;XQCat: <span class="number">0</span>x600003108340&gt;</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">27</span>:<span class="number">25</span>.<span class="number">267749</span>+<span class="number">0800</span> MRCDemo[<span class="number">4032</span>:<span class="number">1406589</span>] cat4:&lt;XQCat: <span class="number">0</span>x600003100f20&gt;</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">27</span>:<span class="number">25</span>.<span class="number">281462</span>+<span class="number">0800</span> MRCDemo[<span class="number">4032</span>:<span class="number">1406589</span>] &lt;XQCat: <span class="number">0</span>x600003100f20&gt;销毁</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">27</span>:<span class="number">25</span>.<span class="number">281524</span>+<span class="number">0800</span> MRCDemo[<span class="number">4032</span>:<span class="number">1406589</span>] &lt;XQCat: <span class="number">0</span>x60000310c140&gt;销毁</span><br></pre></td></tr></table></figure>
<p>你会发现cat1,cat3没被释放，cat2和cat4被释放了，说明系统是遵守这个命名规则的。cat1,cat3是我们自己拥有的，需要我们自己调用release释放，而cat2和cat4不是按照命名规则创建的，说明不是我们拥有的对象，而是注册到自动释放池里的对象。所以我们不能再调用release。</p>
<p>然而，每次手动调用retain和release也是挺麻烦的，稍有不慎多调用了一次release，那就野指针崩溃，少调用了一次就内存泄露。于是人们便想有没有办法让系统自动在合适的地方添加retain和release？答案自然是有。变量的作用域就是一个很好的时机。变量初始化的时候就插入一条retain，当变量超出作用域的时候就插入一条release。这样就不需要我们手动调用了，编译器会在合适的地方自动添加retain和release。上面的例子，人们手动按按钮改为红外线自动感应入和出，这就是自动引用计数了。</p>
<p>关于ARC还有一些问题，比如并不是每次变量初始化都是插入retain，有可能我们需要的是weak，那么编译器是怎么知道的呢？为了解决这个问题，所有权修饰符便出现了。通过不同类型的所有权修饰符，编译器就知道是添加retain还是添加weak了。ARC 有效时，<strong>id 类型和对象类型</strong>必须附加所有权修饰符，有如下几种：</p>
<ul>
<li>__strong 修饰符</li>
<li>__weak 修饰符</li>
<li>__unsafe_unretained 修饰符</li>
<li>__autoreleasing 修饰符</li>
</ul>
<p>其中 <code>__strong</code> 修饰符是OC对象类型的默认修饰符，此时编译器会自动插入retain/release。关于所有权修饰符背后的故事可以参考其他文章。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.devtang.com/2016/07/30/ios-memory-management/">理解 iOS 的内存管理</a></p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>左移与右移</title>
    <url>/2022/10/17/%E5%B7%A6%E7%A7%BB%E4%B8%8E%E5%8F%B3%E7%A7%BB/</url>
    <content><![CDATA[<p>左移与右移：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&gt;&gt;&quot;</span>右移</span><br><span class="line">操作规则：最低位丢弃。正数前面补零，负数前面补<span class="number">1</span>。</span><br><span class="line"><span class="string">&quot;&lt;&lt;&quot;</span>左移</span><br><span class="line">操作规则：最高位丢弃。无论正负数，后面补零。</span><br><span class="line">建议：左右移时参数最好限定为无符号数或正整数。有符号数需要注意的地方太多了。</span><br><span class="line"></span><br><span class="line">有符号数：</span><br><span class="line">根据内存分布，按上述规则移动。</span><br><span class="line">左移：由于有符号数最高位为符号位，左移时可能会发生符号位变化所以最好自己根据内存分布计算。</span><br><span class="line">右移：如果数为正，不溢出的情况下，每移一位相当于除以<span class="number">2</span>并向下取整，等价于除以<span class="number">2</span>。如果数为负，每移一位相当于除以<span class="number">2</span>并向上取整。如-<span class="number">1</span>，-<span class="number">1</span>/<span class="number">2</span> = -<span class="number">0.5</span>向上取整 = -<span class="number">1</span>。-<span class="number">3</span>，-<span class="number">3</span>/<span class="number">2</span> = -<span class="number">1.5</span>向上取整 = -<span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">无符号数：</span><br><span class="line">左移：不溢出的情况下，左移一位相当于乘<span class="number">2</span>。</span><br><span class="line">右移：不溢出的情况下，右移一位相当于除<span class="number">2</span>并向下取整，等价于除以<span class="number">2</span>。</span><br><span class="line"></span><br><span class="line"><span class="built_in">n</span>           = <span class="number">1010</span> <span class="number">1000</span></span><br><span class="line"><span class="built_in">n</span> - <span class="number">1</span>       = <span class="number">1010</span> <span class="number">0111</span></span><br><span class="line"><span class="built_in">n</span> &amp; (<span class="built_in">n</span> - <span class="number">1</span>) = <span class="number">1010</span> <span class="number">0000</span>  //相当于将<span class="built_in">n</span>的最右边的<span class="number">1</span>消为<span class="number">0</span>。<span class="built_in">n</span>为正数或负数都可以。</span><br><span class="line">而右移需要参数为正数。</span><br><span class="line">在数二进制<span class="number">1</span>的个数方面，<span class="built_in">n</span> &amp; (<span class="built_in">n</span> - <span class="number">1</span>)是最佳解决办法。</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">-3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="built_in">hammingWeight</span>(a); <span class="comment">//会被强转为int。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cnt = %d\n&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> b = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d，a / 2 = %d\n&quot;</span>, b, a / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> d = c &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d = %d\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span> <span class="operator">=</span> -<span class="number">3</span></span><br><span class="line"><span class="attribute">cnt</span> <span class="operator">=</span> <span class="number">31</span></span><br><span class="line"><span class="attribute">b</span> <span class="operator">=</span> -<span class="number">2</span>，a / <span class="number">2</span> <span class="operator">=</span> -<span class="number">1</span></span><br><span class="line"><span class="attribute">c</span> <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="attribute">d</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>移位</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO的使用及实现原理</title>
    <url>/2022/11/24/KVO%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="KVO使用"><a href="#KVO使用" class="headerlink" title="KVO使用"></a>KVO使用</h2><p>KVO,观察者与被观察者.被观察者添加某个观察者,观察自身某一属性的变化.当被观察者的属性值发生变化时,被观察者会直接将变化发送给观察者 (通过给观察者发送observeValueForKeyPath:消息),这也是和通知差别比较大的地方.</p>
<p>1.观察者需要实现observeValueForKeyPath:方法,并在该方法中做出相应行为.如果观察者没有实现observeValueForKeyPath:方法,且其父类也没有实现，那么最终会走到NSObject的实现，而NSObject的默认实现就是崩溃:An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.如果观察者本身没有实现observeValueForKeyPath:…方法,但是其父类实现了,那么执行的就是父类的实现,这也是消息的传递过程.</p>
<p>2.[super observeValueForKeyPath:]</p>
<p>对于网上一种写法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object</span><br><span class="line">change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="type">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class="string">@&quot;contentOffset&quot;</span>]) &#123;</span><br><span class="line">      [<span class="keyword">self</span> doSomethingWhenContentOffsetChanges];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [<span class="variable language_">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先要清楚[super method]的作用,[super method]表示的是去执行父类里的实现,消息的接收者还是子类对象本身.并不是说消息的接收者变成了一个父类对象在执行该方法.完整的写法确实应该在else处添加super调用。但由于这种场景很少出现，所以很少有人特意去调super，一般也不会出问题。</p>
<p>3.KVO的context参数取值</p>
<p>context参数虽然可以传入任意值,但如果传入的是一个对象,则必须保证在KVO期间该对象不会被销毁.否则在observeValueForKeyPath方法中将导致野指针访问崩溃.可以传入一些常量比如字符串常量,或类对象.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.people addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:(__bridge <span class="type">void</span> * _Nullable)(<span class="keyword">self</span>.class)];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.people addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="string">@&quot;mycontext&quot;</span>];</span><br></pre></td></tr></table></figure>
<p> 不应该传入一个临时对象比如</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.people addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:(__bridge <span class="type">void</span> * _Nullable)([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class)])];</span><br></pre></td></tr></table></figure>
<p>4.removeObserver:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="type">void</span> *)context API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
<p>作用都是移除观察者. 使用带context的移除方法,可以让你精细控制移除指定场景下的观察者.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="type">void</span> *)context <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">5</span>_0);</span><br></pre></td></tr></table></figure>
<p>官方说明:<br>You should use -removeObserver:forKeyPath:context: instead of -removeObserver:forKeyPath: whenever possible because it allows you to more precisely specify your intent. When the same observer is registered for the same key path multiple times, but with different context pointers each time, -removeObserver:forKeyPath: has to guess at the context pointer when deciding what exactly to remove, and it can guess wrong.<br>也就是说当一个对象多次注册观察同一个key path但context不同时,那么使用带context的方法可以让你精确的移除某个context下的观察,而另一个继续工作.</p>
<p>5.KVO坑</p>
<p>5.1 KVO的addObserver和removeObserver要配对使用,否则导致崩溃.</p>
<p>5.1.1 添加次数&gt;移除次数。</p>
<p>常见的是添加了而不调用移除.这种情况崩溃需要一定的条件触发：观察者先于被观察者销毁，被观察者的属性再发生改变。<br>A添加了B作为观察者，B先于A销毁，B销毁时需要将B从观察者列表中移除。如果不移除,当被观察者的属性发生改变时,系统依然会给这个已销毁的观察者发送observeValueForKeyPath消息,从而导致野指针崩溃.内部实现估计是unsafe_unretain引用。</p>
<p>5.1.2 添加次数&lt;移除次数。</p>
<p>常见的是没有添加却调用移除.这种情况是马上崩溃。<br>如果B不是A的观察者,那么A就不能去removeObserver:B.否则崩溃:Cannot remove an observer <Student 0x60800001a020> for the key path “highlighted” from <UIButton 0x7fc29341f300> because it is not registered as an observer.<br>看起来是废话,但确实有可能发生,比如B之前是A的观察者,后来A removeObserver:B,此时B就不再是A的观察者,如果后面A又removeObserver:B的话,就会导致崩溃.还有一种场景就是B还没注册成为A的观察者时,B就先销毁了,而B的dealloc里有移除操作，这个更有可能发生.</p>
<p>6.重复注册</p>
<p>子类SecondViewController的viewDidLoad里addObserver：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.people addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>
<p>父类BaseViewController的viewDidLoad里也addObserver:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.people addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>
<p>因为SecondViewController实例注册了两次.当people的name发生变化,系统会调用SecondViewController实例的observeValueForKeyPath方法两次.由于注册了两次，在不需要观察时也要移除两次。</p>
<h2 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h2><p>测试代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Tree</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ageVarChanger:(<span class="built_in">NSInteger</span>)age;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)someClassMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Tree *tree;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addKVO &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;add前，class:%@, superClass:%@, setAge:%p&quot;</span>, object_getClass(<span class="keyword">self</span>.tree), class_getSuperclass(object_getClass(<span class="keyword">self</span>.tree)), [<span class="keyword">self</span>.tree methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line">    [<span class="keyword">self</span> printObjectInstanceMethod:object_getClass(<span class="keyword">self</span>.tree)];</span><br><span class="line">    [<span class="keyword">self</span> printObjectClassMethod:object_getClass(<span class="keyword">self</span>.tree)];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.tree addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;add后，class:%@, superClass:%@, setAge:%p&quot;</span>, object_getClass(<span class="keyword">self</span>.tree), class_getSuperclass(object_getClass(<span class="keyword">self</span>.tree)), [<span class="keyword">self</span>.tree methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line">    [<span class="keyword">self</span> printObjectInstanceMethod:object_getClass(<span class="keyword">self</span>.tree)];</span><br><span class="line">    [<span class="keyword">self</span> printObjectClassMethod:object_getClass(<span class="keyword">self</span>.tree)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">329809</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] add前，class:Tree, superClass:NSObject, setAge:<span class="number">0</span>x102fa76fc</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">329868</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,ageVarChanger:</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">329908</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,age</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">329947</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,setAge:</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">329977</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,name</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">330008</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,setName:</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">330037</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,.cxx_destruct</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">330076</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 类方法,someClassMethod</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">330198</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] add后，class:NSKVONotifying_Tree, superClass:Tree, setAge:<span class="number">0</span>x180b5ff00</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">330235</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,setAge:</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">330268</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,class</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">330300</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,dealloc</span><br><span class="line"><span class="attribute">2022</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">13</span>.<span class="number">330330</span>+<span class="number">0800</span> UIObserver[<span class="number">10217</span>:<span class="number">296735</span>] 实例方法,_isKVOA</span><br></pre></td></tr></table></figure>
<p>可以看到对象添加观察者后，对象tree的isa指针指向的是类NSKVONotifying_Tree，而不是Tree。并且setAge:方法的实现也变了。NSKVONotifying_Tree是Tree的子类，并且重写了setAge:。</p>
<p>举个运行时创建类的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    _obj = [ARCPerson new];</span><br><span class="line">    </span><br><span class="line">    Class newClass = objc_allocateClassPair([<span class="built_in">NSString</span> <span class="keyword">class</span>],</span><br><span class="line">    <span class="string">&quot;NSStringSubclass&quot;</span>, <span class="number">0</span>);</span><br><span class="line">     class_addMethod(newClass, <span class="keyword">@selector</span>(report), (IMP)ReportFunction, <span class="string">&quot;v@:&quot;</span>); objc_registerClassPair(newClass);</span><br><span class="line">    <span class="type">id</span> instanceOfNewClass = [[newClass alloc] init];</span><br><span class="line">     [instanceOfNewClass performSelector:<span class="keyword">@selector</span>(report)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> ReportFunction(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot; &gt;&gt; This object is %p.&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot; &gt;&gt; Class is %@, and super is %@.&quot;</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], [<span class="keyword">self</span> superclass]);</span><br><span class="line">    Class prevClass = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>]; currentClass; ++count) &#123;</span><br><span class="line">        prevClass = currentClass;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot; &gt;&gt; Following the isa pointer %d times gives %p&quot;</span>, count, currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">        <span class="keyword">if</span> (prevClass == currentClass)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot; &gt;&gt; NSObject&#x27;s class is %p&quot;</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot; &gt;&gt; NSObject&#x27;s meta class is %p&quot;</span>, object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安全的使用KVO"><a href="#安全的使用KVO" class="headerlink" title="安全的使用KVO"></a>安全的使用KVO</h2><p>前面分析了KVO的使用添加和移除次数必须匹配，否则很容易崩溃。但是在日常使用中有时还是会出现不匹配的情况，有没有可能从技术层面完全避免呢？有，答案就是Facebook开源的KVOController。KVOController在我看来有下面几个优势：</p>
<ol>
<li>API更加现代，使用更加方便。提供block和selector，不仅如此竟然还支持在原生方法里处理。</li>
<li>线程安全。</li>
<li>可以避免添加和移除次数不匹配的问题。</li>
<li>观察者销毁时自动被移除（如果需要）。</li>
</ol>
<p>缺点：</p>
<ol>
<li>不支持设置多个context。</li>
<li>其他一些偏门场景可能会有问题。</li>
</ol>
<p>如果你不想用KVOController，也有两个简单的方法：</p>
<ol>
<li>自己定义一个标志位，添加了设置为true，移除时先判断是不是添加了，添加了才移除。</li>
<li>使用try-catch包裹移除方法。</li>
</ol>
<p>相较起来还是KVOController更牛逼。不过封装本身就是越封装使用越方便，但功能细节也丢失得越多。看情况使用吧。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>中间类是什么时候生成的？是在编译期间生成还是运行时生成？</p>
<p>运行时生成。</p>
<p>p1对象执行过addObserver操作之后，p1对象的isa指针由之前的指向类对象Person变为指向NSKVONotifyin_Person类对象，而p2对象没有任何改变。也就是说一旦p1对象添加了KVO监听以后，其isa指针就会发生变化，因此set方法的执行效果就不一样了。</p>
<p>当一个对象使用了KVO监听，iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类，子类拥有自己的set方法实现，set方法实现内部会顺序调用<strong>willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。</strong></p>
</li>
<li><p>中间类和原类的关系？</p>
<p>生成的中间类NSKVONotifyin_Person是原类Person的子类，并且重写了setAge:，class方法。重写class方法，可以让外部以为使用的还是原类，这样就隐藏了实现细节。当给对象发送其他消息时，由于NSKVONotifyin_Person是Person的子类，而NSKVONotifyin_Person又没有重写这些方法，所以会执行到父类的实现，非常的完美。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903593925935117">iOS底层原理总结 - 探寻KVO本质</a></p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title>openssl使用</title>
    <url>/2022/12/17/openssl%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-创建私钥"><a href="#1-创建私钥" class="headerlink" title="1.创建私钥"></a>1.创建私钥</h3><p>创建不带密码的私钥：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">openssl genrsa -<span class="keyword">out</span> test_rsa_private.pem <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<p>1024表示私钥的长度，长度越长安全性越高。如果对安全要求比较高可以指定私钥长度为2048。</p>
<p>查看私钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> my_test_private.key</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXAIBAAKBgQCj5vQ2rQsavYxtJyNh<span class="symbol">/nugHqOvE2kmY492h8l4lPSr/zMT1I1Z</span></span><br><span class="line">D<span class="symbol">/yTkh3sDSZHNThWk5UJukXZPGsKf5xlAaj6WZiaPSBw5WW/f7Pm8M1+kNBKZGeK</span></span><br><span class="line">sSATuVfyPs69bTBl1Mn9YcBwHXkuu7ijqSxeE8aVlKsUSAR3JDIlFiCn0QIDAQAB</span><br><span class="line">AoGAfRuopCeYR1QSYaszVfSzlvhsRxJQ<span class="symbol">/A2ZD4f8oH9K+BL3gRaIwkfyqw4oqusq</span></span><br><span class="line">ocYc9<span class="symbol">/D1HZTDBlwY9M2NqogG28FJSMp2yVIHg8pG29FnGi5TGJBNV4kx4rmkpulr</span></span><br><span class="line"><span class="symbol">/E7TL1oRVioP2I6ZWxXk5xuiNvwzm60zhyRxuDHn5DHob1UCQQDRMzaTpawx5qHj</span></span><br><span class="line">p<span class="symbol">/yWLmgFyCVB07upFXF9jGOJHmZevgxgwoe6SSh9hzCEmJLY5kYo5eDW/76Nifd+</span></span><br><span class="line">so9ACSD7AkEAyJGNa<span class="symbol">/B7GRLPoYyyA8YUeTTTdWtDmU7lS4D2eceLPrzJbTrKnKR6</span></span><br><span class="line">nijlAWry<span class="symbol">/dKPFIFOq1z28X3gwxeT8aF4owJAJIvW1/pUV69bzsKVDMN0prXtVE+h</span></span><br><span class="line"><span class="number">9</span>Arr9avl45ls9tYqoWi6f1<span class="operator">+</span>ydCN<span class="operator">+</span><span class="number">5</span>VsmJEAuN4zZN5Yb<span class="operator">+</span>uwEUZzuC5jMqwJAA6Xi</span><br><span class="line">FJyDIKme7SlJ85eet7WmQvR4fklZEk5<span class="operator">+</span>LSjb94Anib0QAllbgZTs1WHEmalCwPS5</span><br><span class="line">IZTHSQ0pEWNUZYiyUQJBAIr0BOB3myFPMVGBB4EvQegnTd40JSU7hKXaK3ZBbrE<span class="symbol">/</span></span><br><span class="line">a<span class="attr">Hoxdlz8JJsuuufaaK4Rvkdy78QTuNu0vty9jonQQeM</span><span class="operator">=</span></span><br><span class="line"><span class="operator">-</span>----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p>上述打印是base64过的。可以使用-text，以明文形式输出各个参数值</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> test_rsa_private<span class="selector-class">.pem</span> -<span class="selector-tag">text</span> -noout</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">RSA</span> Private-Key: (<span class="number">1024</span> bit)</span><br><span class="line"><span class="attribute">modulus</span>:</span><br><span class="line">    <span class="attribute">00</span>:a3:e6:f4:<span class="number">36</span>:ad:<span class="number">0</span>b:<span class="number">1</span>a:bd:<span class="number">8</span>c:<span class="number">6</span>d:<span class="number">27</span>:<span class="number">23</span>:<span class="number">61</span>:fe:</span><br><span class="line">    <span class="attribute">7b</span>:a0:<span class="number">1</span>e:a3:af:<span class="number">13</span>:<span class="number">69</span>:<span class="number">26</span>:<span class="number">63</span>:<span class="number">8</span>f:<span class="number">76</span>:<span class="number">87</span>:c9:<span class="number">78</span>:<span class="number">94</span>:</span><br><span class="line">    <span class="attribute">f4</span>:ab:ff:<span class="number">33</span>:<span class="number">13</span>:d4:<span class="number">8</span>d:<span class="number">59</span>:<span class="number">0</span>f:fc:<span class="number">93</span>:<span class="number">92</span>:<span class="number">1</span>d:ec:<span class="number">0</span>d:</span><br><span class="line">    <span class="attribute">26</span>:<span class="number">47</span>:<span class="number">35</span>:<span class="number">38</span>:<span class="number">56</span>:<span class="number">93</span>:<span class="number">95</span>:<span class="number">09</span>:ba:<span class="number">45</span>:d9:<span class="number">3</span>c:<span class="number">6</span>b:<span class="number">0</span>a:<span class="number">7</span>f:</span><br><span class="line">    <span class="attribute">9c</span>:<span class="number">65</span>:<span class="number">01</span>:a8:fa:<span class="number">59</span>:<span class="number">98</span>:<span class="number">9</span>a:<span class="number">3</span>d:<span class="number">20</span>:<span class="number">70</span>:e5:<span class="number">65</span>:bf:<span class="number">7</span>f:</span><br><span class="line">    <span class="attribute">b3</span>:e6:f0:cd:<span class="number">7</span>e:<span class="number">90</span>:d0:<span class="number">4</span>a:<span class="number">64</span>:<span class="number">67</span>:<span class="number">8</span>a:b1:<span class="number">20</span>:<span class="number">13</span>:b9:</span><br><span class="line">    <span class="attribute">57</span>:f2:<span class="number">3</span>e:ce:bd:<span class="number">6</span>d:<span class="number">30</span>:<span class="number">65</span>:d4:c9:fd:<span class="number">61</span>:c0:<span class="number">70</span>:<span class="number">1</span>d:</span><br><span class="line">    <span class="attribute">79</span>:<span class="number">2</span>e:bb:b8:a3:a9:<span class="number">2</span>c:<span class="number">5</span>e:<span class="number">13</span>:c6:<span class="number">95</span>:<span class="number">94</span>:ab:<span class="number">14</span>:<span class="number">48</span>:</span><br><span class="line">    <span class="attribute">04</span>:<span class="number">77</span>:<span class="number">24</span>:<span class="number">32</span>:<span class="number">25</span>:<span class="number">16</span>:<span class="number">20</span>:a7:d1</span><br><span class="line"><span class="attribute">publicExponent</span>: <span class="number">65537</span> (<span class="number">0</span>x10001)</span><br><span class="line"><span class="attribute">privateExponent</span>:</span><br><span class="line">    <span class="attribute">7d</span>:<span class="number">1</span>b:a8:a4:<span class="number">27</span>:<span class="number">98</span>:<span class="number">47</span>:<span class="number">54</span>:<span class="number">12</span>:<span class="number">61</span>:ab:<span class="number">33</span>:<span class="number">55</span>:f4:b3:</span><br><span class="line">    <span class="attribute">96</span>:f8:<span class="number">6</span>c:<span class="number">47</span>:<span class="number">12</span>:<span class="number">50</span>:fc:<span class="number">0</span>d:<span class="number">99</span>:<span class="number">0</span>f:<span class="number">87</span>:fc:a0:<span class="number">7</span>f:<span class="number">4</span>a:</span><br><span class="line">    <span class="attribute">f8</span>:<span class="number">12</span>:f7:<span class="number">81</span>:<span class="number">16</span>:<span class="number">88</span>:c2:<span class="number">47</span>:f2:ab:<span class="number">0</span>e:<span class="number">28</span>:aa:eb:<span class="number">2</span>a:</span><br><span class="line">    <span class="attribute">a1</span>:c6:<span class="number">1</span>c:f7:f0:f5:<span class="number">1</span>d:<span class="number">94</span>:c3:<span class="number">06</span>:<span class="number">5</span>c:<span class="number">18</span>:f4:cd:<span class="number">8</span>d:</span><br><span class="line">    <span class="attribute">aa</span>:<span class="number">88</span>:<span class="number">06</span>:db:c1:<span class="number">49</span>:<span class="number">48</span>:ca:<span class="number">76</span>:c9:<span class="number">52</span>:<span class="number">07</span>:<span class="number">83</span>:ca:<span class="number">46</span>:</span><br><span class="line">    <span class="attribute">db</span>:d1:<span class="number">67</span>:<span class="number">1</span>a:<span class="number">2</span>e:<span class="number">53</span>:<span class="number">18</span>:<span class="number">90</span>:<span class="number">4</span>d:<span class="number">57</span>:<span class="number">89</span>:<span class="number">31</span>:e2:b9:a4:</span><br><span class="line">    <span class="attribute">a6</span>:e9:<span class="number">6</span>b:fc:<span class="number">4</span>e:d3:<span class="number">2</span>f:<span class="number">5</span>a:<span class="number">11</span>:<span class="number">56</span>:<span class="number">2</span>a:<span class="number">0</span>f:d8:<span class="number">8</span>e:<span class="number">99</span>:</span><br><span class="line">    <span class="attribute">5b</span>:<span class="number">15</span>:e4:e7:<span class="number">1</span>b:a2:<span class="number">36</span>:fc:<span class="number">33</span>:<span class="number">9</span>b:ad:<span class="number">33</span>:<span class="number">87</span>:<span class="number">24</span>:<span class="number">71</span>:</span><br><span class="line">    <span class="attribute">b8</span>:<span class="number">31</span>:e7:e4:<span class="number">31</span>:e8:<span class="number">6</span>f:<span class="number">55</span></span><br><span class="line"><span class="attribute">prime1</span>:</span><br><span class="line">    <span class="attribute">00</span>:d1:<span class="number">33</span>:<span class="number">36</span>:<span class="number">93</span>:a5:ac:<span class="number">31</span>:e6:a1:e3:a7:fc:<span class="number">96</span>:<span class="number">2</span>e:</span><br><span class="line">    <span class="attribute">68</span>:<span class="number">05</span>:c8:<span class="number">25</span>:<span class="number">41</span>:d3:bb:a9:<span class="number">15</span>:<span class="number">71</span>:<span class="number">7</span>d:<span class="number">8</span>c:<span class="number">63</span>:<span class="number">89</span>:<span class="number">1</span>e:</span><br><span class="line">    <span class="attribute">66</span>:<span class="number">5</span>e:be:<span class="number">0</span>c:<span class="number">60</span>:c2:<span class="number">87</span>:ba:<span class="number">49</span>:<span class="number">28</span>:<span class="number">7</span>d:<span class="number">87</span>:<span class="number">30</span>:<span class="number">84</span>:<span class="number">98</span>:</span><br><span class="line">    <span class="attribute">92</span>:d8:e6:<span class="number">46</span>:<span class="number">28</span>:e5:e0:d6:ff:be:<span class="number">8</span>d:<span class="number">89</span>:f7:<span class="number">7</span>e:b2:</span><br><span class="line">    <span class="attribute">8f</span>:<span class="number">40</span>:<span class="number">09</span>:<span class="number">20</span>:fb</span><br><span class="line"><span class="attribute">prime2</span>:</span><br><span class="line">    <span class="attribute">00</span>:c8:<span class="number">91</span>:<span class="number">8</span>d:<span class="number">6</span>b:f0:<span class="number">7</span>b:<span class="number">19</span>:<span class="number">12</span>:cf:a1:<span class="number">8</span>c:b2:<span class="number">03</span>:c6:</span><br><span class="line">    <span class="attribute">14</span>:<span class="number">79</span>:<span class="number">34</span>:d3:<span class="number">75</span>:<span class="number">6</span>b:<span class="number">43</span>:<span class="number">99</span>:<span class="number">4</span>e:e5:<span class="number">4</span>b:<span class="number">80</span>:f6:<span class="number">79</span>:c7:</span><br><span class="line">    <span class="attribute">8b</span>:<span class="number">3</span>e:bc:c9:<span class="number">6</span>d:<span class="number">3</span>a:ca:<span class="number">9</span>c:a4:<span class="number">7</span>a:<span class="number">9</span>e:<span class="number">28</span>:e5:<span class="number">01</span>:<span class="number">6</span>a:</span><br><span class="line">    <span class="attribute">f2</span>:fd:d2:<span class="number">8</span>f:<span class="number">14</span>:<span class="number">81</span>:<span class="number">4</span>e:ab:<span class="number">5</span>c:f6:f1:<span class="number">7</span>d:e0:c3:<span class="number">17</span>:</span><br><span class="line">    <span class="attribute">93</span>:f1:a1:<span class="number">78</span>:a3</span><br><span class="line"><span class="attribute">exponent1</span>:</span><br><span class="line">    <span class="attribute">24</span>:<span class="number">8</span>b:d6:d7:fa:<span class="number">54</span>:<span class="number">57</span>:af:<span class="number">5</span>b:ce:c2:<span class="number">95</span>:<span class="number">0</span>c:c3:<span class="number">74</span>:</span><br><span class="line">    <span class="attribute">a6</span>:b5:ed:<span class="number">54</span>:<span class="number">4</span>f:a1:f4:<span class="number">0</span>a:eb:f5:ab:e5:e3:<span class="number">99</span>:<span class="number">6</span>c:</span><br><span class="line">    <span class="attribute">f6</span>:d6:<span class="number">2</span>a:a1:<span class="number">68</span>:ba:<span class="number">7</span>f:<span class="number">5</span>f:b2:<span class="number">74</span>:<span class="number">23</span>:<span class="number">7</span>e:e5:<span class="number">5</span>b:<span class="number">26</span>:</span><br><span class="line">    <span class="attribute">24</span>:<span class="number">40</span>:<span class="number">2</span>e:<span class="number">37</span>:<span class="number">8</span>c:d9:<span class="number">37</span>:<span class="number">96</span>:<span class="number">1</span>b:fa:ec:<span class="number">04</span>:<span class="number">51</span>:<span class="number">9</span>c:ee:</span><br><span class="line">    <span class="attribute">0b</span>:<span class="number">98</span>:cc:ab</span><br><span class="line"><span class="attribute">exponent2</span>:</span><br><span class="line">    <span class="attribute">03</span>:a5:e2:<span class="number">14</span>:<span class="number">9</span>c:<span class="number">83</span>:<span class="number">20</span>:a9:<span class="number">9</span>e:ed:<span class="number">29</span>:<span class="number">49</span>:f3:<span class="number">97</span>:<span class="number">9</span>e:</span><br><span class="line">    <span class="attribute">b7</span>:b5:a6:<span class="number">42</span>:f4:<span class="number">78</span>:<span class="number">7</span>e:<span class="number">49</span>:<span class="number">59</span>:<span class="number">12</span>:<span class="number">4</span>e:<span class="number">7</span>e:<span class="number">2</span>d:<span class="number">28</span>:db:</span><br><span class="line">    <span class="attribute">f7</span>:<span class="number">80</span>:<span class="number">27</span>:<span class="number">89</span>:bd:<span class="number">10</span>:<span class="number">02</span>:<span class="number">59</span>:<span class="number">5</span>b:<span class="number">81</span>:<span class="number">94</span>:ec:d5:<span class="number">61</span>:c4:</span><br><span class="line">    <span class="attribute">99</span>:a9:<span class="number">42</span>:c0:f4:b9:<span class="number">21</span>:<span class="number">94</span>:c7:<span class="number">49</span>:<span class="number">0</span>d:<span class="number">29</span>:<span class="number">11</span>:<span class="number">63</span>:<span class="number">54</span>:</span><br><span class="line">    <span class="attribute">65</span>:<span class="number">88</span>:b2:<span class="number">51</span></span><br><span class="line"><span class="attribute">coefficient</span>:</span><br><span class="line">    <span class="attribute">00</span>:<span class="number">8</span>a:f4:<span class="number">04</span>:e0:<span class="number">77</span>:<span class="number">9</span>b:<span class="number">21</span>:<span class="number">4</span>f:<span class="number">31</span>:<span class="number">51</span>:<span class="number">81</span>:<span class="number">07</span>:<span class="number">81</span>:<span class="number">2</span>f:</span><br><span class="line">    <span class="attribute">41</span>:e8:<span class="number">27</span>:<span class="number">4</span>d:de:<span class="number">34</span>:<span class="number">25</span>:<span class="number">25</span>:<span class="number">3</span>b:<span class="number">84</span>:a5:da:<span class="number">2</span>b:<span class="number">76</span>:<span class="number">41</span>:</span><br><span class="line">    <span class="attribute">6e</span>:b1:<span class="number">3</span>f:<span class="number">68</span>:<span class="number">7</span>a:<span class="number">31</span>:<span class="number">76</span>:<span class="number">5</span>c:fc:<span class="number">24</span>:<span class="number">9</span>b:<span class="number">2</span>e:ba:e7:da:</span><br><span class="line">    <span class="attribute">68</span>:ae:<span class="number">11</span>:be:<span class="number">47</span>:<span class="number">72</span>:ef:c4:<span class="number">13</span>:b8:db:b4:be:dc:bd:</span><br><span class="line">    <span class="attribute">8e</span>:<span class="number">89</span>:d0:<span class="number">41</span>:e3</span><br></pre></td></tr></table></figure>
<p>创建带密码的私钥：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">openssl genrsa -des<span class="number">3</span> -passout pass:<span class="string">&quot;123456&quot;</span> -<span class="keyword">out</span> test<span class="number">_</span>encrypt<span class="number">_</span>rsa<span class="number">_p</span>rivate.pem <span class="number">2048</span></span><br><span class="line"><span class="comment">//或者让终端提示你输入密码</span></span><br><span class="line">openssl genrsa -des<span class="number">3</span> -<span class="keyword">out</span> test<span class="number">_</span>encrypt<span class="number">_</span>rsa<span class="number">_p</span>rivate.pem <span class="number">2048</span></span><br></pre></td></tr></table></figure>
<p>-des3表示使用des3对称加密算法加密私钥。</p>
<p>这个时候如果你还想以明文形式查看私钥的各个参数就需要密码了。这样即使私钥文件泄露，如果对方没有密码也是没用的。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> test_encrypt_rsa_private<span class="selector-class">.pem</span> -<span class="selector-tag">text</span> -noout</span><br></pre></td></tr></table></figure>
<p>如果我们后期想添加、去除或者更改密码也是可以的。</p>
<h3 id="2-根据私钥提取公钥"><a href="#2-根据私钥提取公钥" class="headerlink" title="2.根据私钥提取公钥"></a>2.根据私钥提取公钥</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> test_rsa_private<span class="selector-class">.pem</span> -pubout -out test_rsa_public<span class="selector-class">.pem</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> test_encrypt_rsa_private<span class="selector-class">.pem</span> -passin pass:<span class="number">123456</span> -pubout -out test_encrypt_rsa_public<span class="selector-class">.pem</span></span><br><span class="line"><span class="comment">//或者让终端提示你输入密码</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> test_encrypt_rsa_private<span class="selector-class">.pem</span> -pubout -out test_encrypt_rsa_public.pem</span><br></pre></td></tr></table></figure>
<p>查看公钥：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">cat test_rs<span class="built_in">a_public</span>.pem</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">-----BEGIN <span class="keyword">PUBLIC</span> <span class="keyword">KEY</span>-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCj5vQ2rQsavYxtJyNh/nugHqOv</span><br><span class="line">E2kmY492h8l4lPSr/zMT1I1ZD/yTkh3sDSZHNThWk5UJukXZPGsKf5xlAaj6WZia</span><br><span class="line">PSBw5WW/f7Pm8M1+kNBKZGeKsSATuVfyPs69bTBl1Mn9YcBwHXkuu7ijqSxeE8aV</span><br><span class="line">lKsUSAR3JDIlFiCn0QIDAQAB</span><br><span class="line">-----<span class="keyword">END</span> <span class="keyword">PUBLIC</span> <span class="keyword">KEY</span>-----</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> test_rsa_public<span class="selector-class">.pem</span> -pubin -<span class="selector-tag">text</span> -noout</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">RSA</span> Public-Key: (<span class="number">1024</span> bit)</span><br><span class="line"><span class="attribute">Modulus</span>:</span><br><span class="line">    <span class="attribute">00</span>:a3:e6:f4:<span class="number">36</span>:ad:<span class="number">0</span>b:<span class="number">1</span>a:bd:<span class="number">8</span>c:<span class="number">6</span>d:<span class="number">27</span>:<span class="number">23</span>:<span class="number">61</span>:fe:</span><br><span class="line">    <span class="attribute">7b</span>:a0:<span class="number">1</span>e:a3:af:<span class="number">13</span>:<span class="number">69</span>:<span class="number">26</span>:<span class="number">63</span>:<span class="number">8</span>f:<span class="number">76</span>:<span class="number">87</span>:c9:<span class="number">78</span>:<span class="number">94</span>:</span><br><span class="line">    <span class="attribute">f4</span>:ab:ff:<span class="number">33</span>:<span class="number">13</span>:d4:<span class="number">8</span>d:<span class="number">59</span>:<span class="number">0</span>f:fc:<span class="number">93</span>:<span class="number">92</span>:<span class="number">1</span>d:ec:<span class="number">0</span>d:</span><br><span class="line">    <span class="attribute">26</span>:<span class="number">47</span>:<span class="number">35</span>:<span class="number">38</span>:<span class="number">56</span>:<span class="number">93</span>:<span class="number">95</span>:<span class="number">09</span>:ba:<span class="number">45</span>:d9:<span class="number">3</span>c:<span class="number">6</span>b:<span class="number">0</span>a:<span class="number">7</span>f:</span><br><span class="line">    <span class="attribute">9c</span>:<span class="number">65</span>:<span class="number">01</span>:a8:fa:<span class="number">59</span>:<span class="number">98</span>:<span class="number">9</span>a:<span class="number">3</span>d:<span class="number">20</span>:<span class="number">70</span>:e5:<span class="number">65</span>:bf:<span class="number">7</span>f:</span><br><span class="line">    <span class="attribute">b3</span>:e6:f0:cd:<span class="number">7</span>e:<span class="number">90</span>:d0:<span class="number">4</span>a:<span class="number">64</span>:<span class="number">67</span>:<span class="number">8</span>a:b1:<span class="number">20</span>:<span class="number">13</span>:b9:</span><br><span class="line">    <span class="attribute">57</span>:f2:<span class="number">3</span>e:ce:bd:<span class="number">6</span>d:<span class="number">30</span>:<span class="number">65</span>:d4:c9:fd:<span class="number">61</span>:c0:<span class="number">70</span>:<span class="number">1</span>d:</span><br><span class="line">    <span class="attribute">79</span>:<span class="number">2</span>e:bb:b8:a3:a9:<span class="number">2</span>c:<span class="number">5</span>e:<span class="number">13</span>:c6:<span class="number">95</span>:<span class="number">94</span>:ab:<span class="number">14</span>:<span class="number">48</span>:</span><br><span class="line">    <span class="attribute">04</span>:<span class="number">77</span>:<span class="number">24</span>:<span class="number">32</span>:<span class="number">25</span>:<span class="number">16</span>:<span class="number">20</span>:a7:d1</span><br><span class="line"><span class="attribute">Exponent</span>: <span class="number">65537</span> (<span class="number">0</span>x10001)</span><br></pre></td></tr></table></figure>
<p>ok,到现在为止rsa的公私钥已经创建完毕，我们可以试一下加解密文件了。</p>
<h3 id="3-公钥加密私钥解密"><a href="#3-公钥加密私钥解密" class="headerlink" title="3.公钥加密私钥解密"></a>3.公钥加密私钥解密</h3><p>注意：无论是使用公钥加密还是私钥加密，RSA每次能够加密的数据长度不能超过RSA密钥长度，并且根据具体的补齐方式不同输入的加密数据最大长度也不一样，而输出长度则总是跟RSA密钥长度相等。</p>
<p>准备一个plain.txt文件，输入<code>hello world!</code></p>
<p>公钥加密：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">openssl rsautl -encrypt -<span class="keyword">in</span> plain<span class="selector-class">.txt</span> -out encrypt_plain<span class="selector-class">.txt</span> -pubin -inkey test_rsa_public<span class="selector-class">.pem</span></span><br><span class="line">openssl rsautl -encrypt -<span class="keyword">in</span> plain<span class="selector-class">.txt</span> -out encrypt_plain1<span class="selector-class">.txt</span> -pubin -inkey test_encrypt_rsa_public.pem</span><br></pre></td></tr></table></figure>
<p>私钥解密：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">openssl rsautl -decrypt -<span class="keyword">in</span> encrypt_plain<span class="selector-class">.txt</span> -inkey test_rsa_private<span class="selector-class">.pem</span> -out decrypt_plain<span class="selector-class">.txt</span></span><br><span class="line">openssl rsautl -decrypt -<span class="keyword">in</span> encrypt_plain1<span class="selector-class">.txt</span> -inkey test_encrypt_rsa_private<span class="selector-class">.pem</span> -passin pass:<span class="number">123456</span> -out decrypt_plain1<span class="selector-class">.txt</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">openssl rsautl -decrypt -<span class="keyword">in</span> encrypt_plain1<span class="selector-class">.txt</span> -inkey test_encrypt_rsa_private<span class="selector-class">.pem</span> -out decrypt_plain1.txt</span><br></pre></td></tr></table></figure>
<p>打开plain.txt、decrypt_plain.txt、decrypt_plain1.txt里面的内容应该是一致的。这表明公钥加密私钥解密成功。</p>
<p>ps:密码也可以不输入在命令中，如果需要密码，终端会提示你输入的。</p>
<h3 id="4-私钥加密公钥解密"><a href="#4-私钥加密公钥解密" class="headerlink" title="4.私钥加密公钥解密"></a>4.私钥加密公钥解密</h3><p>私钥加密：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">openssl rsautl -<span class="built_in">sign</span> -<span class="keyword">in</span> plain.txt -inkey test_rsa_private.pem -<span class="keyword">out</span> <span class="built_in">sign</span>.txt</span><br><span class="line">openssl rsautl -<span class="built_in">sign</span> -<span class="keyword">in</span> plain.txt -inkey test_encrypt_rsa_private.pem -passin <span class="keyword">pass</span>:<span class="number">123456</span> -<span class="keyword">out</span> sign1.txt</span><br></pre></td></tr></table></figure>
<p>公钥解密：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">openssl rsautl -<span class="built_in">verify</span> -<span class="keyword">in</span> <span class="built_in">sign</span>.txt -inkey test_rsa_public.pem -pubin -<span class="keyword">out</span> verify_sign.txt</span><br><span class="line">openssl rsautl -<span class="built_in">verify</span> -<span class="keyword">in</span> sign1.txt -inkey test_encrypt_rsa_public.pem -pubin -<span class="keyword">out</span> verify_sign1.txt</span><br></pre></td></tr></table></figure>
<p>打开plain.txt、verify_sign.txt、verify_sign1.txt里面的内容应该是一致的。这表明私钥加密公钥解密成功。</p>
<h3 id="5-base64"><a href="#5-base64" class="headerlink" title="5.base64"></a>5.base64</h3><p>加密后的内容是二进制打开后是一堆乱码无法直观查看，可以将其base64转换为可打印的字符串。</p>
<p>base64加密:</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">openssl <span class="keyword">enc</span> -base64 -<span class="keyword">in</span> encrypt_plain.txt -<span class="keyword">out</span> base64_encrypt_plain.txt</span><br></pre></td></tr></table></figure>
<p>查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> base64_encrypt_plain.txt</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">hPuoNd2lLrszO6nmIHLwNVgCAXfrS4bWTFTTUS0s<span class="symbol">/3jFrLX6nIfdgr4R9ycUSIin</span></span><br><span class="line">dBLRf91TIi1q8qoa7Ct<span class="symbol">/NseM+EHjDXgxPSl0iwcdk2oJDNe9Rdl+KByy+CnCsPp3</span></span><br><span class="line">z47<span class="operator">+</span>W6mC<span class="operator">+</span>dNYlpL7FtFApcWfFUs2<span class="operator">+</span>a0Su4ix64PnFYQ<span class="operator">=</span></span><br></pre></td></tr></table></figure>
<p>base64解密:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">openssl enc -<span class="keyword">base64 </span>-d -in <span class="keyword">base64_encrypt_plain.txt </span>-out de_base64_encrypt_plain.txt</span><br></pre></td></tr></table></figure>
<p>再用私钥解密de_base64_encrypt_plain.txt看看能不能解密:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">openssl rsautl -decrypt -<span class="keyword">in</span> de_base64_encrypt_plain<span class="selector-class">.txt</span> -inkey test_rsa_private<span class="selector-class">.pem</span> -out de_de_base64_encrypt_plain.txt</span><br></pre></td></tr></table></figure>
<p>打开de_de_base64_encrypt_plain.txt，里面的内容还是<code>hello world!</code></p>
<h3 id="6-md5"><a href="#6-md5" class="headerlink" title="6.md5"></a>6.md5</h3><p>准备一个文件abc.txt，输入内容“abc”</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">openssl</span> dgst -md5 abc.txt</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">MD5</span><span class="params">(abc.txt)</span></span>= <span class="number">900150983</span>cd24fb0d6963f7d28e17f72</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/morgan363/p/12965779.html">openssl genrsa 命令详解</a></p>
<p><a href="https://blog.csdn.net/oooo2316/article/details/104595615">openssl加密解密</a></p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift中的关键字</title>
    <url>/2023/02/26/Swift%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="inline"><a href="#inline" class="headerlink" title="@inline"></a>@inline</h3><p>说明：函数内联，一种编译器优化技术。声明内联的函数，编译器会把该函数调用的地方用它的实现替换有点类似C语言的宏，这样就减少了函数的调用开销，属于一种微优化，如果函数实现简单，调用非常频繁可以使用内联进行优化。由于内联是把函数调用的地方用它的实现替换，因此内联可能会让程序的二进制包变大，取决于编译优化等级，编译器可能会自动对一些频繁调用的函数进行内联，如果这个函数实现比较复杂，那么此时的内联可能弊大于利，这个时候可以使用 @inline(never) 明确告知编译器关闭这一特性。@inline的另一个应用场景就是代码混淆增加逆向难度。</p>
<p>用法：使用@inline(__always) 和 @inline(never) 修饰函数。函数的访问权限可以是public也可以是private。</p>
<p>参考：<a href="https://swiftrocks.com/the-forbidden-inline-attribute-in-swift">The Forbidden @inline Attribute in Swift</a></p>
<h3 id="inlinable"><a href="#inlinable" class="headerlink" title="@inlinable"></a>@inlinable</h3><p>说明：<code>@inlinable</code> 属性允许您为特定方法启用<strong>跨模块内联</strong>。这样做了之后，方法的实现将作为模块公共接口的一部分来公开，允许编译器进一步优化来自不同模块的调用。使用 <code>@inlinable</code> 最大的收益就是有些方法可能会有性能开销，尽管大多数的方法这种开销可以忽略不计，但像那种包含泛型和闭包的，开销很大。使用<code>@inlinable</code> 可以带来性能提升，不过包的大小会增加。</p>
<p>用法：’@inlinable’ 只能用于 public 函数，不能修饰private函数。</p>
<p>参考：<a href="https://swiftrocks.com/understanding-inlinable-in-swift.html">Understanding <code>@inlinable</code> in Swift</a></p>
<h3 id="autoclosure"><a href="#autoclosure" class="headerlink" title="@autoclosure"></a>@autoclosure</h3><p>The <code>@autoclosure</code> attribute can be applied to a closure parameter for a function, and automatically creates a closure from an <strong>expression</strong> you pass in. When you call a function that uses this attribute, the code you write <em>isn’t</em> a closure, but it <em>becomes</em> a closure, which can be a bit confusing – even the official Swift reference guide warns that overusing autoclosures makes your code harder to understand.</p>
<p>主要用于延迟表达式的执行。1.有一些情况传入的表达式很有可能不会被执行，使用@autoclosure可以起到一点点优化作用。2.代码更加简洁，少写一对花括号。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res1 <span class="operator">=</span> add(a: <span class="number">3</span>, b: <span class="number">3</span> <span class="operator">*</span> <span class="number">1872</span> <span class="operator">+</span> <span class="number">876</span>)</span><br><span class="line"><span class="keyword">let</span> res2 <span class="operator">=</span> add(a: <span class="operator">-</span><span class="number">2</span>, b: <span class="number">3</span> <span class="operator">*</span> <span class="number">1872</span> <span class="operator">+</span> <span class="number">876</span>) <span class="comment">//这种情况下参数b实际上是不会计算的。如果是普通函数的话那么在运行时会先计算出结果再传入b。DDLog也是这么干的，因为message有可能不会被打印。</span></span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://www.hackingwithswift.com/example-code/language/what-is-the-autoclosure-attribute">What is the autoclosure attribute?</a></p>
<p><a href="https://www.swiftbysundell.com/articles/using-autoclosure-when-designing-swift-apis/">Using @autoclosure when designing Swift APIs</a>  推荐。具体的一些使用场景</p>
<h3 id="frozen"><a href="#frozen" class="headerlink" title="@frozen"></a>@frozen</h3><p>用于枚举和结构体的声名。frozen冰冻，顾名思义就是这个枚举或结构体应该被严格限制改变，你不能去添加或删除、重排case或属性等等操作。和frozen类型交互时编译器会进行一些额外的优化。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>表示不允许对其修饰的内容进行继承或者重写等。Swift中，<strong>final</strong>关键字可以在class、func和var前修饰。final的作用:</p>
<ol>
<li>权限控制。（主要作用）</li>
<li>提升程序性能 。（微优化）</li>
</ol>
<p>参考：<a href="https://www.jianshu.com/p/0f1e041705a4">Swift 特性关键字final的用法</a></p>
<h3 id="objc"><a href="#objc" class="headerlink" title="@objc"></a>@objc</h3><p>把Swift代码（类，方法，属性等）暴露给OC，这样OC代码才能访问。混编时用到。</p>
<h3 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h3><p>让方法调用时走OC的动态派发，由于运行时是OC的特性，所以需要配合@objc使用。在几种方法派发里面是性能最低的。</p>
<p>参考：<a href="https://varun04tomar.medium.com/to-the-depth-of-objc-and-dynamic-in-swift-b5472800b85d">To the depth of @objc and dynamic in Swift</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/attributes/">Attributes</a>  关键字官方文档。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>pod库依赖第三方OC++库编译报错问题</title>
    <url>/2023/02/20/pod%E5%BA%93%E4%BE%9D%E8%B5%96%E7%AC%AC%E4%B8%89%E6%96%B9OC++%E5%BA%93%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在开发pod库时，遇到了一个编译报错的问题，记录一下。</p>
<p>主pod是OC实现的，主pod里依赖了WCDB（一个OC++库），主pod里有一个子pod，子pod采用swift实现。当宿主工程集成子pod时，编译通不过，报错在：WCDB.h里。Since WCDB…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WCDB_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WCDB_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Since WCDB is an Objective-C++ framework, for those files in your project that includes WCDB, you should rename their extension .m to .mm.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>Google了半天也没搜到类似的，感觉应该是混编导致的错误。</p>
<p>我的podspec文件：</p>
<figure class="highlight cal"><table><tr><td class="code"><pre><span class="line">spec.swift_versions = [<span class="string">&#x27;5.5&#x27;</span>, <span class="string">&#x27;5.6&#x27;</span>, <span class="string">&#x27;5.7&#x27;</span>]</span><br><span class="line">spec.requires_arc = <span class="literal">true</span></span><br><span class="line">spec.dependency <span class="string">&quot;CocoaLumberjack&quot;</span>, <span class="string">&quot;~&gt; 3.7.4&quot;</span></span><br><span class="line">spec.dependency <span class="string">&quot;WCDB&quot;</span>, <span class="string">&quot;~&gt; 1.1.0&quot;</span></span><br><span class="line"></span><br><span class="line">spec.default_subspecs = <span class="string">&#x27;Core&#x27;</span></span><br><span class="line"></span><br><span class="line">spec.subspec <span class="string">&#x27;Core&#x27;</span> <span class="keyword">do</span> |ss|</span><br><span class="line">  ss.source_files = <span class="string">&#x27;Sources/MATLog/**/*.&#123;h,m,mm&#125;&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">spec.subspec <span class="string">&#x27;Swift&#x27;</span> <span class="keyword">do</span> |ss|</span><br><span class="line">  ss.dependency <span class="string">&#x27;MATLog/Core&#x27;</span></span><br><span class="line">  ss.source_files = <span class="string">&#x27;Sources/MATLogSwift/**/*.&#123;swift,h,mm&#125;&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>子pod里压根就没使用到WCDB，很奇怪为啥会报那个错。搜也无从搜起，冥思苦想半天，也就 <code>MATLogModel+WCTTableCoding.h</code> 头文件里包含了WCDB.h，后来发现确实是这里引起的。</p>
<p>因为OC pod库头文件默认是public，所以子库能访问到主库所有暴露的头文件，修改podspec文件如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">spec.swift_versions = [<span class="string">&#x27;5.5&#x27;</span>, <span class="string">&#x27;5.6&#x27;</span>, <span class="string">&#x27;5.7&#x27;</span>]</span><br><span class="line">spec.requires_arc = <span class="keyword">true</span></span><br><span class="line">spec.dependency <span class="string">&quot;CocoaLumberjack&quot;</span>, <span class="string">&quot;~&gt; 3.7.4&quot;</span></span><br><span class="line">spec.dependency <span class="string">&quot;WCDB&quot;</span>, <span class="string">&quot;~&gt; 1.1.0&quot;</span></span><br><span class="line"></span><br><span class="line">spec.default_subspecs = <span class="string">&#x27;Core&#x27;</span></span><br><span class="line"></span><br><span class="line">spec.subspec <span class="string">&#x27;Core&#x27;</span> <span class="keyword">do</span> |ss|</span><br><span class="line">  ss.source_files = <span class="string">&#x27;Sources/MATLog/**/*.&#123;h,m,mm&#125;&#x27;</span></span><br><span class="line">  ss.private_header_files = <span class="string">&#x27;Sources/MATLog/*WCTTableCoding.&#123;h&#125;&#x27;</span> #控制OC头文件访问权限的有<span class="keyword">private</span>、<span class="keyword">project</span>、<span class="keyword">public</span>三种。默认<span class="keyword">public</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">spec.subspec <span class="string">&#x27;Swift&#x27;</span> <span class="keyword">do</span> |ss|</span><br><span class="line">  ss.dependency <span class="string">&#x27;MATLog/Core&#x27;</span></span><br><span class="line">  ss.source_files = <span class="string">&#x27;Sources/MATLogSwift/**/*.&#123;swift,h,mm&#125;&#x27;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这时 <code>MATLogModel+WCTTableCoding.h</code> 头文件就变成private了，编译也能通过了。</p>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>混编</tag>
      </tags>
  </entry>
  <entry>
    <title>NSCopying协议</title>
    <url>/2022/10/11/NSCopying%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>NSCopying协议：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSCopying</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone; <span class="comment">//实例方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSMutableCopying</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)mutableCopyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone; <span class="comment">//实例方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>分为不可变和可变两种拷贝。zone参数是被忽略的，因此可以不管。</p>
<p>实现：</p>
<p>具体怎么实现直接参考知名开源框架的写法，跟着大佬来肯定没错。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSData</span> *&gt; *pinnedCertificates;</span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = <span class="keyword">self</span>.SSLPinningMode; <span class="comment">//值类型，直接赋值就可以了。</span></span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="keyword">self</span>.allowInvalidCertificates;</span><br><span class="line">    securityPolicy.validatesDomainName = <span class="keyword">self</span>.validatesDomainName;</span><br><span class="line">    securityPolicy.pinnedCertificates = [<span class="keyword">self</span>.pinnedCertificates copyWithZone:zone]; <span class="comment">//对象类型调用copyWithZone，需要确保对象已经实现了copy协议。这里不需要可变所以调用copyWithZone</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mutableHTTPRequestHeaders;</span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    AFHTTPRequestSerializer *serializer = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.requestHeaderModificationQueue, ^&#123;</span><br><span class="line">      	<span class="comment">//这里需要可变所以调用mutableCopyWithZone</span></span><br><span class="line">        serializer.mutableHTTPRequestHeaders = [<span class="keyword">self</span>.mutableHTTPRequestHeaders mutableCopyWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    serializer.queryStringSerializationStyle = <span class="keyword">self</span>.queryStringSerializationStyle;</span><br><span class="line">    serializer.queryStringSerialization = <span class="keyword">self</span>.queryStringSerialization;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serializer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---AFHTTPResponseSerializer</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - NSCopying</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    AFHTTPResponseSerializer *serializer = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init]; <span class="comment">//不能写死为[AFHTTPResponseSerializer allocWithZone:zone]</span></span><br><span class="line">    serializer.acceptableStatusCodes = [<span class="keyword">self</span>.acceptableStatusCodes copyWithZone:zone];</span><br><span class="line">    serializer.acceptableContentTypes = [<span class="keyword">self</span>.acceptableContentTypes copyWithZone:zone];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serializer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---AFCompoundResponseSerializer:AFHTTPResponseSerializer</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *responseSerializers;</span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    AFCompoundResponseSerializer *serializer = [<span class="variable language_">super</span> copyWithZone:zone];</span><br><span class="line">    serializer.responseSerializers = <span class="keyword">self</span>.responseSerializers; <span class="comment">//responseSerializers属性是copy，所以可以直接赋值。setter方法里会调用copy.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果父类实现了则必须调用super，否则会丢失信息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    AFPropertyListResponseSerializer *serializer = [<span class="variable language_">super</span> copyWithZone:zone]; <span class="comment">//调用super</span></span><br><span class="line">    serializer.format = <span class="keyword">self</span>.format;</span><br><span class="line">    serializer.readOptions = <span class="keyword">self</span>.readOptions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：NSObject是没有实现copy协议的。</p>
<p>NSObject下有两个实例方法：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">id</span>)<span class="keyword">copy</span>;</span><br><span class="line">- (<span class="built_in">id</span>)mutableCopy;</span><br></pre></td></tr></table></figure>
<p>他们仅仅是返回对应的copy协议方法的值。如果对象没实现则会崩溃。这两个方法只是方便使用。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> a convenience <span class="keyword">method</span> <span class="title function_">for</span> <span class="title function_">classes</span> <span class="title function_">that</span> <span class="title function_">adopt</span> <span class="title function_">the</span> <span class="title function_">NSCopying</span> <span class="title function_">protocol</span>. <span class="title function_">An</span> <span class="title function_">exception</span> <span class="title function_">is</span> <span class="title function_">raised</span> <span class="title function_">if</span> <span class="title function_">there</span> <span class="title function_">is</span> <span class="title function_">no</span> <span class="title function_">implementation</span> <span class="title function_">for</span> <span class="title function_">copyWithZone</span>:.</span><br><span class="line">NSObject does <span class="keyword">not</span> itself support the NSCopying protocol. Subclasses must support the protocol <span class="keyword">and</span> implement the copyWithZone: <span class="keyword">method</span>. A subclass version <span class="keyword">of</span> the copyWithZone: <span class="keyword">method</span> <span class="title function_">should</span> <span class="title function_">send</span> <span class="title function_">the</span> <span class="title function_">message</span> <span class="title function_">to</span> <span class="title function_">super</span> <span class="title function_">first</span>, <span class="title function_">to</span> <span class="title function_">incorporate</span> <span class="title function_">its</span> <span class="title function_">implementation</span>, <span class="title function_">unless</span> <span class="title function_">the</span> <span class="title function_">subclass</span> <span class="title function_">descends</span> <span class="title function_">directly</span> <span class="title function_">from</span> <span class="title function_">NSObject</span>.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>NSCopying</tag>
      </tags>
  </entry>
  <entry>
    <title>OC中的访问控制</title>
    <url>/2023/03/08/OC%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>OC中提供了4个访问控制符：@private @package @protected @public。</p>
<p>@private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。</p>
<p>@package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用，同一映像就是编译后生成的同一框架或同一个执行文件，跨框架不可用。简单点讲就是使用package后，该成员变量在同一个框架里的所有类里都可以访问到，别的框架访问不到。</p>
<p>@protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。</p>
<p>@public（公共访问权限）：成员可以在任意地方访问。</p>
<p>private和public比较简单，所以这里具体说一下package和protected的使用场景。</p>
<p>使用package修饰的成员只能在当前框架内被访问。</p>
<p>比如A框架里有一个类XQSheet，它有一个_buttons成员。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XQSheet</span> : <span class="title">JHGrandPopupView</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">@package</span> <span class="built_in">NSMutableArray</span> *_buttons;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>使用package修饰后，那么_buttons只能在A框架内部被访问到（A框架的任意类里都可以），但不能在框架B里被访问。</p>
<p>如果改为protected：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XQSheet</span> : <span class="title">JHGrandPopupView</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">@protected</span> <span class="built_in">NSMutableArray</span> *_buttons;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>那么_buttons只能在当前类及其子类里被访问到。这个子类可以在A框架里，也可以在B框架里，说明可以跨框架，但必须是子类里。A框架里的Person类里能不能访问<code>_buttons</code>? 答案是不能。这就是和package的区别。</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift中的Error</title>
    <url>/2023/04/02/Swift%E4%B8%AD%E7%9A%84Error/</url>
    <content><![CDATA[<p>OC中的错误是一个类NSError：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Immutable, and NSError must be Sendable because it conforms to Error in Swift</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">NSError</span> : <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">NSCopying</span>, <span class="title class_ inherited__">NSSecureCoding</span>, @unchecked <span class="title class_ inherited__">Sendable</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Domain cannot be nil; dict may be nil if no userInfo desired.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">domain</span>: <span class="type">String</span>, <span class="params">code</span>: <span class="type">Int</span>, <span class="params">userInfo</span> <span class="params">dict</span>: [<span class="params">String</span> : <span class="keyword">Any</span>]<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>)</span><br><span class="line">    <span class="operator">....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而Swift中的错误则是一个协议Error：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Error</span> : <span class="title class_ inherited__">Sendable</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Sendable</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Error</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Retrieve the localized description for this error.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> localizedDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">NSError</span> : <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上这个协议没有任何内容，因此任意类、结构体、枚举都可以轻松实现Error协议。</p>
<p>定义Swift Error:</p>
<p>使用枚举</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">NetworkError</span>: <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> domainError</span><br><span class="line">    <span class="keyword">case</span> decodingError</span><br><span class="line">    <span class="keyword">case</span> noDataError</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> localizedDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .domainError:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;url错误&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .decodingError:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;解析出错&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .noDataError:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;无数据&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于错误一般是后台接口给出，所以个人觉得使用结构体表示错误，使用是最方便的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BusinessError</span>: <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> code <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> message <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">code</span>: <span class="type">String</span>, <span class="params">message</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.code <span class="operator">=</span> code</span><br><span class="line">        <span class="keyword">self</span>.message <span class="operator">=</span> message</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> localizedDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要具体判断错误码，可以扩展BusinessError，不同的业务接口可以创建不同的扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BusinessError</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SuperLike</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> unknow <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> badParam <span class="operator">=</span> <span class="string">&quot;-10000&quot;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> badGender <span class="operator">=</span> <span class="string">&quot;-10001&quot;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> notMatch <span class="operator">=</span> <span class="string">&quot;-10002&quot;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> overFrequent <span class="operator">=</span> <span class="string">&quot;-10003&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">estimateErr</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> error.code <span class="operator">==</span> <span class="type">BusinessError</span>.<span class="type">SuperLike</span>.badParam &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;badParam&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> error.code <span class="operator">==</span> <span class="type">BusinessError</span>.<span class="type">SuperLike</span>.badGender &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;badGender&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言整型类型长度与类型溢出</title>
    <url>/2023/04/06/C%E8%AF%AD%E8%A8%80%E6%95%B4%E5%9E%8B%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>C语言由Dennis M. Ritchie在1973年设计和实现。从那以后使用者逐渐增加。到1978年Ritchie和Bell实验室的另一位程序专家Kernighan合写了著名的《The C Programming Language》，将C语言推向全世界，许多国家都出了译本，国内有一些C语言书就是这本书的翻译或者编译。由这本书定义的C语言后来被人们称作K&amp;R C。</p>
<p>随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。这个标准化的工作在美国国家标准局（ANSI）的框架中进行（1983-1988），最终结果是1988年10月颁布的ANSI标准X3.159-1989，也就是后来人们所说的ANSIC标准。由这个标准定义的C语言被称作ANSI C。</p>
<p>ANSI C标准很快被采纳为国际标准和各国的标准。国际标准为ISO/IEC 9899-1990，中国国家标准GB/T15272-94是国际ISO标准的中文翻译。</p>
<p>ANSI C标准化工作的一个主要目标是清除原来C语言中的不安全、不合理、不精确、不完善的东西。由此也产生了ANSIC与K&amp;R C之间的差异。从总体上看，这些差异反应的是C语言走向完善、走向成熟。</p>
<p>我们一般采用ANSI C就可以了。</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型包括：字符，短整型，整型，长整型。每种类型又分为有符号和无符号。</p>
<p>K&amp;R C并没有规定长整型必须比短整型长，只是规定它不得比短整型短。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">长整型 &gt;<span class="operator">=</span> 整型 &gt;<span class="operator">=</span> 短整型</span><br></pre></td></tr></table></figure>
<p>ANSI C在此基础上加入了一个规范，说明了各种整型值的<strong>最小允许范围</strong>。这对程序的可移植性起到了巨大的作用。</p>
<p>变量的最小范围：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">最小范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">0~127</td>
</tr>
<tr>
<td style="text-align:center">signed char</td>
<td style="text-align:center">-127~127</td>
</tr>
<tr>
<td style="text-align:center">unsigned char</td>
<td style="text-align:center">0~255</td>
</tr>
<tr>
<td style="text-align:center">short int</td>
<td style="text-align:center">-(2^15 - 1) ~ (2^15 - 1) 即 -32767~32767</td>
</tr>
<tr>
<td style="text-align:center">unsigned short int</td>
<td style="text-align:center">0~(2^16 - 1) 即 0~65535</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">-(2^15 - 1) ~ (2^15 - 1) 即 -32767~32767</td>
</tr>
<tr>
<td style="text-align:center">unsigned int</td>
<td style="text-align:center">0~(2^16 - 1) 即 0~65535</td>
</tr>
<tr>
<td style="text-align:center">long int</td>
<td style="text-align:center">-(2^31 - 1) ~ (2^31 - 1) 即 -2147483647~2147483647</td>
</tr>
<tr>
<td style="text-align:center">unsigned long int</td>
<td style="text-align:center">0~(2^32 - 1) 即 0~4294967295</td>
</tr>
</tbody>
</table>
</div>
<p>char至少8位，short至少16位，long至少32位。至于缺省的int究竟是16位还是32位由编译器决定，通常这个缺省值是这种机器最为自然的位数，也就是跟机器相关。</p>
<p>注意：上述表格只是类型的最小范围，实际上由于整数是用补码表示的，所以有符号整数类型实际的范围是：<br><code>-(2^(bitWidth - 1))~(2^(bitWidth - 1)) - 1</code>.比如short的范围:-32768~32767</p>
<p>一般情况下在64位机器上：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;sizeof(char):%lu, sizeof(short):%lu, sizeof(int):%lu, sizeof(long):%lu, sizeof(float):%lu, sizeof(double):%lu&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="keyword">sizeof</span>(<span class="type">short</span>), <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="keyword">sizeof</span>(<span class="type">float</span>), <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">sizeof</span><span class="params">(char)</span></span>:<span class="number">1</span>, </span><br><span class="line"><span class="function"><span class="title">sizeof</span><span class="params">(short)</span></span>:<span class="number">2</span>, </span><br><span class="line"><span class="function"><span class="title">sizeof</span><span class="params">(int)</span></span>:<span class="number">4</span>, </span><br><span class="line"><span class="function"><span class="title">sizeof</span><span class="params">(long)</span></span>:<span class="number">8</span>, </span><br><span class="line"><span class="function"><span class="title">sizeof</span><span class="params">(float)</span></span>:<span class="number">4</span>, </span><br><span class="line"><span class="function"><span class="title">sizeof</span><span class="params">(double)</span></span>:<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>是符合ANSI C规范的。</p>
<h2 id="类型溢出"><a href="#类型溢出" class="headerlink" title="类型溢出"></a>类型溢出</h2><p>由于整型类型表示的数据范围有限，所以不管是有符号还是无符号整型类型都有可能发生溢出。发生溢出时的结果是未定义的，但一般是会回绕。</p>
<p>char和unsigned char回绕：255+1=0，0-1=255.</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">|</span><span class="literal">---</span>&gt;        &lt;<span class="literal">---</span><span class="comment">|</span></span><br><span class="line"><span class="literal">-</span><span class="comment">128</span><span class="literal">-----</span><span class="comment">0</span><span class="literal">-------</span><span class="comment">127</span></span><br><span class="line"></span><br><span class="line"><span class="comment">|</span><span class="literal">---</span>&gt;         &lt;<span class="literal">---</span><span class="comment">|</span></span><br><span class="line"><span class="comment">0</span><span class="literal">------</span><span class="comment">127</span><span class="literal">------</span><span class="comment">255</span></span><br></pre></td></tr></table></figure>
<p>如何避免类型溢出？</p>
<p>要先进行类型转换把小类型转为大类型，再执行操作，才能避免溢出。当然如果数字非常大，那么整数类型就都不能用了，可以考虑使用字符串操作。</p>
<p>类型溢出例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_signed_int_overflow</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     a = -2147483648</span></span><br><span class="line"><span class="comment">     b = 2147483647</span></span><br><span class="line"><span class="comment">     c = -2147483648</span></span><br><span class="line"><span class="comment">     d = -2147483648</span></span><br><span class="line"><span class="comment">     e = 2147483648</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> a = INT_MIN; <span class="comment">//补码为1000 0000，-a补码依然是1000 0000，所以c,d,a相等</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="type">int</span> b = INT_MAX;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="type">int</span> c = -a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="type">long</span> d = -a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %ld\n&quot;</span>, d);</span><br><span class="line">    <span class="type">long</span> e = -(<span class="type">long</span>)a; <span class="comment">//要先进行类型转换再执行操作，才能避免溢出。当然如果数字非常大，那么整数类型就都不能用了，只能考虑使用字符串操作了。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e = %ld\n&quot;</span>, e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c == a) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;overflow\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d == a) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not work\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加减乘除都有可能导致类型溢出。类型溢出问题很难发现，比如上面的取负操作，由于int的最小值是-2147483648而最大值只有2147483647，那么对-2147483648取负就会导致int溢出。解决办法就是先强转类型再取负：long e = -(long)a;<br>很多算法题也是考察大数问题，题目看起来会非常简单，比如打印1…n，两个整数相加等等。涉及到整型类型的简单题目一般就是考察大数问题了。</p>
<p>大部分语言对溢出的处理都是回绕，这其实是很危险的，这会导致判断条件失效，进而出现许多诡异bug。Swift在出现类型溢出时程序会直接崩溃，避免了错误逻辑的执行，我觉得是不错的解决办法。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift中的枚举</title>
    <url>/2023/04/02/Swift%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>1.swift的枚举只能拥有原始值和关联值的其中一种，不能同时拥有，会报错：Enum with raw type cannot have cases with arguments。</p>
<p>2.读取关联值时不能写参数的类型,否则编译报错。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BinaryTree</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> leaf</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> node(v: <span class="type">Element</span>, l: <span class="type">BinaryTree</span>&lt;<span class="type">Element</span>&gt;, r: <span class="type">BinaryTree</span>&lt;<span class="type">Element</span>&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">val</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> .node(v: val, l: .leaf, r: .leaf)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取关联值时不能写参数的类型,否则编译报错。</span></span><br><span class="line"><span class="comment">//case let .node(v: Element, l: BinaryTree&lt;Element&gt;, r: BinaryTree&lt;Element&gt;):</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> values: [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .leaf:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .node(v, l, r): <span class="comment">//直接填写变量名称。</span></span><br><span class="line">            <span class="keyword">return</span> l.values <span class="operator">+</span> [v] <span class="operator">+</span> r.values</span><br><span class="line"><span class="comment">//        case .node(let v, var l, var r):</span></span><br><span class="line"><span class="comment">//            return l.values + [v] + r.values</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/59378942/enum-with-raw-type-cannot-have-cases-with-arguments">Enum with raw type cannot have cases with arguments</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>enum</tag>
      </tags>
  </entry>
  <entry>
    <title>DDLog使用注意事项</title>
    <url>/2023/04/04/DDLog%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>DDOSLogger控制台打印，没有使用logMessage的时间戳而是os_log_xxx执行时的时间戳，因此会和logMessage的创建时间有个时间差。如果打印时选择的是DDLogFlagError，打印将是同步执行，这个时间差会非常小。而如果是DDLogFlagError以下级别，那么这条打印将是异步执行的，这时的时间差会更大，和NSLog混用时可能会误导你。因此和NSLog混用或者场景同步打印要求比较高，建议使用DDLogFlagError同步打印日志。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (DDLoggerName)loggerName &#123;</span><br><span class="line">    <span class="keyword">return</span> DDLoggerNameOS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)logMessage:(DDLogMessage *)logMessage &#123;</span><br><span class="line">    <span class="comment">// Skip captured log messages</span></span><br><span class="line">    <span class="keyword">if</span> ([logMessage-&gt;_fileName isEqualToString:<span class="string">@&quot;DDASLLogCapture&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">10.0</span>, macOS <span class="number">10.12</span>, tvOS <span class="number">10.0</span>, watchOS <span class="number">3.0</span>, *)) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> * message = _logFormatter ? [_logFormatter formatLogMessage:logMessage] : logMessage-&gt;_message;</span><br><span class="line">        <span class="keyword">if</span> (message != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="type">char</span> *msg = [message UTF8String];</span><br><span class="line">            __auto_type logger = [<span class="keyword">self</span> logger];</span><br><span class="line">            <span class="keyword">switch</span> (logMessage-&gt;_flag) &#123;</span><br><span class="line">                <span class="keyword">case</span> DDLogFlagError  :</span><br><span class="line">                    os_log_error(logger, <span class="string">&quot;%&#123;public&#125;s&quot;</span>, msg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DDLogFlagWarning:</span><br><span class="line">                <span class="keyword">case</span> DDLogFlagInfo   :</span><br><span class="line">                    os_log_info(logger, <span class="string">&quot;%&#123;public&#125;s&quot;</span>, msg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DDLogFlagDebug  :</span><br><span class="line">                <span class="keyword">case</span> DDLogFlagVerbose:</span><br><span class="line">                <span class="keyword">default</span>              :</span><br><span class="line">                    os_log_debug(logger, <span class="string">&quot;%&#123;public&#125;s&quot;</span>, msg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：打印时选择的是DDLogFlagDebug。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;接收到响应1:%@, 线程：%@&quot;</span>, response.URL.lastPathComponent, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    MATLogDebug(<span class="string">@&quot;MAT,接收到响应:%@, 线程：%@&quot;</span>, response, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;接收到响应2:%@, 线程：%@&quot;</span>, response.URL.lastPathComponent, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = dataTask.originalRequest.URL;</span><br><span class="line">    <span class="built_in">NSMutableData</span> *dataContainer = [<span class="keyword">self</span> dataWithURL:url];</span><br><span class="line">    [dataContainer appendData:data];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;本次接收1:%ld,线程：%@, url:%@&quot;</span>, data.length, [<span class="built_in">NSThread</span> currentThread], url.lastPathComponent);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url.absoluteString == landscapeUrl) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;本次接收2:%ld,总共接收:%ld,线程：%@, url:%@&quot;</span>, data.length, dataContainer.length, [<span class="built_in">NSThread</span> currentThread], url.lastPathComponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">59</span>.<span class="number">463803</span>+<span class="number">0800</span> AFNetworking_fx[<span class="number">3039</span>:<span class="number">152895</span>] &lt;__NSURLSessionLocal: <span class="number">0</span>x103b48e60&gt;</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>.<span class="number">468738</span>+<span class="number">0800</span> AFNetworking_fx[<span class="number">3039</span>:<span class="number">152895</span>] 开始请求：https://tinypng.com/images/example-orig.png</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>.<span class="number">598328</span>+<span class="number">0800</span> AFNetworking_fx[<span class="number">3039</span>:<span class="number">154867</span>] 接收到响应<span class="number">1</span>:example-orig.png, 线程：&lt;NSThread: <span class="number">0</span>x2824d0f40&gt;&#123;number = <span class="number">16</span>, name = (null)&#125;</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>.<span class="number">599692</span>+<span class="number">0800</span> AFNetworking_fx[<span class="number">3039</span>:<span class="number">154867</span>] -----<span class="number">1</span>:<span class="number">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>:<span class="number">600</span>---------</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>.<span class="number">600230</span>+<span class="number">0800</span> AFNetworking_fx[<span class="number">3039</span>:<span class="number">154867</span>] -----<span class="number">2</span>:<span class="number">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>:<span class="number">600</span>---<span class="number">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>:<span class="number">600</span>------</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>.<span class="number">600749</span>+<span class="number">0800</span> AFNetworking_fx[<span class="number">3039</span>:<span class="number">154867</span>] 接收到响应<span class="number">2</span>:example-orig.png, 线程：&lt;NSThread: <span class="number">0</span>x2824d0f40&gt;&#123;number = <span class="number">16</span>, name = (null)&#125;</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>.<span class="number">601729</span>+<span class="number">0800</span> AFNetworking_fx[<span class="number">3039</span>:<span class="number">154867</span>] 本次接收<span class="number">1</span>:<span class="number">5455</span>,线程：&lt;NSThread: <span class="number">0</span>x2824d0f40&gt;&#123;number = <span class="number">16</span>, name = (null)&#125;, url:example-orig.png</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>.<span class="number">601922</span>+<span class="number">0800</span> AFNetworking_fx[<span class="number">3039</span>:<span class="number">154874</span>] <span class="number">2023</span>-<span class="number">04</span>-<span class="number">04</span> <span class="number">11</span>:<span class="number">06</span>:<span class="number">00</span>:<span class="number">600</span> -[SystemSessionViewController URLSession:dataTask:didReceiveResponse:completionHandler:] +<span class="number">171</span><span class="meta"> [level:Debug,module:0]</span></span><br><span class="line"><span class="attribute">MAT</span>,接收到响应:&lt;NSHTTPURLResponse: <span class="number">0</span>x2831fa500&gt; &#123; URL: https://tinypng.com/images/example-orig.png &#125; &#123; Status Code: <span class="number">200</span>, Headers &#123;</span><br></pre></td></tr></table></figure>
<p>logMessage的创建时间是2023-04-04 11:06:00:600，但控制台显示的时间戳是2023-04-04 11:06:00.601922+0800。相差2ms。还以为是didReceiveData的调用跑到didReceiveResponse前面去了，原来是打印的问题。</p>
]]></content>
      <categories>
        <category>第三方库使用</category>
      </categories>
      <tags>
        <tag>DDLog</tag>
      </tags>
  </entry>
  <entry>
    <title>OC class、superClass方法</title>
    <url>/2023/05/06/OC-class%E3%80%81superClass%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>测试代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_class_superClass &#123;</span><br><span class="line">    Person *per = [[Person alloc] init];</span><br><span class="line">    Class cls = [per <span class="keyword">class</span>]; <span class="comment">//Person</span></span><br><span class="line">    Class cls1 = [per superclass]; <span class="comment">//Animal</span></span><br><span class="line">    Class cls2 = Person.self; <span class="comment">//Person</span></span><br><span class="line">    Class cls3 = [Person <span class="keyword">class</span>]; <span class="comment">//Person</span></span><br><span class="line">    Class cls4 = [Person superclass]; <span class="comment">//Animal</span></span><br><span class="line">    Class cls5 = object_getClass(per); <span class="comment">//Person</span></span><br><span class="line">    Class cls6 = class_getSuperclass([Person <span class="keyword">class</span>]); <span class="comment">//Animal</span></span><br><span class="line">    Class cls7 = object_getClass([Person <span class="keyword">class</span>]); <span class="comment">//Person的元类</span></span><br><span class="line">    Class cls8 = class_getSuperclass(cls7); <span class="comment">//Person元类的父类</span></span><br><span class="line">    Class cls9 = [cls7 superclass]; <span class="comment">//Person元类的父类 等于cls8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取对象的类"><a href="#获取对象的类" class="headerlink" title="获取对象的类"></a>获取对象的类</h2><p>获取一个对象（实例对象或类对象）的类的核心方法就是object_getClass，实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Class <span class="title function_">object_getClass</span><span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是获取objc_object结构体里的isa字段的值。因此如果传入的是类对象，那么返回的将是类对象的类即元类。</p>
<p>实例方法class的实现就是调用object_getClass：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">- (Class)<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是类方法class，并不是返回类对象的类，而是直接返回的自己。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)self &#123;</span><br><span class="line">    <span class="keyword">return</span> (id)self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以如果想要获取类的类则必须使用object_getClass。</p>
<h2 id="获取对象的父类"><a href="#获取对象的父类" class="headerlink" title="获取对象的父类"></a>获取对象的父类</h2><p>核心方法是getSuperclass，其实就是objc_class结构体里的superclass的值。</p>
<p>实例方法superclass：先获取到它的类再调用getSuperclass。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">- (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> [self <span class="class"><span class="keyword">class</span>]-&gt;<span class="title">getSuperclass</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类方法superclass：返回类对象结构体里的superclass的值。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">Class</span>)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> self-&gt;getSuperclass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class_getSuperclass传入的参数需要是一个类对象，他的功能和类方法superclass一致。</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Class</span> <span class="title function_">class_getSuperclass</span>(<span class="params">Class</span> <span class="params">cls</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span><span class="variable">cls</span>) <span class="keyword">return</span> <span class="variable">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">cls</span><span class="operator">-</span><span class="operator">&gt;</span><span class="title function_">getSuperclass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="self和super"><a href="#self和super" class="headerlink" title="self和super"></a>self和super</h2><p>测试代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self class]:%@&quot;</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super class]:%@&quot;</span>, <span class="built_in">NSStringFromClass</span>([<span class="variable language_">super</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self superclass]:%@&quot;</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> superclass]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super superclass]:%@&quot;</span>, <span class="built_in">NSStringFromClass</span>([<span class="variable language_">super</span> superclass]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">2023-05-07</span> <span class="number">13</span>:<span class="number">03</span>:<span class="number">59.923896</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">18358</span>:<span class="number">7221193</span>] [self class]:Person</span><br><span class="line"><span class="number">2023-05-07</span> <span class="number">13</span>:<span class="number">03</span>:<span class="number">59.924017</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">18358</span>:<span class="number">7221193</span>] [super class]:Person</span><br><span class="line"><span class="number">2023-05-07</span> <span class="number">13</span>:<span class="number">03:59.924140</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">18358</span>:<span class="number">7221193</span>] [self superclass]:Animal</span><br><span class="line"><span class="number">2023-05-07</span> <span class="number">13</span>:<span class="number">03:59.924237</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">18358</span>:<span class="number">7221193</span>] [super superclass]:Animal</span><br></pre></td></tr></table></figure>
<p>从-class方法的实现：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">- (Class)<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，object_getClass的参数就是对象本身，所以不管是[self class]还是[super class]，传入的参数都是Person对象而不是Animal对象。所以二者的结果是一样的。</p>
<p>super本质上是一个编译指示器, 它并不是一个指针, 它仅仅是表示调用父类的方法,但是调用者仍然是当前对象,跟父类没有关系.也就是说上面的例子不管调用[self class]还是[super class],接受消息的对象都是当前Person这个对象.</p>
<p>使用self调用方法时,会从当前类的方法列表中开始找,如果没有,就从父类中再找;而当使用super时,则从父类的方法列表中开始找.然后调用父类的这个方法，消息接收者对象还是当前这个对象。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>相关方法声明：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">NSObject协议：实例方法</span><br><span class="line"><span class="variable">@property</span> (readonly) Class superclass;</span><br><span class="line">- (Class)<span class="class"><span class="keyword">class</span> <span class="title">OBJC_SWIFT_UNAVAILABLE</span>(&quot;<span class="title">use</span> &#x27;<span class="title">type</span>(<span class="title">of</span>: <span class="title">anObject</span>)&#x27; <span class="title">instead</span>&quot;)</span>;</span><br><span class="line"></span><br><span class="line">NSObject类：类方法</span><br><span class="line">+ (Class)superclass;</span><br><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> <span class="title">OBJC_SWIFT_UNAVAILABLE</span>(&quot;<span class="title">use</span> &#x27;<span class="title">aClass</span>.<span class="title">self</span>&#x27; <span class="title">instead</span>&quot;)</span>;</span><br></pre></td></tr></table></figure>
<p>关于+class说明：</p>
<p>Refer to a class only by its name when it is the receiver of a message. In all other cases, the class object must be obtained through this or a similar method. For example, here <code>SomeClass</code> is passed as an argument to the <a href="doc://com.apple.documentation/documentation/objectivec/1418956-nsobject/1418511-iskindofclass?language=swift">isKindOfClass:</a> method (declared in the <code>NSObject</code> protocol):BOOL test = [self isKindOfClass:[SomeClass class]];</p>
<p>只有类作为消息的接收者的情况才可以直接使用类名代表该类。所有其他需要类的地方都需要通过调用类似class的方法来获取类对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+ (id)self &#123;</span><br><span class="line">    <span class="keyword">return</span> (id)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)self &#123;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getClass</span>(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> self-&gt;<span class="built_in">getSuperclass</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> [self <span class="keyword">class</span>]-&gt;<span class="built_in">getSuperclass</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_getClass.</span></span><br><span class="line"><span class="comment">* Locking: None. If you add locking, tell gdb (rdar://7516456).</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">class_getSuperclass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">getSuperclass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>superClass</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">  <span class="built_in">objc_class</span>(<span class="type">const</span> objc_class&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">objc_class</span>(objc_class&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> objc_class&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(objc_class&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Class <span class="title">getSuperclass</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> superclass;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">(<span class="type">bool</span> authenticated = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rawISA() assumes this is NOT a tagged pointer object or a non pointer ISA</span></span><br><span class="line">    <span class="function">Class <span class="title">rawISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">isaBits</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS输入输出流</title>
    <url>/2023/05/14/iOS%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
    <content><![CDATA[<p>流式读写数据，所谓流式就是像小溪流一样细水长流避免峰值影响。它可以让你避免一次性将数据加载到内存，从而导致内存暴涨。比如播放一个本地视频文件，你不需要先将整个视频都加载到内存再播放，而是读取一段播放一段。</p>
<p>系统提供了两个子类NSInputStream和NSOutputStream用于流式处理。NSInputStream用于流式读取数据，NSOutputStream用于流式写入数据。</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/stream_src_dest.gif" alt=""></p>
<h2 id="NSInputStream"><a href="#NSInputStream" class="headerlink" title="NSInputStream"></a>NSInputStream</h2><p>输入流，按次序从仓库读取数据。这个仓库可以是一个文件，一个NSData对象或者是一个网络socket。注意：网络socket输入流和前面两种输入流的初始化步骤是不一样的。</p>
<p>因为是读数据，所以仓库必须存在，比如如果仓库是一个文件，则该文件必须存在，否则会打开失败提升：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">读错误：<span class="built_in">Error</span> <span class="attribute">Domain</span>=NSPOSIXErrorDomain <span class="attribute">Code</span>=2 <span class="string">&quot;No such file or directory&quot;</span> UserInfo=&#123;<span class="attribute">_kCFStreamErrorCodeKey</span>=2, <span class="attribute">_kCFStreamErrorDomainKey</span>=1&#125;</span><br></pre></td></tr></table></figure>
<p>read:maxLength:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)read:(uint8_t *)buffer maxLength:(<span class="built_in">NSUInteger</span>)len;</span><br><span class="line">    <span class="comment">// reads up to length bytes into the supplied buffer, which must be at least of size len. Returns the actual number of bytes read.</span></span><br></pre></td></tr></table></figure>
<p>返回值说明：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">A <span class="built_in">number</span> indicating <span class="keyword">the</span> outcome <span class="keyword">of</span> <span class="keyword">the</span> operation:</span><br><span class="line">A positive <span class="built_in">number</span> indicates <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="built_in">read</span>.</span><br><span class="line"><span class="number">0</span> indicates that <span class="keyword">the</span> <span class="function"><span class="keyword">end</span> <span class="title">of</span> <span class="title">the</span> <span class="title">buffer</span> <span class="title">was</span> <span class="title">reached</span>.</span></span><br><span class="line"><span class="number">-1</span> means that <span class="keyword">the</span> operation failed; more information about <span class="keyword">the</span> error can be obtained <span class="keyword">with</span> streamError.</span><br></pre></td></tr></table></figure>
<p>一个正数表示读取了多少字节。0表示待读取的数据已经到了结尾，没有待读取的数据了。-1表示读取出错。</p>
<h2 id="NSOutputStream"><a href="#NSOutputStream" class="headerlink" title="NSOutputStream"></a>NSOutputStream</h2><p>输出流，按次序写入数据到一个仓库。这个仓库可以是一个文件，一个C buffer，应用的内存，或者一个网络socket。注意：网络socket输出流和前面三种输出流的初始化步骤是不一样的。</p>
<p>如果仓库是一个文件，打开流后系统会自动创建该文件。</p>
<p>write:maxLength:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">- (NSInteger)write:(<span class="type">const</span> <span class="type">uint8_t</span> *)buffer maxLength:(NSUInteger)len;</span><br><span class="line">    <span class="comment">// writes the bytes from the specified buffer to the stream up to len bytes. Returns the number of bytes actually written.</span></span><br></pre></td></tr></table></figure>
<p>返回值说明：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">A <span class="built_in">number</span> indicating <span class="keyword">the</span> outcome <span class="keyword">of</span> <span class="keyword">the</span> operation:</span><br><span class="line">A positive <span class="built_in">number</span> indicates <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> written.</span><br><span class="line"><span class="number">0</span> indicates that <span class="keyword">a</span> fixed-<span class="built_in">length</span> stream <span class="keyword">and</span> has reached its capacity.</span><br><span class="line"><span class="number">-1</span> means that <span class="keyword">the</span> operation failed; more information about <span class="keyword">the</span> error can be obtained <span class="keyword">with</span> streamError.</span><br></pre></td></tr></table></figure>
<p>一个正数表示写入了多少字节。0表示待写入的数据已经到了结尾，没有待写入的数据了。-1表示写入出错。</p>
<h2 id="流的事件"><a href="#流的事件" class="headerlink" title="流的事件"></a>流的事件</h2><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_OPTIONS</span>(<span class="type">NSUInteger</span>, <span class="type">NSStreamEvent</span>) &#123;</span><br><span class="line">    <span class="type">NSStreamEventNone</span> = 0,</span><br><span class="line">    <span class="type">NSStreamEventOpenCompleted</span> = 1UL &lt;&lt; 0,</span><br><span class="line">    <span class="type">NSStreamEventHasBytesAvailable</span> = 1UL &lt;&lt; 1,</span><br><span class="line">    <span class="type">NSStreamEventHasSpaceAvailable</span> = 1UL &lt;&lt; 2,</span><br><span class="line">    <span class="type">NSStreamEventErrorOccurred</span> = 1UL &lt;&lt; 3,</span><br><span class="line">    <span class="type">NSStreamEventEndEncountered</span> = 1UL &lt;&lt; 4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>NSStreamEventOpenCompleted：流打开完成。</p>
<p>NSStreamEventHasBytesAvailable：有数据可读取。</p>
<p>NSStreamEventHasSpaceAvailable：有空间可写入。</p>
<p>NSStreamEventErrorOccurred：读取流出现错误。</p>
<p>NSStreamEventEndEncountered：读取流结束。</p>
<p>流发生错误或者流已经结束或者流已经关闭，这个流就不能继续使用了，不能再读或再写，只能重新创建。</p>
<h2 id="polling轮询-VS-runloop调度"><a href="#polling轮询-VS-runloop调度" class="headerlink" title="polling轮询 VS runloop调度"></a>polling轮询 VS runloop调度</h2><p>有两种方式获取流事件发生，一种是轮询，一种是事件监听。比如流式读取数据，可能这个数据的产生是随机的，你不知道什么时候会有数据可读，怎么办呢？最简单的办法就是不断地查询是否有数据，这种方式虽然有效但无疑是对CPU的极大浪费。另一种办法就是事件监听，将流绑定到一个线程的runloop，这样当有流事件发生时，代理方法就会被回调，没有事件发生时runloop会进入睡眠。</p>
<p>ps：虽然轮询看起来好像不太行的样子，但是如果流是确定的，使用轮询也未尝不可。</p>
<p>轮询示例：将数据流式写入到内存，再读取出来。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_outputStream_to_memory &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;share_qq_icon&quot;</span> ofType:<span class="string">@&quot;png&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *imgData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSOutputStream</span> *outputStream = [[<span class="built_in">NSOutputStream</span> alloc] initToMemory];</span><br><span class="line">    [outputStream open];</span><br><span class="line">    </span><br><span class="line">    uint8_t *buffer = (uint8_t *)[imgData bytes];</span><br><span class="line">    <span class="built_in">NSInteger</span> totalLength = imgData.length;</span><br><span class="line">    <span class="built_in">NSInteger</span> totalWrite = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> currentWrite = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (totalWrite &gt;= totalLength) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ([outputStream hasSpaceAvailable]) &#123;</span><br><span class="line">            <span class="comment">//一次性写完</span></span><br><span class="line"><span class="comment">//            currWriteLen = [outputStream write:&amp;buffer[totalWrite] maxLength:totalLen - totalWrite];</span></span><br><span class="line">            <span class="comment">//writeStep不能是一个固定值比如512，否则只要stream还有空间就会一直写，超出buffer范围后还会一直往后读出来，超出的都是垃圾数据了。</span></span><br><span class="line">            <span class="built_in">NSInteger</span> writeStep = MIN(totalLength - totalWrite, <span class="number">256</span>);</span><br><span class="line"><span class="comment">//            currWriteLen = [outputStream write:buffer maxLength:writeStep]; //错误。每次写的都是buffer的第一段</span></span><br><span class="line">            <span class="comment">//写完一段后需要移动位置，否则每次写的都是buffer的第一段。</span></span><br><span class="line">            currentWrite = [outputStream write:&amp;buffer[totalWrite] maxLength:writeStep];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentWrite == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;写入出错：%@&quot;</span>, outputStream.streamError);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;写入数据长度：%ld&quot;</span>, currentWrite);</span><br><span class="line">                totalWrite += currentWrite;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *pdata = [outputStream propertyForKey:<span class="built_in">NSStreamDataWrittenToMemoryStreamKey</span>];</span><br><span class="line">    [outputStream close];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWithData:pdata];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;img = %@&quot;</span>, img);</span><br><span class="line">    <span class="built_in">UIImageView</span> *imgView = [<span class="keyword">self</span>.view viewWithTag:<span class="number">1002</span>];</span><br><span class="line">    <span class="keyword">if</span> (imgView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        imgView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:img];</span><br><span class="line">        imgView.tag = <span class="number">1002</span>;</span><br><span class="line">        imgView.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span> * img.size.height / img.size.width);</span><br><span class="line">        [<span class="keyword">self</span>.view addSubview:imgView];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的地方有两个：</p>
<ol>
<li>writeStep不能是一个固定值比如512，否则只要stream还有空间就会一直写，超出buffer范围后还会一直往后读出来，超出的都是垃圾数据了。writeStep到后面肯定是0。</li>
<li>写完一段后需要移动位置，否则每次写的都是buffer的第一段。</li>
</ol>
<p>采用runloop调度也很简单就不展示了。将流安排到runloop里，runloop监听流事件并回调代理方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)scheduleInRunLoop:(<span class="built_in">NSRunLoop</span> *)aRunLoop forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line">- (<span class="type">void</span>)removeFromRunLoop:(<span class="built_in">NSRunLoop</span> *)aRunLoop forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br></pre></td></tr></table></figure>
<h2 id="早期版本AF的使用"><a href="#早期版本AF的使用" class="headerlink" title="早期版本AF的使用"></a>早期版本AF的使用</h2><h3 id="初始化outputStream"><a href="#初始化outputStream" class="headerlink" title="初始化outputStream"></a>初始化outputStream</h3><p>这里初始化了一个输出流，它是将数据写入到应用的内存。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSOutputStream</span> *)outputStream &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_outputStream) &#123;</span><br><span class="line">        <span class="keyword">self</span>.outputStream = [<span class="built_in">NSOutputStream</span> outputStreamToMemory];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _outputStream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setOutputStream:(<span class="built_in">NSOutputStream</span> *)outputStream &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (outputStream != _outputStream) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_outputStream) &#123;</span><br><span class="line">            [_outputStream close];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _outputStream = outputStream;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绑定到网络线程的runloop"><a href="#绑定到网络线程的runloop" class="headerlink" title="绑定到网络线程的runloop"></a>绑定到网络线程的runloop</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)operationDidStart &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *runLoopMode <span class="keyword">in</span> <span class="keyword">self</span>.runLoopModes) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.connection scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">            [<span class="keyword">self</span>.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];<span class="comment">//这一步其实可以不需要，因为后面采用的是轮询</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span>.outputStream open];</span><br><span class="line">        [<span class="keyword">self</span>.connection start];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingOperationDidStartNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><p>流事件可以使用事件监听也可以直接轮询，这里是轮询hasSpaceAvailable。实际上由于每次写入的数据很少，所以下面的代码是一次就写入内存。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> length = [data length];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> totalNumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.outputStream hasSpaceAvailable]) &#123;</span><br><span class="line">            <span class="keyword">const</span> uint8_t *dataBuffer = (uint8_t *)[data bytes];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSInteger</span> numberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (totalNumberOfBytesWritten &lt; (<span class="built_in">NSInteger</span>)length) &#123;</span><br><span class="line">                numberOfBytesWritten = [<span class="keyword">self</span>.outputStream write:&amp;dataBuffer[(<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten)];</span><br><span class="line">                <span class="keyword">if</span> (numberOfBytesWritten == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                totalNumberOfBytesWritten += numberOfBytesWritten;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.outputStream.streamError) &#123;</span><br><span class="line">                [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(connection:didFailWithError:) withObject:<span class="keyword">self</span>.connection withObject:<span class="keyword">self</span>.outputStream.streamError];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.totalBytesRead += (<span class="type">long</span> <span class="type">long</span>)length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgress) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress(length, <span class="keyword">self</span>.totalBytesRead, <span class="keyword">self</span>.response.expectedContentLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>由于数据是写入到内存，我们最终需要将其读取出来，对于outputStreamToMemory的输出流来说，可以使用NSStreamDataWrittenToMemoryStreamKey获取。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> __unused *)connection &#123;</span><br><span class="line">    <span class="keyword">self</span>.responseData = [<span class="keyword">self</span>.outputStream propertyForKey:<span class="built_in">NSStreamDataWrittenToMemoryStreamKey</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.outputStream close];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseData) &#123;</span><br><span class="line">       <span class="keyword">self</span>.outputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后不要忘了关闭流。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html">File System Programming Guide</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Streams/Streams.html#//apple_ref/doc/uid/10000188i">Stream Programming Guide</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Streams/Articles/WritingOutputStreams.html#//apple_ref/doc/uid/20002274-1002103">Writing To Output Streams</a></p>
]]></content>
      <categories>
        <category>Foundation</category>
      </categories>
      <tags>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>OC类与元类</title>
    <url>/2023/05/07/OC%E7%B1%BB%E4%B8%8E%E5%85%83%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="实例对象、类与元类"><a href="#实例对象、类与元类" class="headerlink" title="实例对象、类与元类"></a>实例对象、类与元类</h2><p>实例对象的类称为类（类对象），类（类对象）的类称为元类（元类对象）。他们都是对象。</p>
<p>OC中对象、类和元类的关系如下图：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/9ff681b9-50e6-4b55-bc2a-2f38cb21af1c.png" alt=""></p>
<p>总结下：</p>
<ol>
<li><p>实例对象的类是类对象,类对象的类是元类对象.元类对象的类是根元类,根元类对象的类就是自己本身.这里形成了一个闭环.</p>
</li>
<li><p>类对象里面保存的是实例方法.</p>
</li>
<li><p>元类对象里面保存的是类方法.</p>
</li>
<li><p>根类对象的superClass是nil,根类对象的类是根元类对象,根元类对象的superClass是根类对象,这里也形成了一个闭环.</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_class_metaClass &#123;</span><br><span class="line">    <span class="comment">//根类对象</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;根类对象[NSObject class]:%@,地址:%p&quot;</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>], [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="comment">//根类对象的父类</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;根类对象的父类[[NSObject class] superclass]:%@,地址%p&quot;</span>, [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] superclass], [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] superclass]);</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *nsobjectClassChar = [<span class="built_in">NSStringFromClass</span>([<span class="built_in">NSObject</span> <span class="keyword">class</span>]) UTF8String];</span><br><span class="line">    Class nsobjectMetaClass = objc_getMetaClass(nsobjectClassChar);</span><br><span class="line">    Class nsobjectMetaClass1 = object_getClass(<span class="built_in">NSObject</span>.class); <span class="comment">//nsobjectMetaClass与nsobjectMetaClass1相等。</span></span><br><span class="line">    <span class="comment">//根类对象的类即根元类对象</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;根类对象的类即根元类对象(NSObject metaClass):%@,地址:%p&quot;</span>, nsobjectMetaClass, nsobjectMetaClass);</span><br><span class="line">    <span class="comment">//根元类对象的父类</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;根元类对象的父类(NSObject metaClass superclass):%@,地址:%p&quot;</span>, [nsobjectMetaClass superclass], [nsobjectMetaClass superclass]);</span><br><span class="line">    <span class="comment">//根元类对象的类</span></span><br><span class="line">    Class root = objc_getMetaClass([<span class="built_in">NSStringFromClass</span>(nsobjectMetaClass) UTF8String]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;根元类对象的类:%@,地址:%p&quot;</span>, root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">18</span>.<span class="number">507417</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20896</span>:<span class="number">7290701</span>] 根类对象[NSObject class]:NSObject,地址:<span class="number">0</span>x1b9e44148</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">18</span>.<span class="number">507511</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20896</span>:<span class="number">7290701</span>] 根类对象的父类[[NSObject class] superclass]:(null),地址<span class="number">0</span>x0</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">18</span>.<span class="number">507599</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20896</span>:<span class="number">7290701</span>] 根类对象的类即根元类对象(NSObject metaClass):NSObject,地址:<span class="number">0</span>x1b9e440f8</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">18</span>.<span class="number">507663</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20896</span>:<span class="number">7290701</span>] 根元类对象的父类(NSObject metaClass superclass):NSObject,地址:<span class="number">0</span>x1b9e44148</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">18</span>.<span class="number">507762</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20896</span>:<span class="number">7290701</span>] 根元类对象的类:NSObject,地址:<span class="number">0</span>x1b9e440f8</span><br></pre></td></tr></table></figure>
<p>可以看到根类对象的类是根元类对象0x1b9e440f8。根元类对象的父类是根类对象0x1b9e44148。根元类对象的类是它本身0x1b9e440f8。</p>
<h2 id="类对象响应根类对象的实例方法"><a href="#类对象响应根类对象的实例方法" class="headerlink" title="类对象响应根类对象的实例方法"></a>类对象响应根类对象的实例方法</h2><p>不知道大家有没有发现，给类对象发送根类对象的实例方法，编译器是不会报错的，并且执行时也不会崩溃。这是怎么回事呢？</p>
<p>还是看上图，因为根元类对象的superClass是根类对象，当给类对象发送实例方法时，根据方法的查找顺序，查找到根元类对象时，由于根元类对象里也没有该实例方法，所以继续往上查找，于是查找到根类这里，根类里保存的是实例方法并且包含该实例方法，于是进行调用。因此类是可以响应根类的实例方法的。</p>
<p>我们可以写一些代码验证一下：给ViewController发送NSObject的一些实例方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_class_metaClass1 &#123;</span><br><span class="line">    Class vcCls = [ViewController <span class="keyword">copy</span>];</span><br><span class="line">  	<span class="comment">//copy是根类NSObject的实例方法,但是类对象ViewController依然能够“响应”.</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;vcCls:%p,self.class:%p&quot;</span>, vcCls, [<span class="keyword">self</span> <span class="keyword">class</span>]); <span class="comment">//打印的地址一样,是同一个对象.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([ViewController respondsToSelector:<span class="keyword">@selector</span>(viewDidLoad)]) &#123; <span class="comment">//不能响应</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;ViewController respondsToSelector -viewDidLoad&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);</span></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *msig = [ViewController methodSignatureForSelector:<span class="keyword">@selector</span>(viewDidLoad)];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;msig:%@&quot;</span>, msig);</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *msig1 = [<span class="keyword">self</span> methodSignatureForSelector:<span class="keyword">@selector</span>(viewDidLoad)];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;msig1:%@&quot;</span>, msig1);</span><br><span class="line">    <span class="comment">//- (IMP)methodForSelector:(SEL)aSelector;</span></span><br><span class="line">    IMP imp = [ViewController methodForSelector:<span class="keyword">@selector</span>(viewDidLoad)]; <span class="comment">//这里为啥会有值？不懂。估计走了消息转发。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;imp:%p&quot;</span>, imp); <span class="comment">//(IMP) imp = 0x000000018002f440 (libobjc.A.dylib`_objc_msgForward)</span></span><br><span class="line">    IMP imp1 = [<span class="keyword">self</span> methodForSelector:<span class="keyword">@selector</span>(viewDidLoad)];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;imp1:%p&quot;</span>, imp1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">18</span>:<span class="number">44</span>.<span class="number">308901</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20472</span>:<span class="number">7278793</span>] vcCls:<span class="number">0</span>x104d452d8,self.class:<span class="number">0</span>x104d452d8</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">18</span>:<span class="number">44</span>.<span class="number">309072</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20472</span>:<span class="number">7278793</span>] msig:(null)</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">18</span>:<span class="number">44</span>.<span class="number">309131</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20472</span>:<span class="number">7278793</span>] msig1:&lt;NSMethodSignature: <span class="number">0</span>xa1d3a9acc0fd100f&gt;</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">18</span>:<span class="number">44</span>.<span class="number">309171</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20472</span>:<span class="number">7278793</span>] imp:<span class="number">0</span>x18002f440</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">14</span>:<span class="number">18</span>:<span class="number">44</span>.<span class="number">309209</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">20472</span>:<span class="number">7278793</span>] imp1:<span class="number">0</span>x104d3a940</span><br></pre></td></tr></table></figure>
<p>可以看到，类ViewController都可以响应。不过NSObject根类是比较特殊的，事实上NSObject所有暴露的实例方法都有对应的一份类方法实现，只不过大部分这样的类方法都没有暴露出来。所以根元类里面是有这些类方法的，根据方法的查找顺序，最终会在根元类这里找到而不会继续往根类里找，于是调用相应类方法。这在外部看起来像是类响应了一个实例方法，实际上只是因为NSObject没有暴露对应的类方法。</p>
<p>可以看NSObject的源码实现：performSelector，copy等都只暴露了实例方法接口，但实际上内部有对应的类方法接口。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)performSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)aSelector withObject:(<span class="type">id</span>)object;</span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)aSelector withObject:(<span class="type">id</span>)object1 withObject:(<span class="type">id</span>)object2;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)<span class="keyword">copy</span>;</span><br><span class="line">- (<span class="type">id</span>)mutableCopy;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation OBJC_SWIFT_UNAVAILABLE(<span class="string">&quot;&quot;</span>);</span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>内部实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//performSelector相关</span></span><br><span class="line">+ (<span class="type">id</span>)performSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL))objc_msgSend)((<span class="type">id</span>)<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>))objc_msgSend)((<span class="type">id</span>)<span class="keyword">self</span>, sel, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj1 withObject:(<span class="type">id</span>)obj2 &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>, <span class="type">id</span>))objc_msgSend)((<span class="type">id</span>)<span class="keyword">self</span>, sel, obj1, obj2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL))objc_msgSend)(<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj1 withObject:(<span class="type">id</span>)obj2 &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>, <span class="type">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj1, obj2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy相关</span></span><br><span class="line">+ (<span class="type">id</span>)<span class="keyword">copy</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)copyWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)<span class="keyword">copy</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">id</span>)<span class="keyword">self</span> copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)mutableCopy &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)mutableCopyWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)mutableCopy &#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">id</span>)<span class="keyword">self</span> mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息转发相关</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)instanceMethodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[NSObject instanceMethodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[NSObject methodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;-[NSObject methodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免上述影响，我们可以通过类别给NSObject添加一个实例方法，这样就可以保证根元类里没有对应的类方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">XQPrint</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)printSomething;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">XQPrint</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)printSomething &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;printSomething:%@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:ViewController.class]) &#123; <span class="comment">//根类里的方法如果不进行downcast作用很有限。</span></span><br><span class="line">        ViewController *vc = (ViewController *)<span class="keyword">self</span>;</span><br><span class="line">        [vc handleBtnClicked];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;not work&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    ViewController *vc = (ViewController *)self;</span></span><br><span class="line"><span class="comment">//    [vc handleBtnClicked]; //如果self是类对象这里会直接崩溃。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>调用printSomething方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_class_respond_instance_method &#123;</span><br><span class="line">    [ViewController printSomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">12</span>:<span class="number">12</span>:<span class="number">58</span>.<span class="number">795626</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">45319</span>:<span class="number">7748354</span>] printSomething:ViewController</span><br><span class="line"><span class="attribute">2023</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">12</span>:<span class="number">12</span>:<span class="number">58</span>.<span class="number">795700</span>+<span class="number">0800</span> runtime方法使用Demo[<span class="number">45319</span>:<span class="number">7748354</span>] not work</span><br></pre></td></tr></table></figure>
<p>神奇的事情来了，实例方法printSomething还是被调用了，需要注意的是虽然在实例方法里面但self却是一个类对象。到此为止我们就验证了类可以响应根类的实例方法。</p>
<p>注意1:类对象只能响应根类的实例方法,不能响应其父类的实例方法.</p>
<p>举例：isBeingPresented是UIViewController的实例方法。现在让ViewController执行isBeingPresented，会崩溃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[ViewController performSelector:<span class="meta">@selector(isBeingPresented)</span>];<span class="comment">//崩溃.</span></span><br></pre></td></tr></table></figure>
<p>注意2：不能给实例对象发送类方法。编译器会报错，即使使用下面的performSelector规避报错最终还是会崩溃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[obj performSelector:<span class="meta">@selector(someClassMethod)</span>]; <span class="comment">//崩溃</span></span><br></pre></td></tr></table></figure>
<p>这是因为给实例对象发送消息是沿着类对象的继承链查找的，而NSObject的父类是nil，最终肯定是找不到这个类方法的，因此会崩溃。</p>
<p>总结：</p>
<p>1.类可以响应根类的实例方法。不过不建议这么做，因为没什么意义。所以最好还是类对象发送类方法，实例对象发送实例方法。</p>
<p>2.不能给实例对象发送类方法。</p>
<p>问题</p>
<p>Q：为什么根元类的父类要设置为根类？是为了解决什么问题吗，还是啥原因？</p>
<p>A：就是为了让类可以响应根类的实例方法？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">objc explain: Classes and metaclasses</a>  远古大神</p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>OC对象内存布局</title>
    <url>/2023/05/18/OC%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="OC对象的内存布局"><a href="#OC对象的内存布局" class="headerlink" title="OC对象的内存布局"></a>OC对象的内存布局</h2><p>如下图</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2023-05-18%2022.18.30.png" style="zoom:50%;" /></p>
<p>注：子类可以拥有和父类同名的实例变量，它们是相互独立的。</p>
<p>isa占用8个字节，是所有对象都拥有的。OC对象最少占用16字节，一些对象可能实际只使用了8个字节，但系统在分配内存时会补足到16字节。isa的offset是0，然后按照内存对齐规则，offset一直增加下去。</p>
<p>由于内存对齐的原因，实例变量在内存中的顺序可能会和我们的书写顺序不一致。个人猜测：编译器会尽量和书写顺序一致，再按照内存对齐规则调整。（所以最好就别猜实例变量的顺序了）</p>
<p>可以使用下面的函数打印offset：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> NSUInteger <span class="title function_">FBGetMinimumIvarIndex</span><span class="params">(__unsafe_unretained Class aCls)</span> &#123;</span><br><span class="line">    NSUInteger minimumIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    Ivar *ivars = class_copyIvarList(aCls, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Ivar ivar = ivars[<span class="number">0</span>];</span><br><span class="line">        <span class="type">ptrdiff_t</span> offset = ivar_getOffset(ivar);</span><br><span class="line">        minimumIndex = offset / (<span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="type">ptrdiff_t</span> offset = ivar_getOffset(ivar);</span><br><span class="line">        NSUInteger index = offset / (<span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">        NSLog(@<span class="string">&quot;ivar:%s,offset:%td,index:%lu&quot;</span>, ivar_getName(ivar), offset, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ivars);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minimumIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDEDog</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> property_1_s;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> property_2_w;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>) <span class="type">id</span> property_3_un;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> property_4_w;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> property_5_s;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> property_6_s;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>) <span class="type">id</span> property_7_un;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> property_8_s;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> property_9_s;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> property_10_w;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> property_11_w;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> property_12_s;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> property_13_int;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">short</span> property_14_short;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> property_15_w;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">char</span> property_16_char;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> property_17_s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">758865</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_16_char,offset:<span class="number">8</span>,index:<span class="number">1</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">758907</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_14_short,offset:<span class="number">10</span>,index:<span class="number">1</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">758948</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_13_int,offset:<span class="number">12</span>,index:<span class="number">1</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">758978</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_1_s,offset:<span class="number">16</span>,index:<span class="number">2</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759014</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_2_w,offset:<span class="number">24</span>,index:<span class="number">3</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759049</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_3_un,offset:<span class="number">32</span>,index:<span class="number">4</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759077</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_4_w,offset:<span class="number">40</span>,index:<span class="number">5</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759105</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_5_s,offset:<span class="number">48</span>,index:<span class="number">6</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759134</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_6_s,offset:<span class="number">56</span>,index:<span class="number">7</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759160</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_7_un,offset:<span class="number">64</span>,index:<span class="number">8</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759191</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_8_s,offset:<span class="number">72</span>,index:<span class="number">9</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759256</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_9_s,offset:<span class="number">80</span>,index:<span class="number">10</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759309</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_10_w,offset:<span class="number">88</span>,index:<span class="number">11</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759392</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_11_w,offset:<span class="number">96</span>,index:<span class="number">12</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759458</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_12_s,offset:<span class="number">104</span>,index:<span class="number">13</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759509</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_15_w,offset:<span class="number">112</span>,index:<span class="number">14</span></span><br><span class="line"><span class="attribute">2023</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">23</span>.<span class="number">759583</span>+<span class="number">0800</span> MLeaksFinderDemo[<span class="number">26862</span>:<span class="number">7944628</span>] ivar:_property_17_s,offset:<span class="number">120</span>,index:<span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>另：这里的index是8字节的索引。从0一直到15，总共16个，16*8=128，也是FDEDog实例的大小。</p>
<h2 id="isa结构体字段验证"><a href="#isa结构体字段验证" class="headerlink" title="isa结构体字段验证"></a>isa结构体字段验证</h2><p>isa定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    <span class="type">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="type">isa_t</span>(<span class="type">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls; <span class="comment">//一个指针指向objc_class结构体。这样就可以兼容旧版本。</span></span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">    <span class="comment">//这里展开的是arm64的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uintptr_t</span> nonpointer        : <span class="number">1</span>; <span class="comment">//LSB。0 is raw isa, 1 is non-pointer isa.                                      </span></span><br><span class="line">      	<span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>; <span class="comment">//对象是否有关联对象                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>; <span class="comment">//对象是否有C++或ARC析构函数                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> <span class="comment">//Class地址。</span></span><br><span class="line">        <span class="type">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">//一个魔法数。用于区分是否初始化                                     </span></span><br><span class="line">        <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">//是否有弱引用指针。                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>; <span class="comment">//是否正在被销毁                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>; <span class="comment">//是否有sidetable引用计数。对象的引用计数太大而不能在内部保存时会将引用计数保存到sidetable                                      </span></span><br><span class="line">        <span class="type">uintptr_t</span> extra_rc          : <span class="number">19</span> <span class="comment">//MSB。对象的引用计数超过1时会存在这里。因此extra_rc加1后才是对象的引用计数。由于只有19位所以只有对象的引用计数不太大的时候才保存在这里</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> mileage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Truck</span> : <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> loadCap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test_obj_memory_layout &#123;</span><br><span class="line">    Truck *truck = [[Truck alloc] init];</span><br><span class="line">    truck.loadCap = <span class="number">10</span>;</span><br><span class="line">    truck.mileage = <span class="number">24</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;truck:%@, cls:%@,%p&quot;</span>, truck, truck.class, truck.class);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;class_getInstanceSize([NSObject class]) = %zd&quot;</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">    <span class="comment">//获取对象实际使用的内存大小&lt;=系统实际分配的内存大小</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;class_getInstanceSize([Truck class]) = %zd&quot;</span>, class_getInstanceSize([Truck <span class="keyword">class</span>]));</span><br><span class="line">    <span class="comment">//获取系统实际分配的内存大小。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;malloc_size = %zd&quot;</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *)(truck)));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;sizeof(truck) = %zd, sizeof(Truck *):%lu&quot;</span>, <span class="keyword">sizeof</span>(truck), <span class="keyword">sizeof</span>(Truck *));</span><br><span class="line">  	<span class="comment">//sizeof(truck)和sizeof(Truck *)是等价的，所以都是8.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图1：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2023-05-18%2021.41.17.png" style="zoom:50%;" /></p>
<p>分析：前八个字节是isa的值，第3个4字节是mileage字段的值，第4个4字节是loadCap字段的值。由于是小端存储，为了方便转化为大端（这里仅转换isa的值）</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">04</span> <span class="number">2</span>B <span class="number">51</span> <span class="number">09</span></span><br><span class="line">=&gt;二进制</span><br><span class="line"><span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">000</span>,<span class="number">0</span> <span class="number">00</span>,<span class="number">00</span> <span class="number">0000</span>, <span class="number">0001</span> <span class="number">04</span> <span class="number">2</span>B <span class="number">51</span> <span class="number">0000</span> <span class="number">1</span>,<span class="number">001</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>x1042b5108 -- <span class="number">4</span>*<span class="number">8</span>+<span class="number">1</span> = <span class="number">33</span> //这就是类对象的地址，和打印一致。</span><br><span class="line"><span class="symbol">1:no</span><span class="built_in">n</span>-pointer isa.最后一位为<span class="number">1</span>说明是non-pointer isa。</span><br><span class="line">当前对象的引用计数存储在isa里，引用计数值为<span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<p>引用计数占用19位，实际使用时又分为两段。</p>
<p>进一步测试，增加两个强引用指针ptr1，ptr2指向对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test_obj_memory_layout &#123;</span><br><span class="line">    Truck *truck = [[Truck alloc] init];</span><br><span class="line">    truck.loadCap = <span class="number">10</span>;</span><br><span class="line">    truck.mileage = <span class="number">24</span>;</span><br><span class="line">    </span><br><span class="line">    Truck *ptr1 = truck;</span><br><span class="line">    Truck *ptr2 = truck;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;truck:%@, cls:%@,%p&quot;</span>, truck, truck.class, truck.class);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;class_getInstanceSize([NSObject class]) = %zd&quot;</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">    <span class="comment">//获取对象实际使用的内存大小&lt;=系统实际分配的内存大小</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;class_getInstanceSize([Truck class]) = %zd&quot;</span>, class_getInstanceSize([Truck <span class="keyword">class</span>]));</span><br><span class="line">    <span class="comment">//获取系统实际分配的内存大小。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;malloc_size = %zd&quot;</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *)(truck)));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;sizeof(truck) = %zd, sizeof(Truck *):%lu&quot;</span>, <span class="keyword">sizeof</span>(truck), <span class="keyword">sizeof</span>(Truck *));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图2：</p>
<p><img src="https://raw.githubusercontent.com/xq-120/cloudImage/master/%E6%88%AA%E5%B1%8F2023-05-18%2022.05.25.png" style="zoom:50%;" /></p>
<p>分析：前八个字节是isa的值，由于是小端存储，为了方便转化为大端</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="symbol">D9</span> <span class="number">91</span> <span class="number">09</span></span><br><span class="line">=&gt;二进制</span><br><span class="line"><span class="number">0000</span> <span class="number">0011</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">000</span>,<span class="number">0</span> <span class="number">00</span>,<span class="number">00</span> <span class="number">0000</span>, <span class="number">0001</span> <span class="number">00</span> <span class="symbol">D9</span> <span class="number">91</span> <span class="number">0000</span> <span class="number">1</span>,<span class="number">001</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>x100d99108 -- <span class="number">4</span>*<span class="number">8</span>+<span class="number">1</span> = <span class="number">33</span></span><br><span class="line"><span class="symbol">1:no</span><span class="built_in">n</span>-pointer isa.最后一位为<span class="number">1</span>说明是non-pointer isa。</span><br><span class="line">当前对象的引用计数存储在isa里，引用计数值为<span class="number">3</span>.</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1560419">「类与对象」如何准确获取对象的内存大小？</a></p>
]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>内存布局</tag>
      </tags>
  </entry>
  <entry>
    <title>常用目录命令</title>
    <url>/2023/07/30/%E5%B8%B8%E7%94%A8%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>macOS目录命令</p>
<h2 id="1-新建目录mkdir"><a href="#1-新建目录mkdir" class="headerlink" title="1.新建目录mkdir"></a>1.新建目录mkdir</h2><p>语法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">mkdir [-p] dirName</span><br></pre></td></tr></table></figure>
<p>-p: 如果中间目录不存在则创建一个。不加 -p 参数如果中间目录不存在则会报错：No such file or directory。</p>
<p>示例:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mkdir</span> 文件名<span class="number">1</span></span><br><span class="line"><span class="attribute">mkdir</span> 文件名<span class="number">1</span> 文件名<span class="number">2</span></span><br><span class="line"><span class="attribute">mkdir</span> -p 文件名/文件名</span><br></pre></td></tr></table></figure>
<p>通常使用md较多，md是mkdir -p的别名。</p>
<h2 id="2-删除文件rm"><a href="#2-删除文件rm" class="headerlink" title="2.删除文件rm"></a>2.删除文件rm</h2><p>语法：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">rm [<span class="keyword">OPTION</span>]... <span class="keyword">FILE</span>...</span><br></pre></td></tr></table></figure>
<p>删除文件可以直接使用rm命令。注意：不会有请求确认。</p>
<p>eg：rm some.pdf</p>
<p><strong>选项说明</strong></p>
<p>-i 删除某个文件前请求确认</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -i downsample_ImageIO.png</span><br></pre></td></tr></table></figure>
<p>会提示：remove downsample_ImageIO.png?</p>
<p>此时按n，则不会删除。按y则删除。</p>
<p><code>-f</code> 强制删除,没有提示.只能删除文件,不能删除文件夹.</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> <span class="operator">-f</span> downsample_ImageIO.png</span><br></pre></td></tr></table></figure>
<p><code>-r</code> 递归删除。</p>
<p>如果指定的路径为文件夹，则删除整个文件夹(包括文件夹下所有的文件及其子文件夹)。</p>
<p>如果指定的路径为文件，则删除文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r dsds.md</span><br><span class="line"><span class="built_in">rm</span> -r 未命名文件夹</span><br></pre></td></tr></table></figure>
<p>如果文件夹里面有些文件是只读的，则rm -r会弹出一些提示</p>
<p>eg:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>会提示：override r—r—r— xuequan/staff for test/mytest? y</p>
<p>输入y表示更改mytest文件的权限，然后再删除，按n或enter键则不会删除。</p>
<p>有时不想麻烦，可以使用rm -rf组合强制删除。</p>
<p>注意：使用rm删除的文件不会进废纸篓，很难再恢复，使用一些特殊手段可能可以恢复。一种安全的方法是重定义rm。</p>
<h2 id="3-创建文件touch"><a href="#3-创建文件touch" class="headerlink" title="3.创建文件touch"></a>3.创建文件touch</h2><p>语法：</p>
<figure class="highlight irpf90"><table><tr><td class="code"><pre><span class="line"><span class="keyword">touch</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<p>当然touch命令也不止创建文件这一功能，另外创建文件的命令有很多这里不一一举例了。</p>
<h2 id="4-更改权限chmod"><a href="#4-更改权限chmod" class="headerlink" title="4.更改权限chmod"></a>4.更改权限chmod</h2><p>eg:初始时mytest是可读可写的：</p>
<p>-rw-r—r—  1 xuequan staff   6 6 14 14:10 mytest</p>
<p>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u-w mytest</span><br></pre></td></tr></table></figure>
<p>现在变为只读了：</p>
<p>-r—r—r—  1 xuequan staff   6 6 14 14:10 mytest</p>
<p>更多参考：</p>
<p><a href="https://www.runoob.com/linux/linux-comm-chmod.html">https://www.runoob.com/linux/linux-comm-chmod.html</a></p>
<h2 id="5-移动文件mv"><a href="#5-移动文件mv" class="headerlink" title="5.移动文件mv"></a>5.移动文件mv</h2><p>mv用来为文件或目录改名、或将文件或目录移入其它位置。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> [options] <span class="built_in">source</span> dest</span><br><span class="line"><span class="built_in">mv</span> [options] <span class="built_in">source</span>... directory</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mv source_file(文件) dest_file(文件)</th>
<th>将源文件名 source_file 改为目标文件名 dest_file</th>
</tr>
</thead>
<tbody>
<tr>
<td>mv source_file(文件) dest_directory(目录)</td>
<td>将文件 source_file 移动到目标目录 dest_directory 中</td>
</tr>
<tr>
<td>mv source_directory(目录) dest_directory(目录)</td>
<td>目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory</td>
</tr>
<tr>
<td>mv source_directory(目录)    dest_file(文件)</td>
<td>出错</td>
</tr>
</tbody>
</table>
</div>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>macOS采用的是Unix文件系统，所有文件都挂在根目录”/“下面，所以不要有Windows 下的盘符概念。在 Unix系统中是区别大小写字符的，A.txt 不等于 a.txt。根目录标志 / 不是可有可无，<code>cd /System</code> 表示转到根目录下的System中，而<code>cd System</code> 表示转到当前目录下的 System中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u011291072/article/details/122782942?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122782942-blog-104642218.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122782942-blog-104642218.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=1">Shell、Bash、Zsh这都是啥啊</a></p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>目录命令</tag>
      </tags>
  </entry>
  <entry>
    <title>打包错误Command PhaseScriptExecution failed</title>
    <url>/2023/09/01/%E6%89%93%E5%8C%85%E9%94%99%E8%AF%AFCommand%20PhaseScriptExecution%20failed/</url>
    <content><![CDATA[<p>打测试包的时候，提示Command PhaseScriptExecution failed with a nonzero exit code错误。</p>
<p>找到<code>/Pods/Target Support Files/Pods-Runner/Pods-你的项目-frameworks.sh</code>将</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>=<span class="string">&quot;<span class="subst">$(readlink <span class="string">&quot;<span class="variable">$&#123;source&#125;</span>&quot;</span>)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>=<span class="string">&quot;<span class="subst">$(readlink -f <span class="string">&quot;<span class="variable">$&#123;source&#125;</span>&quot;</span>)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tugberkcanozen.medium.com/resolving-command-phasescriptexecution-failed-with-a-nonzero-exit-code-error-in-xcode-936d292fc9f8">Resolving “Command PhaseScriptExecution failed with a nonzero exit code” Error in Xcode</a></p>
]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/12/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>ssh方式git clone报错</title>
    <url>/2024/01/20/ssh%E6%96%B9%E5%BC%8Fgit%20clone%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>ssh类型的仓库，git clone/pull报错：kex_exchange_identification: Connection closed by remote host</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git pull <span class="comment">--verbose</span></span><br><span class="line">kex_exchange_identification: <span class="keyword">Connection</span> closed <span class="keyword">by</span> remote host</span><br><span class="line"><span class="keyword">Connection</span> closed <span class="keyword">by</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> port <span class="number">7890</span></span><br><span class="line">fatal: Could <span class="keyword">not</span> <span class="keyword">read</span> <span class="keyword">from</span> remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct <span class="keyword">access</span> rights</span><br><span class="line"><span class="keyword">and</span> the repository <span class="keyword">exists</span>.</span><br></pre></td></tr></table></figure>
<p>这个报错其实跟使用梯子有关。</p>
<p>解决：</p>
<p>step 1.将~/.ssh下的id_rsa.pub(没有就先创建公私钥)公钥内容添加到github后台。</p>
<p>step 2.在~/.ssh/config文件（没有就先创建）中添加：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    HostName ssh.github.com</span><br><span class="line">    <span class="keyword">User</span> <span class="title">git</span></span><br><span class="line">    Port <span class="number">443</span></span><br></pre></td></tr></table></figure>
<p>上述内容表示ssh使用443端口而不再是默认的22。</p>
<p>step 3.使用命令<code>ssh -T git@github.com</code>验证</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi xq-<span class="number">120</span>! You<span class="symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure>
<p>这个时候应该就可以正常git clone了。</p>
<p>其实上面执行完后，会在known_hosts添加记录：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">ssh.github.com</span>]:<span class="link">443 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl</span></span><br><span class="line">[<span class="symbol">ssh.github.com</span>]:<span class="link">443 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=</span></span><br><span class="line">[<span class="symbol">ssh.github.com</span>]:<span class="link">443 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=</span></span><br></pre></td></tr></table></figure>
<p>这就是所谓的host key fingerprint，其实就是用来验证服务器身份的，避免中间人攻击。</p>
<p>另外不知道为啥还生成了一个known_hosts.old文件。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>查看仓库的远程URL类型</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git remote -v</span></span><br></pre></td></tr></table></figure>
<p>打印结果：一般是ssh或https</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">origin	ssh:<span class="regexp">//gi</span>t<span class="variable">@github</span>.com/xxx/xxx.git (fetch)</span><br><span class="line">origin	ssh:<span class="regexp">//gi</span>t<span class="variable">@github</span>.com/xxx/xxx.git (<span class="keyword">push</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">origin	https:<span class="regexp">//gi</span>thub.com<span class="regexp">/xxx/</span>xxx.git (fetch)</span><br><span class="line">origin	https:<span class="regexp">//gi</span>thub.com<span class="regexp">/xxx/</span>xxx.git (push)</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7129443602379309086">Github：通过sshkey的方式拉取代码报错kex_exchange_identification: Connection closed by remote</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>shell科普</title>
    <url>/2023/09/07/shell%E7%A7%91%E6%99%AE/</url>
    <content><![CDATA[<h3 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h3><p>看语境，有时候Shell指连接内核和用户的一个应用程序，有时候指一种脚本编程语言。不过这个看语境对于一个小白来说其实还挺难的，大部分情况下说shell其实说的是应用程序，但如果是说shell命令，脚本文件那shell就是指一种编程语言。</p>
<p>macOS 系统的默认终端（shell应用程序）是 Terminal，默认使用的shell是zsh（这里的zsh就是指脚本编程语言）。iTerm2 也是一款终端软件。iTerm2只是比Terminal拥有更多的自定义设置，使用oh-my-zsh美化后都差不多。终端这个shell应用程序可以设置具体使用哪一种shell作为默认shell。使用哪种shell作为默认shell的终端就称为xxx终端，比如zsh终端，bash终端。</p>
<p>Shell 可以指一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。Shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，它和 QQ、迅雷、Firefox 等其它软件没有什么区别。然而 Shell 也有着它的特殊性，就是开机立马启动，并呈现在用户面前；用户通过 Shell 来使用 Linux，不启动 Shell 的话，用户就没办法使用 Linux。</p>
<p>Shell 也可以指一种脚本编程语言。Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器（解释器一般就是shell终端软件也就是Terminal或者iTerm2等等）就可以了。</p>
<p>Shell 主要用来开发一些实用的、自动化的小工具，而不是用来开发具有复杂业务逻辑的中大型软件，例如检测计算机的硬件参数、搭建 Web 运行环境、日志分析等，Shell 都非常合适。</p>
<h3 id="有哪些shell"><a href="#有哪些shell" class="headerlink" title="有哪些shell"></a>有哪些shell</h3><p>shell是一个总称，具体shell有：bash、csh、ksh、zsh等等。Mac默认使用的是zsh。</p>
<p>查看安装了哪些shell：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shells</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># List of acceptable shells for chpass(1).</span></span><br><span class="line"><span class="comment"># Ftpd will not allow users to connect who are not using</span></span><br><span class="line"><span class="comment"># one of these shells.</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/bin/</span>bash</span><br><span class="line"><span class="regexp">/bin/</span>csh</span><br><span class="line"><span class="regexp">/bin/</span>dash</span><br><span class="line"><span class="regexp">/bin/</span>ksh</span><br><span class="line"><span class="regexp">/bin/</span>sh</span><br><span class="line"><span class="regexp">/bin/</span>tcsh</span><br><span class="line"><span class="regexp">/bin/</span>zsh</span><br></pre></td></tr></table></figure>
<p>这里的shell指shell编程语言。不同的shell拥有不同的语法和内置命令，但大差不差，有的可以兼容另一种。一个编写好的shell脚本需要使用shell终端来解释执行。因为有的可以兼容另一种，所以一个使用A shell编写的脚本文件可以不加修改的在使用B shell作为默认shell的终端里解释执行。</p>
<h3 id="查看正在使用的是哪种shell"><a href="#查看正在使用的是哪种shell" class="headerlink" title="查看正在使用的是哪种shell"></a>查看正在使用的是哪种shell</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/bin/</span>zsh</span><br></pre></td></tr></table></figure>
<h3 id="如何执行一个shell脚本"><a href="#如何执行一个shell脚本" class="headerlink" title="如何执行一个shell脚本"></a>如何执行一个shell脚本</h3><p>两者都要先打开终端，在终端里运行。</p>
<p>方式1.给shell脚本添加可执行权限。 这个是常用的做法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.<span class="built_in">cd</span> 到相应目录</span><br><span class="line">2.<span class="built_in">chmod</span> +x ./test.sh  <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">3../test.sh  <span class="comment">#执行脚本</span></span><br></pre></td></tr></table></figure>
<p>方式2.<strong>作为解释器参数</strong>。这种运行方式是直接运行解释器，其参数就是 shell 脚本的文件名。如：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">/bin/zsh <span class="keyword">test</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<h3 id="如何切换shell"><a href="#如何切换shell" class="headerlink" title="如何切换shell"></a>如何切换shell</h3><p>chsh -s /bin/某shell，如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chsh -s <span class="regexp">/bin/</span>zsh  <span class="comment">#切换到zsh</span></span><br><span class="line">chsh -s <span class="regexp">/bin/</span>bash  <span class="comment">#切换到bash</span></span><br></pre></td></tr></table></figure>
<p>最后重启终端。</p>
<h3 id="zsh与oh-my-zsh的关系"><a href="#zsh与oh-my-zsh的关系" class="headerlink" title="zsh与oh-my-zsh的关系"></a>zsh与oh-my-zsh的关系</h3><p>zsh既可以指终端软件又可以指zsh脚本语言，但在这个问题里，zsh指的是终端软件。而oh-my-zsh是一个为了方便配置zsh终端的库。使用oh-my-zsh可以美化zsh终端（美化后的zsh终端看起来要比原始zsh终端要好看很多，不管是字体，颜色等等），增强zsh终端的功能（相比原始zsh终端可以命令高亮，命令补全等等）。当然你也可以使用powerline美化bash终端。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>bash 的环境变量保存在<code>.bash_profile</code>文件。<br>zsh 的环境变量保存在<code>.zshrc</code>文件。</p>
<h4 id="TODO环境变量是什么？"><a href="#TODO环境变量是什么？" class="headerlink" title="TODO环境变量是什么？"></a>TODO环境变量是什么？</h4><h4 id="TODO为什么需要环境变量？"><a href="#TODO为什么需要环境变量？" class="headerlink" title="TODO为什么需要环境变量？"></a>TODO为什么需要环境变量？</h4><p>方便使用。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/xueyingpiaoran/article/details/127930040?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-127930040-blog-104599637.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-127930040-blog-104599637.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=2">iTerm2与zsh的关系</a></p>
<p><a href="http://lichen-blog.logdown.com/posts/1866624-what-is-bash">bash是什么</a></p>
<p><a href="https://linux.cn/article-8842-1.html">Zsh 开发指南（一）：变量和语句</a></p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs介绍</title>
    <url>/2024/02/09/nodejs%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h2><p>Node.js 是能够在服务器端运行JavaScript 的开放源代码、跨平台执行环境。Node.js 由 OpenJS Foundation 持有和维护，亦为Linux 基金会的项目。Node.js 是一个开源的跨平台 <a href="https://nodejs.org/en/about/">JavaScript 运行时环境</a>，侧重于服务器端和网络应用。</p>
<p>Node.js 非常适合用于：</p>
<ul>
<li>使用 Node.js 开发的单页 Web 应用程序</li>
<li>Web 服务器后端</li>
<li>移动和桌面应用程序（包括游戏）</li>
<li>机器学习系统或 IoT 设备的后端</li>
</ul>
<h2 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h2><p>node版本是一个比较棘手的问题，比如6.3.0版的node跑不了一些新项目，升级到10.x版的node后，又跑不了旧项目。所以安装的node最好能方便切换版本。推荐先安装nvm，再使用nvm安装管理node版本。<code>nvm</code> 是 <code>Node.js</code> 的版本管理工具，可以创建不同版本 <code>Node</code> 的隔离环境，从而避免不同版本包之间的干扰。</p>
<p>安装 <code>nvm</code> 之前最好是将现有的全局 <code>Node</code> 进行卸载，否则会发生冲突。</p>
<p>先查看一下node信息：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">➜  ~ which <span class="keyword">node</span></span><br><span class="line"><span class="title">/usr</span>/local/bin/<span class="keyword">node</span></span><br><span class="line"><span class="title">➜  ~ node</span> -v</span><br><span class="line">v21.<span class="number">6.1</span></span><br></pre></td></tr></table></figure>
<p>之前是用homebrew安装的，可以通过brew list查看：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">➜  ~ brew list</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span>&gt; Formulae</span><br><span class="line">abseil		icu<span class="number">4</span><span class="keyword">c</span>		libuv		python<span class="title">@3</span>.<span class="number">11</span>	xz</span><br><span class="line">brotli		inetutils	mpdecimal	readline</span><br><span class="line"><span class="keyword">c</span>-ares		libidn<span class="number">2</span>		node		sqlite</span><br><span class="line">ca-certificates	libnghttp<span class="number">2</span>	openssl<span class="title">@3</span>	swift-protobuf</span><br><span class="line">gettext		libunistring	protobuf	telnet</span><br></pre></td></tr></table></figure>
<p>卸载：brew uninstall node</p>
<h3 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h3><p>方法一：通过官网GitHub的说明书</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -o- https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/nvm-sh/</span>nvm<span class="regexp">/v0.39.7/i</span>nstall.sh | bash</span><br></pre></td></tr></table></figure>
<p>方法二：通过brew安装（本文使用homebrew安装）</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>nvm</span><br></pre></td></tr></table></figure>
<p>安装完成后nvm -v肯定会提示找不到nvm命令。继续：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">brew</span> <span class="literal">info</span> nvm</span><br></pre></td></tr></table></figure>
<p>上述命令会提示你：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">You should create NVM<span class="string">&#x27;s working directory if it doesn&#x27;</span>t exist:</span><br><span class="line">  <span class="built_in">mkdir</span> ~/.nvm</span><br><span class="line"></span><br><span class="line">Add the following to your shell profile e.g. ~/.profile or ~/.zshrc:</span><br><span class="line">  <span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line">  [ -s <span class="string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">  [ -s <span class="string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span> ] &amp;&amp; \. <span class="string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span>  <span class="comment"># This loads nvm bash_completion</span></span><br><span class="line"></span><br><span class="line">You can <span class="built_in">set</span> <span class="variable">$NVM_DIR</span> to any location, but leaving it unchanged from</span><br><span class="line">/usr/local/Cellar/nvm/0.39.7 will destroy any nvm-installed Node installations</span><br><span class="line">upon upgrade/reinstall.</span><br></pre></td></tr></table></figure>
<p>按照上述提示：先创建.nvm文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.nvm</span><br></pre></td></tr></table></figure>
<p>再往~/.zshrc里添加：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> NVM_DIR=<span class="string">&quot;$HOME/.nvm&quot;</span></span><br><span class="line">  [ -s <span class="string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span> ] &amp;&amp; <span class="string">\.</span> <span class="string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">  [ -s <span class="string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span> ] &amp;&amp; <span class="string">\.</span> <span class="string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure>
<p>最后<code>source ~/.zshrc</code></p>
<p>这时查看版本就没有问题了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜  ~ nvm -v</span><br><span class="line">0.39.7</span><br></pre></td></tr></table></figure>
<p>继续，使用nvm安装node</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nvm install --lts</span><br></pre></td></tr></table></figure>
<p>现在安装 Node.js 都会默认安装 npm（node 包管理工具），所以我们不用单独安装 npm。执行完后node就安装好了。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<h2 id="node版本切换"><a href="#node版本切换" class="headerlink" title="node版本切换"></a>node版本切换</h2><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">nvm <span class="keyword">use</span> node版本 <span class="comment">//使用指定版本</span></span><br><span class="line">nvm <span class="keyword">use</span> default <span class="comment">//使用默认版本</span></span><br><span class="line">nvm <span class="keyword">ls</span> <span class="comment">//查看已安装的node版本</span></span><br><span class="line">nvm <span class="keyword">ls</span>-remote</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://heynode.com/tutorial/install-nodejs-locally-nvm/">Install Node.js Locally with Node Version Manager (nvm)</a></p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>homebrew介绍</title>
    <url>/2024/02/09/homebrew%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="homebrew简介"><a href="#homebrew简介" class="headerlink" title="homebrew简介"></a>homebrew简介</h2><p>homebrew类似于QQ软件管家，方便我们安装卸载第三方软件。当然这里的软件指的是命令行软件，而不是我们通常使用的图形界面应用软件。</p>
<h2 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>Homebrew 会将软件包安装到独立目录，Homebrew 不会将文件安装到它本身目录之外，所以您可将 Homebrew 安装到任意位置，默认是安装在:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>homebrew/Cellar</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="regexp">/opt/</span>homebrew<span class="regexp">/Cellar/</span>openssl@<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>，并将其文件软链接至 <code>/opt/homebrew/opt/</code> 。该目录下的文件则是Cellar下对应软件的一个软连接。</p>
<h2 id="homebrew使用"><a href="#homebrew使用" class="headerlink" title="homebrew使用"></a>homebrew使用</h2><h3 id="1-安装软件"><a href="#1-安装软件" class="headerlink" title="1.安装软件"></a>1.安装软件</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>xxx</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">➜  ~ brew install wget</span><br><span class="line">==&gt; Downloading https:<span class="comment">//formulae.brew.sh/api/formula.jws.json</span></span><br><span class="line">######################################################################### <span class="number">100.0</span>%</span><br><span class="line">==&gt; Downloading https:<span class="comment">//formulae.brew.sh/api/cask.jws.json</span></span><br><span class="line">######################################################################### <span class="number">100.0</span>%</span><br><span class="line">==&gt; Downloading https:<span class="comment">//ghcr.io/v2/homebrew/core/wget/manifests/1.21.4</span></span><br><span class="line">######################################################################### <span class="number">100.0</span>%</span><br><span class="line">==&gt; Fetching wget</span><br><span class="line">==&gt; Downloading https:<span class="comment">//ghcr.io/v2/homebrew/core/wget/blobs/sha256:3def758612b33</span></span><br><span class="line">######################################################################### <span class="number">100.0</span>%</span><br><span class="line">==&gt; Pouring wget-<span class="number">-1.21</span><span class="number">.4</span>.sonoma.bottle.tar.gz</span><br><span class="line">🍺  /usr/local/Cellar/wget/<span class="number">1.21</span><span class="number">.4</span>: <span class="number">91</span> files, <span class="number">4.4</span>MB</span><br><span class="line">==&gt; Running `brew cleanup wget`...</span><br><span class="line">Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.</span><br><span class="line">Hide these hints <span class="keyword">with</span> HOMEBREW_NO_ENV_HINTS (see `man brew`).</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">➜  ~ wget -V</span><br><span class="line">GNU Wget <span class="number">1.21</span><span class="number">.4</span> 在 darwin23<span class="number">.0</span><span class="number">.0</span> 上编译。</span><br></pre></td></tr></table></figure>
<h3 id="2-卸载软件"><a href="#2-卸载软件" class="headerlink" title="2.卸载软件"></a>2.卸载软件</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">brew uninstall xxx</span></span><br></pre></td></tr></table></figure>
<h3 id="3-brew-list-查看使用homebrew安装的二进制软件"><a href="#3-brew-list-查看使用homebrew安装的二进制软件" class="headerlink" title="3.brew list-查看使用homebrew安装的二进制软件"></a>3.brew list-查看使用homebrew安装的二进制软件</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">brew list</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">brew list</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span>&gt; Formulae</span><br><span class="line">abseil		gettext		libunistring	openssl<span class="title">@3</span>	sqlite</span><br><span class="line">brotli		icu<span class="number">4</span><span class="keyword">c</span>		libuv		protobuf	swift-protobuf</span><br><span class="line"><span class="keyword">c</span>-ares		inetutils	libyaml		python<span class="title">@3</span>.<span class="number">11</span>	telnet</span><br><span class="line">ca-certificates	libidn<span class="number">2</span>		mpdecimal	readline	wget</span><br><span class="line">cocoapods	libnghttp<span class="number">2</span>	nvm		ruby		xz</span><br></pre></td></tr></table></figure>
<h3 id="4-brew-update-升级homebrew自身"><a href="#4-brew-update-升级homebrew自身" class="headerlink" title="4.brew update-升级homebrew自身"></a>4.brew update-升级homebrew自身</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">brew <span class="keyword">update</span> <span class="comment">--verbose</span></span><br></pre></td></tr></table></figure>
<h3 id="5-brew-upgrade-升级安装的二进制软件"><a href="#5-brew-upgrade-升级安装的二进制软件" class="headerlink" title="5.brew upgrade-升级安装的二进制软件"></a>5.brew upgrade-升级安装的二进制软件</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">brew upgrade xxx</span></span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">brew upgrade cocoapods</span></span><br></pre></td></tr></table></figure>
<h3 id="6-brew-search-搜索包"><a href="#6-brew-search-搜索包" class="headerlink" title="6.brew search-搜索包"></a>6.brew search-搜索包</h3><p>搜索可以安装的包，可以大致查看其最新的版本（可能有延迟，最新的应该去官网查看）。</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="1-安装了两个homebrew"><a href="#1-安装了两个homebrew" class="headerlink" title="1.安装了两个homebrew"></a>1.安装了两个homebrew</h3><p>不知道什么原因电脑里安装了两个homebrew，然后每个homebrew下又都安装了一些软件。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local/Homebrew</span><br><span class="line"><span class="regexp">/opt/</span>homebrew</span><br></pre></td></tr></table></figure>
<p>然后zsh里面，优先使用的是/opt/homebrew的homebrew。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set PATH, MANPATH, etc., for Homebrew.</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(/opt/homebrew/bin/brew shellenv)</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(/usr/local/bin/brew shellenv)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>导致在升级一些软件时提示已经升级了，但查看版本时还是旧的，原因就是升级的是另一个homebrew下的，而/opt/homebrew下的还是旧版本的。所以打算删除掉/opt目录下的。</p>
<p><strong>卸载/opt/homebrew下的homebrew</strong></p>
<p>1.先备份要删除的/opt/homebrew。后续确定没问题了再彻底删除。</p>
<p>2.修改<code>.zprofile</code> 的内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set PATH, MANPATH, etc., for Homebrew.</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(/usr/local/bin/brew shellenv)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>即删除掉之前/opt/homebrew的。</p>
<p>3.查看where brew，应该只剩下一个了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">➜</span>  <span class="operator">~</span> <span class="keyword">where</span> brew</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>brew</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>brew</span><br></pre></td></tr></table></figure>
<p>删除后有一些软件可能得重新安装了，比如之前安装的hexo命令提示没了。</p>
<p>重新安装hexo：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://brew.sh/zh-cn/">homebrew官网</a></p>
<p><a href="https://cherishher.github.io/2018/08/02/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8homebrew%E7%9A%84%E7%BB%8F%E9%AA%8C/">一些使用homebrew的经验</a></p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
